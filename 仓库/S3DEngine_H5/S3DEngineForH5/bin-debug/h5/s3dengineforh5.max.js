/***********************************/
/*http://www.layabox.com 2016/05/19*/
/***********************************/
window.Laya=(function(window,document){
	var Laya={
		__internals:[],
		__packages:{},
		__classmap:{'Object':Object,'Function':Function,'Array':Array,'String':String},
		__sysClass:{'object':'Object','array':'Array','string':'String','dictionary':'Dictionary'},
		__propun:{writable: true,enumerable: false,configurable: true},
		__presubstr:String.prototype.substr,
		__substr:function(ofs,sz){return arguments.length==1?Laya.__presubstr.call(this,ofs):Laya.__presubstr.call(this,ofs,sz>0?sz:(this.length+sz));},
		__init:function(_classs){_classs.forEach(function(o){o.__init$ && o.__init$();});},
		__isClass:function(o){return o && (o.__isclass || o==Object || o==String || o==Array);},
		__newvec:function(sz,value){
			var d=[];
			d.length=sz;
			for(var i=0;i<sz;i++) d[i]=value;
			return d;
		},
		__extend:function(d,b){
			for (var p in b){
				if (!b.hasOwnProperty(p)) continue;
				var g = b.__lookupGetter__(p), s = b.__lookupSetter__(p); 
				if ( g || s ) {
					g && d.__defineGetter__(p, g);
					s && d.__defineSetter__(p, s);
				} 
				else d[p] = b[p];
			}
			function __() { Laya.un(this,'constructor',d); }__.prototype=b.prototype;d.prototype=new __();Laya.un(d.prototype,'__imps',Laya.__copy({},b.prototype.__imps));
		},
		__copy:function(dec,src){
			if(!src) return null;
			dec=dec||{};
			for(var i in src) dec[i]=src[i];
			return dec;
		},
		__package:function(name,o){
			if(Laya.__packages[name]) return;
			Laya.__packages[name]=true;
			var p=window,strs=name.split('.');
			if(strs.length>1){
				for(var i=0,sz=strs.length-1;i<sz;i++){
					var c=p[strs[i]];
					p=c?c:(p[strs[i]]={});
				}
			}
			p[strs[strs.length-1]] || (p[strs[strs.length-1]]=o||{});
		},
		__hasOwnProperty:function(name,o){
			o=o ||this;
		    function classHas(name,o){
				if(Object.hasOwnProperty.call(o.prototype,name)) return true;
				var s=o.prototype.__super;
				return s==null?null:classHas(name,s);
			}
			return (Object.hasOwnProperty.call(o,name)) || classHas(name,o.__class);
		},
		__typeof:function(o,value){
			if(!o || !value) return false;
			if(value==String) return (typeof o=='string');
			if(value==Number) return (typeof o=='number');
			if(value.__interface__) value=value.__interface__;
			else if(typeof value!='string')  return (o instanceof value);
			return (o.__imps && o.__imps[value]) || (o.__class==value);
		},
		__as:function(value,type){
			return (this.__typeof(value,type))?value:null;
		},		
		interface:function(name,_super){
			Laya.__package(name,{});
			var ins=Laya.__internals;
			var a=ins[name]=ins[name] || {};
			a.self=name;
			if(_super)a.extend=ins[_super]=ins[_super] || {};
			var o=window,words=name.split('.');
			for(var i=0;i<words.length-1;i++) o=o[words[i]];o[words[words.length-1]]={__interface__:name};
		},
		class:function(o,fullName,_super,miniName){
			_super && Laya.__extend(o,_super);
			if(fullName){
				Laya.__package(fullName,o);
				Laya.__classmap[fullName]=o;
				if(fullName.indexOf('.')>0){
					if(fullName.indexOf('laya.')==0){
						var paths=fullName.split('.');
						miniName=miniName || paths[paths.length-1];
						if(Laya[miniName]) debugger;
						Laya[miniName]=o;
					}					
				}
				else {
					if(fullName=="Main")
						window.Main=o;
					else{
						if(Laya[fullName]){
							console.log("Err!,Same class:"+fullName,Laya[fullName]);
							debugger;
						}
						Laya[fullName]=o;
					}
				}
			}
			var un=Laya.un,p=o.prototype;
			un(p,'hasOwnProperty',Laya.__hasOwnProperty);
			un(p,'__class',o);
			un(p,'__super',_super);
			un(p,'__className',fullName);
			un(o,'__super',_super);
			un(o,'__className',fullName);
			un(o,'__isclass',true);
			un(o,'super',function(o){this.__super.call(o);});
		},
		imps:function(dec,src){
			if(!src) return null;
			var d=dec.__imps|| Laya.un(dec,'__imps',{});
			for(var i in src){
				d[i]=src[i];
				var c=i;
				while((c=this.__internals[c]) && (c=c.extend) ){
					c=c.self;d[c]=true;
				}
			}
		},		
		getset:function(isStatic,o,name,getfn,setfn){
			if(!isStatic){
				getfn && Laya.un(o,'_$get_'+name,getfn);
				setfn && Laya.un(o,'_$set_'+name,setfn);
			}
			else{
				getfn && (o['_$GET_'+name]=getfn);
				setfn && (o['_$SET_'+name]=setfn);
			}
			if(getfn && setfn) 
				Object.defineProperty(o,name,{get:getfn,set:setfn,enumerable:false});
			else{
				getfn && Object.defineProperty(o,name,{get:getfn,enumerable:false});
				setfn && Object.defineProperty(o,name,{set:setfn,enumerable:false});
			}
		},
		static:function(_class,def){
				for(var i=0,sz=def.length;i<sz;i+=2){
					if(def[i]=='length') 
						_class.length=def[i+1].call(_class);
					else{
						function tmp(){
							var name=def[i];
							var getfn=def[i+1];
							Object.defineProperty(_class,name,{
								get:function(){delete this[name];return this[name]=getfn.call(this);},
								set:function(v){delete this[name];this[name]=v;},enumerable: true,configurable: true});
						}
						tmp();
					}
				}
		},		
		un:function(obj,name,value){
			value || (value=obj[name]);
			Laya.__propun.value=value;
			Object.defineProperty(obj, name, Laya.__propun);
			return value;
		},
		uns:function(obj,names){
			names.forEach(function(o){Laya.un(obj,o)});
		}
	};

	window.console=window.console || ({log:function(){}});
	window.trace=window.console.log;
	Error.prototype.throwError=function(){throw arguments;};
	String.prototype.substr=Laya.__substr;
	Object.defineProperty(Array.prototype,'fixed',{enumerable: false});

	return Laya;
})(window,document);

(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;
	Laya.interface('laya.webgl.shapes.IShape');
	Laya.interface('laya.webgl.resource.IMergeAtlasBitmap');
	Laya.interface('laya.filters.IFilterAction');
	Laya.interface('laya.webgl.submit.ISubmit');
	Laya.interface('laya.filters.IFilter');
	Laya.interface('laya.d3.graphics.IVertex');
	Laya.interface('laya.webgl.text.ICharSegment');
	Laya.interface('specter3d.engine.interfaces.IRenderUpdate');
	Laya.interface('laya.d3.core.render.IRenderable');
	Laya.interface('laya.display.ILayout');
	Laya.interface('laya.runtime.IMarket');
	Laya.interface('laya.resource.IDispose');
	Laya.interface('laya.webgl.canvas.save.ISaveData');
	Laya.interface('laya.ui.IItem');
	Laya.interface('laya.runtime.IConchNode');
	Laya.interface('laya.filters.IFilterActionGL','laya.filters.IFilterAction');
	Laya.interface('specter3d.engine.interfaces.IAnimator','specter3d.engine.interfaces.IRenderUpdate');
	/**
	*@private
	*/
	//class laya.utils.RunDriver
	var RunDriver=(function(){
		function RunDriver(){};
		__class(RunDriver,'laya.utils.RunDriver');
		RunDriver.FILTER_ACTIONS=[];
		RunDriver.pixelRatio=-1;
		RunDriver._charSizeTestDiv=null
		RunDriver.now=function(){
			return Date.now();
		}

		RunDriver.getWindow=function(){
			return window;
		}

		RunDriver.newWebGLContext=function(canvas,webGLName){
			return canvas.getContext(webGLName,{stencil:true,alpha:false,antialias:Config.isAntialias,premultipliedAlpha:false});
		}

		RunDriver.getPixelRatio=function(){
			if (RunDriver.pixelRatio < 0){
				var ctx=Browser.context;
				var backingStore=ctx.backingStorePixelRatio || ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
				RunDriver.pixelRatio=(Browser.window.devicePixelRatio || 1)/ backingStore;
			}
			return RunDriver.pixelRatio;
		}

		RunDriver.getIncludeStr=function(name){
			return null;
		}

		RunDriver.createShaderCondition=function(conditionScript){
			var fn="(function() {return "+conditionScript+";})";
			return Browser.window.eval(fn);
		}

		RunDriver.measureText=function(txt,font){
			if (Render.isConchApp){
				var ctx=ConchTextCanvas;
				ctx.font=font;
				return ctx.measureText(txt);
			}
			if (RunDriver._charSizeTestDiv==null){
				RunDriver._charSizeTestDiv=Browser.createElement('div');
				RunDriver._charSizeTestDiv.style.cssText="z-index:10000000;padding:0px;position: absolute;left:0px;visibility:hidden;top:0px;background:white";
				Browser.container.appendChild(RunDriver._charSizeTestDiv);
			}
			RunDriver._charSizeTestDiv.style.font=font;
			RunDriver._charSizeTestDiv.innerText=txt==" " ? "i" :txt;
			return {width:RunDriver._charSizeTestDiv.offsetWidth,height:RunDriver._charSizeTestDiv.offsetHeight};
		}

		RunDriver.beginFlush=function(){
		};

		RunDriver.endFinish=function(){
		};

		RunDriver.addToAtlas=null
		RunDriver.flashFlushImage=function(atlasWebGLCanvas){
		};

		RunDriver.drawToCanvas=function(sprite,_renderType,canvasWidth,canvasHeight,offsetX,offsetY){
			var canvas=HTMLCanvas.create("2D");
			var context=new RenderContext(canvasWidth,canvasHeight,canvas);
			RenderSprite.renders[_renderType]._fun(sprite,context,offsetX,offsetY);
			return canvas;
		}

		RunDriver.createParticleTemplate2D=null
		RunDriver.createGLTextur=null;
		RunDriver.createWebGLContext2D=null;
		RunDriver.changeWebGLSize=function(w,h){
		};

		RunDriver.createRenderSprite=function(type,next){
			return new RenderSprite(type,next);
		}

		RunDriver.createFilterAction=function(type){
			return new ColorFilterAction();
		}

		RunDriver.createGraphics=function(){
			return new Graphics();
		}

		RunDriver.clear=function(value){
			Render._context.ctx.clear();
		}

		RunDriver.clearAtlas=function(value){
		};

		RunDriver.addTextureToAtlas=function(value){
		};

		RunDriver.getTexturePixels=function(value,x,y,width,height){
			return null;
		}

		RunDriver.fillTextureShader=function(value,x,y,width,height){
			return null;
		}

		RunDriver.skinAniSprite=function(){
			return null;
		}

		return RunDriver;
	})()


	/**
	*<code>Laya</code> 是全局对象的引用入口集。
	*/
	//class Laya
	var ___Laya=(function(){
		//function Laya(){};
		/**
		*表示是否捕获全局错误并弹出提示。
		*/
		__getset(1,Laya,'alertGlobalError',null,function(value){
			var erralert=0;
			if (value){
				Browser.window.onerror=function (msg,url,line,column,detail){
					if (erralert++< 5 && detail)
						alert("出错啦，请把此信息截图给研发商\n"+msg+"\n"+detail.stack);
				}
				}else {
				Browser.window.onerror=null;
			}
		});

		Laya.init=function(width,height,__plugins){
			var plugins=[];for(var i=2,sz=arguments.length;i<sz;i++)plugins.push(arguments[i]);
			Browser.__init__();
			Context.__init__();
			Graphics.__init__();
			Laya.timer=new Timer();
			Laya.loader=new LoaderManager();
			for (var i=0,n=plugins.length;i < n;i++){
				if (plugins[i].enable)plugins[i].enable();
			}
			Font.__init__();
			Style.__init__();
			ResourceManager.__init__();
			CacheManger.beginCheck();
			Laya.stageBox=Laya.stage=new Stage();
			Laya.stage.model&&Laya.stage.model.setRootNode();
			var location=Browser.window.location;
			var pathName=location.pathname;
			pathName=pathName.charAt(2)==':' ? pathName.substring(1):pathName;
			URL.rootPath=URL.basePath=URL.getPath(location.protocol=="file:" ? pathName :location.origin+pathName);
			Laya.render=new Render(50,50);
			Laya.stage.size(width,height);
			RenderSprite.__init__();
			KeyBoardManager.__init__();
			MouseManager.instance.__init__(Laya.stage,Render.canvas);
			Input.__init__();
			SoundManager.autoStopMusic=true;
			return Render.canvas;
		}

		Laya.stage=null;
		Laya.timer=null;
		Laya.loader=null;
		Laya.render=null
		Laya.version="1.2.0";
		Laya.stageBox=null
		__static(Laya,
		['conchMarket',function(){return this.conchMarket=window.conch?conchMarket:null;}
		]);
		return Laya;
	})()


	/**
	*...
	*@author wangcx
	*/
	//class S3DEngineForH5
	var S3DEngineForH5=(function(){
		function S3DEngineForH5(){
			this.cameraController=null;
			this.distanceIncrement=0;
			this.distanceSpeed=1000;
			this.lastMouseX=NaN;
			this.lastMouseY=NaN;
			this.lastPanAngle=NaN;
			this.lastTiltAngle=NaN;
			this.move=false;
			this.panIncrement=0;
			this.panSpeed=2;
			this.tiltIncrement=0;
			this.tiltSpeed=2;
			this._controller=null;
			this._dLight=null;
			this._pLight=null;
			this._pLight2=null;
			this._pLight3=null;
			this._pLight4=null;
			this._lightMesh=null;
			this._lightMesh2=null;
			this._lightMesh3=null;
			this._lightMesh4=null;
			this.initEngine();
		}

		__class(S3DEngineForH5,'S3DEngineForH5');
		var __proto=S3DEngineForH5.prototype;
		Laya.imps(__proto,{"specter3d.engine.interfaces.IRenderUpdate":true})
		__proto.update=function(time,dt){
			(dt===void 0)&& (dt=0);
			if (this._controller){
				this._controller.lookAtPosition=new Vector3D();
				this._controller.update();
			}
			if (this.cameraController){
				if (!this.move){
					this.cameraController.panAngle+=this.panIncrement;
					this.cameraController.tiltAngle+=this.tiltIncrement;
					this.cameraController.distance+=this.distanceIncrement;
				}
				this.cameraController.update(false);
			}
			if (this._pLight){
				this._pLight.transform.x=400 *Math.cos(time / 1000);
				this._pLight.transform.z=400 *Math.sin(time / 1000);
				this._lightMesh.transform.setPosition(this._pLight.transform.x,this._pLight.transform.y,this._pLight.transform.z);
			}
			if (this._pLight2){
				this._pLight2.transform.x=-400 *Math.cos(time / 1000);
				this._pLight2.transform.z=-400 *Math.sin(time / 1000);
				this._lightMesh2.transform.setPosition(this._pLight2.transform.x,this._pLight2.transform.y,this._pLight2.transform.z);
			}
			if (this._pLight3){
				this._pLight3.transform.x=400 *Math.cos(time / 1000);
				this._pLight3.transform.z=-400 *Math.sin(time / 1000);
				this._lightMesh3.transform.setPosition(this._pLight3.transform.x,this._pLight3.transform.y,this._pLight3.transform.z);
			}
			if (this._pLight4){
				this._pLight4.transform.x=-400 *Math.cos(time / 1000);
				this._pLight4.transform.z=400 *Math.sin(time / 1000);
				this._lightMesh4.transform.setPosition(this._pLight4.transform.x,this._pLight4.transform.y,this._pLight4.transform.z);
			}
		}

		__proto._loaded3DModelSOver=function(){
			var _3dsGeometry=AssetLib.getAsset("asset/3ds/Teapot.3ds","S3DEngineForH5._loaded");
			var _3dsImage=AssetLib.getImage("asset/3ds/Fieldstone.png","S3DEngineForH5._loaded");
			var _3dsMat=new TextureMaterial3D(new BitmapTexture(_3dsImage),false);
			_3dsMat.bothSides=true;
			var _3dsMesh=new Mesh3D(_3dsGeometry,_3dsMat);
			_3dsMesh.transform.setPosition(0,100,0);
			_3dsMesh.transform.setRotation(-90,0,0);
			_3dsMesh.transform.setScale(2);
			AppGlobalContext.stage3d.addChild(_3dsMesh);
		}

		__proto._onMouseDown=function(event){
			this.move=true;
			this.lastPanAngle=this.cameraController.panAngle;
			this.lastTiltAngle=this.cameraController.tiltAngle;
			this.lastMouseX=event.mouseX;
			this.lastMouseY=event.mouseY;
		}

		__proto._onMouseMove=function(event){
			if (!this.move)
				return;
			this.cameraController.panAngle=0.3 *(event.mouseX-this.lastMouseX)+this.lastPanAngle;
			this.cameraController.tiltAngle=0.3 *(event.mouseY-this.lastMouseY)+this.lastTiltAngle;
			this.lastMouseX=event.mouseX;
			this.lastMouseY=event.mouseY;
			this.lastPanAngle=this.cameraController.panAngle;
			this.lastTiltAngle=this.cameraController.tiltAngle;
		}

		__proto._onMouseUp=function(event){
			this.move=false;
		}

		__proto._onMouseWheel=function(event){
			this.cameraController.distance+=event.delta;
		}

		__proto._testRay=function(){
			var layer=AppGlobalContext.stage3d.getLayer3D("defaultLayer3D");
			var camera3d=layer.camera3d;
			camera3d.transform.setPosition(0,500,-600);
			camera3d.lookAt(new Vector3D());
			this.cameraController=new HoverController(camera3d,null,0,10,1000,-70,70);
			this.cameraController.lookAtPosition=new Vector3D();
			NativeEventManager.instance.on("mousedown",this,this._onMouseDown);
			NativeEventManager.instance.on("mouseup",this,this._onMouseUp);
			NativeEventManager.instance.on("mousemove",this,this._onMouseMove);
			NativeEventManager.instance.on("mousewheel",this,this._onMouseWheel);
		}

		__proto.create3DSModel=function(){
			var resources=[
			new ResourceVo("asset/3ds/Teapot.3ds",52),
			new ResourceVo("asset/3ds/Fieldstone.png",51),
			new ResourceVo("asset/UV_Grid_Sm.jpg",50),
			new ResourceVo("asset/floor_diffuse.jpg",49)];
			AppGlobalContext.fileLoader.loads(resources,Handler.create(this,this._loaded3DModelSOver));
		}

		/**
		*创建灯光
		*
		*/
		__proto.createLights=function(){
			this._dLight=new DirectionLight(0.0,0.0,-10.0);
			this._dLight.color=0xffffff;
			this._dLight.ambientColor=0x2833d2;
			this._dLight.diffuse=1.2;
			this._dLight.specularShininess=0.2;
			AppGlobalContext.stage3d.addChild(this._dLight);
			this._pLight=new PointLight();
			this._pLight.color=0xffffff;
			this._pLight.ambientColor=0x00000;
			this._pLight.diffuse=1.5;
			this._pLight.specularShininess=0.2;
			this._pLight.transform.setPosition(0,300,-400);
			AppGlobalContext.stage3d.addChild(this._pLight);
			this._pLight2=new PointLight();
			this._pLight2.color=0xffffff;
			this._pLight2.ambientColor=0x00000;
			this._pLight2.diffuse=1.5;
			this._pLight2.specularShininess=0.2;
			this._pLight2.transform.setPosition(0,300,400);
			AppGlobalContext.stage3d.addChild(this._pLight2);
			this._pLight3=new PointLight();
			this._pLight3.color=0xffffff;
			this._pLight3.ambientColor=0x00000;
			this._pLight3.diffuse=1.5;
			this._pLight3.specularShininess=0.2;
			this._pLight3.transform.setPosition(400,300,0);
			AppGlobalContext.stage3d.addChild(this._pLight3);
			this._pLight4=new PointLight();
			this._pLight4.color=0xffffff;
			this._pLight4.ambientColor=0x00000;
			this._pLight4.diffuse=1.5;
			this._pLight4.specularShininess=0.2;
			this._pLight4.transform.setPosition(-400,300,0);
			AppGlobalContext.stage3d.addChild(this._pLight4);
			var _sphereGeom=new SphereGeometry(10,32,32);
			var _colorMat=new ColorMaterial3D(0x0000FF);
			this._lightMesh=new Mesh3D(_sphereGeom,_colorMat);
			AppGlobalContext.stage3d.addChild(this._lightMesh);
			this._lightMesh.transform.setPosition(this._pLight.transform.x,this._pLight.transform.y,this._pLight.transform.z);
			this._lightMesh2=new Mesh3D(_sphereGeom,_colorMat);
			AppGlobalContext.stage3d.addChild(this._lightMesh2);
			this._lightMesh2.transform.setPosition(this._pLight2.transform.x,this._pLight2.transform.y,this._pLight2.transform.z);
			this._lightMesh3=new Mesh3D(_sphereGeom,_colorMat);
			AppGlobalContext.stage3d.addChild(this._lightMesh3);
			this._lightMesh3.transform.setPosition(this._pLight3.transform.x,this._pLight3.transform.y,this._pLight3.transform.z);
			this._lightMesh4=new Mesh3D(_sphereGeom,_colorMat);
			AppGlobalContext.stage3d.addChild(this._lightMesh4);
			this._lightMesh4.transform.setPosition(this._pLight4.transform.x,this._pLight4.transform.y,this._pLight4.transform.z);
		}

		__proto.createObject=function(){
			var _lightPicker=new LightPicker([this._dLight]);
			var _planeGeom=new PlaneGeometry(1024,1024,1,true);
			var _sphereGeom=new SphereGeometry(50,32,32);
			var _boxGeom=new CubeGeometry();
			var _redColorMat=new ColorMaterial3D(0xFF0000);
			var _blueColorMat=new ColorMaterial3D(0x0000FF);
			var _planeColorMat=new ColorMaterial3D(0x00FF00);
			_planeColorMat.lightPicker=_blueColorMat.lightPicker=_redColorMat.lightPicker=_lightPicker;
			var _sphereMesh=new Mesh3D(_sphereGeom,_redColorMat);
			_sphereMesh.transform.setPosition(300,50,0);
			AppGlobalContext.stage3d.addChild(_sphereMesh);
			_sphereMesh=new Mesh3D(_sphereGeom,_blueColorMat);
			_sphereMesh.transform.setPosition(-300,50,0);
			AppGlobalContext.stage3d.addChild(_sphereMesh);
			_sphereMesh=new Mesh3D(_sphereGeom,_redColorMat);
			_sphereMesh.transform.setPosition(0,50,-300);
			AppGlobalContext.stage3d.addChild(_sphereMesh);
			_sphereMesh=new Mesh3D(_sphereGeom,_blueColorMat);
			_sphereMesh.transform.setPosition(0,50,300);
			AppGlobalContext.stage3d.addChild(_sphereMesh);
			var _planeMesh=new Mesh3D(_planeGeom,_planeColorMat);
			AppGlobalContext.stage3d.addChild(_planeMesh);
		}

		/**
		*初始化引擎
		*
		*/
		__proto.initEngine=function(){
			Debug.setChannel("all");
			Debug.dotrace("wangcx","S3DEngineForH5.initEngine()");
			AppGlobalContext.initEngine(60);
			AppGlobalContext.on("EngineInitComplete",this,this.onEngineInitComplete);
		}

		/**
		*初始化引擎结束
		*
		*/
		__proto.onEngineInitComplete=function(){
			AppGlobalContext.off("EngineInitComplete",this,this.onEngineInitComplete);
			AppGlobalContext.renderDrive.register(this);
			this._testRay();
			this.createLights();
			this.create3DSModel();
			this.createObject();
		}

		return S3DEngineForH5;
	})()


	/**
	*<code>EventDispatcher</code> 类是可调度事件的所有类的基类。
	*/
	//class laya.events.EventDispatcher
	var EventDispatcher=(function(){
		var EventHandler;
		function EventDispatcher(){
			this._events=null;
		}

		__class(EventDispatcher,'laya.events.EventDispatcher');
		var __proto=EventDispatcher.prototype;
		/**
		*检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。
		*@param type 事件的类型。
		*@return 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
		*/
		__proto.hasListener=function(type){
			var listener=this._events && this._events[type];
			return !!listener;
		}

		__proto.dispatchEvent=function(e){
			return this.event(e.type,e);
		}

		/**
		*派发事件。
		*@param type 事件类型。
		*@param data 回调数据。
		*<b>注意：</b>如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。
		*@return 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。
		*/
		__proto.event=function(type,data){
			if (!this._events || !this._events[type])return false;
			var listeners=this._events[type];
			if (listeners.run){
				if (listeners.once)delete this._events[type];
				data !=null ? listeners.runWith(data):listeners.run();
				}else {
				for (var i=0,n=listeners.length;i < n;i++){
					var listener=listeners[i];
					if (listener){
						(data !=null)? listener.runWith(data):listener.run();
					}
					if (!listener || listener.once){
						listeners.splice(i,1);
						i--;
						n--;
					}
				}
				if (listeners.length===0)delete this._events[type];
			}
			return true;
		}

		/**
		*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args 事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.on=function(type,caller,listener,args){
			return this._createListener(type,caller,listener,args,false);
		}

		/**
		*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args 事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.once=function(type,caller,listener,args){
			return this._createListener(type,caller,listener,args,true);
		}

		__proto._createListener=function(type,caller,listener,args,once){
			this.off(type,caller,listener,once);
			var handler=EventHandler.create(caller || this,listener,args,once);
			this._events || (this._events={});
			var events=this._events;
			if (!events[type])events[type]=handler;
			else {
				if (!events[type].run)events[type].push(handler);
				else events[type]=[events[type],handler];
			}
			return this;
		}

		/**
		*从 EventDispatcher 对象中删除侦听器。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param onceOnly 如果值为 true ,则只移除通过 once 方法添加的侦听器。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.off=function(type,caller,listener,onceOnly){
			(onceOnly===void 0)&& (onceOnly=false);
			if (!this._events || !this._events[type])return this;
			var listeners=this._events[type];
			if (listener !=null){
				if (listeners.run){
					if ((!caller || listeners.caller===caller)&& listeners.method===listener && (!onceOnly || listeners.once)){
						delete this._events[type];
						listeners.recover();
					}
					}else {
					var count=0;
					for (var i=0,n=listeners.length;i < n;i++){
						var item=listeners[i];
						if (item && (!caller || item.caller===caller)&& item.method===listener && (!onceOnly || item.once)){
							count++;
							listeners[i]=null;
							item.recover();
						}
					}
					if (count===n)delete this._events[type];
				}
			}
			return this;
		}

		/**
		*从 EventDispatcher 对象中删除指定事件类型的所有侦听器。
		*@param type 事件类型，如果值为 null，则移除本对象所有类型的侦听器。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.offAll=function(type){
			var events=this._events;
			if (!events)return this;
			if (type){
				this._recoverHandlers(events[type]);
				delete events[type];
				}else {
				for (var name in events){
					this._recoverHandlers(events[name]);
				}
				this._events=null;
			}
			return this;
		}

		__proto._recoverHandlers=function(arr){
			if(!arr)return;
			if (arr.run){
				arr.recover();
				}else {
				for (var i=arr.length-1;i >-1;i--){
					if (arr[i]){
						arr[i].recover();
						arr[i]=null;
					}
				}
			}
		}

		/**
		*检测指定事件类型是否是鼠标事件。
		*@param type 事件的类型。
		*@return 如果是鼠标事件，则值为 true;否则，值为 false。
		*/
		__proto.isMouseEvent=function(type){
			return EventDispatcher.MOUSE_EVENTS[type];
		}

		EventDispatcher.MOUSE_EVENTS={"rightmousedown":true,"rightmouseup":true,"rightclick":true,"mousedown":true,"mouseup":true,"mousemove":true,"mouseover":true,"mouseout":true,"click":true,"doubleclick":true};
		EventDispatcher.__init$=function(){
			/**@private */
			//class EventHandler extends laya.utils.Handler
			EventHandler=(function(_super){
				function EventHandler(caller,method,args,once){
					EventHandler.__super.call(this,caller,method,args,once);
				}
				__class(EventHandler,'',_super);
				var __proto=EventHandler.prototype;
				__proto.recover=function(){
					if (this._id > 0){
						this._id=0;
						EventHandler._pool.push(this.clear());
					}
				}
				EventHandler.create=function(caller,method,args,once){
					(once===void 0)&& (once=true);
					if (EventHandler._pool.length)return EventHandler._pool.pop().setTo(caller,method,args,once);
					return new EventHandler(caller,method,args,once);
				}
				EventHandler._pool=[];
				return EventHandler;
			})(Handler)
		}

		return EventDispatcher;
	})()


	/**
	*<p><code>Handler</code> 是事件处理器类。</p>
	*<p>推荐使用 Handler.create()方法从对象池创建，减少对象创建消耗。</p>
	*<p><b>注意：</b>由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。</p>
	*/
	//class laya.utils.Handler
	var Handler=(function(){
		function Handler(caller,method,args,once){
			//this.caller=null;
			//this.method=null;
			//this.args=null;
			this.once=false;
			this._id=0;
			(once===void 0)&& (once=false);
			this.setTo(caller,method,args,once);
		}

		__class(Handler,'laya.utils.Handler');
		var __proto=Handler.prototype;
		/**
		*设置此对象的指定属性值。
		*@param caller 执行域(this)。
		*@param method 回调方法。
		*@param args 携带的参数。
		*@param once 是否只执行一次，如果为true，执行后执行recover()进行回收。
		*@return 返回 handler 本身。
		*/
		__proto.setTo=function(caller,method,args,once){
			this._id=Handler._gid++;
			this.caller=caller;
			this.method=method;
			this.args=args;
			this.once=once;
			return this;
		}

		/**
		*执行处理器。
		*/
		__proto.run=function(){
			if (this.method==null)return null;
			var id=this._id;
			var result=this.method.apply(this.caller,this.args);
			this._id===id && this.once && this.recover();
			return result;
		}

		/**
		*执行处理器，携带额外数据。
		*@param data 附加的回调数据，可以是单数据或者Array(作为多参)。
		*/
		__proto.runWith=function(data){
			if (this.method==null)return null;
			var id=this._id;
			if (data==null)
				var result=this.method.apply(this.caller,this.args);
			else if (!this.args && !data.unshift)result=this.method.call(this.caller,data);
			else if (this.args)result=this.method.apply(this.caller,this.args.concat(data));
			else result=this.method.apply(this.caller,data);
			this._id===id && this.once && this.recover();
			return result;
		}

		/**
		*清理对象引用。
		*/
		__proto.clear=function(){
			this.caller=null;
			this.method=null;
			this.args=null;
			return this;
		}

		/**
		*清理并回收到 Handler 对象池内。
		*/
		__proto.recover=function(){
			if (this._id > 0){
				this._id=0;
				Handler._pool.push(this.clear());
			}
		}

		Handler.create=function(caller,method,args,once){
			(once===void 0)&& (once=true);
			if (Handler._pool.length)return Handler._pool.pop().setTo(caller,method,args,once);
			return new Handler(caller,method,args,once);
		}

		Handler._pool=[];
		Handler._gid=1;
		return Handler;
	})()


	//class specter3d.engine.bounds.Bound
	var Bound=(function(){
		function Bound(){
			this._min=null;
			this._max=null;
			this._center=null;
			this._min=new Vector3D();
			this._max=new Vector3D();
			this._center=new Vector3D();
		}

		__class(Bound,'specter3d.engine.bounds.Bound');
		var __proto=Bound.prototype;
		__proto.fromVertices=function(vertices){
			this.fromArray(vertices);
		}

		__proto.fromArray=function(vertices){
			var i=0;
			var len=vertices.length;
			var minX=NaN,minY=NaN,minZ=NaN;
			var maxX=NaN,maxY=NaN,maxZ=NaN;
			if (len==0){
				this.setSize(0,0,0,0,0,0);
				return;
			};
			var v=NaN;
			minX=maxX=vertices[uint(i++)];
			minY=maxY=vertices[uint(i++)];
			minZ=maxZ=vertices[uint(i++)];
			while (i < len){
				v=vertices[i++];
				if (v < minX)
					minX=v;
				else if (v > maxX)
				maxX=v;
				v=vertices[i++];
				if (v < minY)
					minY=v;
				else if (v > maxY)
				maxY=v;
				v=vertices[i++];
				if (v < minZ)
					minZ=v;
				else if (v > maxZ)
				maxZ=v;
			}
			this.setSize(minX,minY,minZ,maxX,maxY,maxZ);
		}

		__proto.fromGeometry=function(geometry){
			var subGeoms=geometry.subGeometry;
			var numSubGeoms=subGeoms.length;
			var minX=NaN,minY=NaN,minZ=NaN;
			var maxX=NaN,maxY=NaN,maxZ=NaN;
			if (numSubGeoms > 0){
				var subGeom=subGeoms[0];
				var vertices=subGeom.vertexData;
				var i=0;
				minX=maxX=vertices[i];
				minY=maxY=vertices[i+1];
				minZ=maxZ=vertices[i+2];
				var j=0;
				while (j < numSubGeoms){
					subGeom=subGeoms[j++];
					vertices=subGeom.vertexData;
					var vertexDataLen=vertices.length;
					i=0;
					var stride=subGeom.vertexStride;
					while (i < vertexDataLen){
						var v=vertices[i];
						if (v < minX)
							minX=v;
						else if (v > maxX)
						maxX=v;
						v=vertices[i+1];
						if (v < minY)
							minY=v;
						else if (v > maxY)
						maxY=v;
						v=vertices[i+2];
						if (v < minZ)
							minZ=v;
						else if (v > maxZ)
						maxZ=v;
						i+=stride;
					}
				}
				this.setSize(minX,minY,minZ,maxX,maxY,maxZ);
			}else
			this.setSize(0,0,0,0,0,0);
		}

		__proto.fromSphere=function(center,radius){
			this.setSize(center.x-radius,center.y-radius,center.z-radius,center.x+radius,center.y+radius,center.z+radius);
		}

		__proto.setSize=function(minX,minY,minZ,maxX,maxY,maxZ){
			this._min.x=minX;
			this._min.y=minY;
			this._min.z=minZ;
			this._max.x=maxX;
			this._max.y=maxY;
			this._max.z=maxZ;
			this._center.x=(this._max.x+this._min.x)/ 2;
			this._center.y=(this._max.y+this._min.y)/ 2;
			this._center.z=(this._max.z+this._min.z)/ 2;
		}

		__proto.rayIntersection=function(position,direction,targetNormal){
			return-1;
		}

		__proto.containsPoint=function(point){
			throw new AbstractMethodError();
		}

		__proto.clone=function(){
			throw new AbstractMethodError();
		}

		__getset(0,__proto,'min',function(){
			return this._min;
		});

		__getset(0,__proto,'max',function(){
			return this._max;
		});

		__getset(0,__proto,'center',function(){
			return this._center;
		});

		return Bound;
	})()


	//class specter3d.engine.controllers.ControllerBase
	var ControllerBase=(function(){
		function ControllerBase(targetObject){
			this._autoUpdate=true;
			this._targetObject=null;
			this._sVector3D=new Vector3D();
			this.targetObject=targetObject;
		}

		__class(ControllerBase,'specter3d.engine.controllers.ControllerBase');
		var __proto=ControllerBase.prototype;
		__proto.notifyUpdate=function(){}
		/**
		*Manually applies updates to the target 3D object.
		*/
		__proto.update=function(interpolate){
			(interpolate===void 0)&& (interpolate=true);
			throw new AbstractMethodError();
		}

		/**
		*Target object on which the controller acts. Defaults to null.
		*/
		__getset(0,__proto,'targetObject',function(){
			return this._targetObject;
			},function(val){
			if (this._targetObject==val)
				return;
			this._targetObject=val;
			this.notifyUpdate();
		});

		/**
		*Determines whether the controller applies updates automatically. Defaults to true
		*/
		__getset(0,__proto,'autoUpdate',function(){
			return this._autoUpdate;
			},function(val){
			if (this._autoUpdate==val)
				return;
			this._autoUpdate=val;
		});

		return ControllerBase;
	})()


	/**
	*Matrix3D
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.geom.Matrix3D
	var Matrix3D=(function(){
		function Matrix3D(){
			this.rawData=new Float32Array(16);
			this.identity();
		}

		__class(Matrix3D,'specter3d.engine.core.geom.Matrix3D');
		var __proto=Matrix3D.prototype;
		/**
		*通过将另一个 Matrix3D 对象与当前 Matrix3D 对象相乘来后置一个矩阵。
		*@param lhs
		*
		*/
		__proto.append=function(lhs){
			var m111=this.rawData[0];
			var m121=this.rawData[4];
			var m131=this.rawData[8];
			var m141=this.rawData[12];
			var m112=this.rawData[1];
			var m122=this.rawData[5];
			var m132=this.rawData[9];
			var m142=this.rawData[13];
			var m113=this.rawData[2];
			var m123=this.rawData[6];
			var m133=this.rawData[10];
			var m143=this.rawData[14];
			var m114=this.rawData[3];
			var m124=this.rawData[7];
			var m134=this.rawData[11];
			var m144=this.rawData[15];
			var m211=lhs.rawData[0];
			var m221=lhs.rawData[4];
			var m231=lhs.rawData[8];
			var m241=lhs.rawData[12];
			var m212=lhs.rawData[1];
			var m222=lhs.rawData[5];
			var m232=lhs.rawData[9];
			var m242=lhs.rawData[13];
			var m213=lhs.rawData[2];
			var m223=lhs.rawData[6];
			var m233=lhs.rawData[10];
			var m243=lhs.rawData[14];
			var m214=lhs.rawData[3];
			var m224=lhs.rawData[7];
			var m234=lhs.rawData[11];
			var m244=lhs.rawData[15];
			this.rawData[0]=m111 *m211+m112 *m221+m113 *m231+m114 *m241;
			this.rawData[1]=m111 *m212+m112 *m222+m113 *m232+m114 *m242;
			this.rawData[2]=m111 *m213+m112 *m223+m113 *m233+m114 *m243;
			this.rawData[3]=m111 *m214+m112 *m224+m113 *m234+m114 *m244;
			this.rawData[4]=m121 *m211+m122 *m221+m123 *m231+m124 *m241;
			this.rawData[5]=m121 *m212+m122 *m222+m123 *m232+m124 *m242;
			this.rawData[6]=m121 *m213+m122 *m223+m123 *m233+m124 *m243;
			this.rawData[7]=m121 *m214+m122 *m224+m123 *m234+m124 *m244;
			this.rawData[8]=m131 *m211+m132 *m221+m133 *m231+m134 *m241;
			this.rawData[9]=m131 *m212+m132 *m222+m133 *m232+m134 *m242;
			this.rawData[10]=m131 *m213+m132 *m223+m133 *m233+m134 *m243;
			this.rawData[11]=m131 *m214+m132 *m224+m133 *m234+m134 *m244;
			this.rawData[12]=m141 *m211+m142 *m221+m143 *m231+m144 *m241;
			this.rawData[13]=m141 *m212+m142 *m222+m143 *m232+m144 *m242;
			this.rawData[14]=m141 *m213+m142 *m223+m143 *m233+m144 *m243;
			this.rawData[15]=m141 *m214+m142 *m224+m143 *m234+m144 *m244;
		}

		/**
		*在 Matrix3D 对象上后置一个增量旋转。
		*@param degrees
		*@param axis
		*@param pivot
		*
		*/
		__proto.appendRotation=function(degrees,axis,pivot){
			if (pivot){
				Matrix3D.getAxisRotation(axis.x,axis.y,axis.z,pivot.x,pivot.y,pivot.z,degrees,Matrix3D._mt);
			}
			else{
				Matrix3D.getAxisRotation(axis.x,axis.y,axis.z,0,0,0,degrees,Matrix3D._mt);
			}
			this.append(Matrix3D._mt);
		}

		/**
		*在 Matrix3D 对象上后置一个增量缩放，沿 x、y 和 z 轴改变位置。
		*@param x
		*@param y
		*@param z
		*
		*/
		__proto.appendScale=function(x,y,z){
			var v=new Float32Array([x,0.0,0.0,0.0,0.0,y,0.0,0.0,0.0,0.0,z,0.0,0.0,0.0,0.0,1.0]);
			Matrix3D._mt.copyRawDataFrom(v);
			this.append(Matrix3D._mt);
		}

		/**
		*在 Matrix3D 对象上后置一个增量平移，沿 x、y 和 z 轴重新定位。
		*@param x
		*@param y
		*@param z
		*
		*/
		__proto.appendTranslation=function(x,y,z){
			this.rawData[12]+=x;
			this.rawData[13]+=y;
			this.rawData[14]+=z;
		}

		/**
		*将 Vector3D 对象复制到调用方 Matrix3D 对象的特定列中。
		*@param column
		*@param vec
		*
		*/
		__proto.copyColumnFrom=function(column,vec){
			this.rawData[column *4+0]=vec.x;
			this.rawData[column *4+1]=vec.y;
			this.rawData[column *4+2]=vec.z;
			this.rawData[column *4+3]=vec.w;
		}

		/**
		*将调用方 Matrix3D 对象的特定列复制到 Vector3D 对象中。
		*@param column
		*@param vec
		*
		*/
		__proto.copyColumnTo=function(column,vec){
			vec.x=this.rawData[column *4+0];
			vec.y=this.rawData[column *4+1];
			vec.z=this.rawData[column *4+2];
			vec.w=this.rawData[column *4+3];
		}

		/**
		*将源 Matrix3D 对象中的所有矩阵数据复制到调用方 Matrix3D 对象中。
		*@param mt
		*
		*/
		__proto.copyFrom=function(mt){
			for (var i=0;i < 16;i++){
				this.rawData[i]=mt.rawData[i];
			}
		}

		__proto.clone=function(){
			var cloneMatrix=new Matrix3D();
			cloneMatrix.copyFrom(this);
			return cloneMatrix;
		}

		/**
		*将源 Vector 对象中的所有矢量数据复制到调用方 Matrix3D 对象中。
		*@param vec
		*
		*/
		__proto.copyRawDataFrom=function(vec){
			for (var i=0;i < 16;i++){
				this.rawData[i]=vec[i];
			}
		}

		/**
		*将调用方 Matrix3D 对象中的所有矩阵数据复制到提供的矢量中。
		*@param vec
		*
		*/
		__proto.copyRawDataTo=function(vec){
			for (var i=0;i < 16;i++){
				vec[i]=this.rawData[i];
			}
		}

		/**
		*将 Vector3D 对象复制到调用方 Matrix3D 对象的特定行中。
		*@param raw
		*@param vec
		*
		*/
		__proto.copyRawFrom=function(raw,vec){
			this.rawData[raw+0]=vec.x;
			this.rawData[raw+4]=vec.y;
			this.rawData[raw+8]=vec.z;
			this.rawData[raw+12]=vec.w;
		}

		/**
		*将调用方 Matrix3D 对象的特定行复制到 Vector3D 对象中。
		*@param raw
		*@param vec
		*
		*/
		__proto.copyRawTo=function(raw,vec){
			vec.x=this.rawData[raw+0];
			vec.y=this.rawData[raw+4];
			vec.z=this.rawData[raw+8];
			vec.w=this.rawData[raw+12];
		}

		/**
		*获取矩阵数据
		*@param dest
		*/
		__proto.copyToMatrix3D=function(dest){
			for (var i=0;i < 16;i++){
				dest.rawData[i]=this.rawData[i];
			}
		}

		/**
		*将转换矩阵的平移、旋转和缩放设置作为由三个 Vector3D 对象组成的矢量返回。
		*@param style
		*@param vec
		*
		*/
		__proto.decompose=function(orientationStyle,vec){
			var mr=new Float32Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])
			this.copyRawDataTo(mr);
			vec[0].x=mr[12];
			vec[0].y=mr[13];
			vec[0].z=mr[14];
			mr[12]=mr[13]=mr[14]=0.0;
			vec[2].x=Math.sqrt(mr[0] *mr[0]+mr[1] *mr[1]+mr[2] *mr[2]);
			vec[2].y=Math.sqrt(mr[4] *mr[4]+mr[5] *mr[5]+mr[6] *mr[6]);
			vec[2].z=Math.sqrt(mr[8] *mr[8]+mr[9] *mr[9]+mr[10] *mr[10]);
			if (mr[0] *(mr[5] *mr[10]-mr[6] *mr[9])-mr[1] *(mr[4] *mr[10]-mr[6] *mr[8])+mr[2] *(mr[4] *mr[9]-mr[5] *mr[8])< 0)
				vec[2].z=-vec[2].z;
			mr[0]/=vec[2].x;
			mr[1]/=vec[2].x;
			mr[2]/=vec[2].x;
			mr[4]/=vec[2].y;
			mr[5]/=vec[2].y;
			mr[6]/=vec[2].y;
			mr[8]/=vec[2].z;
			mr[9]/=vec[2].z;
			mr[10]/=vec[2].z;
			if (orientationStyle=="EulerAngles"){
				vec[1].y=Math.asin(-mr[2]);
				if (mr[2] !=1 && mr[2] !=-1){
					vec[1].x=Math.atan2(mr[6],mr[10]);
					vec[1].z=Math.atan2(mr[1],mr[0]);
				}
				else{
					vec[1].z=0;
					vec[1].x=Math.atan2(mr[4],mr[5]);
				}
			}
			else if (orientationStyle=="AxisAngle"){
				vec[1].w=Math.acos((mr[0]+mr[5]+mr[10]-1)/ 2);
				var len=Math.sqrt((mr[6]-mr[9])*(mr[6]-mr[9])+(mr[8]-mr[2])*(mr[8]-mr[2])+(mr[1]-mr[4])*(mr[1]-mr[4]));
				vec[1].x=(mr[6]-mr[9])/ len;
				vec[1].y=(mr[8]-mr[2])/ len;
				vec[1].z=(mr[1]-mr[4])/ len;
			}
			else if (orientationStyle=="Quaternion"){
				var tr=mr[0]+mr[5]+mr[10];
				if (tr > 0){
					vec[1].w=Math.sqrt(1+tr)/ 2;
					vec[1].x=(mr[6]-mr[9])/ (4 *vec[1].w);
					vec[1].y=(mr[8]-mr[2])/ (4 *vec[1].w);
					vec[1].z=(mr[1]-mr[4])/ (4 *vec[1].w);
				}
				else if ((mr[0] > mr[5])&& (mr[0] > mr[10])){
					vec[1].x=Math.sqrt(1+mr[0]-mr[5]-mr[10])/ 2;
					vec[1].w=(mr[6]-mr[9])/ (4 *vec[1].x);
					vec[1].y=(mr[1]+mr[4])/ (4 *vec[1].x);
					vec[1].z=(mr[8]+mr[2])/ (4 *vec[1].x);
				}
				else{
					vec[1].z=Math.sqrt(1+mr[10]-mr[0]-mr[5])/ 2;
					vec[1].x=(mr[8]+mr[2])/ (4 *vec[1].z);
					vec[1].y=(mr[6]+mr[9])/ (4 *vec[1].z);
					vec[1].w=(mr[1]-mr[4])/ (4 *vec[1].z);
				}
			}
		}

		/**
		*可逆
		*@return
		*/
		__proto.determinant=function(){
			return ((this.rawData[0] *this.rawData[5]-this.rawData[4] *this.rawData[1])*(this.rawData[10] *this.rawData[15]-this.rawData[14] *this.rawData[11])-(this.rawData[0] *this.rawData[9]-this.rawData[8] *this.rawData[1])*(this.rawData[6] *this.rawData[15]-this.rawData[14] *this.rawData[7])+(this.rawData[0] *this.rawData[13]-this.rawData[12] *this.rawData[1])*(this.rawData[6] *this.rawData[11]-this.rawData[10] *this.rawData[7])+(this.rawData[4] *this.rawData[9]-this.rawData[8] *this.rawData[5])*(this.rawData[2] *this.rawData[15]-this.rawData[14] *this.rawData[3])-(this.rawData[4] *this.rawData[13]-this.rawData[12] *this.rawData[5])*(this.rawData[2] *this.rawData[11]-this.rawData[10] *this.rawData[3])+(this.rawData[8] *this.rawData[13]-this.rawData[12] *this.rawData[9])*(this.rawData[2] *this.rawData[7]-this.rawData[6] *this.rawData[3]));
		}

		/**
		*将当前矩阵转换为恒等或单位矩阵。
		*
		*/
		__proto.identity=function(){
			this.rawData[0]=1.0;
			this.rawData[1]=0.0;
			this.rawData[2]=0.0;
			this.rawData[3]=0.0;
			this.rawData[4]=0.0;
			this.rawData[5]=1.0;
			this.rawData[6]=0.0;
			this.rawData[7]=0.0;
			this.rawData[8]=0.0;
			this.rawData[9]=0.0;
			this.rawData[10]=1.0;
			this.rawData[11]=0.0;
			this.rawData[12]=0.0;
			this.rawData[13]=0.0;
			this.rawData[14]=0.0;
			this.rawData[15]=1.0;
		}

		/**
		*朝着目标矩阵的平移、旋转和缩放转换插补此矩阵。
		*@param dest
		*@param percent
		*
		*/
		__proto.interpolateTo=function(dest,percent){
			for (var i=0;i < 16;i++){
				dest.rawData[i]=this.rawData[i]+(dest.rawData[i]-this.rawData[i])*percent;
			}
		}

		/**
		*反转当前矩阵。
		*
		*/
		__proto.invert=function(){
			var d=this.determinant();
			if (d < 0.0){
				d=-d;
			};
			var invertable=d > 0.00000000001;
			if (invertable){
				d=1 / d;
				var m11=this.rawData[0];
				var m21=this.rawData[4];
				var m31=this.rawData[8];
				var m41=this.rawData[12];
				var m12=this.rawData[1];
				var m22=this.rawData[5];
				var m32=this.rawData[9];
				var m42=this.rawData[13];
				var m13=this.rawData[2];
				var m23=this.rawData[6];
				var m33=this.rawData[10];
				var m43=this.rawData[14];
				var m14=this.rawData[3];
				var m24=this.rawData[7];
				var m34=this.rawData[11];
				var m44=this.rawData[15];
				this.rawData[0]=d *(m22 *(m33 *m44-m43 *m34)-m32 *(m23 *m44-m43 *m24)+m42 *(m23 *m34-m33 *m24));
				this.rawData[1]=-d *(m12 *(m33 *m44-m43 *m34)-m32 *(m13 *m44-m43 *m14)+m42 *(m13 *m34-m33 *m14));
				this.rawData[2]=d *(m12 *(m23 *m44-m43 *m24)-m22 *(m13 *m44-m43 *m14)+m42 *(m13 *m24-m23 *m14));
				this.rawData[3]=-d *(m12 *(m23 *m34-m33 *m24)-m22 *(m13 *m34-m33 *m14)+m32 *(m13 *m24-m23 *m14));
				this.rawData[4]=-d *(m21 *(m33 *m44-m43 *m34)-m31 *(m23 *m44-m43 *m24)+m41 *(m23 *m34-m33 *m24));
				this.rawData[5]=d *(m11 *(m33 *m44-m43 *m34)-m31 *(m13 *m44-m43 *m14)+m41 *(m13 *m34-m33 *m14));
				this.rawData[6]=-d *(m11 *(m23 *m44-m43 *m24)-m21 *(m13 *m44-m43 *m14)+m41 *(m13 *m24-m23 *m14));
				this.rawData[7]=d *(m11 *(m23 *m34-m33 *m24)-m21 *(m13 *m34-m33 *m14)+m31 *(m13 *m24-m23 *m14));
				this.rawData[8]=d *(m21 *(m32 *m44-m42 *m34)-m31 *(m22 *m44-m42 *m24)+m41 *(m22 *m34-m32 *m24));
				this.rawData[9]=-d *(m11 *(m32 *m44-m42 *m34)-m31 *(m12 *m44-m42 *m14)+m41 *(m12 *m34-m32 *m14));
				this.rawData[10]=d *(m11 *(m22 *m44-m42 *m24)-m21 *(m12 *m44-m42 *m14)+m41 *(m12 *m24-m22 *m14));
				this.rawData[11]=-d *(m11 *(m22 *m34-m32 *m24)-m21 *(m12 *m34-m32 *m14)+m31 *(m12 *m24-m22 *m14));
				this.rawData[12]=-d *(m21 *(m32 *m43-m42 *m33)-m31 *(m22 *m43-m42 *m23)+m41 *(m22 *m33-m32 *m23));
				this.rawData[13]=d *(m11 *(m32 *m43-m42 *m33)-m31 *(m12 *m43-m42 *m13)+m41 *(m12 *m33-m32 *m13));
				this.rawData[14]=-d *(m11 *(m22 *m43-m42 *m23)-m21 *(m12 *m43-m42 *m13)+m41 *(m12 *m23-m22 *m13));
				this.rawData[15]=d *(m11 *(m22 *m33-m32 *m23)-m21 *(m12 *m33-m32 *m13)+m31 *(m12 *m23-m22 *m13));
			}
		}

		/**
		*通过将当前 Matrix3D 对象与另一个 Matrix3D 对象相乘来前置一个矩阵。
		*@param rhs
		*
		*/
		__proto.prepend=function(rhs){
			var m111=rhs.rawData[0];
			var m121=rhs.rawData[4];
			var m131=rhs.rawData[8];
			var m141=rhs.rawData[12];
			var m112=rhs.rawData[1];
			var m122=rhs.rawData[5];
			var m132=rhs.rawData[9];
			var m142=rhs.rawData[13];
			var m113=rhs.rawData[2];
			var m123=rhs.rawData[6];
			var m133=rhs.rawData[10];
			var m143=rhs.rawData[14];
			var m114=rhs.rawData[3];
			var m124=rhs.rawData[7];
			var m134=rhs.rawData[11];
			var m144=rhs.rawData[15];
			var m211=this.rawData[0];
			var m221=this.rawData[4];
			var m231=this.rawData[8];
			var m241=this.rawData[12];
			var m212=this.rawData[1];
			var m222=this.rawData[5];
			var m232=this.rawData[9];
			var m242=this.rawData[13];
			var m213=this.rawData[2];
			var m223=this.rawData[6];
			var m233=this.rawData[10];
			var m243=this.rawData[14];
			var m214=this.rawData[3];
			var m224=this.rawData[7];
			var m234=this.rawData[11];
			var m244=this.rawData[15];
			this.rawData[0]=m111 *m211+m112 *m221+m113 *m231+m114 *m241;
			this.rawData[1]=m111 *m212+m112 *m222+m113 *m232+m114 *m242;
			this.rawData[2]=m111 *m213+m112 *m223+m113 *m233+m114 *m243;
			this.rawData[3]=m111 *m214+m112 *m224+m113 *m234+m114 *m244;
			this.rawData[4]=m121 *m211+m122 *m221+m123 *m231+m124 *m241;
			this.rawData[5]=m121 *m212+m122 *m222+m123 *m232+m124 *m242;
			this.rawData[6]=m121 *m213+m122 *m223+m123 *m233+m124 *m243;
			this.rawData[7]=m121 *m214+m122 *m224+m123 *m234+m124 *m244;
			this.rawData[8]=m131 *m211+m132 *m221+m133 *m231+m134 *m241;
			this.rawData[9]=m131 *m212+m132 *m222+m133 *m232+m134 *m242;
			this.rawData[10]=m131 *m213+m132 *m223+m133 *m233+m134 *m243;
			this.rawData[11]=m131 *m214+m132 *m224+m133 *m234+m134 *m244;
			this.rawData[12]=m141 *m211+m142 *m221+m143 *m231+m144 *m241;
			this.rawData[13]=m141 *m212+m142 *m222+m143 *m232+m144 *m242;
			this.rawData[14]=m141 *m213+m142 *m223+m143 *m233+m144 *m243;
			this.rawData[15]=m141 *m214+m142 *m224+m143 *m234+m144 *m244;
		}

		/**
		*在 Matrix3D 对象上前置一个增量旋转。
		*@param degrees
		*@param axis
		*@param pivot
		*
		*/
		__proto.prependRotation=function(degrees,axis,pivot){
			if (pivot){
				Matrix3D.getAxisRotation(axis.x,axis.y,axis.y,pivot.x,pivot.y,pivot.z,degrees,Matrix3D._mt);
			}
			else{
				Matrix3D.getAxisRotation(axis.x,axis.y,axis.y,0,0,0,degrees,Matrix3D._mt);
			}
			this.prepend(Matrix3D._mt);
		}

		/**
		*在 Matrix3D 对象上前置一个增量缩放，沿 x、y 和 z 轴改变位置
		*@param x
		*@param y
		*@param z
		*
		*/
		__proto.prependScale=function(x,y,z){
			var v=new Float32Array([x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1]);
			Matrix3D._mt.copyRawDataFrom(v);
			this.prepend(Matrix3D._mt);
		}

		/**
		*在 Matrix3D 对象上前置一个增量平移，沿 x、y 和 z 轴重新定位。
		*@param x
		*@param y
		*@param z
		*
		*/
		__proto.prependTranslation=function(x,y,z){
			Matrix3D._mt.identity();
			Matrix3D._mt.setPosition(x,y,z);
			this.prepend(Matrix3D._mt);
		}

		/**
		*设置转换矩阵的平移、旋转和缩放设置。
		*@param components
		*
		*/
		__proto.recompose=function(components){
			this.identity();
			this.appendScale(components[2].x,components[2].y,components[2].z);
			var angle=-components[1].x;
			var v=new Float32Array([1,0,0,0,0,Math.cos(angle),-Math.sin(angle),0,0,Math.sin(angle),Math.cos(angle),0,0,0,0,0]);
			Matrix3D._mt.copyRawDataFrom(v);
			this.append(Matrix3D._mt);
			angle=-components[1].y;
			var v0=new Float32Array([Math.cos(angle),0,Math.sin(angle),0,0,1,0,0,-Math.sin(angle),0,Math.cos(angle),0,0,0,0,0]);
			Matrix3D._mt.copyRawDataFrom(v0);
			this.append(Matrix3D._mt);
			angle=-components[1].z;
			var v1=new Float32Array([Math.cos(angle),-Math.sin(angle),0,0,Math.sin(angle),Math.cos(angle),0,0,0,0,1,0,0,0,0,0]);
			Matrix3D._mt.copyRawDataFrom(v1);
			this.append(Matrix3D._mt);
			this.setPosition(components[0].x,components[0].y,components[0].z);
			this.rawData[15]=1.0;
		}

		/**
		*设置位移
		*@param x
		*@param y
		*@param z
		*/
		__proto.setPosition=function(x,y,z){
			this.rawData[12]=x;
			this.rawData[13]=y;
			this.rawData[14]=z;
		}

		/**
		*设置位移
		*@param position
		*/
		__proto.setPosition2=function(position){
			this.rawData[12]=position.x;
			this.rawData[13]=position.y;
			this.rawData[14]=position.z;
		}

		/**
		*使用转换矩阵将 Vector3D 对象从一个空间坐标转换到另一个空间坐标。
		*@param _in
		*@param _out
		*
		*/
		__proto.transformVector=function(_in,_out){
			if(!_out)
				_out=new Vector3D();
			var x=_in.x;
			var y=_in.y;
			var z=_in.z;
			_out.x=(x *this.rawData[0]+y *this.rawData[4]+z *this.rawData[8]+this.rawData[12]);
			_out.y=(x *this.rawData[1]+y *this.rawData[5]+z *this.rawData[9]+this.rawData[13]);
			_out.z=(x *this.rawData[2]+y *this.rawData[6]+z *this.rawData[10]+this.rawData[14]);
			_out.w=(x *this.rawData[3]+y *this.rawData[7]+z *this.rawData[11]+this.rawData[15]);
			return _out;
		}

		/**
		*使用转换矩阵将由数字构成的矢量从一个空间坐标转换到另一个空间坐标。
		*@param vin
		*@param vout
		*
		*/
		__proto.transformVectors=function(vin,vout){
			var i=0;
			var x=0.0;
			var y=0.0;
			var z=0.0;
			while (i+3 <=24){
				x=vin[i];
				y=vin[i+1];
				z=vin[i+2];
				vout[i+0]=x *this.rawData[0]+y *this.rawData[4]+z *this.rawData[8]+this.rawData[12];
				vout[i+1]=x *this.rawData[1]+y *this.rawData[5]+z *this.rawData[9]+this.rawData[13];
				vout[i+2]=x *this.rawData[2]+y *this.rawData[6]+z *this.rawData[10]+this.rawData[14];
				i+=3;
			}
		}

		/**
		*将当前 Matrix3D 对象转换为一个矩阵，并将互换其中的行和列。
		*
		*/
		__proto.transpose=function(){
			var v=new Float32Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);
			for (var i=0;i < 16;i++){
				v[i]=this.rawData[i];
			}
			this.rawData[1]=v[4];
			this.rawData[2]=v[8];
			this.rawData[3]=v[12];
			this.rawData[4]=v[1];
			this.rawData[6]=v[9];
			this.rawData[7]=v[13];
			this.rawData[8]=v[2];
			this.rawData[9]=v[6];
			this.rawData[11]=v[14];
			this.rawData[12]=v[3];
			this.rawData[13]=v[7];
			this.rawData[14]=v[11];
		}

		__proto.log=function(){
			var s="";
			s+=this.rawData[0]+"\t"+this.rawData[1]+"\t"+this.rawData[2]+"\t"+this.rawData[3];
			s+=this.rawData[4]+"\t"+this.rawData[5]+"\t"+this.rawData[6]+"\t"+this.rawData[7];
			s+=this.rawData[8]+"\t"+this.rawData[9]+"\t"+this.rawData[10]+"\t"+this.rawData[11];
			s+=this.rawData[12]+"\t"+this.rawData[13]+"\t"+this.rawData[14]+"\t"+this.rawData[15];
			return s;
		}

		Matrix3D.getAxisRotation=function(u,v,w,a,b,c,degress,m){
			var rad=degress / 180.0 *Math.PI;
			var u2=u *u;
			var v2=v *v;
			var w2=w *w;
			var l2=u2+v2+w2;
			var l=Math.sqrt(l2);
			u/=l;
			v/=l;
			w/=l;
			u2/=l2;
			v2/=l2;
			w2/=l2;
			var cos=Math.cos(rad);
			var sin=Math.sin(rad);
			m.rawData[0]=u2+(v2+w2)*cos;
			m.rawData[1]=u *v *(1-cos)+w *sin;
			m.rawData[2]=u *w *(1-cos)-v *sin;
			m.rawData[3]=0;
			m.rawData[4]=u *v *(1-cos)-w *sin;
			m.rawData[5]=v2+(u2+w2)*cos;
			m.rawData[6]=v *w *(1-cos)+u *sin;
			m.rawData[7]=0;
			m.rawData[8]=u *w *(1-cos)+v *sin;
			m.rawData[9]=v *w *(1-cos)-u *sin;
			m.rawData[10]=w2+(u2+v2)*cos;
			m.rawData[11]=0;
			m.rawData[12]=(a *(v2+w2)-u *(b *v+c *w))*(1-cos)+(b *w-c *v)*sin;
			m.rawData[13]=(b *(u2+w2)-v *(a *u+c *w))*(1-cos)+(c *u-a *w)*sin;
			m.rawData[14]=(c *(u2+v2)-w *(a *u+b *v))*(1-cos)+(a *v-b *u)*sin;
			m.rawData[15]=1;
		}

		__static(Matrix3D,
		['_mt',function(){return this._mt=new Matrix3D();}
		]);
		return Matrix3D;
	})()


	//class specter3d.engine.core.geom.OrientationStyle
	var OrientationStyle=(function(){
		function OrientationStyle(){};
		__class(OrientationStyle,'specter3d.engine.core.geom.OrientationStyle');
		OrientationStyle.AxisAngle="AxisAngle";
		OrientationStyle.EulerAngles="EulerAngles";
		OrientationStyle.Quaternion="Quaternion";
		return OrientationStyle;
	})()


	/**
	*A Quaternion object which can be used to represent rotations.
	*/
	//class specter3d.engine.core.geom.Quaternion
	var Quaternion=(function(){
		function Quaternion(x,y,z,w){
			this.x=0;
			this.y=0;
			this.z=0;
			this.w=1;
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(w===void 0)&& (w=1);
			this.x=x;
			this.y=y;
			this.z=z;
			this.w=w;
		}

		__class(Quaternion,'specter3d.engine.core.geom.Quaternion');
		var __proto=Quaternion.prototype;
		/**
		*Fills the quaternion object with the result from a multiplication of two quaternion objects.
		*
		*@param qa The first quaternion in the multiplication.
		*@param qb The second quaternion in the multiplication.
		*/
		__proto.multiply=function(qa,qb){
			var w1=qa.w,x1=qa.x,y1=qa.y,z1=qa.z;
			var w2=qb.w,x2=qb.x,y2=qb.y,z2=qb.z;
			this.w=w1*w2-x1*x2-y1*y2-z1*z2;
			this.x=w1*x2+x1*w2+y1*z2-z1*y2;
			this.y=w1*y2-x1*z2+y1*w2+z1*x2;
			this.z=w1*z2+x1*y2-y1*x2+z1*w2;
		}

		__proto.multiplyVector=function(vector,target){target=target|| new Quaternion();
			var x2=vector.x;
			var y2=vector.y;
			var z2=vector.z;
			target.w=-this.x*x2-this.y*y2-this.z*z2;
			target.x=this.w*x2+this.y*z2-this.z*y2;
			target.y=this.w*y2-this.x*z2+this.z*x2;
			target.z=this.w*z2+this.x*y2-this.y*x2;
			return target;
		}

		/**
		*Fills the quaternion object with values representing the given rotation around a vector.
		*
		*@param axis The axis around which to rotate
		*@param angle The angle in radians of the rotation.
		*/
		__proto.fromAxisAngle=function(axis,angle){
			var sin_a=Math.sin(angle/2);
			var cos_a=Math.cos(angle/2);
			this.x=axis.x*sin_a;
			this.y=axis.y*sin_a;
			this.z=axis.z*sin_a;
			this.w=cos_a;
			this.normalize();
		}

		/**
		*Spherically interpolates between two quaternions,providing an interpolation between rotations with constant angle change rate.
		*@param qa The first quaternion to interpolate.
		*@param qb The second quaternion to interpolate.
		*@param t The interpolation weight,a value between 0 and 1.
		*/
		__proto.slerp=function(qa,qb,t){
			var w1=qa.w,x1=qa.x,y1=qa.y,z1=qa.z;
			var w2=qb.w,x2=qb.x,y2=qb.y,z2=qb.z;
			var dot=w1*w2+x1*x2+y1*y2+z1*z2;
			if (dot < 0){
				dot=-dot;
				w2=-w2;
				x2=-x2;
				y2=-y2;
				z2=-z2;
			}
			if (dot < 0.95){
				var angle=Math.acos(dot);
				var s=1/Math.sin(angle);
				var s1=Math.sin(angle*(1-t))*s;
				var s2=Math.sin(angle*t)*s;
				this.w=w1*s1+w2*s2;
				this.x=x1*s1+x2*s2;
				this.y=y1*s1+y2*s2;
				this.z=z1*s1+z2*s2;
				}else {
				this.w=w1+t*(w2-w1);
				this.x=x1+t*(x2-x1);
				this.y=y1+t*(y2-y1);
				this.z=z1+t*(z2-z1);
				var len=1.0/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);
				this.w *=len;
				this.x *=len;
				this.y *=len;
				this.z *=len;
			}
		}

		/**
		*Linearly interpolates between two quaternions.
		*@param qa The first quaternion to interpolate.
		*@param qb The second quaternion to interpolate.
		*@param t The interpolation weight,a value between 0 and 1.
		*/
		__proto.lerp=function(qa,qb,t){
			var w1=qa.w,x1=qa.x,y1=qa.y,z1=qa.z;
			var w2=qb.w,x2=qb.x,y2=qb.y,z2=qb.z;
			var len=NaN;
			if (w1*w2+x1*x2+y1*y2+z1*z2 < 0){
				w2=-w2;
				x2=-x2;
				y2=-y2;
				z2=-z2;
			}
			this.w=w1+t*(w2-w1);
			this.x=x1+t*(x2-x1);
			this.y=y1+t*(y2-y1);
			this.z=z1+t*(z2-z1);
			len=1.0/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);
			this.w *=len;
			this.x *=len;
			this.y *=len;
			this.z *=len;
		}

		/**
		*Fills the quaternion object with values representing the given euler rotation.
		*
		*@param ax The angle in radians of the rotation around the ax axis.
		*@param ay The angle in radians of the rotation around the ay axis.
		*@param az The angle in radians of the rotation around the az axis.
		*/
		__proto.fromEulerAngles=function(ax,ay,az){
			var halfX=ax*.5,halfY=ay*.5,halfZ=az*.5;
			var cosX=Math.cos(halfX),sinX=Math.sin(halfX);
			var cosY=Math.cos(halfY),sinY=Math.sin(halfY);
			var cosZ=Math.cos(halfZ),sinZ=Math.sin(halfZ);
			this.w=cosX*cosY*cosZ+sinX*sinY*sinZ;
			this.x=sinX*cosY*cosZ-cosX*sinY*sinZ;
			this.y=cosX*sinY*cosZ+sinX*cosY*sinZ;
			this.z=cosX*cosY*sinZ-sinX*sinY*cosZ;
		}

		/**
		*Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
		*@param target An optional Vector3D object to contain the Euler angles. If not provided,a new object is created.
		*@return The Vector3D containing the Euler angles.
		*/
		__proto.toEulerAngles=function(target){target=target|| new Vector3D();
			target.x=Math.atan2(2*(this.w*this.x+this.y*this.z),1-2*(this.x*this.x+this.y*this.y));
			target.y=Math.asin(2*(this.w*this.y-this.z*this.x));
			target.z=Math.atan2(2*(this.w*this.z+this.x*this.y),1-2*(this.y*this.y+this.z*this.z));
			return target;
		}

		/**
		*Normalises the quaternion object.
		*/
		__proto.normalize=function(val){
			(val===void 0)&& (val=1);
			var mag=val/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);
			this.x *=mag;
			this.y *=mag;
			this.z *=mag;
			this.w *=mag;
		}

		/**
		*Used to trace the values of a quaternion.
		*
		*@return A string representation of the quaternion object.
		*/
		__proto.toString=function(){
			return "{x:"+this.x+" y:"+this.y+" z:"+this.z+" w:"+this.w+"}";
		}

		/**
		*Converts the quaternion to a Matrix3D object representing an equivalent rotation.
		*@param target An optional Matrix3D container to store the transformation in. If not provided,a new object is created.
		*@return A Matrix3D object representing an equivalent rotation.
		*/
		__proto.toMatrix3D=function(target){
			var m=new Matrix3D();
			var xy2=2.0*this.x*this.y,xz2=2.0*this.x*this.z,xw2=2.0*this.x*this.w;
			var yz2=2.0*this.y*this.z,yw2=2.0*this.y*this.w,zw2=2.0*this.z*this.w;
			var xx=this.x*this.x,yy=this.y*this.y,zz=this.z*this.z,ww=this.w*this.w;
			m.rawData[0]=xx-yy-zz+ww;
			m.rawData[4]=xy2-zw2;
			m.rawData[8]=xz2+yw2;
			m.rawData[12]=0;
			m.rawData[1]=xy2+zw2;
			m.rawData[5]=-xx+yy-zz+ww;
			m.rawData[9]=yz2-xw2;
			m.rawData[13]=0;
			m.rawData[2]=xz2-yw2;
			m.rawData[6]=yz2+xw2;
			m.rawData[10]=-xx-yy+zz+ww;
			m.rawData[14]=0;
			m.rawData[3]=0.0;
			m.rawData[7]=0.0;
			m.rawData[11]=0;
			m.rawData[15]=1;
			if (!target)
				return m;
			target.rawData=m.rawData;
			return target;
		}

		/**
		*Extracts a quaternion rotation matrix out of a given Matrix3D object.
		*@param matrix The Matrix3D out of which the rotation will be extracted.
		*/
		__proto.fromMatrix=function(matrix){
			var v;
			var vec=[];
			vec[0]=new Vector3D();
			vec[1]=new Vector3D();
			vec[2]=new Vector3D();
			matrix.decompose("Quaternion",vec);
			v=vec[1];
			this.x=v.x;
			this.y=v.y;
			this.z=v.z;
			this.w=v.w;
		}

		/**
		*Converts the quaternion to a Vector.&lt;Number&gt;matrix representation of a rotation equivalent to this quaternion.
		*@param target The Vector.&lt;Number&gt;to contain the raw matrix data.
		*@param exclude4thRow If true,the last row will be omitted,and a 4x3 matrix will be generated instead of a 4x4.
		*/
		__proto.toRawData=function(target,exclude4thRow){
			(exclude4thRow===void 0)&& (exclude4thRow=false);
			var xy2=2.0*this.x*this.y,xz2=2.0*this.x*this.z,xw2=2.0*this.x*this.w;
			var yz2=2.0*this.y*this.z,yw2=2.0*this.y*this.w,zw2=2.0*this.z*this.w;
			var xx=this.x*this.x,yy=this.y*this.y,zz=this.z*this.z,ww=this.w*this.w;
			target[0]=xx-yy-zz+ww;
			target[1]=xy2-zw2;
			target[2]=xz2+yw2;
			target[4]=xy2+zw2;
			target[5]=-xx+yy-zz+ww;
			target[6]=yz2-xw2;
			target[8]=xz2-yw2;
			target[9]=yz2+xw2;
			target[10]=-xx-yy+zz+ww;
			target[3]=target[7]=target[11]=0;
			if (!exclude4thRow){
				target[12]=target[13]=target[14]=0;
				target[15]=1;
			}
		}

		/**
		*Clones the quaternion.
		*@return An exact duplicate of the current Quaternion.
		*/
		__proto.clone=function(){
			return new Quaternion(this.x,this.y,this.z,this.w);
		}

		/**
		*Rotates a point.
		*@param vector The Vector3D object to be rotated.
		*@param target An optional Vector3D object that will contain the rotated coordinates. If not provided,a new object will be created.
		*@return A Vector3D object containing the rotated point.
		*/
		__proto.rotatePoint=function(vector,target){
			var x1=NaN,y1=NaN,z1=NaN,w1=NaN;
			var x2=vector.x,y2=vector.y,z2=vector.z;target=target|| new Vector3D();
			w1=-this.x*x2-this.y*y2-this.z*z2;
			x1=this.w*x2+this.y*z2-this.z*y2;
			y1=this.w*y2-this.x*z2+this.z*x2;
			z1=this.w*z2+this.x*y2-this.y*x2;
			target.x=-w1*this.x+x1*this.w-y1*this.z+z1*this.y;
			target.y=-w1*this.y+x1*this.z+y1*this.w-z1*this.x;
			target.z=-w1*this.z-x1*this.y+y1*this.x+z1*this.w;
			return target;
		}

		/**
		*Copies the data from a quaternion into this instance.
		*@param q The quaternion to copy from.
		*/
		__proto.copyFrom=function(q){
			this.x=q.x;
			this.y=q.y;
			this.z=q.z;
			this.w=q.w;
		}

		/**
		*Returns the magnitude of the quaternion object.
		*/
		__getset(0,__proto,'magnitude',function(){
			return Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);
		});

		return Quaternion;
	})()


	/**
	*Vector3D
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.geom.Vector3D
	var Vector3D=(function(){
		function Vector3D(x,y,z,w){
			this.elements=new Float32Array(4);
			this.elements3=new Float32Array(3);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(w===void 0)&& (w=0);
			this.elements[0]=x;
			this.elements[1]=y;
			this.elements[2]=z;
			this.elements[3]=w;
		}

		__class(Vector3D,'specter3d.engine.core.geom.Vector3D');
		var __proto=Vector3D.prototype;
		/**
		*　将当前 Vector3D 对象的 x、y 和 z 元素的值与另一个 Vector3D 对象的 x、y 和 z 元素的值相加。
		*@param v
		*@return
		*
		*/
		__proto.add=function(v){
			this.elements[0]+=v.x;
			this.elements[1]+=v.y;
			this.elements[2]+=v.z;
			return this;
		}

		/**
		*　返回一个新 Vector3D 对象，它是与当前 Vector3D 对象完全相同的副本。
		*@return
		*
		*/
		__proto.clone=function(){
			return new Vector3D(this.elements[0],this.elements[1],this.elements[2],this.elements[3]);
		}

		/**
		*从一个三维向量复制。
		*@param v 源向量。
		*/
		__proto.copyFrom=function(v){
			var e=this.elements,s=v.elements;
			e[0]=s[0];
			e[1]=s[1];
			e[2]=s[2];
			return this;
		}

		/**
		*　返回一个新的 Vector3D 对象，它与当前 Vector3D 对象和另一个 Vector3D 对象垂直（成直角）。
		*@param v
		*@return
		*
		*/
		__proto.crossProduct=function(v){
			var x1=this.y *v.z-this.z *v.y;
			var y1=this.z *v.x-this.x *v.z;
			var z1=this.x *v.y-this.y *v.x;
			return new Vector3D(x1,y1,z1);
		}

		/**
		*　按照指定的 Vector3D 对象的 x、y 和 z 元素的值递减当前 Vector3D 对象的 x、y 和 z 元素的值。
		*@param v
		*
		*/
		__proto.decrementBy=function(v){
			this.elements[0]-=v.x;
			this.elements[1]-=v.y;
			this.elements[2]-=v.z;
		}

		/**
		*　如果当前 Vector3D 对象和作为参数指定的 Vector3D 对象均为单元顶点，此方法将返回这两个顶点之间所成角的余弦值。
		*@param v
		*@return
		*
		*/
		__proto.dotProduct=function(v){
			return specter3d.engine.core.geom.Vector3D.dot(this,v);
		}

		/**
		*将当前 Vector3D 对象设置为其逆对象。也可以将逆对象视为与原始对象相反的对象。当前 Vector3D 对象的 x、y 和 z 属性的值将更改为-x、-y 和-z。
		*
		*/
		__proto.negate=function(){
			this.elements[0]=-this.elements[0];
			this.elements[1]=-this.elements[1];
			this.elements[2]=-this.elements[2];
		}

		/**
		*通过将最前面的三个元素（x、y、z）除以矢量的长度可将 Vector3D 对象转换为单位矢量。
		*
		*/
		__proto.normalize=function(){
			var invLenght=0.0;
			if (this.length==0){
				invLenght=0;
			}
			else{
				invLenght=1.0 / this.length;
			}
			this.elements[0]*=invLenght;
			this.elements[1]*=invLenght;
			this.elements[2]*=invLenght;
		}

		/**
		*将当前 Vector3D 对象的 x、y 和 z 属性的值除以其 w 属性的值。
		*
		*/
		__proto.project=function(){
			this.elements[0]/=this.elements[3];
			this.elements[1]/=this.elements[3];
			this.elements[2]/=this.elements[3];
		}

		__proto.scaleBy=function(val){
			specter3d.engine.core.geom.Vector3D.scale(this,val,this);
		}

		__proto.setTo=function(x,y,z,w){
			this.elements[0]=x;
			this.elements[1]=y;
			this.elements[2]=z;
			this.elements[3]=w;
		}

		/**
		*从另一个 Vector3D 对象的 x、y 和 z 元素的值中减去当前 Vector3D 对象的 x、y 和 z 元素的值。
		*@param a
		*@return
		*
		*/
		__proto.subtract=function(a){
			specter3d.engine.core.geom.Vector3D.subtract(this,a,this);
			return this;
		}

		/**考虑shader需要使用vec3的格式所以特殊处理一下 .vec4 格式请直接使用elements*/
		__getset(0,__proto,'elementsForVec3',function(){
			this.elements3[0]=this.elements[0];
			this.elements3[1]=this.elements[1];
			this.elements3[2]=this.elements[2];
			return this.elements3;
		});

		/**
		*设置Z轴坐标。
		*@param z Z轴坐标。
		*/
		/**
		*获取W轴坐标。
		*@return w W轴坐标。
		*/
		__getset(0,__proto,'w',function(){
			return this.elements[3];
			},function(value){
			this.elements[3]=value;
		});

		/**
		*当前 Vector3D 对象的长度（大小），即从原点 (0,0,0)到该对象的 x、y 和 z 坐标的距离。
		*@return
		*
		*/
		__getset(0,__proto,'length',function(){
			return Math.sqrt(this.elements[0] *this.elements[0]+this.elements[1] *this.elements[1]+this.elements[2] *this.elements[2]);
		});

		/**
		*　当前 Vector3D 对象长度的平方，它是使用 x、y 和 z 属性计算出来的。
		*@return
		*
		*/
		__getset(0,__proto,'lengthSquared',function(){
			return this.elements[0] *this.elements[0]+this.elements[1] *this.elements[1]+this.elements[2] *this.elements[2];
		});

		/**
		*设置X轴坐标。
		*@param x X轴坐标。
		*/
		/**
		*获取X轴坐标。
		*@return x X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
			},function(value){
			this.elements[0]=value;
		});

		/**
		*设置Y轴坐标。
		*@param y Y轴坐标。
		*/
		/**
		*获取Y轴坐标。
		*@return y Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
			},function(value){
			this.elements[1]=value;
		});

		/**
		*设置Z轴坐标。
		*@param z Z轴坐标。
		*/
		/**
		*获取Z轴坐标。
		*@return z Z轴坐标。
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
			},function(value){
			this.elements[2]=value;
		});

		Vector3D.distance=function(pt1,pt2){
			return Math.sqrt(((pt1.x-pt2.x)^ 2+(pt1.y-pt2.y)^ 2+(pt1.z-pt2.z)^ 2));
		}

		Vector3D.distanceSquared=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			return (x *x)+(y *y)+(z *z);
		}

		Vector3D.dot=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2]);
			return r;
		}

		Vector3D.lerp=function(a,b,t,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements;
			var ax=f[0],ay=f[1],az=f[2];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
		}

		Vector3D.max=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.max(f[0],g[0]);
			e[1]=Math.max(f[1],g[1]);
			e[2]=Math.max(f[2],g[2]);
		}

		Vector3D.min=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.min(f[0],g[0]);
			e[1]=Math.min(f[1],g[1]);
			e[2]=Math.min(f[2],g[2]);
		}

		Vector3D.multiply=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=f[0] *g[0];
			e[1]=f[1] *g[1];
			e[2]=f[2] *g[2];
		}

		Vector3D.scale=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			e[0]=f[0] *b;
			e[1]=f[1] *b;
			e[2]=f[2] *b;
		}

		Vector3D.subtract=function(a,b,o){
			var oe=o.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0]-be[0];
			oe[1]=ae[1]-be[1];
			oe[2]=ae[2]-be[2];
		}

		__static(Vector3D,
		['X_AXIS',function(){return this.X_AXIS=new Vector3D(1.0,0.0,0.0,1.0);},'Y_AXIS',function(){return this.Y_AXIS=new Vector3D(0.0,1.0,0.0,1.0);},'Z_AXIS',function(){return this.Z_AXIS=new Vector3D(0.0,0.0,1.0,1.0);},'ZERO',function(){return this.ZERO=new Vector3D(0.0,0.0,0.0,1.0);},'HELP',function(){return this.HELP=new Vector3D(0.0,0.0,0.0,1.0);}
		]);
		return Vector3D;
	})()


	//class specter3d.engine.core.picker.PickerType
	var PickerType=(function(){
		function PickerType(){}
		__class(PickerType,'specter3d.engine.core.picker.PickerType');
		PickerType.BOUND=1;
		PickerType.MESH=2;
		return PickerType;
	})()


	//class specter3d.engine.core.picker.PickerVO
	var PickerVO=(function(){
		function PickerVO(target){
			this.target=null;
			this.distance=NaN;
			this.pickerType=0;
			this.localPosition=null;
			this.uv=null;
			this.index=0;
			this.surfaceIndex=0;
			this.renderable=null;
			this.localNormal=new Vector3D();
			this.localRayPosition=new Vector3D();
			this.localRayDirection=new Vector3D();
			this.target=target;
		}

		__class(PickerVO,'specter3d.engine.core.picker.PickerVO');
		var __proto=PickerVO.prototype;
		__proto.clone=function(){
			var vo=new PickerVO();
			vo.target=this.target;
			vo.distance=this.distance;
			vo.pickerType=this.pickerType;
			vo.localPosition=this.localPosition.clone();
			vo.uv=this.uv.clone();
			vo.localRayPosition=this.localRayPosition.clone();
			vo.localRayDirection=this.localRayDirection.clone();
			vo.localNormal=this.localNormal.clone();
			return vo;
		}

		return PickerVO;
	})()


	;
	//class specter3d.engine.core.picker.RaycastPicker
	var RaycastPicker=(function(){
		function RaycastPicker(){}
		__class(RaycastPicker,'specter3d.engine.core.picker.RaycastPicker');
		var __proto=RaycastPicker.prototype;
		__proto.dispose=function(){}
		__proto.getViewCollision=function(x,y,layer){
			var rayPosition=new Vector3D;
			var rayDirection=new Vector3D;
			layer.camera3d.screen2DToScene3D(x,y,0,rayPosition);
			layer.camera3d.screen2DToScene3D(x,y,1,rayDirection);
			Vector3DUtils.sub(rayDirection,rayPosition,rayDirection);
			var ray=new Ray(rayPosition,rayDirection);
			var entities=new Array;
			this.collectEntities(layer.scene3d._rootContainer3D,entities);
			var pickEntities=new Array;
			for (var i=0;i < entities.length;i++){
				if (this.intersectBound(entities[i],rayPosition,rayDirection)){
					pickEntities.push(entities[i]);
				}
			}
			if (pickEntities.length==0)
				return null;
			pickEntities.sort(this.sortDistance);
			var findClosestCollision=true;
			var shortestCollisionDistance=Number.MAX_VALUE;
			var bestCollisionVO;
			for (i=0;i < pickEntities.length;i++){
				var entity=pickEntities[i];
				var pickVO=entity.pickVO;
				if (!bestCollisionVO || pickVO.distance < bestCollisionVO.distance){
					if (entity.pickType==PickerType.BOUND){
						this.updateLocalPosition(pickVO);
						return pickVO;
					}
					else if (entity.pickType==PickerType.MESH){
						if (this.intersectMesh(entity,entity.pickVO.localPosition,entity.pickVO.localRayDirection,
							shortestCollisionDistance,findClosestCollision)){
							shortestCollisionDistance=pickVO.distance;
							bestCollisionVO=pickVO;
							if (!findClosestCollision){
								this.updateLocalPosition(pickVO);
								return pickVO;
							}
						}
					}
				}
			}
			return bestCollisionVO;
		}

		__proto.collectEntities=function(obj3d,result){
			if ((obj3d instanceof specter3d.engine.core.Entity3D )&& obj3d.visible && (obj3d).pickEnabled){
				result.push(obj3d);
			}
			for (var current=obj3d._childrenList;current !=null;current=current._next){
				this.collectEntities(current,result);
			}
		}

		__proto.sortDistance=function(a,b){
			return a.distance-b.distance;
		}

		__proto.intersectBound=function(entity,rayPosition,rayDirection){
			var pickVO=entity.pickVO;
			var invWorld=entity.transform.invWorld;
			var localRayPosition=pickVO.localRayPosition;
			var localRayDirection=pickVO.localRayDirection;
			Matrix3DUtils.transformVector(invWorld,rayPosition,localRayPosition);
			Matrix3DUtils.deltaTransformVector(invWorld,rayDirection,localRayDirection);
			var rayEntryDistance=entity.bound.rayIntersection(localRayPosition,localRayDirection,pickVO.localNormal);
			if (rayEntryDistance < 0)
				return false;
			pickVO.distance=rayEntryDistance;
			return true;
		}

		__proto.intersectMesh=function(mesh,rayPosition,rayDirection,shortestCollisionDistance,findClosest){
			mesh.pickVO.renderable=null;
			var length=mesh.surfaces.length;
			for (var i=0;i < length;i++){
				var surface=mesh.surfaces[i];
				if (this.intersectSurface(surface,mesh.pickVO.localRayPosition,mesh.pickVO.localRayDirection,
					mesh.pickVO,shortestCollisionDistance,findClosest)){
					shortestCollisionDistance=mesh.pickVO.distance;
					mesh.pickVO.renderable=surface;
					if (!findClosest)
						return true;
				}
			}
			return false;
		}

		__proto.intersectSurface=function(surface3D,localPosition,localDirection,pickVO,shortestCollisionDistance,findClosestCollision){
			(findClosestCollision===void 0)&& (findClosestCollision=false);
			var rayPosition=localPosition;
			var rayDirection=localDirection;
			var t=NaN;
			var i0=0,i1=0,i2=0;
			var rx=NaN,ry=NaN,rz=NaN;
			var nx=NaN,ny=NaN,nz=NaN;
			var cx=NaN,cy=NaN,cz=NaN;
			var coeff=NaN,u=NaN,v=NaN,w=NaN;
			var p0x=NaN,p0y=NaN,p0z=NaN;
			var p1x=NaN,p1y=NaN,p1z=NaN;
			var p2x=NaN,p2y=NaN,p2z=NaN;
			var s0x=NaN,s0y=NaN,s0z=NaN;
			var s1x=NaN,s1y=NaN,s1z=NaN;
			var nl=NaN,nDotV=NaN,D=NaN,disToPlane=NaN;
			var Q1Q2=NaN,Q1Q1=NaN,Q2Q2=NaN,RQ1=NaN,RQ2=NaN;
			var indexData=surface3D.indexData;
			var vertexData=surface3D.vertexData;
			var collisionTriangleIndex=-1;
			var bothSides=(surface3D.material && surface3D.material.bothSides);
			var vertexStride=surface3D.vertexStride;
			var vertexOffset=surface3D.vertexOffset;
			var numIndices=indexData.length;
			for (var index=0;index < numIndices;index+=3){
				i0=vertexOffset+indexData[ index]*vertexStride;
				i1=vertexOffset+indexData[ uint(index+1)]*vertexStride;
				i2=vertexOffset+indexData[ uint(index+2)]*vertexStride;
				p0x=vertexData[ i0];
				p0y=vertexData[ uint(i0+1)];
				p0z=vertexData[ uint(i0+2)];
				p1x=vertexData[ i1];
				p1y=vertexData[ uint(i1+1)];
				p1z=vertexData[ uint(i1+2)];
				p2x=vertexData[ i2];
				p2y=vertexData[ uint(i2+1)];
				p2z=vertexData[ uint(i2+2)];
				s0x=p1x-p0x;
				s0y=p1y-p0y;
				s0z=p1z-p0z;
				s1x=p2x-p0x;
				s1y=p2y-p0y;
				s1z=p2z-p0z;
				nx=s0y*s1z-s0z*s1y;
				ny=s0z*s1x-s0x*s1z;
				nz=s0x*s1y-s0y*s1x;
				nl=1/Math.sqrt(nx*nx+ny*ny+nz*nz);
				nx *=nl;
				ny *=nl;
				nz *=nl;
				nDotV=nx*rayDirection.x+ny*+rayDirection.y+nz*rayDirection.z;
				if ((!bothSides && nDotV < 0.0)|| (bothSides && nDotV !=0.0)){
					D=-(nx*p0x+ny*p0y+nz*p0z);
					disToPlane=-(nx*rayPosition.x+ny*rayPosition.y+nz*rayPosition.z+D);
					t=disToPlane/nDotV;
					cx=rayPosition.x+t*rayDirection.x;
					cy=rayPosition.y+t*rayDirection.y;
					cz=rayPosition.z+t*rayDirection.z;
					Q1Q2=s0x*s1x+s0y*s1y+s0z*s1z;
					Q1Q1=s0x*s0x+s0y*s0y+s0z*s0z;
					Q2Q2=s1x*s1x+s1y*s1y+s1z*s1z;
					rx=cx-p0x;
					ry=cy-p0y;
					rz=cz-p0z;
					RQ1=rx*s0x+ry*s0y+rz*s0z;
					RQ2=rx*s1x+ry*s1y+rz*s1z;
					coeff=1/(Q1Q1*Q2Q2-Q1Q2*Q1Q2);
					v=coeff*(Q2Q2*RQ1-Q1Q2*RQ2);
					w=coeff*(-Q1Q2*RQ1+Q1Q1*RQ2);
					if (v < 0)
						continue ;
					if (w < 0)
						continue ;
					u=1-v-w;
					if (!(u < 0)&& t > 0 && t < shortestCollisionDistance){
						shortestCollisionDistance=t;
						collisionTriangleIndex=index/3;
						pickVO.distance=t;
						pickVO.localPosition=new Vector3D(cx,cy,cz);
						pickVO.localNormal=new Vector3D(nx,ny,nz);
						pickVO.index=index;
						pickVO.surfaceIndex=surface3D.parentMesh.getSurfaceIndex(surface3D);
						if (!findClosestCollision)
							return true;
					}
				}
			}
			if (collisionTriangleIndex >=0)
				return true;
			return false;
		}

		__proto.getCollisionNormal=function(indexData,vertexData,triangleIndex,normal){
			var i0=indexData[ triangleIndex]*3;
			var i1=indexData[ triangleIndex+1]*3;
			var i2=indexData[ triangleIndex+2]*3;
			var side0x=vertexData[ i1]-vertexData[ i0];
			var side0y=vertexData[ i1+1]-vertexData[ i0+1];
			var side0z=vertexData[ i1+2]-vertexData[ i0+2];
			var side1x=vertexData[ i2]-vertexData[ i0];
			var side1y=vertexData[ i2+1]-vertexData[ i0+1];
			var side1z=vertexData[ i2+2]-vertexData[ i0+2];
			if(!normal)normal=new Vector3D();
			normal.x=side0y*side1z-side0z*side1y;
			normal.y=side0z*side1x-side0x*side1z;
			normal.z=side0x*side1y-side0y*side1x;
			normal.w=1;
			normal.normalize();
			return normal;
		}

		__proto.getCollisionUV=function(indexData,uvData,triangleIndex,v,w,u,uvOffset,uvStride,uv){
			var uIndex=indexData[ triangleIndex]*uvStride+uvOffset;
			var uv0x=uvData[ uIndex];
			var uv0y=uvData[ uIndex+1];
			uIndex=indexData[ triangleIndex+1]*uvStride+uvOffset;
			var uv1x=uvData[ uIndex];
			var uv1y=uvData[ uIndex+1];
			uIndex=indexData[ triangleIndex+2]*uvStride+uvOffset;
			var uv2x=uvData[ uIndex];
			var uv2y=uvData[ uIndex+1];
			if(!uv)uv=new Vector3D();
			uv.x=u*uv0x+v*uv1x+w*uv2x;
			uv.y=u*uv0y+v*uv1y+w*uv2y;
			return uv;
		}

		__proto.updateLocalPosition=function(pickVO){
			var collisionPos=pickVO.localPosition=pickVO.localPosition|| new Vector3D();
			var rayDir=pickVO.localRayDirection;
			var rayPos=pickVO.localRayPosition;
			var t=pickVO.distance;
			collisionPos.x=rayPos.x+t*rayDir.x;
			collisionPos.y=rayPos.y+t*rayDir.y;
			collisionPos.z=rayPos.z+t*rayDir.z;
		}

		return RaycastPicker;
	})()


	;
	/**
	*渲染单元
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.render.data.DrawUnit
	var DrawUnit=(function(){
		function DrawUnit(type){
			this._type=0;
			this._type=type;
		}

		__class(DrawUnit,'specter3d.engine.core.render.data.DrawUnit');
		var __proto=DrawUnit.prototype;
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		__getset(0,__proto,'subGeometry',function(){
			return null;
		});

		__getset(0,__proto,'material',function(){
			return null;
			},function(value){
		});

		// TODO Auto Generated method stub
		__getset(0,__proto,'transform',function(){
			return null;
		});

		DrawUnit.LIGHT_UNIT=0;
		DrawUnit.SURFACE_UNIT=1;
		DrawUnit.SKYBOX_UNIT=2;
		return DrawUnit;
	})()


	;
	/**
	*渲染器
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.render.Renderer
	var Renderer=(function(){
		function Renderer(_layer3d){
			this._camera3d=null;
			this._renderUnits=[];
			this._camera3d=_layer3d.camera3d;
		}

		__class(Renderer,'specter3d.engine.core.render.Renderer');
		var __proto=Renderer.prototype;
		__proto.clear=function(){
			this._renderUnits.length=0;
		}

		__proto.render=function(_context3d){
			if (_context3d){
				var _renderUnitsLength=this._renderUnits.length;
				for (var i=0;i < _renderUnitsLength;i++){
					var _renderUnit=this._renderUnits[i];
					if(_renderUnit.type==0){
					}
					else{
						if(!_renderUnit || !_renderUnit.material || !_renderUnit.subGeometry)return
							_renderUnit.material.activate(_renderUnit,_context3d,this._camera3d);
						_context3d.drawElements(0x0004,_renderUnit.subGeometry.numTriangles *3,0x1403,0);
					}
				}
			}
		}

		Renderer.__init$=function(){
			/*namespace*/;
		}

		return Renderer;
	})()


	//class specter3d.engine.debug.Debug
	var Debug=(function(){
		function Debug(){};
		__class(Debug,'specter3d.engine.debug.Debug');
		__getset(1,Debug,'channel',function(){
			return Debug._channel;
		});

		Debug.dotrace=function(user,__msg){
			var msg=[];for(var i=1,sz=arguments.length;i<sz;i++)msg.push(arguments[i]);
			if (Debug._channel==user || Debug._channel=="all"){
				msg.unshift("["+user+"->debug] running time:"+AppGlobalContext.renderDrive.time+" ms\n");
				Debug.traceLog(msg);
			}
		}

		Debug.error=function(user,__msg){
			var msg=[];for(var i=1,sz=arguments.length;i<sz;i++)msg.push(arguments[i]);
			if (Debug._channel==user || Debug._channel=="all"){
				msg.unshift("["+user+"->error] running time:"+AppGlobalContext.renderDrive.time+" ms\n");
				Debug.traceLog(msg);
			}
		}

		Debug.setChannel=function(value){
			Debug._channel=value;
		}

		Debug.warning=function(user,__msg){
			var msg=[];for(var i=1,sz=arguments.length;i<sz;i++)msg.push(arguments[i]);
			if (Debug._channel==user || Debug._channel=="all"){
				msg.unshift("["+user+"->warning] running time:"+AppGlobalContext.renderDrive.time+" ms\n");
				Debug.traceLog(msg);
			}
		}

		Debug.traceLog=function(obj){
			Debug.tempArr.length=0;
			var key;
			var index=0;
			for (key in obj){
				ArrayUtil.insertAt(Debug.tempArr,index++,obj[key]);
			};
			var rst;
			rst=Debug.tempArr.join("");
			console.log(rst);
		}

		Debug.ALL="all";
		Debug.ENGINE="engine";
		Debug.glslDebug=false;
		Debug._channel=null
		Debug.tempArr=[];
		return Debug;
	})()


	/**
	*<code>Event</code> 是事件类型的集合。
	*/
	//class laya.events.Event
	var Event=(function(){
		function Event(){
			//this.type=null;
			//this.nativeEvent=null;
			//this.target=null;
			//this.currentTarget=null;
			//this._stoped=false;
			//this.touchId=0;
			//this.keyCode=0;
		}

		__class(Event,'laya.events.Event');
		var __proto=Event.prototype;
		/**
		*设置事件数据。
		*@param type 事件类型。
		*@param currentTarget 事件目标触发对象。
		*@param target 事件当前冒泡对象。
		*@return 返回当前 Event 对象。
		*/
		__proto.setTo=function(type,currentTarget,target){
			this.type=type;
			this.currentTarget=currentTarget;
			this.target=target;
			return this;
		}

		/**
		*防止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。
		*/
		__proto.stopPropagation=function(){
			this._stoped=true;
		}

		/**
		*表示 Shift 键是处于活动状态 (true)还是非活动状态 (false)。
		*/
		__getset(0,__proto,'shiftKey',function(){
			return this.nativeEvent.shiftKey;
		});

		/**
		*触摸点列表。
		*/
		__getset(0,__proto,'touches',function(){
			var arr=this.nativeEvent.touches;
			if (arr){
				for (var i=0,n=arr.length;i < n;i++){
					var e=arr[i];
					var point=Point.TEMP;
					point.setTo(e.clientX,e.clientY);
					Laya.stage._canvasTransform.invertTransformPoint(point);
					e.stageX=point.x;
					e.stageY=point.y;
				}
			}
			return arr;
		});

		/**
		*表示 Alt 键是处于活动状态 (true)还是非活动状态 (false)。
		*/
		__getset(0,__proto,'altKey',function(){
			return this.nativeEvent.altKey;
		});

		/**
		*表示 Ctrl 键是处于活动状态 (true)还是非活动状态 (false)。
		*/
		__getset(0,__proto,'ctrlKey',function(){
			return this.nativeEvent.ctrlKey;
		});

		/**
		*表示键在键盘上的位置。这对于区分在键盘上多次出现的键非常有用。<br>
		*例如，您可以根据此属性的值来区分左 Shift 键和右 Shift 键：左 Shift 键的值为 KeyLocation.LEFT，右 Shift 键的值为 KeyLocation.RIGHT。另一个示例是区分标准键盘 (KeyLocation.STANDARD)与数字键盘 (KeyLocation.NUM_PAD)上按下的数字键。
		*/
		__getset(0,__proto,'keyLocation',function(){
			return this.nativeEvent.keyLocation;
		});

		/**
		*包含按下或释放的键的字符代码值。字符代码值为英文键盘值。
		*/
		__getset(0,__proto,'charCode',function(){
			return this.nativeEvent.charCode;
		});

		Event.EMPTY=new Event();
		Event.MOUSE_DOWN="mousedown";
		Event.MOUSE_UP="mouseup";
		Event.CLICK="click";
		Event.RIGHT_MOUSE_DOWN="rightmousedown";
		Event.RIGHT_MOUSE_UP="rightmouseup";
		Event.RIGHT_CLICK="rightclick";
		Event.MOUSE_MOVE="mousemove";
		Event.MOUSE_OVER="mouseover";
		Event.MOUSE_OUT="mouseout";
		Event.MOUSE_WHEEL="mousewheel";
		Event.ROLL_OVER="mouseover";
		Event.ROLL_OUT="mouseout";
		Event.DOUBLE_CLICK="doubleclick";
		Event.CHANGE="change";
		Event.CHANGED="changed";
		Event.RESIZE="resize";
		Event.ADDED="added";
		Event.REMOVED="removed";
		Event.DISPLAY="display";
		Event.UNDISPLAY="undisplay";
		Event.ERROR="error";
		Event.COMPLETE="complete";
		Event.LOADED="loaded";
		Event.PROGRESS="progress";
		Event.INPUT="input";
		Event.RENDER="render";
		Event.OPEN="open";
		Event.MESSAGE="message";
		Event.CLOSE="close";
		Event.KEY_DOWN="keydown";
		Event.KEY_PRESS="keypress";
		Event.KEY_UP="keyup";
		Event.FRAME="enterframe";
		Event.DRAG_START="dragstart";
		Event.DRAG_MOVE="dragmove";
		Event.DRAG_END="dragend";
		Event.ENTER="enter";
		Event.SELECT="select";
		Event.BLUR="blur";
		Event.FOCUS="focus";
		Event.PLAYED="played";
		Event.PAUSED="paused";
		Event.STOPPED="stopped";
		Event.START="start";
		Event.END="end";
		Event.ENABLED_CHANGED="enabledchanged";
		Event.COMPONENT_ADDED="componentadded";
		Event.COMPONENT_REMOVED="componentremoved";
		Event.ACTIVE_CHANGED="activechanged";
		Event.LAYER_CHANGED="layerchanged";
		Event.HIERARCHY_LOADED="hierarchyloaded";
		Event.RECOVERING="recovering";
		Event.RECOVERED="recovered";
		Event.RELEASED="released";
		Event.LINK="link";
		Event.LABEL="label";
		Event.FULL_SCREEN_CHANGE="fullscreenchange";
		Event.DEVICE_LOST="devicelost";
		Event.MESH_CHANGED="meshchanged";
		Event.MATERIAL_CHANGED="materialchanged";
		Event.RENDERQUEUE_CHANGED="renderqueuechanged";
		Event.WORLDMATRIX_NEEDCHANGE="worldmatrixneedchanged";
		return Event;
	})()


	//class specter3d.engine.lights.LightType
	var LightType=(function(){
		function LightType(){};
		__class(LightType,'specter3d.engine.lights.LightType');
		LightType.DIRECTION_LIGHT=0x00;
		LightType.POINT_LIGHT=0x01;
		LightType.SPOT_LIGHT=0x02;
		return LightType;
	})()


	/**
	*资源分组枚举值定义
	*@author wangcx
	*
	*/
	//class specter3d.engine.loaders.AssetGroupEnum
	var AssetGroupEnum=(function(){
		function AssetGroupEnum(){};
		__class(AssetGroupEnum,'specter3d.engine.loaders.AssetGroupEnum');
		AssetGroupEnum.DEFAULT_GROUP="default_group";
		AssetGroupEnum.SCENE_GROUP="scene_group";
		AssetGroupEnum.EFFECT_GROUP="effect_group";
		AssetGroupEnum.UI_ROOT_GROUP="ui_root_group";
		AssetGroupEnum.TEMP_UI_GROUP="temp_ui_group";
		return AssetGroupEnum;
	})()


	//class specter3d.engine.loaders.AssetLib
	var AssetLib=(function(){
		function AssetLib(){};
		__class(AssetLib,'specter3d.engine.loaders.AssetLib');
		AssetLib.addCite=function(url,citeKey){
			var arr=AssetLib.citeList.getValue(url);
			arr=arr=arr|| [];
			if(arr.indexOf(citeKey)==-1){
				arr.push(citeKey);
				AssetLib.citeList.put(url,arr);
			}
		}

		AssetLib.delAsset=function(url){
			url=AssetLib.operationUrlByVersion(url);
			var _isDefaultGroup=false;
			var _groupArr=AssetLib._assetGroupCiteList.getValue(url);
			var _index=-1;
			if (_groupArr){
				for (var i=0;i < _groupArr.length;i++){
					if(_groupArr[i] !="default_group"){
						var _assetArray=AssetLib._assetGroupInfoLib.getValue(_groupArr[i]);
						if (_assetArray !=null){
							_index=_assetArray.indexOf(url);
							_index !=-1 && _assetArray.splice(_index,1);
						}
					}
					else{
						_isDefaultGroup=true;
					}
				}
				if(!_isDefaultGroup){
					AssetLib._assetGroupCiteList.remove(url);
					AssetLib.disposeAsset(url);
				}
				else{
					AssetLib._assetGroupCiteList.put(url,["default_group"]);
				}
			}
		}

		AssetLib.getResourceURL=function(url){
			url=AssetLib.relativePath+url;
			var realUrl=specter3d.engine.loaders.AssetLib.getRealUrl(url);
			return realUrl ? (url+"?"+realUrl):url;
		}

		AssetLib.disposeAsset=function(url){
			try{
			}
			catch (e){
				Debug.error("engine","dispose() "+url+" error!");
			}
		}

		AssetLib.disposeGroup=function(group,ignoreCite){
			(ignoreCite===void 0)&& (ignoreCite=false);
			if(group=="default_group"){
				return;
			};
			var _assetUrlArr=AssetLib._assetGroupInfoLib.remove(group);
			if (_assetUrlArr){
				for (var i=0;i < _assetUrlArr.length;i++){
					var url=_assetUrlArr[i];
					var _groupArr=AssetLib._assetGroupCiteList.getValue(url);
					var _index=_groupArr.indexOf(group);
					_index !=-1 && _groupArr.splice(_index,1);
					if (_groupArr.length==0){
						if(!ignoreCite){
							url=url.replace(specter3d.engine.loaders.AssetLib.relativePath,"");
							var arr=AssetLib.citeList.getValue(url);
							if(arr && arr.length==0){
								AssetLib.disposeAsset(url);
							}
							else if(arr==null){
								AssetLib.disposeAsset(url);
							}
						}
						else{
							AssetLib.citeList.remove(url);
							AssetLib.disposeAsset(url);
						}
					}
				}
			}
		}

		AssetLib.getImage=function(url,citeKey){
			return AssetLib.getAsset(url,citeKey);
		}

		AssetLib.getArrayBuffer=function(url,citeKey){
			return AssetLib.getAsset(url,citeKey);
		}

		AssetLib.getAsset=function(url,citeKey){
			var _asset=AssetLib._assetLib.getValue(AssetLib.operationUrlByVersion(url));
			if(_asset){
				AssetLib.addCite(url,citeKey);
				AssetLib.autoRecoveryList.remove(url);
			}
			return _asset;
		}

		AssetLib.disposeAssetCite=function(url,citeKey){
			var arr=AssetLib.citeList.getValue(url);
			arr=arr=arr|| [];
			var index=arr.indexOf(citeKey);
			index !=-1 && arr.splice(index,1);
			if(arr && arr.length==0){
				AssetLib.delAsset(url);
				AssetLib.citeList.remove(url);
			}
		}

		AssetLib.operationUrlByVersion=function(url){
			if (!url){
				return url;
			}
			url=AssetLib.formatPath(url);
			if(url.indexOf(AssetLib.relativePath)!=-1){
				return url;
			}
			if (url.indexOf("assets")==-1){
				url=AssetLib.relativePath+url;
			}
			return url;
		}

		AssetLib.hasAsset=function(url){
			if (AssetLib.requestErrorDic.indexOf(url)!=-1){
				return false;
			}
			url=url.replace(AssetLib.relativePath,"");
			return AssetLib._assetLib.containsKey(AssetLib.operationUrlByVersion(url));
		}

		AssetLib.hasAssets=function(urls){
			var url;
			for(var $each_url in urls){
				url=urls[$each_url];
				if (!AssetLib.hasAsset(url)){
					return false;
				}
			}
			return true
		}

		AssetLib.hasAssetByGroup=function(url,group){
			var _assetGroup=AssetLib._assetGroupInfoLib.getValue(group);
			if (!_assetGroup)
				return false;
			var index=_assetGroup.indexOf(url);
			return index !=-1 ? true :false;
		}

		AssetLib.autoRecovery=function(time){
			AssetLib.autoRecoveryList.forEach(AssetLib.autoRecoveryForEach,time);
		}

		AssetLib.autoRecoveryForEach=function(key,value,time){
			var _asset=value;
			if(_asset && (time-_asset.lastUseTime)> 10000){
				AssetLib.autoRecoveryList.remove(key);
				AssetLib.delAsset(key);
			}
		}

		AssetLib.putAsset=function(url,data,group){
			var list=AssetLib._assetGroupInfoLib.getValue(group);
			if (list==null){
				list=[];
				AssetLib._assetGroupInfoLib.put(group,list);
			};
			var index=list.indexOf(url);
			if (index==-1){
				list.push(url);
			}
			AssetLib._assetLib.put(url,data);
			if((data instanceof specter3d.engine.loaders.parsers.AssetObject )){
				AssetLib.autoRecoveryList.put(url.replace(specter3d.engine.loaders.AssetLib.relativePath,""),data);
			};
			var groupArr=AssetLib._assetGroupCiteList.getValue(url);
			groupArr=groupArr=groupArr||[];
			if (groupArr.indexOf(group)==-1){
				groupArr.push(group);
				AssetLib._assetGroupCiteList.put(url,groupArr);
			}
		}

		AssetLib.getRepeatResources=function(url){
			return AssetLib._assetLib.getValue(url);
		}

		AssetLib.formatPath=function(path){
			if (path==null){
				return "";
			}
			path=path.replace(/\\\\/g,"\\");
			path=path.replace(/\\/g,"/");
			return path;
		}

		AssetLib.C3DS_TYPE=".3ds";
		AssetLib.JPG_TYPE=".jpg";
		AssetLib.PNG_TYPE=".png";
		AssetLib.MP3_TYPE=".mp3";
		AssetLib.ZMD5MESH_TYPE=".zmd5mesh";
		AssetLib.relativePath="";
		AssetLib.getRealUrl=null;
		AssetLib.requestErrorDic=[];
		__static(AssetLib,
		['_assetGroupInfoLib',function(){return this._assetGroupInfoLib=new HashMap;},'_assetLib',function(){return this._assetLib=new HashMap;},'_assetGroupCiteList',function(){return this._assetGroupCiteList=new HashMap();},'citeList',function(){return this.citeList=new HashMap();},'autoRecoveryList',function(){return this.autoRecoveryList=new HashMap();}
		]);
		return AssetLib;
	})()


	//class specter3d.engine.loaders.AssetType
	var AssetType=(function(){
		function AssetType(){};
		__class(AssetType,'specter3d.engine.loaders.AssetType');
		AssetType.ENTITY='entity';
		AssetType.SPRITE3D='sprite3d';
		AssetType.SEGMENT_SET='segmentSet';
		AssetType.MESH='mesh';
		AssetType.COMPLEX_MESH='complex_mesh';
		AssetType.GEOMETRY='geometry';
		AssetType.SKELETON='skeleton';
		AssetType.SKELETON_POSE='skeletonPose';
		AssetType.CONTAINER='container';
		AssetType.TEXTURE='texture';
		AssetType.MATERIAL='material';
		AssetType.ANIMATION_SET='animationSet';
		AssetType.ANIMATION_STATE='animationState';
		AssetType.ANIMATION_NODE='animationNode';
		AssetType.STATE_TRANSITION='stateTransition';
		AssetType.SKELETON_BONE_TAG="skeletonBoneTag";
		return AssetType;
	})()


	/**
	*A Skeleton object is a hierarchical grouping of joint objects that can be used for skeletal animation.
	*
	*@see away3d.animators.data.SkeletonJoint
	*/
	//class specter3d.engine.loaders.data.Skeleton
	var Skeleton=(function(){
		function Skeleton(){
			this.joints=null;
			this.joints=[];
		}

		__class(Skeleton,'specter3d.engine.loaders.data.Skeleton');
		var __proto=Skeleton.prototype;
		/**
		*Returns the joint object in the skeleton with the given name,otherwise returns a null object.
		*
		*@param jointName The name of the joint object to be found.
		*@return The joint object with the given name.
		*
		*@see #joints
		*/
		__proto.jointFromName=function(jointName){
			var jointIndex=this.jointIndexFromName(jointName);
			if (jointIndex !=-1)
				return this.joints[jointIndex];
			else
			return null;
		}

		/**
		*Returns the joint index,given the joint name.-1 is returned if the joint name is not found.
		*
		*@param jointName The name of the joint object to be found.
		*@return The index of the joint object in the joints vector.
		*
		*@see #joints
		*/
		__proto.jointIndexFromName=function(jointName){
			var jointIndex=0;
			var joint;
			for(var $each_joint in this.joints){
				joint=this.joints[$each_joint];
				if (joint.name==jointName)
					return jointIndex;
				jointIndex++;
			}
			return-1;
		}

		/**
		*@inheritDoc
		*/
		__proto.dispose=function(){
			this.joints.length=0;
		}

		/**
		*The total number of joints in the skeleton.
		*/
		__getset(0,__proto,'numJoints',function(){
			return this.joints.length;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'assetType',function(){
			return 'SKELETON';
		});

		return Skeleton;
	})()


	/**
	*A value obect representing a single joint in a skeleton object.
	*
	*@see away3d.animators.data.Skeleton
	*/
	//class specter3d.engine.loaders.data.SkeletonJoint
	var SkeletonJoint=(function(){
		function SkeletonJoint(){
			this.parentIndex=-1;
			this.name=null;
			this.inverseBindPose=null;
		}

		__class(SkeletonJoint,'specter3d.engine.loaders.data.SkeletonJoint');
		return SkeletonJoint;
	})()


	//class specter3d.engine.loaders.MultithreadedLoader
	var MultithreadedLoader=(function(){
		function MultithreadedLoader(){
			this._failure=false;
			this.init();
		}

		__class(MultithreadedLoader,'specter3d.engine.loaders.MultithreadedLoader');
		var __proto=MultithreadedLoader.prototype;
		__proto.startLoadTime=function(){
			if (MultithreadedLoader._loaderPool.length==0 || MultithreadedLoader._loadlist.length==0){
				AppGlobalContext.timer.clear(this,this.onTimeHandler);
				MultithreadedLoader._timerRunning=false;
			}
			if (MultithreadedLoader._timerRunning==false){
				AppGlobalContext.timer.loop(10,this,this.onTimeHandler);
				MultithreadedLoader._timerRunning=true;
			}
		}

		__proto.onTimeHandler=function(){
			for (var i=0;i < MultithreadedLoader._maxConnectionNum;i++){
				this.start();
			}
		}

		__proto.start=function(){
			if (MultithreadedLoader._loaderPool.length==0){
				return;
			};
			var loader;
			if(MultithreadedLoader._loadlist.length > 0){
				MultithreadedLoader._loadlist.sort(this.sortLoadList);
				loader=MultithreadedLoader._loaderPool.pop();
				var resourceVo=MultithreadedLoader._loadlist.pop();
				MultithreadedLoader._useLoaderMap.set(resourceVo.url,loader);
				loader.loadOne(resourceVo,null,resourceVo.group);
			}
		}

		__proto.sortLoadList=function(a,b){
			return a.level-b.level;
		}

		__proto.init=function(){
			Debug.dotrace("engine","MultithreadedLoader init.");
			if(MultithreadedLoader._loaderPool.length > 0)
				return;
			FileLoader.registerParserAll();
			for (var i=0;i < MultithreadedLoader._maxConnectionNum;i++){
				var deamon=new QueueFileLoader();
				MultithreadedLoader._loaderPool.push(deamon);
			}
		}

		/**
		*加载一组资源
		*@param arr ResourceVo 数组
		*@param callbackHandler,资源加载完回调函数
		*用法实例：
		*<p>var arr:Vector.<ResourceVo>=new Vector.<ResourceVo>();</p>
		*<p>arr.push(new ResourceVo("url0",1,test));//单个资源加载完完成</p>
		*<p>arr.push(new ResourceVo("url1",2,test));//单个资源加载完完成</p>
		*<p>arr.push(new ResourceVo("url2",3,test));//单个资源加载完完成</p>
		*<p>AppGlobalContext.fileLoader.loads(arr,test1);//该组所有资源加载完成</p>
		*加载完成之后从AssetLib这里面获取资源;
		*/
		__proto.loads=function(arr,callbackHandler,group){
			(group===void 0)&& (group="default_group");
			var map=new Dictionary;
			var info=[map,callbackHandler,0];
			var resourceVo;
			for(var $each_resourceVo in arr){
				resourceVo=arr[$each_resourceVo];
				MultithreadedLoader._groupMap.set(resourceVo,info);
				if(map.get(resourceVo)==null){
					map.set(resourceVo,resourceVo);
					info[2]+=1;
				}
				this.doAdd(resourceVo,null,group,true);
			}
			this.start();
		}

		/**
		*加载单个资源
		*@param resourceVo
		*@param callbackHandler,资源加载完回调函数
		*<p>用法实例：</p>
		*AppGlobalContext.fileLoader.fileLoader(new ResourceVo("url",1,callback));
		*<p>加载完成之后从AssetLib这里面获取资源</p>
		*/
		__proto.loadOne=function(resourceVo,group){
			(group===void 0)&& (group="default_group");
			this.doAdd(resourceVo,null,group);
		}

		/**
		*清除组
		*@param group
		*
		*/
		__proto.clearByGroup=function(group){
			var len=MultithreadedLoader._loadlist.length-1;
			for(var i=len;i>=0;i--){
				var loadVo=MultithreadedLoader._loadlist[i];
				if(loadVo.group==group){
					MultithreadedLoader._loadlist.splice(i,1);
					MultithreadedLoader._loadingUrlMap.remove(loadVo.url);
				}
			}
		}

		/**
		*取消加载
		*@param url
		*@param complete
		*
		*/
		__proto.cancelLoad=function(url,complete){
			url=AssetLib.operationUrlByVersion(url);
			var data=MultithreadedLoader._loadingUrlMap.get(url);
			if(data !=null){
				var list=data[1];
				var callBack=data [2];
				for(var i=list.length-1;i>=0;i--){
					var arr=list[i];
					var resourceVo=arr[0];
					if(resourceVo.callBackHandler==complete || arr[1]==complete){
						resourceVo.callBackHandler=null;
						list.splice(i,1);
					}
				}
				if(callBack==complete){
					data[2]=null;
				}
			}
		}

		/**
		*改变加载等级
		*@param url
		*@param level
		*
		*/
		__proto.chageLevel=function(url,level){
			var loadVo;
			for(var $each_loadVo in MultithreadedLoader._loadlist){
				loadVo=MultithreadedLoader._loadlist[$each_loadVo];
				if(loadVo.url==url){
					loadVo.level=level;
					break ;
				}
			}
		}

		__proto.doAdd=function(resourceVo,callbackHandler,group,isLockStart){
			(group===void 0)&& (group="default_group");
			(isLockStart===void 0)&& (isLockStart=false);
			var fileName=this.getFileName(resourceVo.url);
			if(fileName.indexOf("null")!=-1 || fileName==""){
				return;
			};
			var list;
			var loadVo;
			var data=MultithreadedLoader._loadingUrlMap.get(resourceVo.url);
			if (data !=null){
				loadVo=data[0];
				list=data[1];
				data[2]=callbackHandler;
				loadVo.level=Math.max(resourceVo.level,loadVo.level);
				list.unshift([resourceVo,callbackHandler]);
			}
			else{
				list=[[resourceVo,callbackHandler]];
				loadVo=new ResourceVo(resourceVo.url,resourceVo.level,Handler.create(this,this.onComplete),Handler.create(this,this.onErrorComplete));
				loadVo.url=resourceVo.url;
				MultithreadedLoader._loadingUrlMap.set(resourceVo.url,[loadVo,list,callbackHandler]);
				MultithreadedLoader._loadlist.push(loadVo);
			}
			loadVo.group=group;
			loadVo.progressCallBackHandler=resourceVo.progressCallBackHandler;
			if(isLockStart==false){
				this.startLoadTime();
			}
		}

		__proto.onErrorComplete=function(url){
			if(MultithreadedLoader.loaderErrorHandler !=null){
				MultithreadedLoader.loaderErrorHandler.runWith(url);
			}
			this._failure=true;
			this.onComplete(url)
			this._failure=false;
		}

		__proto.onComplete=function(url){
			var loader=MultithreadedLoader._useLoaderMap.get(url);
			var data=MultithreadedLoader._loadingUrlMap.get(url);
			MultithreadedLoader._loadingUrlMap.remove(url);
			MultithreadedLoader._useLoaderMap.remove(url);
			if(loader==null){
				Debug.error("engine","加载崩溃");
				return;
			}
			MultithreadedLoader._loaderPool.push(loader);
			this.exceuteCallBack(data,url);
			this.startLoadTime();
		}

		__proto.exceuteCallBack=function(data,url){
			if(data !=null){
				var list=data[1];
				var callBack=data [2];
				var callBackMap=new Dictionary;
				while (list.length){
					var arr=list.pop();
					var resourceVo=arr[0];
					if(this._failure){
						if (resourceVo.errorCallBackHandler !=null){
							resourceVo.errorCallBackHandler.runWith(url);
						}
					}
					else{
						if (resourceVo.callBackHandler !=null){
							resourceVo.callBackHandler.runWith(url);
						}
					};
					var singleCallBack=arr [1];
					if(arr[1] !=callBack && singleCallBack !=null && this._failure==false){
						singleCallBack.run();
					};
					var info=MultithreadedLoader._groupMap.get(resourceVo);
					if(info !=null){
						var map=info[0];
						var groupCallBack=info [1];
						if(map.get(resourceVo)!=null){
							info[2]=info[2]-1;
							map.remove(resourceVo);
						}
						if(info[2] <=0){
							groupCallBack.run();
						}
					}
					MultithreadedLoader._groupMap.remove(resourceVo);
				}
				if (callBack !=null && this._failure==false){
					callBack.run();
				}
			}
		}

		__proto.getFileName=function(path){
			var lastIndex=path.lastIndexOf("\/");
			lastIndex=lastIndex <0? 0:lastIndex+1;
			var lastSuffixIndex=path.lastIndexOf(".");
			if(lastSuffixIndex < 0)
				return "";
			return path.slice(lastIndex,lastSuffixIndex);
		}

		/**
		*最大连接数
		*/
		__getset(1,MultithreadedLoader,'maxConnectionNum',function(){
			return MultithreadedLoader._maxConnectionNum;
		});

		MultithreadedLoader.setMaxConnectionNum=function(value){
			MultithreadedLoader._maxConnectionNum=value;
		}

		MultithreadedLoader.checkResourceExist=function(resourceVo){
			return AssetLib.hasAsset(resourceVo.url);
		}

		MultithreadedLoader._maxConnectionNum=6;
		MultithreadedLoader._loadlist=[];
		MultithreadedLoader._loaderPool=[];
		MultithreadedLoader.loaderErrorHandler=null;
		MultithreadedLoader._timerRunning=false;
		__static(MultithreadedLoader,
		['_loadingUrlMap',function(){return this._loadingUrlMap=new Dictionary();},'_useLoaderMap',function(){return this._useLoaderMap=new Dictionary();},'_groupMap',function(){return this._groupMap=new Dictionary;}
		]);
		return MultithreadedLoader;
	})()


	//class specter3d.engine.loaders.parsers.AssetObject
	var AssetObject=(function(){
		function AssetObject(url){
			this._url=null;
			this._lastUseTime=0;
			this._url=url;
			this.updateLastUseTime();
		}

		__class(AssetObject,'specter3d.engine.loaders.parsers.AssetObject');
		var __proto=AssetObject.prototype;
		/**
		*资源释放
		*
		*/
		__proto.dispose=function(){}
		/**
		*强制资源释放（该函数会忽略引用计数)
		*
		*/
		__proto.updateLastUseTime=function(){
			this._lastUseTime=AppGlobalContext.timer.currTimer;
		}

		/**
		*最后使用的时间
		*/
		__getset(0,__proto,'lastUseTime',function(){
			return this._lastUseTime;
		});

		return AssetObject;
	})()


	//class specter3d.engine.loaders.parsers.data.FaceVO
	var FaceVO=(function(){
		function FaceVO(){
			this.a=0;
			this.b=0;
			this.c=0;
			this.smoothGroup=0;
			this.materialId=0;
		}

		__class(FaceVO,'specter3d.engine.loaders.parsers.data.FaceVO');
		return FaceVO;
	})()


	//class specter3d.engine.loaders.parsers.data.MaterialVO
	var MaterialVO=(function(){
		function MaterialVO(){
			this.name=null;
			this.ambientColor=0;
			this.diffuseColor=0;
			this.specularColor=0;
			this.twoSided=false;
			this.colorMap=null;
			this.specularMap=null;
			this.material=null;
		}

		__class(MaterialVO,'specter3d.engine.loaders.parsers.data.MaterialVO');
		return MaterialVO;
	})()


	//class specter3d.engine.loaders.parsers.data.ObjectVO
	var ObjectVO=(function(){
		function ObjectVO(){
			this.name=null;
			this.type=null;
			this.pivotX=NaN;
			this.pivotY=NaN;
			this.pivotZ=NaN;
			this.transform=null;
			this.verts=null;
			this.indices=null;
			this.uvs=null;
			this.materialFaces=null;
			this.materials=null;
			this.smoothingGroups=null;
		}

		__class(ObjectVO,'specter3d.engine.loaders.parsers.data.ObjectVO');
		return ObjectVO;
	})()


	//class specter3d.engine.loaders.parsers.data.TextureVO
	var TextureVO=(function(){
		function TextureVO(){
			this.url=null;
			this.texture=null;
		}

		__class(TextureVO,'specter3d.engine.loaders.parsers.data.TextureVO');
		return TextureVO;
	})()


	//class specter3d.engine.loaders.parsers.data.VertexVO
	var VertexVO=(function(){
		function VertexVO(){
			this.x=NaN;
			this.y=NaN;
			this.z=NaN;
			this.u=NaN;
			this.v=NaN;
			this.normal=null;
			this.tangent=null;
			this.materialId=0;
		}

		__class(VertexVO,'specter3d.engine.loaders.parsers.data.VertexVO');
		return VertexVO;
	})()


	/**
	*An enumeration providing values to describe the data format of parsed data.
	*/
	//class specter3d.engine.loaders.parsers.ParserDataFormat
	var ParserDataFormat=(function(){
		function ParserDataFormat(){};
		__class(ParserDataFormat,'specter3d.engine.loaders.parsers.ParserDataFormat');
		ParserDataFormat.BINARY="binary";
		ParserDataFormat.PLAIN_TEXT="plainText";
		return ParserDataFormat;
	})()


	/**
	*Mouse3DManager enforces a singleton pattern and is not intended to be instanced.
	*it provides a manager class for detecting 3D mouse hits on Layer3D objects and sending out 3D mouse events.
	*/
	//class specter3d.engine.managers.Mouse3DManager
	var Mouse3DManager=(function(){
		function Mouse3DManager(){
			this._layer=null;
			this._updateDirty=true;
			this._forceMouseMove=false;
			this._nullVector=new Vector3D();
			this._mouseMoveEvent=new MouseEvent3D("mouseMove3d");
			this._mousePicker=new RaycastPicker();
		}

		__class(Mouse3DManager,'specter3d.engine.managers.Mouse3DManager');
		var __proto=Mouse3DManager.prototype;
		//---------------------------------------------------------------------
		__proto.updateCollider=function(layer){
			Mouse3DManager._previousCollidingObject=Mouse3DManager._collidingObject;
			if (layer==this.layer && (this._forceMouseMove || this._updateDirty)){
			}
			this._updateDirty=false;
		}

		__proto.fireMouseEvents=function(){
			var i=0;
			var len=0;
			var event;
			var dispatcher;
			if (Mouse3DManager._collidingObject !=Mouse3DManager._previousCollidingObject){
				if (Mouse3DManager._previousCollidingObject)
					this.queueDispatch2(Mouse3DManager._mouseOut,this._mouseMoveEvent,Mouse3DManager._previousCollidingObject);
				if (Mouse3DManager._collidingObject)
					this.queueDispatch2(Mouse3DManager._mouseOver,this._mouseMoveEvent,Mouse3DManager._collidingObject);
			}
			if (this._forceMouseMove && Mouse3DManager._collidingObject)
				this.queueDispatch2(Mouse3DManager._mouseMove,this._mouseMoveEvent,Mouse3DManager._collidingObject);
			len=Mouse3DManager._queuedEvents.length;
			for (i=0;i < len;++i){
				event=Mouse3DManager._queuedEvents[i];
				dispatcher=event.object;
				while (dispatcher)
				dispatcher=dispatcher.parent;
				if (dispatcher)
					dispatcher.dispatchEvent(event);
			}
			Mouse3DManager._queuedEvents.length=0;
			this._updateDirty=false;
			Mouse3DManager._previousCollidingObject=Mouse3DManager._collidingObject;
		}

		__proto.dispose=function(){
			this._mousePicker.dispose();
		}

		//---------------------------------------------------------------------
		__proto.queueDispatch2=function(event,sourceEvent,collider){
			this.queueDispatch(event,
			sourceEvent.screenX,sourceEvent.screenY,sourceEvent.delta,
			sourceEvent.ctrlKey,sourceEvent.altKey,sourceEvent.shiftKey,
			collider);
		}

		__proto.queueDispatch=function(event,screenX,screenY,delta,ctrlKey,altKey,shiftKey,collider){
			event.ctrlKey=ctrlKey;
			event.altKey=altKey;
			event.shiftKey=shiftKey;
			event.delta=delta;
			event.screenX=screenX;
			event.screenY=screenY;collider=collider|| Mouse3DManager._collidingObject;
			if (collider){
				event.object=collider.target;
				event.renderable=collider.renderable;
				event.uv=collider.uv;
				event.localPosition=collider.localPosition? collider.localPosition.clone():null;
				event.localNormal=collider.localNormal? collider.localNormal.clone():null;
				event.index=collider.index;
				event.surfaceIndex=collider.surfaceIndex;
				}else {
				event.uv=null;
				event.object=null;
				event.localPosition=this._nullVector;
				event.localNormal=this._nullVector;
				event.index=0;
				event.surfaceIndex=0;
			}
			Mouse3DManager._queuedEvents.push(event);
		}

		//---------------------------------------------------------------------
		__proto.onMouseMove=function(screenX,screenY,ctrlKey,altKey,shiftKey){
			if (Mouse3DManager._collidingObject){
				this._mouseMoveEvent.screenX=screenX;
				this._mouseMoveEvent.screenY=screenY;
				this._mouseMoveEvent.delta=0;
				this._mouseMoveEvent.ctrlKey=ctrlKey;
				this._mouseMoveEvent.altKey=altKey;
				this._mouseMoveEvent.shiftKey=shiftKey;
				this.queueDispatch(Mouse3DManager._mouseMove,screenX,screenY,0,ctrlKey,altKey,shiftKey);
			}
			this._updateDirty=true;
		}

		__proto.onMouseOut=function(screenX,screenY,ctrlKey,altKey,shiftKey){
			if (Mouse3DManager._collidingObject)
				this.queueDispatch(Mouse3DManager._mouseOut,screenX,screenY,0,ctrlKey,altKey,shiftKey,Mouse3DManager._collidingObject);
			this._updateDirty=true;
		}

		__proto.onMouseOver=function(screenX,screenY,ctrlKey,altKey,shiftKey){
			if (Mouse3DManager._collidingObject && Mouse3DManager._previousCollidingObject !=Mouse3DManager._collidingObject)
				this.queueDispatch(Mouse3DManager._mouseOver,screenX,screenY,0,ctrlKey,altKey,shiftKey,Mouse3DManager._collidingObject);
			this._updateDirty=true;
		}

		__proto.onClick=function(screenX,screenY,ctrlKey,altKey,shiftKey){
			if (Mouse3DManager._collidingObject)
				this.queueDispatch(Mouse3DManager._mouseClick,screenX,screenY,0,ctrlKey,altKey,shiftKey);
			this._updateDirty=true;
		}

		__proto.onDoubleClick=function(screenX,screenY,ctrlKey,altKey,shiftKey){
			if (Mouse3DManager._collidingObject)
				this.queueDispatch(Mouse3DManager._mouseDoubleClick,screenX,screenY,0,ctrlKey,altKey,shiftKey);
			this._updateDirty=true;
		}

		__proto.onMouseDown=function(screenX,screenY,ctrlKey,altKey,shiftKey){
			if (Mouse3DManager._collidingObject)
				this.queueDispatch(Mouse3DManager._mouseDown,screenX,screenY,0,ctrlKey,altKey,shiftKey);
			this._updateDirty=true;
		}

		__proto.onMouseUp=function(screenX,screenY,ctrlKey,altKey,shiftKey){
			if (Mouse3DManager._collidingObject)
				this.queueDispatch(Mouse3DManager._mouseUp,screenX,screenY,0,ctrlKey,altKey,shiftKey);
			this._updateDirty=true;
		}

		__proto.onMouseWheel=function(screenX,screenY,delta,ctrlKey,altKey,shiftKey){
			if (Mouse3DManager._collidingObject)
				this.queueDispatch(Mouse3DManager._mouseWheel,screenX,screenY,delta,ctrlKey,altKey,shiftKey);
			this._updateDirty=true;
		}

		__getset(0,__proto,'layer',function(){
			return this._layer;
			},function(value){
			this._layer=value;
		});

		__getset(0,__proto,'mousePicker',function(){
			return this._mousePicker;
			},function(value){
			this._mousePicker=value;
		});

		__getset(0,__proto,'forceMouseMove',function(){
			return this._forceMouseMove;
			},function(value){
			this._forceMouseMove=value;
		});

		Mouse3DManager._collidingObject=null
		Mouse3DManager._previousCollidingObject=null
		Mouse3DManager._collidingLayerObjects=null
		Mouse3DManager._queuedEvents=[];
		__static(Mouse3DManager,
		['_mouseUp',function(){return this._mouseUp=new MouseEvent3D("mouseUp3d");},'_mouseClick',function(){return this._mouseClick=new MouseEvent3D("click3d");},'_mouseOut',function(){return this._mouseOut=new MouseEvent3D("mouseOut3d");},'_mouseDown',function(){return this._mouseDown=new MouseEvent3D("mouseDown3d");},'_mouseMove',function(){return this._mouseMove=new MouseEvent3D("mouseMove3d");},'_mouseOver',function(){return this._mouseOver=new MouseEvent3D("mouseOver3d");},'_mouseWheel',function(){return this._mouseWheel=new MouseEvent3D("mouseWheel3d");},'_mouseDoubleClick',function(){return this._mouseDoubleClick=new MouseEvent3D("doubleClick3d");}
		]);
		return Mouse3DManager;
	})()


	;
	/**
	*Material3D
	*@author wangcx
	*
	*/
	//class specter3d.engine.materials.Material3D
	var Material3D=(function(){
		function Material3D(){
			this.name=null;
			this._compiledPass=null;
			this._passes=null;
			this._programId=-1;
			this._alpha=1;
			this._alphaBlend=false;
			this._bothSides=false;
			this._passes=[];
			this._compiledPass=new CompiledPass(this);
			this._passes[0]=this._compiledPass;
		}

		__class(Material3D,'specter3d.engine.materials.Material3D');
		var __proto=Material3D.prototype;
		__proto.dispose=function(){}
		__proto.canBatch=function(other){
			return false;
		}

		__proto.clone=function(){
			var res=new Material3D();
			res.clonePropertiesFrom(this);
			return res;
		}

		__proto.clonePropertiesFrom=function(source){
			this.name=source.name;
		}

		__proto.activate=function(renderable,_context3d,_camera3d){
			for (var i=0;i < this._passes.length;i++)
			this.renderPass(i,_context3d,_camera3d,renderable);
		}

		__proto.renderPass=function(index,_context3d,camera,renderable){
			if (_context3d){
				var _pass=this._passes[index];
				_pass && _pass.render(_context3d,renderable,camera);
			}
		}

		__getset(0,__proto,'bothSides',function(){
			return this._bothSides;
			},function(value){
			this._bothSides=value;
			for (var i=0;i < this._passes.length;i++)
			this._passes[i].bothSides=this._bothSides;
		});

		__getset(0,__proto,'alphaBlend',function(){
			return this._alphaBlend;
			},function(value){
			this._alphaBlend=value;
			for (var i=0;i < this._passes.length;i++)
			this._passes[i].alphaBlend=this._alphaBlend;
		});

		__getset(0,__proto,'alpha',function(){
			return this._alpha;
			},function(value){
			if (this._alpha !=value && this._alpha >=0){
				this._alpha=value;
				for (var i=0;i < this._passes.length;i++)
				this._passes[i].alpha=this._alpha;
			}
		});

		__getset(0,__proto,'lightPicker',function(){
			return this._compiledPass.lightPicker;
			},function(value){
			this._compiledPass.lightPicker=value;
		});

		Material3D.__init$=function(){
			;
			/*namespace*/;
		}

		return Material3D;
	})()


	;
	/**
	*ShaderCompiler
	*@author wangcx
	*
	*/
	//class specter3d.engine.materials.compilation.ShaderCompiler
	var ShaderCompiler=(function(){
		function ShaderCompiler(){};
		__class(ShaderCompiler,'specter3d.engine.materials.compilation.ShaderCompiler');
		ShaderCompiler.__initDefinition__=function(){
			if (ShaderCompiler.VERTEX_PROGRAM==null || ShaderCompiler.FRAGMENTS_PROGRAM==null){
				ShaderCompiler.VERTEX_PROGRAM="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nattribute vec3 a_Position;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_viewMatrix;\nuniform mat4 u_modelMatrix;\nvarying vec3 v_eye;\n\n#ifdef USE_UV\n	attribute vec2 a_UV;\n	varying vec2 v_UV;\n#endif\n\n#ifdef USE_NORMAL\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal;\n#endif\n\n#ifdef USER_LIGHT_POINT\n	varying vec3 out_fragpos;\n#endif\n\nvoid main()\n{\n	 vec4 vertex = u_viewMatrix * u_modelMatrix * vec4(a_Position, 1.0);\n	 v_eye = -vec3(vertex);\n	 gl_Position = u_projectionMatrix * vertex;\n	 #ifdef USE_NORMAL\n	 	v_Normal =  mat3(u_modelMatrix) * a_Normal;\n	 #endif\n	 #ifdef USE_UV\n	 	v_UV = a_UV;\n	 #endif\n	 #ifdef USER_LIGHT_POINT\n		out_fragpos = vec3(u_modelMatrix * vec4(a_Position, 1));\n	#endif\n}";
				ShaderCompiler.FRAGMENTS_PROGRAM="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nuniform vec3 u_camerapos;\nuniform float u_DiffuseAlpha;\nvarying vec3 v_eye;\n\n#ifdef USE_DIFFUSE_MAP\n	uniform sampler2D u_DiffuseSampler;\n#else\n	uniform vec3 u_DiffuseColor;\n#endif\n\n#ifdef USE_UV\n	varying vec2 v_UV;\n#endif\n\n#ifdef USE_NORMAL\n	varying vec3 v_Normal;\n#endif\n\n#ifdef USE_LIGHT_DIRECTION\nstruct DirectionLight\n{\n	vec3 diffuseColor;\n	vec3 direction;\n	vec3 ambientColor;\n	vec3 specularColor;\n	float specularShininess;\n};\n\nuniform DirectionLight u_DirectionLight;\n\nvec4 computeDirectionLight(vec3 outNormal,in vec4 singleColor,in DirectionLight dLight)\n{\n	vec3 normal = normalize(outNormal);\n	vec3 lightVec=-normalize(dLight.direction);\n	float diffuseFactor = dot(normal,lightVec);\n	vec3 diffuseColor= vec3(0.0);\n	vec3 specularColor=vec3(0.0);\n	if(diffuseFactor  > 0.0)\n	{\n	    diffuseColor = dLight.diffuseColor * diffuseFactor ;\n		vec3 reflection=reflect(lightVec,normal);\n		vec3 eye = normalize(v_eye);\n		float specularFactor=pow(max(dot(eye,reflection),0.0),dLight.specularShininess);\n		specularColor = dLight.specularColor * specularFactor;\n	}\n	return vec4((dLight.ambientColor + diffuseColor + specularColor) * singleColor.rgb,u_DiffuseAlpha);\n}\n#endif\n\n#ifdef USER_LIGHT_POINT\nstruct PointLight\n{\n	vec3 position;\n	vec3 diffuseColor;\n	vec3 ambientColor;\n	vec3 specularColor;\n	float specularShininess;\n	float range;\n	vec3 attenuation;\n};\nuniform PointLight u_PointLight[8];\nvarying vec3 out_fragpos;\n\nvec4 computePointLight(vec3 outNormal,in vec4 singleColor,in PointLight pLight)\n{\n	vec3 diffuseColor= vec3(0.0);\n	vec3 specularColor=vec3(0.0);\n	\n	vec3 normal = normalize(outNormal);\n	vec3 lightVec=normalize(pLight.position-out_fragpos);\n	\n	float d = length(lightVec);\n	\n	if( d > pLight.range)\n		return vec4((pLight.ambientColor + diffuseColor + specularColor) * singleColor.rgb,u_DiffuseAlpha);\n		\n	lightVec /= d;\n	\n	float diffuseFactor = dot(normal,lightVec);\n	\n	if(diffuseFactor  > 0.0)\n	{\n		diffuseColor = pLight.diffuseColor * diffuseFactor;\n		vec3 reflection=normalize(reflect(lightVec,normal));\n		vec3 eye = normalize(out_fragpos);\n		float specularFactor=pow(max(dot(eye,reflection),0.0),pLight.specularShininess);\n		specularColor = pLight.specularColor * specularFactor;\n	}\n	float attenuate = 1.0 / dot(pLight.attenuation, vec3(1.0, d, d*d));\n	diffuseColor  *= attenuate;\n	specularColor *= attenuate;\n	return vec4((pLight.ambientColor + diffuseColor + specularColor) * singleColor.rgb,u_DiffuseAlpha);\n}\n#endif\n\nvoid main()\n{\n	vec4 singleColor = vec4(1.0);\n	#ifdef USE_DIFFUSE_MAP\n		singleColor = texture2D(u_DiffuseSampler, v_UV);\n	#else\n		singleColor = vec4(u_DiffuseColor,u_DiffuseAlpha);\n	#endif\n	#ifdef USE_LIGHT_DIRECTION\n		singleColor = computeDirectionLight(v_Normal,singleColor,u_DirectionLight);\n	#endif\n	#ifdef USER_LIGHT_POINT\n		vec4 results = vec4(0.0);\n		results += computePointLight(v_Normal,singleColor,u_PointLight[0]);\n		results += computePointLight(v_Normal,singleColor,u_PointLight[1]);\n		results += computePointLight(v_Normal,singleColor,u_PointLight[2]);\n		results += computePointLight(v_Normal,singleColor,u_PointLight[3]);\n		singleColor = results;\n	#endif\n	\n	\n	singleColor.a = u_DiffuseAlpha;\n	gl_FragColor = singleColor;\n	\n}";
				ShaderCompiler.LIGHTING_PROGRAM=''/*__INCLUDESTR__ ERR:no this file:shader/files/Lighting.glsl*/
				;
			}
		}

		ShaderCompiler.compile=function(_context3d,pass,vertexCode,fragmentCode){
			var key=ShaderCompiler.getKey(vertexCode,fragmentCode);
			var _program=ShaderCompiler._program3DCache[key];
			if (_program==null){
				ShaderCompiler._keys[ShaderCompiler._currentId]=key;
				ShaderCompiler._usages[ShaderCompiler._currentId]=0;
				ShaderCompiler._ids[key]=ShaderCompiler._currentId;
				++ShaderCompiler._currentId;
				_program=_context3d.createProgram();
				var _vshader=ShaderCompiler.createShader(0x8B31,vertexCode,_context3d);
				var _fshader=ShaderCompiler.createShader(0x8B30,fragmentCode,_context3d);
				ShaderCompiler.uploadProgram3D(_context3d,_program,_vshader,_fshader);
				ShaderCompiler._program3DCache[key]=_program;
				if (Debug.glslDebug){
					Debug.dotrace("engine","Compiling GLSL VertexCode: \n"+vertexCode);
					Debug.dotrace("engine","Compiling GLSL FragmentCode: \n"+fragmentCode);
				}
			}
			_context3d.useProgram(_program);
			var oldId=pass.material._programId;
			var newId=ShaderCompiler._ids[key];
			if (oldId !=newId){
				if (oldId >=0)
					ShaderCompiler.freeProgram3D(_context3d,oldId);
				ShaderCompiler._usages[newId]++;
			}
			pass.material._programId=newId;
			return _program;
		}

		ShaderCompiler.createShader=function(mode,source,_context3d){
			var _shader=_context3d.createShader(mode);
			_context3d.shaderSource(_shader,source);
			_context3d.compileShader(_shader);
			if (!_context3d.getShaderParameter(_shader,0x8B81)){
				throw _context3d.getShaderInfoLog(_shader);
			}
			return _shader;
		}

		ShaderCompiler.freeProgram3D=function(_context3d,programId){
			ShaderCompiler._usages[programId]--;
			if (ShaderCompiler._usages[programId]==0){
				var key=ShaderCompiler._keys[programId];
				_context3d.deleteProgram(ShaderCompiler._program3DCache[key]);
				ShaderCompiler._program3DCache[key]=null;
				delete ShaderCompiler._program3DCache[key];
				ShaderCompiler._ids[key]=-1;
			}
		}

		ShaderCompiler.getKey=function(vertexCode,fragmentCode){
			return vertexCode+"__"+fragmentCode;
		}

		ShaderCompiler.uploadProgram3D=function(_context3d,_program,_vshader,_fshader){
			_context3d.attachShader(_program,_vshader);
			_context3d.attachShader(_program,_fshader);
			_context3d.linkProgram(_program);
		}

		ShaderCompiler.FRAGMENTS_PROGRAM=null;
		ShaderCompiler.LIGHTING_PROGRAM=null;
		ShaderCompiler.VERTEX_PROGRAM=null;
		ShaderCompiler.shaderVersion=100;
		ShaderCompiler._currentId=0;
		ShaderCompiler._ids=[];
		ShaderCompiler._keys=[];
		ShaderCompiler._program3DCache=[];
		ShaderCompiler._usages=[];
		return ShaderCompiler;
	})()


	//class specter3d.engine.materials.compilation.ShaderElementArray
	var ShaderElementArray=(function(){
		function ShaderElementArray(version){
			this._codes=null;
			this._length=0;
			this._codes=new Array;
			this.setVersion(version);
		}

		__class(ShaderElementArray,'specter3d.engine.materials.compilation.ShaderElementArray');
		var __proto=ShaderElementArray.prototype;
		__proto.setVersion=function(version){
			this.additional("#version\t"+version);
		}

		__proto.additional=function(element){
			this._codes[this._length]=element;
			this._length++;
		}

		__proto.toString=function(){
			return this._codes.filter(ShaderElementArray.filterEmptyLine).join("\n");
		}

		/**
		*使用宏
		*@param name
		*
		*/
		__proto.useMacro=function(name){
			this.additional("#define\t"+name);
		}

		/**
		*　定义 uniform
		*@param type
		*@param name
		*
		*/
		__proto.defineUniform=function(type,name){
			this.additional("uniform\t"+type+"\t"+name+";");
		}

		/**
		*定义 varying
		*@param type
		*@param name
		*
		*/
		__proto.defineVarying=function(type,name){
			this.additional("varying\t"+type+"\t"+name+";");
		}

		/**
		*定义 Attribute
		*@param type
		*@param name
		*
		*/
		__proto.defineAttribute=function(type,name){
			this.additional("attribute\t"+type+"\t"+name+";");
		}

		__proto.clear=function(){
			this._codes.length=0;
			this._length=0;
		}

		ShaderElementArray.filterEmptyLine=function(line){
			return line !="";
		}

		ShaderElementArray.MACRO_DEFINE="#define\t";
		ShaderElementArray.VERSION="#version\t";
		ShaderElementArray.UNIFORM="uniform\t";
		ShaderElementArray.VARYING="varying\t";
		ShaderElementArray.ATTRIBUTE="attribute\t";
		return ShaderElementArray;
	})()


	//class specter3d.engine.materials.compilation.ShaderRegisterUsage
	var ShaderRegisterUsage=(function(){
		function ShaderRegisterUsage(){};
		__class(ShaderRegisterUsage,'specter3d.engine.materials.compilation.ShaderRegisterUsage');
		ShaderRegisterUsage.USE_MACRO_UV="USE_UV";
		ShaderRegisterUsage.USE_MACRO_NORMAL="USE_NORMAL";
		ShaderRegisterUsage.USE_MACRO_TANGENT="USE_TANGENT";
		ShaderRegisterUsage.USE_MACRO_DIFFUSE_MAP="USE_DIFFUSE_MAP";
		ShaderRegisterUsage.USE_MACRO_NORMAL_MAP="USE_NORMAL_MAP";
		ShaderRegisterUsage.USE_MACRO_LIGHT_DIRECTION="USE_LIGHT_DIRECTION";
		ShaderRegisterUsage.USE_MACRO_LIGHT_POINT="USER_LIGHT_POINT";
		ShaderRegisterUsage.POSITION="a_Position";
		ShaderRegisterUsage.NORMAL="a_Normal";
		ShaderRegisterUsage.TANGENT="a_Tangent";
		ShaderRegisterUsage.UV="a_UV";
		ShaderRegisterUsage.SECONDARY_UV="a_SecondaryUV";
		ShaderRegisterUsage.MVP="u_MVPMatrix";
		ShaderRegisterUsage.LIGHT_DIRECTION="u_DirectionLight";
		ShaderRegisterUsage.DIFFUSE_ALPHA="u_DiffuseAlpha";
		ShaderRegisterUsage.DIFFUSE_COLOR="u_DiffuseColor";
		ShaderRegisterUsage.DIFFUSE_SAMPLER="u_DiffuseSampler";
		ShaderRegisterUsage.NORMAL_MAP_SAMPLER="u_NormalMapSampler";
		return ShaderRegisterUsage;
	})()


	/**
	*MathConsts provides some commonly used mathematical constants
	*/
	//class specter3d.engine.math.MathConsts
	var MathConsts=(function(){
		function MathConsts(){};
		__class(MathConsts,'specter3d.engine.math.MathConsts');
		__static(MathConsts,
		['RADIANS_TO_DEGREES',function(){return this.RADIANS_TO_DEGREES=180/Math.PI;},'DEGREES_TO_RADIANS',function(){return this.DEGREES_TO_RADIANS=Math.PI/180;}
		]);
		return MathConsts;
	})()


	//class specter3d.engine.math.Ray
	var Ray=(function(){
		function Ray(origin,direction){
			this.origin=null;
			this.direction=null;
			this.origin=origin || new Vector3D;
			this.direction=direction || new Vector3D;
		}

		__class(Ray,'specter3d.engine.math.Ray');
		return Ray;
	})()


	;
	//class specter3d.engine.resources.Geometry3D
	var Geometry3D=(function(){
		function Geometry3D(){
			this._subGeometries=null;
			this._subGeometries=[];
		}

		__class(Geometry3D,'specter3d.engine.resources.Geometry3D');
		var __proto=Geometry3D.prototype;
		__proto.addSubGeometry=function(subGeometry){
			if (!subGeometry)
				return;
			this._subGeometries.push(subGeometry);
			subGeometry.parentGeometry=this;
		}

		__proto.clone=function(){
			var clone=new Geometry3D();
			var len=this._subGeometries.length;
			for (var i=0;i < len;++i){
				clone.addSubGeometry(this._subGeometries[i].clone());
			}
			return clone;
		}

		__proto.removeSubGeometry=function(subGeometry){
			this._subGeometries.splice(this._subGeometries.indexOf(subGeometry),1);
			subGeometry.parentGeometry=null;
		}

		__getset(0,__proto,'subGeometry',function(){
			return this._subGeometries;
		});

		Geometry3D.__init$=function(){
			/*namespace*/;
		}

		return Geometry3D;
	})()


	/**A utility class containing methods related to the Array class.
	*
	*<p>Many methods of the Array class cause the creation of temporary objects,which is
	*problematic for any code that repeats very often. The utility methods in this class
	*can be used to avoid that.</p> */
	//class specter3d.engine.utlis.ArrayUtil
	var ArrayUtil=(function(){
		/**@private */
		function ArrayUtil(){throw new AbstractMethodError;}
		__class(ArrayUtil,'specter3d.engine.utlis.ArrayUtil');
		ArrayUtil.insertAt=function(array,index,object){
			var i=0;
			var length=array.length;
			if (index < 0)index+=length+1;
			if (index < 0)index=0;
			for (i=index-1;i >=length;--i)
			array[i]=null;
			for (i=length;i > index;--i)
			array[i]=array[i-1];
			array[index]=object;
		}

		ArrayUtil.removeAt=function(array,index){
			var i=0;
			var length=array.length;
			if (index < 0)index+=length;
			if (index < 0)index=0;else if (index >=length)index=length-1;
			var object=array[index];
			for (i=index+1;i < length;++i)
			array[i-1]=array[i];
			array.length=length-1;
			return object;
		}

		return ArrayUtil;
	})()


	//class specter3d.engine.utlis.GeomUtil
	var GeomUtil=(function(){
		function GeomUtil(){};
		__class(GeomUtil,'specter3d.engine.utlis.GeomUtil');
		GeomUtil.constructSubGeometry=function(verts,indices,uvs,normals,tangents){
			var sub=new SubGeometry3D();
			sub.indices=new Uint16Array(indices);
			var vertsData=[];
			var index=0,vi=0,ni=0,ti=0,ui=0;
			var loop=verts.length / 3 *13;
			while(index < loop){
				vertsData[index++]=verts[vi++];
				vertsData[index++]=verts[vi++];
				vertsData[index++]=verts[vi++];
				if (normals && normals.length){
					vertsData[index++]=normals[ni++];
					vertsData[index++]=normals[ni++];
					vertsData[index++]=normals[ni++];
				}
				else{
					vertsData[index++]=0;
					vertsData[index++]=0;
					vertsData[index++]=0;
				}
				if (tangents && tangents.length){
					vertsData[index++]=tangents[ti++];
					vertsData[index++]=tangents[ti++];
					vertsData[index++]=tangents[ti++];
				}
				else{
					vertsData[index++]=0;
					vertsData[index++]=0;
					vertsData[index++]=0;
				}
				if (uvs && uvs.length){
					vertsData[index++]=uvs[ui];
					vertsData[index++]=uvs[ui+1];
					vertsData[index++]=uvs[ui++];
					vertsData[index++]=uvs[ui++];
				}
				else{
					vertsData[index++]=0;
					vertsData[index++]=0;
					vertsData[index++]=0;
					vertsData[index++]=0;
				}
			}
			sub.updateVertexAttribute(new Float32Array(vertsData),GeomUtil.SUB_GEOMETRY_ATTRIBUTES);
			sub.autoDeriveVertexNormals=normals && normals.length ? false :true;
			sub.autoDeriveVertexTangents=tangents && tangents.length ? false :true;
			sub.autoGenerateUVs=uvs && uvs.length ? false :true;
			return sub;
		}

		GeomUtil.fromVectors=function(verts,indices,uvs,normals,tangents){
			var subs=[];
			if (indices.length >=GeomUtil.LIMIT){
				var i=0,len=0,outIndex=0;
				var splitVerts=[];
				var splitIndices=[];
				var splitUvs=(uvs !=null)? [] :null;
				var splitNormals=(normals !=null)? [] :null;
				var splitTangents=(tangents !=null)? [] :null;
				var mappings=new Array(verts.length / 3);
				i=mappings.length;
				while (i--> 0)
				mappings[i]=-1;
				outIndex=0;
				len=indices.length;
				for (i=0;i < len;i+=3){
					var j=0;
					if (outIndex *3 >=GeomUtil.LIMIT){
						subs.push(GeomUtil.constructSubGeometry(splitVerts,splitIndices,splitUvs,splitNormals,splitTangents));
						splitVerts=[];
						splitIndices=[];
						splitUvs=(uvs !=null)? [] :null;
						splitNormals=(normals !=null)? [] :null;
						splitTangents=(tangents !=null)? [] :null;
						j=mappings.length;
						while (j--> 0)
						mappings[j]=-1;
						outIndex=0;
					}
					for (j=0;j < 3;j++){
						var originalIndex=0;
						var splitIndex=0;
						originalIndex=indices[i+j];
						if (mappings[originalIndex] >=0){
							splitIndex=mappings[originalIndex];
						}
						else{
							var o0=0,o1=0,o2=0,s0=0,s1=0,s2=0;
							o0=originalIndex *3+0;
							o1=originalIndex *3+1;
							o2=originalIndex *3+2;
							splitIndex=splitVerts.length / 3;
							s0=splitIndex *3+0;
							s1=splitIndex *3+1;
							s2=splitIndex *3+2;
							splitVerts[s0]=verts[o0];
							splitVerts[s1]=verts[o1];
							splitVerts[s2]=verts[o2];
							if (uvs){
								var su=0,ou=0,sv=0,ov=0;
								su=splitIndex *2+0;
								sv=splitIndex *2+1;
								ou=originalIndex *2+0;
								ov=originalIndex *2+1;
								splitUvs[su]=uvs[ou];
								splitUvs[sv]=uvs[ov];
							}
							if (normals){
								splitNormals[s0]=normals[o0];
								splitNormals[s1]=normals[o1];
								splitNormals[s2]=normals[o2];
							}
							if (tangents){
								splitTangents[s0]=tangents[o0];
								splitTangents[s1]=tangents[o1];
								splitTangents[s2]=tangents[o2];
							}
							mappings[originalIndex]=splitIndex;
						}
						splitIndices[outIndex+j]=splitIndex;
					}
					outIndex+=3;
				}
				splitVerts.length > 0 && subs.push(GeomUtil.constructSubGeometry(splitVerts,splitIndices,splitUvs,splitNormals,splitTangents));
			}
			else{
				subs.push(GeomUtil.constructSubGeometry(verts,indices,uvs,normals,tangents));
			}
			return subs;
		}

		__static(GeomUtil,
		['LIMIT',function(){return this.LIMIT=3 *0xffff;},'SUB_GEOMETRY_ATTRIBUTES',function(){return this.SUB_GEOMETRY_ATTRIBUTES=[
			new VertexElement(0,"vector3","a_Position"),
			new VertexElement(12,"vector3","a_Normal"),
			new VertexElement(24,"vector3","a_Tangent"),
			new VertexElement(36,"vector2","a_UV"),
			new VertexElement(44,"vector2","a_SecondaryUV")];},'SKINNED_SUB_GEOMETRY_ATTRIBUTES',function(){return this.SKINNED_SUB_GEOMETRY_ATTRIBUTES=[
			new VertexElement(0,"vector3","a_Position"),
			new VertexElement(12,"vector3","a_Normal"),
			new VertexElement(24,"vector3","a_Tangent"),
			new VertexElement(36,"vector2","a_UV"),
			new VertexElement(44,"vector2","a_SecondaryUV")];}
		]);
		return GeomUtil;
	})()


	/**
	*哈希表 项目中哈希结构均需使用 HashMap
	*@author wangcx
	*
	*/
	//class specter3d.engine.utlis.HashMap
	var HashMap=(function(){
		function HashMap(){
			this._keys=null;
			this._mapLenth=0;
			this._values=null;
			this._values=[];
			this._keys=[];
		}

		__class(HashMap,'specter3d.engine.utlis.HashMap');
		var __proto=HashMap.prototype;
		__proto.clear=function(){
			this._values.length=0;
			this._keys.length=0;
			this._mapLenth=0;
		}

		__proto.clone=function(){
			var hashMap=new HashMap();
			var keys=this.keySet();
			for (var i=0;i < keys.length;i++){
				var key=keys[i];
				var value=this.getValue(key);
				hashMap.put(key,value);
			}
			return hashMap;
		}

		__proto.containsKey=function(key){
			var result=null;
			var index=this.indexOf(key);
			return index >=0;
		}

		__proto.forEach=function(callback,__args){
			var args=[];for(var i=1,sz=arguments.length;i<sz;i++)args.push(arguments[i]);
			if (this._mapLenth > 0){
				args.unshift(null,null);
				for (var i=0;i < this._mapLenth;i++){
					args[0]=this._keys[i];
					args[1]=this._values[i];
					callback.apply(null,args);
				}
			}
		}

		__proto.getValue=function(key){
			var result=null;
			var index=this.indexOf(key);
			if (index >=0){
				result=this._values[index];
			}
			return result;
		}

		__proto.isEmpty=function(){
			if (this.size < 1){
				return true;
			}
			return false;
		}

		__proto.keySet=function(){
			return this._keys.concat();
		}

		__proto.put=function(key,value){
			if (key==null || key==undefined){
				return value;
			};
			var index=this.indexOf(key);
			if (index >=0){
				this._values[index]=value;
				return;
			}
			ArrayUtil.insertAt(this._keys,this._mapLenth,key);
			ArrayUtil.insertAt(this._values,this._mapLenth,value);
			this._mapLenth++;
			return value;
		}

		__proto.putAll=function(map){
			var len=map._mapLenth;
			if (len > 0){
				for (var i=0;i < len;i++){
					this.put(map._keys[i],map._values[i]);
				}
			}
		}

		__proto.remove=function(key){
			var result=null;
			var index=this.indexOf(key);
			if (index >=0){
				ArrayUtil.removeAt(this._keys,index);
				result=ArrayUtil.removeAt(this._values,index);
				this._mapLenth--;
			}
			return result;
		}

		__proto.size=function(){
			return this._mapLenth;
		}

		__proto.toString=function(){
			var out=[];
			for (var i=0;i < this._keys.length;i++){
				out[i]=this._keys[i]+"="+this._values[i];
			}
			return out.join(",");
		}

		__proto.values=function(){
			return this._values.concat();
		}

		/**
		*获取指定对象的键名索引。
		*@param key 键名对象。
		*@return 键名索引。
		*/
		__proto.indexOf=function(key){
			var index=this._keys.indexOf(key);
			if (index < 0){
				key=((typeof key=='string'))? Number(key):(((typeof key=='number'))? key.toString():key);
				index=this._keys.indexOf(key);
			}
			return index;
		}

		return HashMap;
	})()


	//class specter3d.engine.utlis.HTMLImageValidate
	var HTMLImageValidate=(function(){
		function HTMLImageValidate(){};
		__class(HTMLImageValidate,'specter3d.engine.utlis.HTMLImageValidate');
		HTMLImageValidate.isBitmapDataValid=function(img){
			if (img==null)
				return true;
			return HTMLImageValidate.isDimensionValid(img.width)&& HTMLImageValidate.isDimensionValid(img.height);
		}

		HTMLImageValidate.isDimensionValid=function(d){
			return d >=1 && d <=2048 && HTMLImageValidate.isPowerOfTwo(d);
		}

		HTMLImageValidate.isPowerOfTwo=function(value){
			return value? ((value &-value)==value):false;
		}

		HTMLImageValidate.getBestPowerOf2=function(value){
			var p=1;
			while (p < value)
			p <<=1;
			if (p > 2048)
				p=2048;
			return p;
		}

		HTMLImageValidate.MAX_SIZE=2048;
		return HTMLImageValidate;
	})()


	/**
	*极限值边界
	*@author wangcx
	*
	*/
	//class specter3d.engine.utlis.LimitValueUtlis
	var LimitValueUtlis=(function(){
		function LimitValueUtlis(){};
		__class(LimitValueUtlis,'specter3d.engine.utlis.LimitValueUtlis');
		LimitValueUtlis.INT_MAX_VALUE=2147483647;
		LimitValueUtlis.INT_MIN_VALUE=-2147483648;
		LimitValueUtlis.UINT_MAX_VALUE=4294967295;
		LimitValueUtlis.UINT_MIN_VALUE=0;
		__static(LimitValueUtlis,
		['NUMBER_MAX_VALUE',function(){return this.NUMBER_MAX_VALUE=1.79769313486231E308;},'NUMBER_MIN_VALUE',function(){return this.NUMBER_MIN_VALUE=4.9E-324;}
		]);
		return LimitValueUtlis;
	})()


	/**
	*Matrix3DUtils
	*@author wangcx
	*
	*/
	//class specter3d.engine.utlis.Matrix3DUtils
	var Matrix3DUtils=(function(){
		function Matrix3DUtils(){};
		__class(Matrix3DUtils,'specter3d.engine.utlis.Matrix3DUtils');
		Matrix3DUtils.buildOrthoProjection=function(left,right,bottom,top,near,far,out){
			var scaleX=0;
			var scaleY=0;
			var scaleZ=0;
			var offsX=0;
			var offsY=0;
			var offsZ=0;
			if (out==null){
				out=new Matrix3D();
			}
			scaleX=2 / (right-left);
			scaleY=2 / (top-bottom);
			scaleZ=1 / (far-near);
			offsX=(-0.5 *(right+left))*scaleX;
			offsY=(-0.5 *(top+bottom))*scaleY;
			offsZ=-near *scaleZ;
			Matrix3DUtils._raw[0]=scaleX;
			Matrix3DUtils._raw[5]=scaleY;
			Matrix3DUtils._raw[10]=scaleZ;
			Matrix3DUtils._raw[12]=offsX;
			Matrix3DUtils._raw[13]=offsY;
			Matrix3DUtils._raw[14]=offsZ;
			Matrix3DUtils._raw[1]=Matrix3DUtils._raw[2]=Matrix3DUtils._raw[4]=Matrix3DUtils._raw[6]=Matrix3DUtils._raw[8]=Matrix3DUtils._raw[9]=Matrix3DUtils._raw[3]=Matrix3DUtils._raw[7]=Matrix3DUtils._raw[11]=0;
			Matrix3DUtils._raw[15]=1;
			out.copyRawDataFrom(Matrix3DUtils._raw);
			return out;
		}

		Matrix3DUtils.deltaTransformVector=function(m,vector,out){
			if (out==null){
				out=new Vector3D();
			}
			Matrix3DUtils._vector.copyFrom(vector);
			m.copyRawTo(0,Matrix3DUtils._right);
			m.copyRawTo(1,Matrix3DUtils._up);
			m.copyRawTo(2,Matrix3DUtils._dir);
			out.x=(((Matrix3DUtils._vector.x *Matrix3DUtils._right.x)+(Matrix3DUtils._vector.y *Matrix3DUtils._right.y))+(Matrix3DUtils._vector.z *Matrix3DUtils._right.z));
			out.y=(((Matrix3DUtils._vector.x *Matrix3DUtils._up.x)+(Matrix3DUtils._vector.y *Matrix3DUtils._up.y))+(Matrix3DUtils._vector.z *Matrix3DUtils._up.z));
			out.z=(((Matrix3DUtils._vector.x *Matrix3DUtils._dir.x)+(Matrix3DUtils._vector.y *Matrix3DUtils._dir.y))+(Matrix3DUtils._vector.z *Matrix3DUtils._dir.z));
			return out;
		}

		Matrix3DUtils.equal=function(a,b){
			var v0=a.rawData;
			var v1=b.rawData;
			var i=0;
			while (i < 16){
				if (v0[i] !=v1[i]){
					return (false);
				}
				i++;
			}
			return true;
		}

		Matrix3DUtils.getBackward=function(m,out){
			if (out==null){
				out=new Vector3D();
			}
			m.copyColumnTo(2,out);
			out.negate();
			return out;
		}

		Matrix3DUtils.getDir=function(m,out){
			if (out==null){
				out=new Vector3D();
			}
			m.copyColumnTo(2,out);
			return out;
		}

		Matrix3DUtils.getDown=function(m,out){
			if (out==null){
				out=new Vector3D();
			}
			m.copyColumnTo(1,out);
			out.negate();
			return out;
		}

		Matrix3DUtils.getLeft=function(m,out){
			if (out==null){
				out=new Vector3D();
			}
			m.copyColumnTo(0,out);
			out.negate();
			return out;
		}

		Matrix3DUtils.getPosition=function(m,out){
			if (out==null){
				out=new Vector3D();
			}
			m.copyColumnTo(3,out);
			return out;
		}

		Matrix3DUtils.getRight=function(m,out){
			if (out==null){
				out=new Vector3D();
			}
			m.copyColumnTo(0,out);
			return out;
		}

		Matrix3DUtils.getRotation=function(m,out){
			out=((out)|| (new Vector3D()));
			if(Matrix3DUtils.decomposes.length==0){
				Matrix3DUtils.decomposes[0]=new Vector3D;
				Matrix3DUtils.decomposes[1]=new Vector3D;
				Matrix3DUtils.decomposes[2]=new Vector3D;
			}
			m.decompose("EulerAngles",Matrix3DUtils.decomposes);
			Matrix3DUtils._vector.copyFrom(Matrix3DUtils.decomposes[1]);
			out.x=Matrix3DUtils._vector.x *Matrix3DUtils._toAng;
			out.y=Matrix3DUtils._vector.y *Matrix3DUtils._toAng;
			out.z=Matrix3DUtils._vector.z *Matrix3DUtils._toAng;
			return out;
		}

		Matrix3DUtils.getScale=function(m,out){
			if (out==null){
				out=new Vector3D();
			}
			m.copyColumnTo(0,Matrix3DUtils._right);
			m.copyColumnTo(1,Matrix3DUtils._up);
			m.copyColumnTo(2,Matrix3DUtils._dir);
			out.x=Matrix3DUtils._right.length;
			out.y=Matrix3DUtils._up.length;
			out.z=Matrix3DUtils._dir.length;
			return out;
		}

		Matrix3DUtils.getUp=function(m,out){
			if (out==null){
				out=new Vector3D();
			}
			m.copyColumnTo(1,out);
			return out;
		}

		Matrix3DUtils.interpolateTo=function(src,dest,percent){
			specter3d.engine.utlis.Matrix3DUtils.getScale(src,Matrix3DUtils._scale);
			specter3d.engine.utlis.Matrix3DUtils.getScale(dest,Matrix3DUtils._vector);
			Matrix3DUtils._scale.x=(Matrix3DUtils._scale.x+((Matrix3DUtils._vector.x-Matrix3DUtils._scale.x)*percent));
			Matrix3DUtils._scale.y=(Matrix3DUtils._scale.y+((Matrix3DUtils._vector.y-Matrix3DUtils._scale.y)*percent));
			Matrix3DUtils._scale.z=(Matrix3DUtils._scale.z+((Matrix3DUtils._vector.z-Matrix3DUtils._scale.z)*percent));
			src.interpolateTo(dest,percent);
			src.prependScale(Matrix3DUtils._scale.x,Matrix3DUtils._scale.y,Matrix3DUtils._scale.z);
		}

		Matrix3DUtils.invert=function(m,out){
			if (out==null){
				out=new Matrix3D();
			}
			out.copyFrom(m);
			out.invert();
			return out;
		}

		Matrix3DUtils.lookAt=function(m,x,y,z,up,smooth){
			(smooth===void 0)&& (smooth=1);
			m.copyColumnTo(3,Matrix3DUtils._pos);
			Matrix3DUtils._vector.x=(x-Matrix3DUtils._pos.x);
			Matrix3DUtils._vector.y=(y-Matrix3DUtils._pos.y);
			Matrix3DUtils._vector.z=(z-Matrix3DUtils._pos.z);
			Matrix3DUtils.setOrientation(m,Matrix3DUtils._vector,up,smooth);
		}

		Matrix3DUtils.resetPosition=function(m){
			Matrix3DUtils.setPosition(m,0,0,0);
		}

		Matrix3DUtils.resetRotation=function(m){
			Matrix3DUtils.setRotation(m,0,0,0);
		}

		Matrix3DUtils.resetScale=function(m){
			Matrix3DUtils.setScale(m,1,1,1);
		}

		Matrix3DUtils.rotateAxis=function(m,angle,axis,pivotPoint){
			Matrix3DUtils._vector.x=axis.x;
			Matrix3DUtils._vector.y=axis.y;
			Matrix3DUtils._vector.z=axis.z;
			Matrix3DUtils._vector.normalize();
			m.copyColumnTo(3,Matrix3DUtils._pos);
			m.appendRotation(angle,Matrix3DUtils._vector,((pivotPoint)|| (Matrix3DUtils._pos)));
		}

		Matrix3DUtils.rotateX=function(m,angle,local,pivotPoint){
			(local===void 0)&& (local=true);
			Matrix3DUtils.rotateAxis(m,angle,(local)? Matrix3DUtils.getRight(m,Matrix3DUtils._vector):Vector3D.X_AXIS,pivotPoint);
		}

		Matrix3DUtils.rotateY=function(m,angle,local,pivotPoint){
			(local===void 0)&& (local=true);
			Matrix3DUtils.rotateAxis(m,angle,(local)? Matrix3DUtils.getUp(m,Matrix3DUtils._vector):Vector3D.Y_AXIS,pivotPoint);
		}

		Matrix3DUtils.rotateZ=function(m,angle,local,pivotPoint){
			(local===void 0)&& (local=true);
			Matrix3DUtils.rotateAxis(m,angle,(local)? Matrix3DUtils.getDir(m,Matrix3DUtils._vector):Vector3D.Z_AXIS,pivotPoint);
		}

		Matrix3DUtils.scaleX=function(m,scale){
			m.copyColumnTo(0,Matrix3DUtils._right);
			Matrix3DUtils._right.normalize();
			Matrix3DUtils._right.x=(Matrix3DUtils._right.x *scale);
			Matrix3DUtils._right.y=(Matrix3DUtils._right.y *scale);
			Matrix3DUtils._right.z=(Matrix3DUtils._right.z *scale);
			m.copyColumnFrom(0,Matrix3DUtils._right);
		}

		Matrix3DUtils.scaleY=function(m,scale){
			m.copyColumnTo(1,Matrix3DUtils._up);
			Matrix3DUtils._up.normalize();
			Matrix3DUtils._up.x=(Matrix3DUtils._up.x *scale);
			Matrix3DUtils._up.y=(Matrix3DUtils._up.y *scale);
			Matrix3DUtils._up.z=(Matrix3DUtils._up.z *scale);
			m.copyColumnFrom(1,Matrix3DUtils._up);
		}

		Matrix3DUtils.scaleZ=function(m,scale){
			m.copyColumnTo(2,Matrix3DUtils._dir);
			Matrix3DUtils._dir.normalize();
			Matrix3DUtils._dir.x=(Matrix3DUtils._dir.x *scale);
			Matrix3DUtils._dir.y=(Matrix3DUtils._dir.y *scale);
			Matrix3DUtils._dir.z=(Matrix3DUtils._dir.z *scale);
			m.copyColumnFrom(2,Matrix3DUtils._dir);
		}

		Matrix3DUtils.setNormalOrientation=function(m,normal,smooth){
			(smooth===void 0)&& (smooth=1);
			if (((normal.x==0)&& (normal.y==0))&& (normal.z==0)){
				return;
			}
			Matrix3DUtils.getScale(m,Matrix3DUtils._scale);
			Matrix3DUtils.getDir(m,Matrix3DUtils._dir);
			if (smooth !=1){
				Matrix3DUtils.getUp(m,Matrix3DUtils._up);
				Matrix3DUtils._up.x=(Matrix3DUtils._up.x+((normal.x-Matrix3DUtils._up.x)*smooth));
				Matrix3DUtils._up.y=(Matrix3DUtils._up.y+((normal.y-Matrix3DUtils._up.y)*smooth));
				Matrix3DUtils._up.z=(Matrix3DUtils._up.z+((normal.z-Matrix3DUtils._up.z)*smooth));
				normal=Matrix3DUtils._up;
			}
			normal.normalize();
			var dir=((Math.abs(Matrix3DUtils._dir.dotProduct(normal))==1))? Matrix3DUtils.getRight(m,Matrix3DUtils._right):Matrix3DUtils._dir;
			var rVec=normal.crossProduct(dir);
			rVec.normalize();
			var dVec=rVec.crossProduct(normal);
			rVec.scaleBy(Matrix3DUtils._scale.x);
			normal.scaleBy(Matrix3DUtils._scale.y);
			dVec.scaleBy(Matrix3DUtils._scale.z);
			Matrix3DUtils.setVectors(m,rVec,normal,dVec);
		}

		Matrix3DUtils.setOrientation=function(m,dir,up,smooth){
			(smooth===void 0)&& (smooth=1);
			Matrix3DUtils.getScale(m,Matrix3DUtils._scale);
			if (up==null){
				if ((((((dir.x==0))&& ((Math.abs(dir.y)==1))))&& ((dir.z==0)))){
					up=Vector3D.Z_AXIS;
				}
				else{
					up=Vector3D.Y_AXIS;
				}
			}
			if (smooth !=1){
				Matrix3DUtils.getDir(m,Matrix3DUtils._dir);
				Matrix3DUtils._dir.x=(Matrix3DUtils._dir.x+((dir.x-Matrix3DUtils._dir.x)*smooth));
				Matrix3DUtils._dir.y=(Matrix3DUtils._dir.y+((dir.y-Matrix3DUtils._dir.y)*smooth));
				Matrix3DUtils._dir.z=(Matrix3DUtils._dir.z+((dir.z-Matrix3DUtils._dir.z)*smooth));
				dir=Matrix3DUtils._dir;
				Matrix3DUtils.getUp(m,Matrix3DUtils._up);
				Matrix3DUtils._up.x=(Matrix3DUtils._up.x+((up.x-Matrix3DUtils._up.x)*smooth));
				Matrix3DUtils._up.y=(Matrix3DUtils._up.y+((up.y-Matrix3DUtils._up.y)*smooth));
				Matrix3DUtils._up.z=(Matrix3DUtils._up.z+((up.z-Matrix3DUtils._up.z)*smooth));
				up=Matrix3DUtils._up;
			}
			dir.normalize();
			var rVec=up.crossProduct(dir);
			rVec.normalize();
			var uVec=dir.crossProduct(rVec);
			rVec.scaleBy(Matrix3DUtils._scale.x);
			uVec.scaleBy(Matrix3DUtils._scale.y);
			dir.scaleBy(Matrix3DUtils._scale.z);
			Matrix3DUtils.setVectors(m,rVec,uVec,dir);
		}

		Matrix3DUtils.setPosition=function(m,x,y,z,smooth){
			(smooth===void 0)&& (smooth=1);
			if (smooth==1){
				Matrix3DUtils._vector.setTo(x,y,z,1);
				Matrix3DUtils._vector.w=1;
				m.copyColumnFrom(3,Matrix3DUtils._vector);
			}
			else{
				m.copyColumnTo(3,Matrix3DUtils._pos);
				Matrix3DUtils._pos.x=(Matrix3DUtils._pos.x+((x-Matrix3DUtils._pos.x)*smooth));
				Matrix3DUtils._pos.y=(Matrix3DUtils._pos.y+((y-Matrix3DUtils._pos.y)*smooth));
				Matrix3DUtils._pos.z=(Matrix3DUtils._pos.z+((z-Matrix3DUtils._pos.z)*smooth));
				m.copyColumnFrom(3,Matrix3DUtils._pos);
			}
		}

		Matrix3DUtils.setRotation=function(m,x,y,z){
			if(Matrix3DUtils.decomposes.length==0){
				Matrix3DUtils.decomposes[0]=new Vector3D;
				Matrix3DUtils.decomposes[1]=new Vector3D;
				Matrix3DUtils.decomposes[2]=new Vector3D;
			}
			m.decompose("EulerAngles",Matrix3DUtils.decomposes);
			Matrix3DUtils.decomposes[1].x=(x *Matrix3DUtils._toRad);
			Matrix3DUtils.decomposes[1].y=(y *Matrix3DUtils._toRad);
			Matrix3DUtils.decomposes[1].z=(z *Matrix3DUtils._toRad);
			m.recompose(Matrix3DUtils.decomposes);
		}

		Matrix3DUtils.setScale=function(m,x,y,z,smooth){
			(smooth===void 0)&& (smooth=1);
			Matrix3DUtils.getScale(m,Matrix3DUtils._scale);
			Matrix3DUtils._x=Matrix3DUtils._scale.x;
			Matrix3DUtils._y=Matrix3DUtils._scale.y;
			Matrix3DUtils._z=Matrix3DUtils._scale.z;
			Matrix3DUtils._scale.x=(Matrix3DUtils._scale.x+((x-Matrix3DUtils._scale.x)*smooth));
			Matrix3DUtils._scale.y=(Matrix3DUtils._scale.y+((y-Matrix3DUtils._scale.y)*smooth));
			Matrix3DUtils._scale.z=(Matrix3DUtils._scale.z+((z-Matrix3DUtils._scale.z)*smooth));
			Matrix3DUtils._right.scaleBy((Matrix3DUtils._scale.x / Matrix3DUtils._x));
			Matrix3DUtils._up.scaleBy((Matrix3DUtils._scale.y / Matrix3DUtils._y));
			Matrix3DUtils._dir.scaleBy((Matrix3DUtils._scale.z / Matrix3DUtils._z));
			Matrix3DUtils.setVectors(m,Matrix3DUtils._right,Matrix3DUtils._up,Matrix3DUtils._dir);
		}

		Matrix3DUtils.setTranslation=function(m,x,y,z,local){
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(local===void 0)&& (local=true);
			if (local){
				m.prependTranslation(x,y,z);
			}
			else{
				m.appendTranslation(x,y,z);
			}
		}

		Matrix3DUtils.transformVector=function(m,vector,out){
			if (out==null){
				out=new Vector3D();
			}
			Matrix3DUtils._vector.copyFrom(vector);
			m.copyRawTo(0,Matrix3DUtils._right);
			m.copyRawTo(1,Matrix3DUtils._up);
			m.copyRawTo(2,Matrix3DUtils._dir);
			m.copyColumnTo(3,out);
			out.x=out.x+(Matrix3DUtils._vector.x *Matrix3DUtils._right.x)+(Matrix3DUtils._vector.y *Matrix3DUtils._right.y)+(Matrix3DUtils._vector.z *Matrix3DUtils._right.z);
			out.y=out.y+(Matrix3DUtils._vector.x *Matrix3DUtils._up.x)+(Matrix3DUtils._vector.y *Matrix3DUtils._up.y)+(Matrix3DUtils._vector.z *Matrix3DUtils._up.z);
			out.z=out.z+(Matrix3DUtils._vector.x *Matrix3DUtils._dir.x)+(Matrix3DUtils._vector.y *Matrix3DUtils._dir.y)+(Matrix3DUtils._vector.z *Matrix3DUtils._dir.z);
			return out;
		}

		Matrix3DUtils.translateAxis=function(m,distance,axis){
			m.copyColumnTo(3,Matrix3DUtils._pos);
			Matrix3DUtils._pos.x=(Matrix3DUtils._pos.x+(distance *axis.x));
			Matrix3DUtils._pos.y=(Matrix3DUtils._pos.y+(distance *axis.y));
			Matrix3DUtils._pos.z=(Matrix3DUtils._pos.z+(distance *axis.z));
			m.copyColumnFrom(3,Matrix3DUtils._pos);
		}

		Matrix3DUtils.translateX=function(m,distance,local){
			(local===void 0)&& (local=true);
			m.copyColumnTo(3,Matrix3DUtils._pos);
			m.copyColumnTo(0,Matrix3DUtils._right);
			if (local){
				Matrix3DUtils._pos.x=(Matrix3DUtils._pos.x+(distance *Matrix3DUtils._right.x));
				Matrix3DUtils._pos.y=(Matrix3DUtils._pos.y+(distance *Matrix3DUtils._right.y));
				Matrix3DUtils._pos.z=(Matrix3DUtils._pos.z+(distance *Matrix3DUtils._right.z));
			}
			else{
				Matrix3DUtils._pos.x=(Matrix3DUtils._pos.x+distance);
			}
			m.copyColumnFrom(3,Matrix3DUtils._pos);
		}

		Matrix3DUtils.translateY=function(m,distance,local){
			(local===void 0)&& (local=true);
			m.copyColumnTo(3,Matrix3DUtils._pos);
			m.copyColumnTo(1,Matrix3DUtils._up);
			if (local){
				Matrix3DUtils._pos.x=(Matrix3DUtils._pos.x+(distance *Matrix3DUtils._up.x));
				Matrix3DUtils._pos.y=(Matrix3DUtils._pos.y+(distance *Matrix3DUtils._up.y));
				Matrix3DUtils._pos.z=(Matrix3DUtils._pos.z+(distance *Matrix3DUtils._up.z));
			}
			else{
				Matrix3DUtils._pos.y=(Matrix3DUtils._pos.y+distance);
			}
			m.copyColumnFrom(3,Matrix3DUtils._pos);
		}

		Matrix3DUtils.translateZ=function(m,distance,local){
			(local===void 0)&& (local=true);
			m.copyColumnTo(3,Matrix3DUtils._pos);
			m.copyColumnTo(2,Matrix3DUtils._dir);
			if (local){
				Matrix3DUtils._pos.x=(Matrix3DUtils._pos.x+(distance *Matrix3DUtils._dir.x));
				Matrix3DUtils._pos.y=(Matrix3DUtils._pos.y+(distance *Matrix3DUtils._dir.y));
				Matrix3DUtils._pos.z=(Matrix3DUtils._pos.z+(distance *Matrix3DUtils._dir.z));
			}
			else{
				Matrix3DUtils._pos.z=(Matrix3DUtils._pos.z+distance);
			}
			m.copyColumnFrom(3,Matrix3DUtils._pos);
		}

		Matrix3DUtils.setVectors=function(m,right,up,dir){
			right.w=0;
			up.w=0;
			dir.w=0;
			m.copyColumnFrom(0,right);
			m.copyColumnFrom(1,up);
			m.copyColumnFrom(2,dir);
		}

		Matrix3DUtils._toAng=57.2957795130823;
		Matrix3DUtils._toRad=0.0174532925199433;
		Matrix3DUtils._x=NaN
		Matrix3DUtils._y=NaN
		Matrix3DUtils._z=NaN
		Matrix3DUtils.decomposes=[];
		__static(Matrix3DUtils,
		['RAW_DATA',function(){return this.RAW_DATA=new Float32Array(16);},'_dir',function(){return this._dir=new Vector3D();},'_pos',function(){return this._pos=new Vector3D();},'_raw',function(){return this._raw=new Float32Array(16);},'_right',function(){return this._right=new Vector3D();},'_scale',function(){return this._scale=new Vector3D();},'_up',function(){return this._up=new Vector3D();},'_vector',function(){return this._vector=new Vector3D();}
		]);
		return Matrix3DUtils;
	})()


	//class specter3d.engine.utlis.ParserUtil
	var ParserUtil=(function(){
		function ParserUtil(){};
		__class(ParserUtil,'specter3d.engine.utlis.ParserUtil');
		ParserUtil.toByte=function(data){
			return (data instanceof ArrayBuffer)? new Byte(data):null;
		}

		ParserUtil.toString=function(data,length){
			(length===void 0)&& (length=0);
			var ba;length=length|| 4294967295;
			if ((typeof data=='string'))
				return String(data).substr(0,length);
			ba=ParserUtil.toByte(data);
			if (ba){
				ba.pos=0;
				return ba.readUTFBytes(Math.min(ba.bytesAvailable,length));
			}
			return null;
		}

		return ParserUtil;
	})()


	/**
	*Vector3DUtils
	*@author wangcx
	*
	*/
	//class specter3d.engine.utlis.Vector3DUtils
	var Vector3DUtils=(function(){
		function Vector3DUtils(){};
		__class(Vector3DUtils,'specter3d.engine.utlis.Vector3DUtils');
		Vector3DUtils.abs=function(a){
			if (a.elements[0] < 0){
				a.elements[0]=-a.elements[0];
			}
			if (a.elements[1] < 0){
				a.elements[1]=-a.elements[1];
			}
			if (a.elements[2] < 0){
				a.elements[2]=-a.elements[2];
			}
		}

		Vector3DUtils.add=function(a,b,out){
			if (out==null){
				out=new Vector3D();
			}
			out.elements[0]=a.elements[0]+b.elements[0];
			out.elements[1]=a.elements[1]+b.elements[1];
			out.elements[2]=a.elements[2]+b.elements[2];
			return out;
		}

		Vector3DUtils.cross=function(a,b,out){
			if (!out){
				out=new Vector3D();
			}
			out.elements[0]=a.elements[1] *b.elements[2]-a.elements[2] *b.elements[1];
			out.elements[1]=a.elements[2] *b.elements[0]-a.elements[0] *b.elements[2];
			out.elements[2]=a.elements[0] *b.elements[1]-a.elements[1] *b.elements[0];
			return out;
		}

		Vector3DUtils.interpolate=function(a,b,value,out){
			if (out==null){
				out=new Vector3D();
			}
			out.elements[0]=a.elements[0]+(b.elements[0]-a.elements[0])*value;
			out.elements[1]=a.elements[1]+(b.elements[1]-a.elements[1])*value;
			out.elements[2]=a.elements[2]+(b.elements[2]-a.elements[2])*value;
			return out;
		}

		Vector3DUtils.length=function(a,b){
			var dx=a.elements[0]-b.elements[0];
			var dy=a.elements[1]-b.elements[1];
			var dz=a.elements[2]-b.elements[2];
			return Math.sqrt(dx *dx+dy *dy+dz *dz);
		}

		Vector3DUtils.lengthSquared=function(a,b){
			var dx=a.elements[0]-b.elements[0];
			var dy=a.elements[1]-b.elements[1];
			var dz=a.elements[2]-b.elements[2];
			return dx *dx+dy *dy+dz *dz;
		}

		Vector3DUtils.max=function(a,b,out){
			if (out==null){
				out=new Vector3D();
			}
			out.elements[0]=(a.elements[0] > b.elements[0])? a.elements[0] :b.elements[0];
			out.elements[1]=(a.elements[1] > b.elements[1])? a.elements[1] :b.elements[1];
			out.elements[2]=(a.elements[2] > b.elements[2])? a.elements[2] :b.elements[2];
			return out;
		}

		Vector3DUtils.min=function(a,b,out){
			if (out==null){
				out=new Vector3D();
			}
			out.elements[0]=(a.elements[0] < b.elements[0])? a.elements[0] :b.elements[0];
			out.elements[1]=(a.elements[1] < b.elements[1])? a.elements[1] :b.elements[1];
			out.elements[2]=(a.elements[2] < b.elements[2])? a.elements[2] :b.elements[2];
			return out;
		}

		Vector3DUtils.mirror=function(vector,normal,out){
			if (out==null){
				out=new Vector3D();
			};
			var dot=vector.dotProduct(normal);
			out.elements[0]=vector.elements[0]-(2 *normal.elements[0])*dot;
			out.elements[1]=vector.elements[1]-(2 *normal.elements[1])*dot;
			out.elements[2]=vector.elements[2]-(2 *normal.elements[2])*dot;
			return out;
		}

		Vector3DUtils.mul=function(a,b,out){
			out.elements[0]=a.elements[0] *b.elements[0];
			out.elements[1]=a.elements[1] *b.elements[1];
			out.elements[2]=a.elements[2] *b.elements[2];
		}

		Vector3DUtils.negate=function(a,out){
			if (out==null){
				out=new Vector3D();
			}
			out.elements[0]=-a.elements[0];
			out.elements[1]=-a.elements[1];
			out.elements[2]=-a.elements[2];
			return out;
		}

		Vector3DUtils.random=function(min,max,out){
			if (out==null){
				out=new Vector3D();
			}
			out.elements[0]=Math.random()*(max-min)+min;
			out.elements[1]=Math.random()*(max-min)+min;
			out.elements[2]=Math.random()*(max-min)+min;
			return out;
		}

		Vector3DUtils.set=function(a,x,y,z,w){
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(w===void 0)&& (w=0);
			a.elements[0]=x;
			a.elements[1]=y;
			a.elements[2]=z;
			a.w=w;
		}

		Vector3DUtils.setLength=function(a,length){
			var l=a.length;
			if (l > 0){
				l=l / length;
				a.elements[0]=a.elements[0] / l;
				a.elements[1]=a.elements[1] / l;
				a.elements[2]=a.elements[2] / l;
			}
			else{
				a.elements[0]=a.elements[1]=a.elements[2]=0;
			}
		}

		Vector3DUtils.sub=function(a,b,out){
			if (out==null){
				out=new Vector3D();
			}
			out.elements[0]=a.elements[0]-b.elements[0];
			out.elements[1]=a.elements[1]-b.elements[1];
			out.elements[2]=a.elements[2]-b.elements[2];
			return out;
		}

		__static(Vector3DUtils,
		['BACK',function(){return this.BACK=new Vector3D(0,0,-1);},'DOWN',function(){return this.DOWN=new Vector3D(0,-1,0);},'FORWARD',function(){return this.FORWARD=new Vector3D(0,0,1);},'LEFT',function(){return this.LEFT=new Vector3D(-1,0,0);},'ONE',function(){return this.ONE=new Vector3D(1,1,1);},'RIGHT',function(){return this.RIGHT=new Vector3D(1,0,0);},'UP',function(){return this.UP=new Vector3D(0,1,0);},'ZERO',function(){return this.ZERO=new Vector3D(0,0,0);},'vec0',function(){return this.vec0=new Vector3D();},'vec1',function(){return this.vec1=new Vector3D();},'vec2',function(){return this.vec2=new Vector3D();}
		]);
		return Vector3DUtils;
	})()


	/**
	*Config 用于配置一些全局参数。
	*/
	//class Config
	var Config=(function(){
		function Config(){};
		__class(Config,'Config');
		Config.WebGLTextCacheCount=500;
		Config.atlasEnable=false;
		Config.showCanvasMark=false;
		Config.CPUMemoryLimit=120 *1024 *1024;
		Config.GPUMemoryLimit=160 *1024 *1024;
		Config.animationInterval=30;
		Config.isAntialias=true;
		return Config;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.shader.ShaderValue
	var ShaderValue=(function(){
		function ShaderValue(){}
		__class(ShaderValue,'laya.webgl.shader.ShaderValue');
		return ShaderValue;
	})()


	/**
	*<code>Graphics</code> 类用于创建绘图显示对象。
	*@see laya.display.Sprite#graphics
	*/
	//class laya.display.Graphics
	var Graphics=(function(){
		function Graphics(){
			//this._sp=null;
			this._one=null;
			this._cmds=null;
			//this._temp=null;
			//this._bounds=null;
			//this._rstBoundPoints=null;
			//this._vectorgraphArray=null;
			this._render=this._renderEmpty;
			this._render=this._renderEmpty;
			if (Render.isConchNode){
				this._nativeObj=new _conchGraphics();;
				this.id=this._nativeObj.conchID;;
			}
		}

		__class(Graphics,'laya.display.Graphics');
		var __proto=Graphics.prototype;
		/**
		*<p>销毁此对象。</p>
		*/
		__proto.destroy=function(){
			this.clear();
			this._temp=null;
			this._bounds=null;
			this._rstBoundPoints=null;
			this._sp && (this._sp._renderType=0);
			this._sp=null;
		}

		/**
		*<p>清空绘制命令。</p>
		*/
		__proto.clear=function(){
			this._one=null;
			this._render=this._renderEmpty;
			this._cmds=null;
			this._temp && (this._temp.length=0);
			this._sp && (this._sp._renderType &=~0x01);
			this._sp && (this._sp._renderType &=~0x100);
			this._repaint();
			if (this._vectorgraphArray){
				for (var i=0,n=this._vectorgraphArray.length;i < n;i++){
					VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
				}
				this._vectorgraphArray.length=0;
			}
		}

		/**
		*@private
		*重绘此对象。
		*/
		__proto._repaint=function(){
			this._temp && (this._temp.length=0);
			this._sp && this._sp.repaint();
		}

		/**@private */
		__proto._isOnlyOne=function(){
			return !this._cmds || this._cmds.length===0;
		}

		/**
		*获取位置及宽高信息矩阵(比较耗，尽量少用)。
		*@return 位置与宽高组成的 一个 Rectangle 对象。
		*/
		__proto.getBounds=function(){
			if (!this._bounds || !this._temp || this._temp.length < 1){
				this._bounds=Rectangle._getWrapRec(this.getBoundPoints(),this._bounds)
			}
			return this._bounds;
		}

		/**
		*@private
		*获取端点列表。
		*/
		__proto.getBoundPoints=function(){
			if (!this._temp || this._temp.length < 1)
				this._temp=this._getCmdPoints();
			return this._rstBoundPoints=Utils.copyArray(this._rstBoundPoints,this._temp);
		}

		__proto._addCmd=function(a){
			this._cmds=this._cmds || [];
			a.callee=a.shift();
			this._cmds.push(a);
		}

		__proto._getCmdPoints=function(){
			var context=Render._context;
			var cmds=this._cmds;
			var rst;
			rst=this._temp || (this._temp=[]);
			rst.length=0;
			if (!cmds && this._one !=null){
				Graphics._tempCmds.length=0;
				Graphics._tempCmds.push(this._one);
				cmds=Graphics._tempCmds;
			}
			if (!cmds)
				return rst;
			var matrixs;
			matrixs=Graphics._tempMatrixArrays;
			matrixs.length=0;
			var tMatrix=Graphics._initMatrix;
			tMatrix.identity();
			var tempMatrix=Graphics._tempMatrix;
			var cmd;
			for (var i=0,n=cmds.length;i < n;i++){
				cmd=cmds[i];
				switch (cmd.callee){
					case context.save:
					case 7:
						matrixs.push(tMatrix);
						tMatrix=tMatrix.clone();
						break ;
					case context.restore:
					case 8:
						tMatrix=matrixs.pop();
						break ;
					case context._scale:
					case 5:
						tempMatrix.identity();
						tempMatrix.translate(-cmd[2],-cmd[3]);
						tempMatrix.scale(cmd[0],cmd[1]);
						tempMatrix.translate(cmd[2],cmd[3]);
						this._switchMatrix(tMatrix,tempMatrix);
						break ;
					case context._rotate:
					case 3:
						tempMatrix.identity();
						tempMatrix.translate(-cmd[1],-cmd[2]);
						tempMatrix.rotate(cmd[0]);
						tempMatrix.translate(cmd[1],cmd[2]);
						this._switchMatrix(tMatrix,tempMatrix);
						break ;
					case context._translate:
					case 6:
						tempMatrix.identity();
						tempMatrix.translate(cmd[0],cmd[1]);
						this._switchMatrix(tMatrix,tempMatrix);
						break ;
					case context._transform:
					case 4:
						tempMatrix.identity();
						tempMatrix.translate(-cmd[1],-cmd[2]);
						tempMatrix.concat(cmd[0]);
						tempMatrix.translate(cmd[1],cmd[2]);
						this._switchMatrix(tMatrix,tempMatrix);
						break ;
					case 16:
					case 24:
						Graphics._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[0],cmd[1],cmd[2],cmd[3]),tMatrix);
						break ;
					case 17:
						tMatrix.copyTo(tempMatrix);
						tempMatrix.concat(cmd[4]);
						Graphics._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[0],cmd[1],cmd[2],cmd[3]),tempMatrix);
						break ;
					case context._drawTexture:
					case context._fillTexture:
						if (cmd[3] && cmd[4]){
							Graphics._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],cmd[3],cmd[4]),tMatrix);
							}else {
							var tex=cmd[0];
							Graphics._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],tex.width,tex.height),tMatrix);
						}
						break ;
					case context._drawTextureWithTransform:
						tMatrix.copyTo(tempMatrix);
						tempMatrix.concat(cmd[5]);
						if (cmd[3] && cmd[4]){
							Graphics._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],cmd[3],cmd[4]),tempMatrix);
							}else {
							tex=cmd[0];
							Graphics._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[1],cmd[2],tex.width,tex.height),tempMatrix);
						}
						break ;
					case context._drawRect:
					case 13:
						Graphics._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[0],cmd[1],cmd[2],cmd[3]),tMatrix);
						break ;
					case context._drawCircle:
					case context._fillCircle:
					case 14:
						Graphics._addPointArrToRst(rst,Rectangle._getBoundPointS(cmd[0]-cmd[2],cmd[1]-cmd[2],cmd[2]+cmd[2],cmd[2]+cmd[2]),tMatrix);
						break ;
					case context._drawLine:
					case 20:
						Graphics._tempPoints.length=0;
						var lineWidth=NaN;
						lineWidth=cmd[5] *0.5;
						if (cmd[0]==cmd[2]){
							Graphics._tempPoints.push(cmd[0]+lineWidth,cmd[1],cmd[2]+lineWidth,cmd[3],cmd[0]-lineWidth,cmd[1],cmd[2]-lineWidth,cmd[3]);
							}else if (cmd[1]==cmd[3]){
							Graphics._tempPoints.push(cmd[0],cmd[1]+lineWidth,cmd[2],cmd[3]+lineWidth,cmd[0],cmd[1]-lineWidth,cmd[2],cmd[3]-lineWidth);
							}else {
							Graphics._tempPoints.push(cmd[0],cmd[1],cmd[2],cmd[3]);
						}
						Graphics._addPointArrToRst(rst,Graphics._tempPoints,tMatrix);
						break ;
					case context._drawCurves:
					case 22:
						Graphics._addPointArrToRst(rst,Bezier.I.getBezierPoints(cmd[2]),tMatrix,cmd[0],cmd[1]);
						break ;
					case context._drawPoly:
					case context._drawLines:
					case 18:
						Graphics._addPointArrToRst(rst,cmd[2],tMatrix,cmd[0],cmd[1]);
						break ;
					case context._drawPath:
					case 19:
						Graphics._addPointArrToRst(rst,this._getPathPoints(cmd[2]),tMatrix,cmd[0],cmd[1]);
						break ;
					case context._drawPie:
					case 15:
						Graphics._addPointArrToRst(rst,this._getPiePoints(cmd[0],cmd[1],cmd[2],cmd[3],cmd[4]),tMatrix);
						break ;
					}
			}
			if (rst.length > 200){
				rst=Utils.copyArray(rst,Rectangle._getWrapRec(rst)._getBoundPoints());
			}else if (rst.length > 8)
			rst=GrahamScan.scanPList(rst);
			return rst;
		}

		__proto._switchMatrix=function(tMatix,tempMatrix){
			tempMatrix.concat(tMatix);
			tempMatrix.copyTo(tMatix);
		}

		/**
		*绘制纹理。
		*@param tex 纹理。
		*@param x X 轴偏移量。
		*@param y Y 轴偏移量。
		*@param width 宽度。
		*@param height 高度。
		*@param m 矩阵信息。
		*/
		__proto.drawTexture=function(tex,x,y,width,height,m){
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			if (!tex)return;
			if (!width)width=tex.sourceWidth;
			if (!height)height=tex.sourceHeight;
			width=width-tex.sourceWidth+tex.width;
			height=height-tex.sourceHeight+tex.height;
			if (tex.loaded && (width <=0 || height <=0))return;
			x+=tex.offsetX;
			y+=tex.offsetY;
			this._sp && (this._sp._renderType |=0x100);
			var args=[tex,x,y,width,height,m];
			args.callee=m ? Render._context._drawTextureWithTransform :Render._context._drawTexture;
			if (this._one==null && !m){
				this._one=args;
				this._render=this._renderOneImg;
				}else {
				this._saveToCmd(args.callee,args);
			}
			if (!tex.loaded){
				tex.once("loaded",this,this._textureLoaded,[tex,args]);
			}
			this._repaint();
		}

		/**
		*用texture填充
		*@param tex 纹理。
		*@param x X 轴偏移量。
		*@param y Y 轴偏移量。
		*@param width 宽度。
		*@param height 高度。
		*@param type 填充类型 repeat|repeat-x|repeat-y|no-repeat
		*@param offset 贴图纹理偏移
		*
		*/
		__proto.fillTexture=function(tex,x,y,width,height,type,offset){
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			(type===void 0)&& (type="repeat");
			if (!tex)return;
			var args=[tex,x,y,width,height,type,offset];
			if (!tex.loaded){
				tex.once("loaded",this,this._textureLoaded,[tex,args]);
			}
			if (Render.isWebGL){
				var tFillTextureSprite=RunDriver.fillTextureShader(tex,x,y,width,height);
				args.push(tFillTextureSprite);
			}
			this._saveToCmd(Render._context._fillTexture,args);
		}

		__proto._textureLoaded=function(tex,param){
			param[3]=param[3] || tex.width;
			param[4]=param[4] || tex.height;
			this._repaint();
		}

		/**
		*@private
		*保存到命令流。
		*/
		__proto._saveToCmd=function(fun,args){
			this._sp && (this._sp._renderType |=0x100);
			if (this._one==null){
				this._one=args;
				this._render=this._renderOne;
				}else {
				this._sp && (this._sp._renderType &=~0x01);
				this._render=this._renderAll;
				(this._cmds || (this._cmds=[])).length===0 && this._cmds.push(this._one);
				this._cmds.push(args);
			}
			args.callee=fun;
			this._temp && (this._temp.length=0);
			this._repaint();
			return args;
		}

		/**
		*设置剪裁区域，超出剪裁区域的坐标不显示。
		*@param x X 轴偏移量。
		*@param y Y 轴偏移量。
		*@param width 宽度。
		*@param height 高度。
		*/
		__proto.clipRect=function(x,y,width,height){
			this._saveToCmd(Render._context._clipRect,[x,y,width,height]);
		}

		/**
		*在画布上绘制文本。
		*@param text 在画布上输出的文本。
		*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
		*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
		*@param font 定义字号和字体，比如"20px Arial"。
		*@param color 定义文本颜色，比如"#ff0000"。
		*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
		*/
		__proto.fillText=function(text,x,y,font,color,textAlign){
			this._saveToCmd(Render._context._fillText,[text,x,y,font || Font.defaultFont,color,textAlign]);
		}

		/**
		*在画布上绘制“被填充且镶边的”文本。
		*@param text 在画布上输出的文本。
		*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
		*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
		*@param font 定义字体和字号，比如"20px Arial"。
		*@param fillColor 定义文本颜色，比如"#ff0000"。
		*@param borderColor 定义镶边文本颜色。
		*@param lineWidth 镶边线条宽度。
		*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
		*/
		__proto.fillBorderText=function(text,x,y,font,fillColor,borderColor,lineWidth,textAlign){
			this._saveToCmd(Render._context._fillBorderText,[text,x,y,font || Font.defaultFont,fillColor,borderColor,lineWidth,textAlign]);
		}

		/**
		*在画布上绘制文本（没有填色）。文本的默认颜色是黑色。
		*@param text 在画布上输出的文本。
		*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
		*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
		*@param font 定义字体和字号，比如"20px Arial"。
		*@param color 定义文本颜色，比如"#ff0000"。
		*@param lineWidth 线条宽度。
		*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
		*/
		__proto.strokeText=function(text,x,y,font,color,lineWidth,textAlign){
			this._saveToCmd(Render._context._strokeText,[text,x,y,font || Font.defaultFont,color,lineWidth,textAlign]);
		}

		/**
		*设置透明度。
		*@param value 透明度。
		*/
		__proto.alpha=function(value){
			this._saveToCmd(Render._context._alpha,[value]);
		}

		/**
		*替换绘图的当前转换矩阵。
		*@param mat 矩阵。
		*@param pivotX 水平方向轴心点坐标。
		*@param pivotY 垂直方向轴心点坐标。
		*/
		__proto.transform=function(matrix,pivotX,pivotY){
			(pivotX===void 0)&& (pivotX=0);
			(pivotY===void 0)&& (pivotY=0);
			this._saveToCmd(Render._context._transform,[matrix,pivotX,pivotY]);
		}

		/**
		*旋转当前绘图。
		*@param angle 旋转角度，以弧度计。
		*@param pivotX 水平方向轴心点坐标。
		*@param pivotY 垂直方向轴心点坐标。
		*/
		__proto.rotate=function(angle,pivotX,pivotY){
			(pivotX===void 0)&& (pivotX=0);
			(pivotY===void 0)&& (pivotY=0);
			this._saveToCmd(Render._context._rotate,[angle,pivotX,pivotY]);
		}

		/**
		*缩放当前绘图至更大或更小。
		*@param scaleX 水平方向缩放值。
		*@param scaleY 垂直方向缩放值。
		*@param pivotX 水平方向轴心点坐标。
		*@param pivotY 垂直方向轴心点坐标。
		*/
		__proto.scale=function(scaleX,scaleY,pivotX,pivotY){
			(pivotX===void 0)&& (pivotX=0);
			(pivotY===void 0)&& (pivotY=0);
			this._saveToCmd(Render._context._scale,[scaleX,scaleY,pivotX,pivotY]);
		}

		/**
		*重新映射画布上的 (0,0)位置。
		*@param x 添加到水平坐标（x）上的值。
		*@param y 添加到垂直坐标（y）上的值。
		*/
		__proto.translate=function(x,y){
			this._saveToCmd(Render._context._translate,[x,y]);
		}

		/**
		*保存当前环境的状态。
		*/
		__proto.save=function(){
			this._saveToCmd(Render._context._save,[]);
		}

		/**
		*返回之前保存过的路径状态和属性。
		*/
		__proto.restore=function(){
			this._saveToCmd(Render._context._restore,[]);
		}

		/**
		*@private
		*替换文本内容。
		*@param text 文本内容。
		*@return 替换成功则值为true，否则值为flase。
		*/
		__proto.replaceText=function(text){
			this._repaint();
			var cmds=this._cmds;
			if (!cmds){
				if (this._one && this._isTextCmd(this._one.callee)){
					if (this._one[0].toUpperCase)this._one[0]=text;
					else this._one[0].setText(text);
					return true;
				}
				}else {
				for (var i=cmds.length-1;i >-1;i--){
					if (this._isTextCmd(cmds[i].callee)){
						if (cmds[i][0].toUpperCase)cmds[i][0]=text;
						else cmds[i][0].setText(text);
						return true;
					}
				}
			}
			return false;
		}

		/**@private */
		__proto._isTextCmd=function(fun){
			return fun===Render._context._fillText || fun===Render._context._fillBorderText || fun===Render._context._strokeText;
		}

		/**
		*@private
		*替换文本颜色。
		*@param color 颜色。
		*/
		__proto.replaceTextColor=function(color){
			this._repaint();
			var cmds=this._cmds;
			if (!cmds){
				if (this._one && this._isTextCmd(this._one.callee)){
					this._one[4]=color;
					if (!this._one[0].toUpperCase)this._one[0].changed=true;
				}
				}else {
				for (var i=cmds.length-1;i >-1;i--){
					if (this._isTextCmd(cmds[i].callee)){
						cmds[i][4]=color;
						if (!cmds[i][0].toUpperCase)cmds[i][0].changed=true;
					}
				}
			}
		}

		/**
		*加载并显示一个图片。
		*@param url 图片地址。
		*@param x 显示图片的x位置。
		*@param y 显示图片的y位置。
		*@param width 显示图片的宽度，设置为0表示使用图片默认宽度。
		*@param height 显示图片的高度，设置为0表示使用图片默认高度。
		*@param complete 加载完成回调。
		*/
		__proto.loadImage=function(url,x,y,width,height,complete){
			var _$this=this;
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			var tex=Loader.getRes(url);
			if (tex)onloaded(tex);
			else Laya.loader.load(url,Handler.create(null,onloaded),null,"image");
			function onloaded (tex){
				if (tex){
					_$this.drawTexture(tex,x,y,width,height);
					if (complete !=null)complete.call(_$this._sp,tex);
				}
			}
		}

		/**
		*@private
		*/
		__proto._renderEmpty=function(sprite,context,x,y){}
		/**
		*@private
		*/
		__proto._renderAll=function(sprite,context,x,y){
			var cmds=this._cmds,cmd;
			for (var i=0,n=cmds.length;i < n;i++){
				(cmd=cmds[i]).callee.call(context,x,y,cmd);
			}
		}

		/**
		*@private
		*/
		__proto._renderOne=function(sprite,context,x,y){
			this._one.callee.call(context,x,y,this._one);
		}

		/**
		*@private
		*/
		__proto._renderOneImg=function(sprite,context,x,y){
			this._one.callee.call(context,x,y,this._one);
			if (sprite._renderType!==2305){
				sprite._renderType |=0x01;
			}
		}

		/**
		*绘制一条线。
		*@param fromX X 轴开始位置。
		*@param fromY Y 轴开始位置。
		*@param toX X 轴结束位置。
		*@param toY Y 轴结束位置。
		*@param lineColor 颜色。
		*@param lineWidth 线条宽度。
		*/
		__proto.drawLine=function(fromX,fromY,toX,toY,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var tId=0;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
			};
			var arr=[fromX+0.5,fromY+0.5,toX+0.5,toY+0.5,lineColor,lineWidth,tId];
			this._saveToCmd(Render._context._drawLine,arr);
		}

		/**
		*绘制一系列线段。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param points 线段的点集合。格式:[x1,y1,x2,y2,x3,y3...]。
		*@param lineColor 线段颜色，或者填充绘图的渐变对象。
		*@param lineWidth 线段宽度。
		*/
		__proto.drawLines=function(x,y,points,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var tId=0;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
			};
			var arr=[x+0.5,y+0.5,points,lineColor,lineWidth,tId];
			this._saveToCmd(Render._context._drawLines,arr);
		}

		/**
		*绘制一系列曲线。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param points 线段的点集合，格式[startx,starty,ctrx,ctry,startx,starty...]。
		*@param lineColor 线段颜色，或者填充绘图的渐变对象。
		*@param lineWidth 线段宽度。
		*/
		__proto.drawCurves=function(x,y,points,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var arr=[x+0.5,y+0.5,points,lineColor,lineWidth];
			this._saveToCmd(Render._context._drawCurves,arr);
		}

		/**
		*绘制矩形。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param width 矩形宽度。
		*@param height 矩形高度。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor 边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth 边框宽度。
		*/
		__proto.drawRect=function(x,y,width,height,fillColor,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var offset=lineColor ? 0.5 :0;
			var arr=[x+offset,y+offset,width,height,fillColor,lineColor,lineWidth];
			this._saveToCmd(Render._context._drawRect,arr);
		}

		/**
		*绘制圆形。
		*@param x 圆点X 轴位置。
		*@param y 圆点Y 轴位置。
		*@param radius 半径。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor 边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth 边框宽度。
		*/
		__proto.drawCircle=function(x,y,radius,fillColor,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var offset=lineColor ? 0.5 :0;
			var tId=0;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
			};
			var arr=[x+offset,y+offset,radius,fillColor,lineColor,lineWidth,tId];
			this._saveToCmd(Render._context._drawCircle,arr);
		}

		/**
		*绘制扇形。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param radius 扇形半径。
		*@param startAngle 开始角度。
		*@param endAngle 结束角度。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor 边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth 边框宽度。
		*/
		__proto.drawPie=function(x,y,radius,startAngle,endAngle,fillColor,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var offset=lineColor ? 0.5 :0;
			var tId=0;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
			};
			var arr=[x+offset,y+offset,radius,startAngle,endAngle,fillColor,lineColor,lineWidth,tId];
			arr[3]=Utils.toRadian(startAngle);
			arr[4]=Utils.toRadian(endAngle);
			this._saveToCmd(Render._context._drawPie,arr);
		}

		__proto._getPiePoints=function(x,y,radius,startAngle,endAngle){
			var rst=Graphics._tempPoints;
			Graphics._tempPoints.length=0;
			rst.push(x,y);
			var dP=Math.PI / 10;
			var i=NaN;
			for (i=startAngle;i < endAngle;i+=dP){
				rst.push(x+radius *Math.cos(i),y+radius *Math.sin(i));
			}
			if (endAngle !=i){
				rst.push(x+radius *Math.cos(endAngle),y+radius *Math.sin(endAngle));
			}
			return rst;
		}

		/**
		*绘制多边形。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param points 多边形的点集合。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor 边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth 边框宽度。
		*/
		__proto.drawPoly=function(x,y,points,fillColor,lineColor,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var offset=lineColor ? 0.5 :0;
			var tId=0;
			if (Render.isWebGL){
				tId=VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray==null)this._vectorgraphArray=[];
				this._vectorgraphArray.push(tId);
				var tIsConvexPolygon=false;
				if (points.length > 6){
					tIsConvexPolygon=false;
					}else {
					tIsConvexPolygon=true;
				}
			};
			var arr=[x+offset,y+offset,points,fillColor,lineColor,lineWidth,tId,tIsConvexPolygon];
			this._saveToCmd(Render._context._drawPoly,arr);
		}

		__proto._getPathPoints=function(paths){
			var i=0,len=0;
			var rst=Graphics._tempPoints;
			rst.length=0;
			len=paths.length;
			var tCMD;
			for (i=0;i < len;i++){
				tCMD=paths[i];
				if (tCMD.length > 1){
					rst.push(tCMD[1],tCMD[2]);
					if (tCMD.length > 3){
						rst.push(tCMD[3],tCMD[4]);
					}
				}
			}
			return rst;
		}

		/**
		*绘制路径。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param paths 路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y,x,y,x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]。
		*@param brush 刷子定义，支持以下设置{fillStyle}。
		*@param pen 画笔定义，支持以下设置{strokeStyle,lineWidth,lineJoin,lineCap,miterLimit}。
		*/
		__proto.drawPath=function(x,y,paths,brush,pen){
			var arr=[x+0.5,y+0.5,paths,brush,pen];
			this._saveToCmd(Render._context._drawPath,arr);
		}

		/**@private */
		/**
		*@private
		*命令流。
		*/
		__getset(0,__proto,'cmds',function(){
			return this._cmds;
			},function(value){
			this._sp && (this._sp._renderType |=0x100);
			this._cmds=value;
			this._render=this._renderAll;
			this._repaint();
		});

		Graphics.__init__=function(){
			if (Render.isConchNode){
				var from=laya.display.Graphics.prototype;
				var to=ConchGraphics.prototype;
				var list=["clear","destroy","alpha","rotate","transform","scale","translate","save","restore","clipRect","blendMode","fillText","fillBorderText","_fands","drawRect","drawCircle","drawPie","drawPoly","drawPath","drawImageM","drawLine","drawLines","_drawPs","drawCurves","replaceText","replaceTextColor","_fillImage","fillTexture"];
				for (var i=0,len=list.length;i <=len;i++){
					var temp=list[i];
					from[temp]=to[temp];
				}
				from._saveToCmd=null;
				from.drawTexture=function (tex,x,y,width,height,m){
					(x===void 0)&& (x=0);
					(y===void 0)&& (y=0);
					(width===void 0)&& (width=0);
					(height===void 0)&& (height=0);
					if (!(tex.loaded && tex.bitmap && tex.source)){
						return;
					}
					if (!width)width=tex.sourceWidth;
					if (!height)height=tex.sourceHeight;
					width=width-tex.sourceWidth+tex.width;
					height=height-tex.sourceHeight+tex.height;
					if (width <=0 || height <=0)return;
					x+=tex.offsetX;
					y+=tex.offsetY;
					var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
					this.drawImageM(tex.bitmap.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,x,y,width,height,m);
				}
				from.fillTexture=function (tex,x,y,width,height,type,offset){
					(width===void 0)&& (width=0);
					(height===void 0)&& (height=0);
					(type===void 0)&& (type="repeat");
					if (tex.loaded){
						var ctxi=Render._context.ctx;
						var w=tex.bitmap.width,h=tex.bitmap.height,uv=tex.uv;
						var pat;
						if (tex.uv !=Texture.DEF_UV){
							pat=ctxi.createPattern(tex.bitmap.source,type,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h);
							}else {
							pat=ctxi.createPattern(tex.bitmap.source,type);
						};
						var sX=0,sY=0;
						if (offset){
							x+=offset.x % tex.width;
							y+=offset.y % tex.height;
							sX-=offset.x % tex.width;
							sY-=offset.y % tex.height;
						}
						this._fillImage(pat,x,y,sX,sY,width,height);
					}
				}
			}
		}

		Graphics._addPointArrToRst=function(rst,points,matrix,dx,dy){
			(dx===void 0)&& (dx=0);
			(dy===void 0)&& (dy=0);
			var i=0,len=0;
			len=points.length;
			for (i=0;i < len;i+=2){
				Graphics._addPointToRst(rst,points[i]+dx,points[i+1]+dy,matrix);
			}
		}

		Graphics._addPointToRst=function(rst,x,y,matrix){
			var _tempPoint=Point.TEMP;
			_tempPoint.setTo(x ? x :0,y ? y :0);
			matrix.transformPoint(_tempPoint);
			rst.push(_tempPoint.x,_tempPoint.y);
		}

		Graphics._tempPoints=[];
		Graphics._tempMatrixArrays=[];
		Graphics._tempCmds=[];
		__static(Graphics,
		['_tempMatrix',function(){return this._tempMatrix=new Matrix();},'_initMatrix',function(){return this._initMatrix=new Matrix();}
		]);
		return Graphics;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.FrustumCullingObject
	var FrustumCullingObject=(function(){
		function FrustumCullingObject(){
			this._boundingSphere=null;
			this._component=null;
			this._mesh=null;
			this._layerMask=0;
			this._ownerEnable=false;
		}

		__class(FrustumCullingObject,'laya.d3.core.FrustumCullingObject');
		return FrustumCullingObject;
	})()


	/**
	*<code>Layer</code> 类用于实现遮罩层。
	*/
	//class laya.d3.core.Layer
	var Layer=(function(){
		function Layer(){
			this._id=0;
			this._number=0;
			this._mask=0;
			this._active=true;
			this._visible=true;
			this.name=null;
			this._id=Layer._uniqueIDCounter;
			Layer._uniqueIDCounter++;
			if (this._id > 1+31)
				throw new Error("不允许创建Layer，请参考函数getLayerByNumber、getLayerByMask、getLayerByName！");
		}

		__class(Layer,'laya.d3.core.Layer');
		var __proto=Layer.prototype;
		/**
		*获取编号。
		*@return 编号。
		*/
		__getset(0,__proto,'number',function(){
			return this._number;
		});

		/**
		*获取蒙版值。
		*@return 蒙版值。
		*/
		__getset(0,__proto,'mask',function(){
			return this._mask;
		});

		/**
		*设置是否激活。
		*@param value 是否激活。
		*/
		/**
		*获取是否激活。
		*@return 是否激活。
		*/
		__getset(0,__proto,'active',function(){
			return this._active;
			},function(value){
			if (this._number===29 || this._number==30)
				return;
			this._active=value;
			if (value)
				Layer._activeLayers=Layer._activeLayers | this.mask;
			else
			Layer._activeLayers=Layer._activeLayers & ~this.mask;
		});

		/**
		*设置是否显示。
		*@param value 是否显示。
		*/
		/**
		*获取是否显示。
		*@return 是否显示。
		*/
		__getset(0,__proto,'visible',function(){
			return this._visible;
			},function(value){
			if (this._number===29 || this._number==30)
				return;
			this._visible=value;
			if (value)
				Layer._visibleLayers=Layer._visibleLayers | this.mask;
			else
			Layer._visibleLayers=Layer._visibleLayers & ~this.mask;
		});

		/**
		*设置Layer激活层。
		*@param value 激活层。
		*/
		/**
		*获取Layer激活层。
		*@return 激活层。
		*/
		__getset(1,Layer,'activeLayers',function(){
			return Layer._activeLayers;
			},function(value){
			Layer._activeLayers=value | Layer.getLayerByNumber(29).mask | Layer.getLayerByNumber(30).mask;
			for (var i=0;i < Layer._layerList.length;i++){
				var layer=Layer._layerList[i];
				layer._active=(layer._mask & Layer._activeLayers)!==0;
			}
		});

		/**
		*设置Layer显示层。
		*@param value 显示层。
		*/
		/**
		*获取Layer显示层。
		*@return 显示层。
		*/
		__getset(1,Layer,'visibleLayers',function(){
			return Layer._visibleLayers;
			},function(value){
			Layer._visibleLayers=value | Layer.getLayerByNumber(29).mask | Layer.getLayerByNumber(30).mask;
			for (var i=0;i < Layer._layerList.length;i++){
				var layer=Layer._layerList[i];
				layer._visible=(layer._mask & Layer._visibleLayers)!==0;
			}
		});

		Layer.__init__=function(){
			Layer._layerList.length=31;
			for (var i=0;i < 31;i++){
				var layer=new Layer();
				Layer._layerList[i]=layer;
				if (i===0)
					layer.name="Default Layer";
				else if (i===29)
				layer.name="Reserved Layer0";
				else if (i===30)
				layer.name="Reserved Layer1";
				else
				layer.name="Layer-"+i;
				layer._number=i;
				layer._mask=Math.pow(2,i);
			}
			Layer._activeLayers=2147483647;
			Layer._visibleLayers=2147483647;
			Layer._currentCameraCullingMask=2147483647;
			Layer.currentCreationLayer=Layer._layerList[0];
		}

		Layer.getLayerByNumber=function(number){
			if (number < 0 || number > 30)
				throw new Error("无法返回指定Layer，该number超出范围！");
			return Layer._layerList[number];
		}

		Layer.getLayerByMask=function(mask){
			for (var i=0;i < 31;i++){
				if (Layer._layerList[i].mask===mask)
					return Layer._layerList[i];
			}
			throw new Error("无法返回指定Layer,该mask不存在");
		}

		Layer.getLayerByName=function(name){
			for (var i=0;i < 31;i++){
				if (Layer._layerList[i].name===name)
					return Layer._layerList[i];
			}
			throw new Error("无法返回指定Layer,该name不存在");
		}

		Layer.isActive=function(mask){
			return (mask & Layer._activeLayers)!=0;
		}

		Layer.isVisible=function(mask){
			return (mask & Layer._currentCameraCullingMask & Layer._visibleLayers)!=0;
		}

		Layer._uniqueIDCounter=1;
		Layer._layerCount=31;
		Layer._layerList=[];
		Layer._activeLayers=0;
		Layer._visibleLayers=0;
		Layer._currentCameraCullingMask=0;
		Layer.currentCreationLayer=null
		return Layer;
	})()


	/**
	*<code>RenderClip</code> 类用于实现渲染裁剪。
	*/
	//class laya.d3.core.render.RenderClip
	var RenderClip=(function(){
		/**
		*创建一个 <code>RenderClip</code> 实例。
		*/
		function RenderClip(){}
		__class(RenderClip,'laya.d3.core.render.RenderClip');
		var __proto=RenderClip.prototype;
		/**
		*处理3D物理是否可见。
		*@param o 3D精灵。
		*/
		__proto.view=function(o){
			return true;
		}

		return RenderClip;
	})()


	/**
	*<code>RenderConfig</code> 类用于实现渲染配置。
	*/
	//class laya.d3.core.render.RenderConfig
	var RenderConfig=(function(){
		function RenderConfig(){
			this.depthTest=true;
			this.depthMask=1;
			this.blend=false;
			this.cullFace=true;
			this.sFactor=1;
			this.dFactor=0;
			this.frontFace=0x0900;
		}

		__class(RenderConfig,'laya.d3.core.render.RenderConfig');
		return RenderConfig;
	})()


	/**
	*<code>RenderObject</code> 类用于实现渲染物体。
	*/
	//class laya.d3.core.render.RenderObject
	var RenderObject=(function(){
		function RenderObject(){
			this.renderQneue=null;
			this.type=0;
			this.owner=null;
			this.renderElement=null;
			this.material=null;
			this.tag=null;
			this.mainSortID=0;
			this.triangleCount=0;
		}

		__class(RenderObject,'laya.d3.core.render.RenderObject');
		return RenderObject;
	})()


	/**
	*<code>RenderQuene</code> 类用于实现渲染队列。
	*/
	//class laya.d3.core.render.RenderQueue
	var RenderQueue=(function(){
		function RenderQueue(renderConfig){
			this._id=0;
			this._changed=false;
			this._needSort=false;
			this._renderObjects=null;
			this._staticRenderObjects=null;
			this._staticLength=0;
			this._mergeRenderObjects=null;
			this._merageLength=0;
			this._renderConfig=null;
			this._staticBatchManager=null;
			this._id=++RenderQueue._uniqueIDCounter;
			this._changed=false;
			this._needSort=false;
			this._renderConfig=renderConfig;
			this._renderObjects=[];
			this._staticRenderObjects=[];
			this._staticLength=0;
			this._mergeRenderObjects=[];
			this._merageLength=0;
			this._staticBatchManager=new StaticBatchManager();
		}

		__class(RenderQueue,'laya.d3.core.render.RenderQueue');
		var __proto=RenderQueue.prototype;
		__proto._getStaticRenderObj=function(){
			var o=this._staticRenderObjects[this._staticLength++];
			return o || (this._staticRenderObjects[this._staticLength-1]=new RenderObject());
		}

		/**
		*重置并清空队列。
		*/
		__proto._reset=function(){
			this._staticLength=0;
			this._merageLength=0;
			this._staticBatchManager._reset();
		}

		/**
		*@private
		*更新组件preRenderUpdate函数
		*@param state 渲染相关状态
		*/
		__proto._preRenderUpdateComponents=function(sprite3D,state){
			for (var i=0;i < sprite3D.componentsCount;i++){
				var component=sprite3D.getComponentByIndex(i);
				(!component.started)&& (component._start(state),component.started=true);
				(component.isActive)&& (component._preRenderUpdate(state));
			}
		}

		/**
		*@private
		*更新组件postRenderUpdate函数
		*@param state 渲染相关状态
		*/
		__proto._postRenderUpdateComponents=function(sprite3D,state){
			for (var i=0;i < sprite3D.componentsCount;i++){
				var component=sprite3D.getComponentByIndex(i);
				(!component.started)&& (component._start(state),component.started=true);
				(component.isActive)&& (component._postRenderUpdate(state));
			}
		}

		/**
		*@private
		*应用渲染状态到显卡。
		*@param gl WebGL上下文。
		*/
		__proto._setState=function(gl){
			WebGLContext.setDepthTest(gl,this._renderConfig.depthTest);
			WebGLContext.setDepthMask(gl,this._renderConfig.depthMask);
			WebGLContext.setBlend(gl,this._renderConfig.blend);
			WebGLContext.setBlendFunc(gl,this._renderConfig.sFactor,this._renderConfig.dFactor);
			WebGLContext.setCullFace(gl,this._renderConfig.cullFace);
			WebGLContext.setFrontFaceCCW(gl,this._renderConfig.frontFace);
		}

		/**
		*@private
		*准备渲染队列。
		*@param state 渲染状态。
		*/
		__proto._preRender=function(state){
			if (this._changed){
				this._changed=false;
				this._reset();
				this._needSort && (this._renderObjects.sort(RenderQueue._sort));
				var lastIsStatic=false;
				var lastMaterial;
				var lastVertexDeclaration;
				var lastCanMerage=false;
				var curStaticBatch;
				var currentRenderObjIndex=0;
				var renderObj;
				var renderElement;
				var isStatic=false;
				var lastRenderObj;
				var batchObject;
				var vb;
				for (var i=0,n=this._renderObjects.length;i < n;i++){
					renderObj=this._renderObjects[i];
					renderElement=renderObj.renderElement;
					isStatic=renderObj.owner.isStatic;
					vb=renderElement.getVertexBuffer(0);
					if ((lastMaterial===renderObj.material)&& (lastVertexDeclaration===vb.vertexDeclaration)&& lastIsStatic && isStatic && (renderElement.VertexBufferCount===1)&& renderObj.owner.visible){
						if (!lastCanMerage){
							curStaticBatch=this._staticBatchManager.getStaticBatchQneue(lastVertexDeclaration,lastMaterial);
							lastRenderObj=this._renderObjects[i-1];
							if (!curStaticBatch.addRenderObj(lastRenderObj)|| !curStaticBatch.addRenderObj(renderObj)){
								this._mergeRenderObjects[this._merageLength++]=this._renderObjects[currentRenderObjIndex];
								lastCanMerage=false;
								}else {
								batchObject=this._getStaticRenderObj();
								batchObject.renderElement=curStaticBatch;
								batchObject.type=1;
								this._mergeRenderObjects[this._merageLength-1]=batchObject;
								lastCanMerage=true;
							}
							}else {
							if (!curStaticBatch.addRenderObj(renderObj)){
								this._mergeRenderObjects[this._merageLength++]=this._renderObjects[currentRenderObjIndex];
								lastCanMerage=false;
							}
						}
						}else {
						this._mergeRenderObjects[this._merageLength++]=this._renderObjects[currentRenderObjIndex];
						lastCanMerage=false;
					}
					currentRenderObjIndex++;
					lastIsStatic=isStatic;
					lastMaterial=renderObj.material;
					lastVertexDeclaration=vb.vertexDeclaration;
				}
				this._staticBatchManager._garbageCollection();
				this._staticBatchManager._finsh();
			}
		}

		/**
		*@private
		*渲染队列。
		*@param state 渲染状态。
		*/
		__proto._render=function(state){
			var preShaderValue=state.shaderValue.length;
			var renObj;
			for (var i=0,n=this._merageLength;i < n;i++){
				renObj=this._mergeRenderObjects[i];
				var preShadeDef=0;
				if (renObj.type===0){
					var owner=renObj.owner;
					state.owner=owner;
					state.renderObj=renObj;
					preShadeDef=state.shaderDefs.getValue();
					this._preRenderUpdateComponents(owner,state);
					(owner.visible)&& (renObj.renderElement._render(state));
					this._postRenderUpdateComponents(owner,state);
					state.shaderDefs.setValue(preShadeDef);
					}else if (renObj.type===1){
					state.owner=null;
					state.renderObj=renObj;
					preShadeDef=state.shaderDefs.getValue();
					(renObj.renderElement._render(state));
					state.shaderDefs.setValue(preShadeDef);
				}
				state.shaderValue.length=preShaderValue;
			}
		}

		/**
		*获取队列中的渲染物体。
		*@return gl 渲染物体。
		*/
		__proto.getRenderObj=function(){
			this._changed=true;
			this._needSort=true;
			var o=new RenderObject();
			this._renderObjects.push(o);
			o.renderQneue=this;
			return o;
		}

		/**
		*删除渲染物体。
		*@param renderObj 渲染物体。
		*/
		__proto.deleteRenderObj=function(renderObj){
			this._changed=true;
			var index=this._renderObjects.indexOf(renderObj);
			if (index!==-1){
				this._renderObjects.splice(index,1);
				renderObj.renderQneue=null;
			}
		}

		/**
		*获取唯一标识ID(通常用于优化或识别)。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		RenderQueue._sort=function(a,b){
			var id=a.mainSortID-b.mainSortID;
			return (a.owner.isStatic && b.owner.isStatic && id===0)? a.triangleCount-b.triangleCount :id;
		}

		RenderQueue._uniqueIDCounter=0;
		RenderQueue.NONEWRITEDEPTH=0;
		RenderQueue.OPAQUE=1;
		RenderQueue.OPAQUE_DOUBLEFACE=2;
		RenderQueue.ALPHA_BLEND=3;
		RenderQueue.ALPHA_BLEND_DOUBLEFACE=4;
		RenderQueue.ALPHA_ADDTIVE_BLEND=5;
		RenderQueue.ALPHA_ADDTIVE_BLEND_DOUBLEFACE=6;
		RenderQueue.DEPTHREAD_ALPHA_BLEND=7;
		RenderQueue.DEPTHREAD_ALPHA_BLEND_DOUBLEFACE=8;
		RenderQueue.DEPTHREAD_ALPHA_ADDTIVE_BLEND=9;
		RenderQueue.DEPTHREAD_ALPHA_ADDTIVE_BLEND_DOUBLEFACE=10;
		return RenderQueue;
	})()


	/**
	*<code>RenderState</code> 类用于实现渲染状态。
	*/
	//class laya.d3.core.render.RenderState
	var RenderState=(function(){
		function RenderState(){
			this._shadingMode=0;
			this.elapsedTime=NaN;
			this.loopCount=0;
			this.context=null;
			this.scene=null;
			this.owner=null;
			this.renderObj=null;
			this.camera=null;
			this.viewMatrix=null;
			this.projectionMatrix=null;
			this.projectionViewMatrix=null;
			this.cameraBoundingFrustum=null;
			this.viewport=null;
			this.worldShaderValue=new ValusArray;
			this.shaderValue=new ValusArray;
			this.shaderDefs=new ShaderDefines3D();
			this.renderClip=new RenderClip();
			this.reset();
		}

		__class(RenderState,'laya.d3.core.render.RenderState');
		var __proto=RenderState.prototype;
		/**
		*重置。
		*/
		__proto.reset=function(){
			this.worldShaderValue.length=0;
			this.shaderValue.length=0;
			this.shaderDefs.setValue(0);
			(WebGL.frameShaderHighPrecision)&& (this.shaderDefs.setValue(0x100000));
		}

		/**
		*设置着色模式。
		*@param value 着色模式
		*/
		/**
		*获取着色模式。
		*@return 着色模式
		*/
		__getset(0,__proto,'shadingMode',function(){
			return this._shadingMode;
			},function(value){
			this.shaderDefs.remove(value==0x04 ? 0x08 :0x04);
			this.shaderDefs.add(value);
			this._shadingMode=value;
		});

		RenderState.VERTEXSHADERING=0x04;
		RenderState.PIXELSHADERING=0x08;
		RenderState.clientWidth=0;
		RenderState.clientHeight=0;
		return RenderState;
	})()


	/**
	*@private
	*<code>StaticBatch</code> 类用于创建静态批处理。
	*/
	//class laya.d3.graphics.StaticBatch
	var StaticBatch=(function(){
		function StaticBatch(vertexDeclaration,material){
			this._currentVertexCount=0;
			this._currentIndexCount=0;
			this._elementCount=0;
			this._vertexDeclaration=null;
			this._material=null;
			this._vertexDatas=null;
			this._indexDatas=null;
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._lastRenderObjects=null;
			this._renderObjects=null;
			this._renderOwners=null;
			this._needReMerage=false;
			this._elementCount=0;
			this._vertexDeclaration=vertexDeclaration;
			this._material=material;
			this._lastRenderObjects=[];
			this._renderObjects=[];
			this._renderOwners=[];
			this._needReMerage=false;
		}

		__class(StaticBatch,'laya.d3.graphics.StaticBatch');
		var __proto=StaticBatch.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
		__proto.getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vertexBuffer;
			else
			return null;
		}

		__proto.getIndexBuffer=function(){
			return this._indexBuffer;
		}

		__proto.getBakedVertexs=function(index,transform){
			return null;
		}

		__proto.getBakedIndices=function(){
			return null;
		}

		__proto._reset=function(){
			this._renderObjects.length=0;
			this._renderOwners.length=0;
			this._currentIndexCount=0;
			this._currentVertexCount=0;
		}

		__proto._finsh=function(){
			if (!this._needReMerage && this._lastRenderObjects.length !=this._renderObjects.length){
				this._needReMerage=true;
			}
			if (this._needReMerage){
				this._needReMerage=false;
				var curMerVerCount=0;
				var curMerIndCount=0;
				this._elementCount=0;
				this._vertexDatas=new Float32Array(this._vertexDeclaration.vertexStride / 4 *this._currentVertexCount);
				this._indexDatas=new Uint16Array(this._currentIndexCount);
				if (!this._vertexBuffer){
					this._vertexBuffer=VertexBuffer3D.create(this._vertexDeclaration,this._currentVertexCount,0x88E8);
					this._indexBuffer=IndexBuffer3D.create("ushort",this._currentIndexCount,0x88E8);
					}else {
					this._vertexBuffer.dispose();
					this._indexBuffer.dispose();
					this._vertexBuffer=VertexBuffer3D.create(this._vertexDeclaration,this._currentVertexCount,0x88E8);
					this._indexBuffer=IndexBuffer3D.create("ushort",this._currentIndexCount,0x88E8);
				}
				for (var i=0;i < this._renderObjects.length;i++){
					var renderObj=this._renderObjects[i];
					var subVertexDatas=renderObj.getBakedVertexs(0,this._renderOwners[i].transform.worldMatrix);
					var subIndexDatas=renderObj.getBakedIndices();
					var indexOffset=curMerVerCount / (this._vertexDeclaration.vertexStride / 4);
					var indexStart=curMerIndCount;
					var indexEnd=indexStart+subIndexDatas.length;
					this._indexDatas.set(subIndexDatas,curMerIndCount);
					for (var k=indexStart;k < indexEnd;k++)
					this._indexDatas[k]=indexOffset+this._indexDatas[k];
					curMerIndCount+=subIndexDatas.length;
					this._vertexDatas.set(subVertexDatas,curMerVerCount);
					curMerVerCount+=subVertexDatas.length;
					this._elementCount+=subIndexDatas.length;
				}
				this._vertexBuffer.setData(this._vertexDatas);
				this._indexBuffer.setData(this._indexDatas);
			}
			this._lastRenderObjects=this._renderObjects.slice();
		}

		__proto._getShader=function(state,vertexBuffer,material){
			if (!material)
				return null;
			var def=0;
			var shaderAttribute=vertexBuffer.vertexDeclaration.shaderAttribute;
			(shaderAttribute.UV)&& (def |=material.shaderDef);
			(shaderAttribute.COLOR)&& (def |=0x20);
			(state.scene.enableFog)&& (def |=0x20000);
			def > 0 && state.shaderDefs.addInt(def);
			var shader=material.getShader(state);
			return shader;
		}

		__proto.addRenderObj=function(renderObj){
			var renderElement=renderObj.renderElement;
			var indexbuffer=renderElement.getIndexBuffer();
			var indexCount=this._currentIndexCount+indexbuffer.byteLength / indexbuffer.indexTypeByteCount;
			var vertexCount=this._currentVertexCount+renderElement.getVertexBuffer().byteLength / this._vertexDeclaration.vertexStride;
			if (vertexCount > StaticBatch.maxVertexCount || indexCount > StaticBatch.maxIndexCount)
				return false;
			this._renderObjects.push(renderElement);
			this._renderOwners.push(renderObj.owner);
			if (!this._needReMerage && this._lastRenderObjects.indexOf(renderElement)===-1)
				this._needReMerage=true;
			this._currentIndexCount=indexCount;
			this._currentVertexCount=vertexCount;
			return true;
		}

		__proto._render=function(state){
			var vb=this._vertexBuffer;
			var ib=this._indexBuffer;
			var material=this._material;
			if (material.normalTexture && !vb.vertexDeclaration.shaderAttribute["TANGENT0"]){
				var vertexDatas=vb.getData();
				var newVertexDatas=Utils3D.generateTangent(vertexDatas,vb.vertexDeclaration.vertexStride / 4,vb.vertexDeclaration.shaderAttribute["POSITION"][4] / 4,vb.vertexDeclaration.shaderAttribute["UV"][4] / 4,ib.getData());
				var vertexDeclaration=Utils3D.getVertexTangentDeclaration(vb.vertexDeclaration.getVertexElements());
				var newVB=VertexBuffer3D.create(vertexDeclaration,0x88E4);
				newVB.setData(newVertexDatas);
				vb.dispose();
				this._vertexBuffer=vb=newVB;
			}
			vb._bind();
			ib._bind();
			if (material){
				var shader=this._getShader(state,vb,material);
				var presz=state.shaderValue.length;
				state.shaderValue.pushArray(vb.vertexDeclaration.shaderValues);
				state.shaderValue.pushValue("MATRIX1",Matrix4x4.DEFAULT.elements,-1);
				state.shaderValue.pushValue("MVPMATRIX",state.projectionViewMatrix.elements,-1);
				if (!material.upload(state,null,shader)){
					state.shaderValue.length=presz;
					return false;
				}
				state.shaderValue.length=presz;
			}
			state.context.drawElements(0x0004,this._elementCount,0x1403,0);
			Stat.drawCall++;
			Stat.trianglesFaces+=this._elementCount / 3;
			return true;
		}

		__getset(0,__proto,'VertexBufferCount',function(){
			return 1;
		});

		__getset(0,__proto,'indexOfHost',function(){
			return 0;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._indexBuffer.indexCount/3;
		});

		__getset(0,__proto,'currentVertexCount',function(){
			return this._currentVertexCount;
		});

		__getset(0,__proto,'currentIndexCount',function(){
			return this._currentIndexCount;
		});

		StaticBatch.maxVertexCount=65535;
		StaticBatch.maxIndexCount=120000;
		return StaticBatch;
	})()


	/**
	*@private
	*<code>StaticBatchManager</code> 类用于创建静态批处理管理员。
	*/
	//class laya.d3.graphics.StaticBatchManager
	var StaticBatchManager=(function(){
		function StaticBatchManager(){
			this._keys=null;
			this._useFPS=null;
			this._staticBatchs=null;
			this._keys=[];
			this._useFPS=[];
			this._staticBatchs=[];
		}

		__class(StaticBatchManager,'laya.d3.graphics.StaticBatchManager');
		var __proto=StaticBatchManager.prototype;
		__proto.getStaticBatchQneue=function(_vertexDeclaration,material){
			var staticBatch;
			var key=material.id *1000+_vertexDeclaration.id;
			if (this._keys.indexOf(key)===-1){
				this._keys.push(key);
				this._useFPS.push(Stat.loopCount);
				staticBatch=new StaticBatch(_vertexDeclaration,material);
				this._staticBatchs.push(staticBatch);
				}else {
				var index=this._keys.indexOf(key);
				this._useFPS[index]=Stat.loopCount;
				staticBatch=this._staticBatchs[index];
			}
			return staticBatch;
		}

		/**@private 通常应在所有getStaticBatchQneue函数相关操作结束后执行,不必逐帧执行。*/
		__proto._garbageCollection=function(){
			for (var i=0;i < this._keys.length;i++){
				if (this._useFPS[i] < Stat.loopCount){
					this._keys.splice(i,1);
					this._useFPS.splice(i,1);
					this._staticBatchs.splice(i,1);
					i--;
				}
			}
		}

		/**重置*/
		__proto._reset=function(){
			for (var i=0;i < this._keys.length;i++){
				this._staticBatchs[i]._reset();
			}
		}

		/**刷新*/
		__proto._finsh=function(){
			for (var i=0;i < this._keys.length;i++){
				this._staticBatchs[i]._finsh();
			}
		}

		__proto.dispose=function(){
			this._keys.length=0;
			this._useFPS.length=0;
			this._staticBatchs.length=0;
		}

		StaticBatchManager.maxVertexDeclaration=1000;
		__static(StaticBatchManager,
		['maxMaterialCount',function(){return this.maxMaterialCount=Math.floor(2147483647 / 1000);}
		]);
		return StaticBatchManager;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.graphics.VertexDeclaration
	var VertexDeclaration=(function(){
		function VertexDeclaration(vertexStride,vertexElements){
			this._id=0;
			this._shaderValues=null;
			this._shaderAttribute=null;
			this._vertexStride=0;
			this._vertexElements=null;
			this._id=++VertexDeclaration._uniqueIDCounter;
			if (this._id > VertexDeclaration.maxVertexDeclaration)
				throw new Error("VertexDeclaration: VertexDeclaration count should not large than ",VertexDeclaration.maxVertexDeclaration);
			this._shaderAttribute={};
			this._shaderValues=new ValusArray();
			this._vertexStride=vertexStride;
			this._vertexElements=vertexElements;
			for (var i=0;i < vertexElements.length;i++){
				var vertexElement=vertexElements[i];
				var attributeName=vertexElement.elementUsage;
				var value=[VertexDeclaration._getTypeSize(vertexElement.elementFormat)/ 4,0x1406,false,this._vertexStride,vertexElement.offset];
				this._shaderValues.pushValue(attributeName,value,-1);
				this._shaderAttribute[attributeName]=value;
			}
		}

		__class(VertexDeclaration,'laya.d3.graphics.VertexDeclaration');
		var __proto=VertexDeclaration.prototype;
		//临时
		__proto.getVertexElements=function(){
			return this._vertexElements.slice();
		}

		__proto.unBinding=function(){}
		/**
		*获取唯一标识ID(通常用于优化或识别)。
		*@return 唯一标识ID
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		__getset(0,__proto,'shaderAttribute',function(){
			return this._shaderAttribute;
		});

		__getset(0,__proto,'shaderValues',function(){
			return this._shaderValues;
		});

		__getset(0,__proto,'vertexStride',function(){
			return this._vertexStride;
		});

		VertexDeclaration._getTypeSize=function(format){
			switch (format){
				case "single":
					return 4;
				case "vector2":
					return 8;
				case "vector3":
					return 12;
				case "vector4":
					return 16;
				case "volor":
					return 4;
				case "byte4":
					return 4;
				case "short2":
					return 4;
				case "short4":
					return 8;
				case "normalizedshort2":
					return 4;
				case "normalizedshort4":
					return 8;
				case "halfvector2":
					return 4;
				case "halfvector4":
					return 8;
				}
			return 0;
		}

		VertexDeclaration.getVertexStride=function(vertexElements){
			var curStride=0;
			for (var i=0;i < vertexElements.Length;i++){
				var element=vertexElements[i];
				var stride=element.offset+VertexDeclaration._getTypeSize(element.elementFormat);
				if (curStride < stride){
					curStride=stride;
				}
			}
			return curStride;
		}

		VertexDeclaration._maxVertexDeclarationBit=1000;
		VertexDeclaration._uniqueIDCounter=1;
		__static(VertexDeclaration,
		['maxVertexDeclaration',function(){return this.maxVertexDeclaration=2147483647-Math.floor(2147483647 / 1000)*1000;}
		]);
		return VertexDeclaration;
	})()


	/**
	*<code>VertexElement</code> 类用于创建顶点结构分配。
	*/
	//class laya.d3.graphics.VertexElement
	var VertexElement=(function(){
		function VertexElement(offset,elementFormat,elementUsage){
			this.offset=0;
			this.elementFormat=null;
			this.elementUsage=null;
			this.offset=offset;
			this.elementFormat=elementFormat;
			this.elementUsage=elementUsage;
		}

		__class(VertexElement,'laya.d3.graphics.VertexElement');
		return VertexElement;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.graphics.VertexElementFormat
	var VertexElementFormat=(function(){
		function VertexElementFormat(){};
		__class(VertexElementFormat,'laya.d3.graphics.VertexElementFormat');
		VertexElementFormat.Single="single";
		VertexElementFormat.Vector2="vector2";
		VertexElementFormat.Vector3="vector3";
		VertexElementFormat.Vector4="vector4";
		VertexElementFormat.Color="volor";
		VertexElementFormat.Byte4="byte4";
		VertexElementFormat.Short2="short2";
		VertexElementFormat.Short4="short4";
		VertexElementFormat.NormalizedShort2="normalizedshort2";
		VertexElementFormat.NormalizedShort4="normalizedshort4";
		VertexElementFormat.HalfVector2="halfvector2";
		VertexElementFormat.HalfVector4="halfvector4";
		return VertexElementFormat;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.graphics.VertexElementUsage
	var VertexElementUsage=(function(){
		function VertexElementUsage(){};
		__class(VertexElementUsage,'laya.d3.graphics.VertexElementUsage');
		VertexElementUsage.POSITION0="POSITION";
		VertexElementUsage.COLOR0="COLOR";
		VertexElementUsage.TEXTURECOORDINATE0="UV";
		VertexElementUsage.NORMAL0="NORMAL";
		VertexElementUsage.BINORMAL0="BINORMAL";
		VertexElementUsage.TANGENT0="TANGENT0";
		VertexElementUsage.BLENDINDICES0="BLENDINDICES";
		VertexElementUsage.BLENDWEIGHT0="BLENDWEIGHT";
		VertexElementUsage.DEPTH0="DEPTH";
		VertexElementUsage.FOG0="FOG";
		VertexElementUsage.POINTSIZE0="POINTSIZE";
		VertexElementUsage.SAMPLE0="SAMPLE";
		VertexElementUsage.TESSELLATEFACTOR0="TESSELLATEFACTOR";
		VertexElementUsage.COLOR1="COLOR1";
		VertexElementUsage.NEXTTEXTURECOORDINATE0="NEXTUV";
		VertexElementUsage.TEXTURECOORDINATE1="UV1";
		VertexElementUsage.NEXTTEXTURECOORDINATE1="NEXTUV1";
		VertexElementUsage.CORNERTEXTURECOORDINATE0="CORNERTEXTURECOORDINATE";
		VertexElementUsage.VELOCITY0="VELOCITY";
		VertexElementUsage.STARTCOLOR0="STARTCOLOR";
		VertexElementUsage.ENDCOLOR0="ENDCOLOR";
		VertexElementUsage.SIZEROTATION0="SIZEROTATION";
		VertexElementUsage.RADIUS0="RADIUS";
		VertexElementUsage.RADIAN0="RADIAN";
		VertexElementUsage.AGEADDSCALE0="AGEADDSCALE";
		VertexElementUsage.TIME0="TIME";
		return VertexElementUsage;
	})()


	/**
	*<code>VertexPositionNormalColor</code> 类用于创建位置、法线、颜色顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColor
	var VertexPositionNormalColor=(function(){
		function VertexPositionNormalColor(position,normal,color){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
		}

		__class(VertexPositionNormalColor,'laya.d3.graphics.VertexPositionNormalColor');
		var __proto=VertexPositionNormalColor.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColor._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColor,'vertexDeclaration',function(){
			return VertexPositionNormalColor._vertexDeclaration;
		});

		__static(VertexPositionNormalColor,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR")]);}
		]);
		return VertexPositionNormalColor;
	})()


	/**
	*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorSkin
	var VertexPositionNormalColorSkin=(function(){
		function VertexPositionNormalColorSkin(position,normal,color,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorSkin,'laya.d3.graphics.VertexPositionNormalColorSkin');
		var __proto=VertexPositionNormalColorSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorSkin,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkin._vertexDeclaration;
		});

		__static(VertexPositionNormalColorSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR"),
			new VertexElement(40,"vector4","BLENDWEIGHT"),
			new VertexElement(56,"vector4","BLENDINDICES")]);}
		]);
		return VertexPositionNormalColorSkin;
	})()


	/**
	*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorSkinTangent
	var VertexPositionNormalColorSkinTangent=(function(){
		function VertexPositionNormalColorSkinTangent(position,normal,color,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorSkinTangent,'laya.d3.graphics.VertexPositionNormalColorSkinTangent');
		var __proto=VertexPositionNormalColorSkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkinTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorSkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorSkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(84,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR"),
			new VertexElement(40,"vector4","BLENDWEIGHT"),
			new VertexElement(56,"vector4","BLENDINDICES"),
			new VertexElement(72,"vector3","TANGENT0")]);}
		]);
		return VertexPositionNormalColorSkinTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTangent</code> 类用于创建位置、法线、颜色、切线顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTangent
	var VertexPositionNormalColorTangent=(function(){
		function VertexPositionNormalColorTangent(position,normal,color,tangent){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalColorTangent,'laya.d3.graphics.VertexPositionNormalColorTangent');
		var __proto=VertexPositionNormalColorTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(52,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR"),
			new VertexElement(40,"vector3","TANGENT0")]);}
		]);
		return VertexPositionNormalColorTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTexture</code> 类用于创建位置、法线、颜色、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTexture
	var VertexPositionNormalColorTexture=(function(){
		function VertexPositionNormalColorTexture(position,normal,color,textureCoordinate){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
		}

		__class(VertexPositionNormalColorTexture,'laya.d3.graphics.VertexPositionNormalColorTexture');
		var __proto=VertexPositionNormalColorTexture.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTexture,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(48,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR"),
			new VertexElement(40,"vector2","UV")]);}
		]);
		return VertexPositionNormalColorTexture;
	})()


	/**
	*<code>VertexPositionNormalColorTexture</code> 类用于创建位置、法线、颜色、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1
	var VertexPositionNormalColorTexture0Texture1=(function(){
		function VertexPositionNormalColorTexture0Texture1(position,normal,color,textureCoordinate0,textureCoordinate1){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
		}

		__class(VertexPositionNormalColorTexture0Texture1,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1');
		var __proto=VertexPositionNormalColorTexture0Texture1.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR"),
			new VertexElement(40,"vector2","UV"),
			new VertexElement(48,"vector2","UV1")]);}
		]);
		return VertexPositionNormalColorTexture0Texture1;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Skin
	var VertexPositionNormalColorTexture0Texture1Skin=(function(){
		function VertexPositionNormalColorTexture0Texture1Skin(position,normal,color,textureCoordinate0,textureCoordinate1,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTexture0Texture1Skin,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Skin');
		var __proto=VertexPositionNormalColorTexture0Texture1Skin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Skin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1Skin,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Skin._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1Skin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR"),
			new VertexElement(40,"vector2","UV"),
			new VertexElement(48,"vector2","UV1"),
			new VertexElement(56,"vector4","BLENDWEIGHT"),
			new VertexElement(72,"vector4","BLENDINDICES")]);}
		]);
		return VertexPositionNormalColorTexture0Texture1Skin;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTextureSkin
	var VertexPositionNormalColorTextureSkin=(function(){
		function VertexPositionNormalColorTextureSkin(position,normal,color,textureCoordinate,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTextureSkin,'laya.d3.graphics.VertexPositionNormalColorTextureSkin');
		var __proto=VertexPositionNormalColorTextureSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureSkin,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkin._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(80,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR"),
			new VertexElement(40,"vector2","UV"),
			new VertexElement(48,"vector4","BLENDWEIGHT"),
			new VertexElement(64,"vector4","BLENDINDICES")]);}
		]);
		return VertexPositionNormalColorTextureSkin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTextureSkinTangent
	var VertexPositionNormalColorTextureSkinTangent=(function(){
		function VertexPositionNormalColorTextureSkinTangent(position,normal,color,textureCoordinate,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTextureSkinTangent,'laya.d3.graphics.VertexPositionNormalColorTextureSkinTangent');
		var __proto=VertexPositionNormalColorTextureSkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkinTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureSkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureSkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(92,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR"),
			new VertexElement(40,"vector2","UV"),
			new VertexElement(48,"vector4","BLENDWEIGHT"),
			new VertexElement(64,"vector4","BLENDINDICES"),
			new VertexElement(80,"vector3","TANGENT0")]);}
		]);
		return VertexPositionNormalColorTextureSkinTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTextureTangent
	var VertexPositionNormalColorTextureTangent=(function(){
		function VertexPositionNormalColorTextureTangent(position,normal,color,textureCoordinate,tangent){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalColorTextureTangent,'laya.d3.graphics.VertexPositionNormalColorTextureTangent');
		var __proto=VertexPositionNormalColorTextureTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(60,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector4","COLOR"),
			new VertexElement(40,"vector2","UV"),
			new VertexElement(48,"vector3","TANGENT0")]);}
		]);
		return VertexPositionNormalColorTextureTangent;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTexture
	var VertexPositionNormalTexture=(function(){
		function VertexPositionNormalTexture(position,normal,textureCoordinate){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
		}

		__class(VertexPositionNormalTexture,'laya.d3.graphics.VertexPositionNormalTexture');
		var __proto=VertexPositionNormalTexture.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTexture,'vertexDeclaration',function(){
			return VertexPositionNormalTexture._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(32,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector2","UV")]);}
		]);
		return VertexPositionNormalTexture;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTexture0Texture1
	var VertexPositionNormalTexture0Texture1=(function(){
		function VertexPositionNormalTexture0Texture1(position,normal,textureCoordinate0,textureCoordinate1){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
		}

		__class(VertexPositionNormalTexture0Texture1,'laya.d3.graphics.VertexPositionNormalTexture0Texture1');
		var __proto=VertexPositionNormalTexture0Texture1.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTexture0Texture1,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector2","UV"),
			new VertexElement(32,"vector2","UV1")]);}
		]);
		return VertexPositionNormalTexture0Texture1;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTexture0Texture1Skin
	var VertexPositionNormalTexture0Texture1Skin=(function(){
		function VertexPositionNormalTexture0Texture1Skin(position,normal,textureCoordinate0,textureCoordinate1,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTexture0Texture1Skin,'laya.d3.graphics.VertexPositionNormalTexture0Texture1Skin');
		var __proto=VertexPositionNormalTexture0Texture1Skin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Skin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTexture0Texture1Skin,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Skin._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1Skin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector2","UV"),
			new VertexElement(32,"vector2","UV1"),
			new VertexElement(40,"vector4","BLENDWEIGHT"),
			new VertexElement(56,"vector4","BLENDINDICES")]);}
		]);
		return VertexPositionNormalTexture0Texture1Skin;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTextureSkin
	var VertexPositionNormalTextureSkin=(function(){
		function VertexPositionNormalTextureSkin(position,normal,textureCoordinate,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTextureSkin,'laya.d3.graphics.VertexPositionNormalTextureSkin');
		var __proto=VertexPositionNormalTextureSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureSkin,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkin._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(64,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector2","UV"),
			new VertexElement(32,"vector4","BLENDWEIGHT"),
			new VertexElement(48,"vector4","BLENDINDICES")]);}
		]);
		return VertexPositionNormalTextureSkin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTextureSkinTangent
	var VertexPositionNormalTextureSkinTangent=(function(){
		function VertexPositionNormalTextureSkinTangent(position,normal,textureCoordinate,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTextureSkinTangent,'laya.d3.graphics.VertexPositionNormalTextureSkinTangent');
		var __proto=VertexPositionNormalTextureSkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkinTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureSkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureSkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(76,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector2","UV"),
			new VertexElement(32,"vector4","BLENDWEIGHT"),
			new VertexElement(48,"vector4","BLENDINDICES"),
			new VertexElement(64,"vector3","TANGENT0")]);}
		]);
		return VertexPositionNormalTextureSkinTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTextureTangent
	var VertexPositionNormalTextureTangent=(function(){
		function VertexPositionNormalTextureTangent(position,normal,textureCoordinate,tangent){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalTextureTangent,'laya.d3.graphics.VertexPositionNormalTextureTangent');
		var __proto=VertexPositionNormalTextureTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTextureTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(44,[
			new VertexElement(0,"vector3","POSITION"),
			new VertexElement(12,"vector3","NORMAL"),
			new VertexElement(24,"vector2","UV"),
			new VertexElement(32,"vector3","TANGENT0")]);}
		]);
		return VertexPositionNormalTextureTangent;
	})()


	/**
	*@private
	*<code>LoadModel</code> 类用于模型加载。
	*/
	//class laya.d3.loaders.LoadModel
	var LoadModel=(function(){
		function LoadModel(data,mesh,materials,url){
			this._strings=['BLOCK','DATA',"STRINGS"];
			this._materials=null;
			this._fileData=null;
			this._readData=null;
			this._mesh=null;
			this._BLOCK={count:0};
			this._DATA={offset:0,size:0};
			this._STRINGS={offset:0,size:0};
			this._shaderAttributes=null;
			this._mesh=mesh;
			this._materials=materials;
			this._onLoaded(data,url);
		}

		__class(LoadModel,'laya.d3.loaders.LoadModel');
		var __proto=LoadModel.prototype;
		/**
		*@private
		*/
		__proto._onLoaded=function(data,url){
			var preBasePath=URL.basePath;
			URL.basePath=URL.getPath(URL.formatURL(url));
			this._fileData=data;
			this._readData=new Byte(this._fileData);
			this._readData.pos=0;
			var version=this._readData.readUTFString();
			this.READ_BLOCK();
			for (var i=0;i < this._BLOCK.count;i++){
				var index=this._readData.getUint16();
				var blockName=this._strings[index];
				var fn=this["READ_"+blockName];
				if (fn==null)throw new Error("model file err,no this function:"+index+" "+blockName);
				if (!fn.call(this))break ;
			}
			URL.basePath=preBasePath;
			return this._mesh;
		}

		__proto.onError=function(){}
		/**
		*@private
		*/
		__proto._readString=function(){
			return this._strings[this._readData.getUint16()];
		}

		__proto.READ_BLOCK=function(){
			var n=this._readData.getUint16();
			this._BLOCK.count=this._readData.getUint16();
			return true;
		}

		__proto.READ_DATA=function(){
			this._DATA.offset=this._readData.getUint32();
			this._DATA.size=this._readData.getUint32();
			return true;
		}

		__proto.READ_STRINGS=function(){
			this._STRINGS.offset=this._readData.getUint16();
			this._STRINGS.size=this._readData.getUint16();
			var ofs=this._readData.pos;
			this._readData.pos=this._STRINGS.offset+this._DATA.offset;
			for (var i=0;i < this._STRINGS.size;i++){
				this._strings[i]=this._readData.readUTFString();
			}
			this._readData.pos=ofs;
			return true;
		}

		__proto.READ_MATERIAL=function(){
			var i=0,n=0;
			var index=this._readData.getUint16();
			var shaderName=this._readString();
			var url=this._readString();
			if (url!=="null"){
				url=URL.formatURL(url);
				var material=Resource.materialCache[url];
				if (material){
					this._materials[index]=material;
					}else {
					material=this._materials[index]=Resource.materialCache[url]=new Material();
					material.setShaderName(shaderName);
					Material.createFromFile(url,material);
				}
				}else {
				this._materials[index]=new Material();
			}
			return true;
		}

		__proto.READ_MESH=function(){
			var name=this._readString();
			return true;
		}

		__proto.READ_SUBMESH=function(){
			var className=this._readString();
			var material=this._readData.getUint8();
			var bufferAttribute=this._readString();
			this._shaderAttributes=bufferAttribute.match(LoadModel._attrReg);
			var ibofs=this._readData.getUint32();
			var ibsize=this._readData.getUint32();
			var vbIndicesofs=this._readData.getUint32();
			var vbIndicessize=this._readData.getUint32();
			var vbofs=this._readData.getUint32();
			var vbsize=this._readData.getUint32();
			var boneDicofs=this._readData.getUint32();
			var boneDicsize=this._readData.getUint32();
			var arrayBuffer=this._readData.__getBuffer();
			var submesh=new SubMesh(this._mesh);
			submesh.material=material;
			submesh.verticesIndices=new Uint32Array(arrayBuffer.slice(vbIndicesofs+this._DATA.offset,vbIndicesofs+this._DATA.offset+vbIndicessize));
			var vertexDeclaration=this._getVertexDeclaration();
			var vb=VertexBuffer3D.create(vertexDeclaration,vbsize / vertexDeclaration.vertexStride,0x88E4,true);
			var vbStart=vbofs+this._DATA.offset;
			var vbArrayBuffer=arrayBuffer.slice(vbStart,vbStart+vbsize);
			vb.setData(new Float32Array(vbArrayBuffer));
			submesh.setVB(vb);
			var vertexElements=vb.vertexDeclaration.getVertexElements();
			for (var i=0;i < vertexElements.length;i++)
			submesh._bufferUsage[(vertexElements [i]).elementUsage]=vb;
			var ib=IndexBuffer3D.create("ushort",ibsize / 2,0x88E4,true);
			var ibStart=ibofs+this._DATA.offset;
			var ibArrayBuffer=arrayBuffer.slice(ibStart,ibStart+ibsize);
			ib.setData(new Uint16Array(ibArrayBuffer));
			submesh.setIB(ib,ibsize / 2);
			var boneDicArrayBuffer=arrayBuffer.slice(boneDicofs+this._DATA.offset,boneDicofs+this._DATA.offset+boneDicsize);
			submesh._setBoneDic(new Uint8Array(boneDicArrayBuffer));
			this._mesh.add(submesh);
			return true;
		}

		__proto.READ_DATAAREA=function(){
			return false;
		}

		__proto._getVertexDeclaration=function(){
			var position=false,normal=false,color=false,texcoord0=false,texcoord1=false,blendWeight=false,blendIndex=false;
			for (var i=0;i < this._shaderAttributes.length;i+=8){
				switch (this._shaderAttributes[i]){
					case "POSITION":
						position=true;
						break ;
					case "NORMAL":
						normal=true;
						break ;
					case "COLOR":
						color=true;
						break ;
					case "UV":
						texcoord0=true;
						break ;
					case "UV1":
						texcoord1=true;
						break ;
					case "BLENDWEIGHT":
						blendWeight=true;
						break ;
					case "BLENDINDICES":
						blendIndex=true;
						break ;
					}
			};
			var vertexDeclaration;
			if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex)
				vertexDeclaration=VertexPositionNormalColorTexture0Texture1Skin.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalTexture0Texture1Skin.vertexDeclaration;
			else if (position && normal && color && texcoord0 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorTextureSkin.vertexDeclaration;
			else if (position && normal && texcoord0 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalTextureSkin.vertexDeclaration;
			else if (position && normal && color && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorSkin.vertexDeclaration;
			else if (position && normal && color && texcoord0 && texcoord1)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1)
			vertexDeclaration=VertexPositionNormalTexture0Texture1.vertexDeclaration;
			else if (position && normal && color && texcoord0)
			vertexDeclaration=VertexPositionNormalColorTexture.vertexDeclaration;
			else if (position && normal && texcoord0)
			vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
			else if (position && normal && color)
			vertexDeclaration=VertexPositionNormalColor.vertexDeclaration;
			return vertexDeclaration;
		}

		__getset(0,__proto,'mesh',function(){
			return this._mesh;
		});

		LoadModel._attrReg=new RegExp("(\\w+)|([:,;])","g");
		return LoadModel;
	})()


	/**
	*<code>BoundBox</code> 类用于创建包围盒。
	*/
	//class laya.d3.math.BoundBox
	var BoundBox1=(function(){
		function BoundBox(min,max){
			this.min=null;
			this.max=null;
			this.min=min;
			this.max=max;
		}

		__class(BoundBox,'laya.d3.math.BoundBox',null,'BoundBox1');
		var __proto=BoundBox.prototype;
		/**
		*获取包围盒的8个角顶点。
		*@param corners 返回顶点的输出队列。
		*/
		__proto.getCorners=function(corners){
			corners.length=8;
			var mine=this.min.elements;
			var maxe=this.max.elements;
			var minX=mine[0];
			var minY=mine[1];
			var minZ=mine[2];
			var maxX=maxe[0];
			var maxY=maxe[1];
			var maxZ=maxe[2];
			corners[0]=new Vector3(minX,maxY,maxZ);
			corners[1]=new Vector3(maxX,maxY,maxZ);
			corners[2]=new Vector3(maxX,minY,maxZ);
			corners[3]=new Vector3(minX,minY,maxZ);
			corners[4]=new Vector3(minX,maxY,minZ);
			corners[5]=new Vector3(maxX,maxY,minZ);
			corners[6]=new Vector3(maxX,minY,minZ);
			corners[7]=new Vector3(minX,minY,minZ);
		}

		__proto.toDefault=function(){
			this.min.toDefault();
			this.max.toDefault();
		}

		BoundBox.createfromPoints=function(points,out){
			if (points==null)
				throw new Error("points");
			var min=new Vector3(Number.MAX_VALUE);
			var max=new Vector3(-Number.MAX_VALUE);
			for (var i=0;i < points.length;++i){
				Vector3.min(min,points[i],min);
				Vector3.max(max,points[i],max);
			}
			out.min=min;
			out.max=max;
		}

		return BoundBox;
	})()


	/**
	*<code>BoundFrustum</code> 类用于创建锥截体。
	*/
	//class laya.d3.math.BoundFrustum
	var BoundFrustum=(function(){
		function BoundFrustum(matrix){
			this._matrix=null;
			this._near=null;
			this._far=null;
			this._left=null;
			this._right=null;
			this._top=null;
			this._bottom=null;
			this._matrix=matrix;
			this._near=new Plane(new Vector3());
			this._far=new Plane(new Vector3());
			this._left=new Plane(new Vector3());
			this._right=new Plane(new Vector3());
			this._top=new Plane(new Vector3());
			this._bottom=new Plane(new Vector3());
			BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
		}

		__class(BoundFrustum,'laya.d3.math.BoundFrustum');
		var __proto=BoundFrustum.prototype;
		/**
		*判断是否与其他锥截体相等。
		*@param other 锥截体。
		*/
		__proto.equalsBoundFrustum=function(other){
			return this._matrix.equalsOtherMatrix(other.matrix)
		}

		/**
		*判断是否与其他对象相等。
		*@param obj 对象。
		*/
		__proto.equalsObj=function(obj){
			if ((obj instanceof laya.d3.math.BoundFrustum )){
				var bf=obj;
				return this.equalsBoundFrustum(bf);
			}
			return false;
		}

		/**
		*获取锥截体的任意一平面。
		*0:近平面
		*1:远平面
		*2:左平面
		*3:右平面
		*4:顶平面
		*5:底平面
		*@param index 索引。
		*/
		__proto.getPlane=function(index){
			switch(index){
				case 0:
					return this._near;
				case 1:
					return this._far;
				case 2:
					return this._left;
				case 3:
					return this._right;
				case 4:
					return this._top;
				case 5:
					return this._bottom;
				default :
					return null;
				}
		}

		/**
		*锥截体的8个顶点。
		*@param corners 返回顶点的输出队列。
		*/
		__proto.getCorners=function(corners){
			corners[0]=BoundFrustum.get3PlaneInterPoint(this._near,this._bottom,this._right);
			corners[1]=BoundFrustum.get3PlaneInterPoint(this._near,this._top,this._right);
			corners[2]=BoundFrustum.get3PlaneInterPoint(this._near,this._top,this._left);
			corners[3]=BoundFrustum.get3PlaneInterPoint(this._near,this._bottom,this._left);
			corners[4]=BoundFrustum.get3PlaneInterPoint(this._far,this._bottom,this._right);
			corners[5]=BoundFrustum.get3PlaneInterPoint(this._far,this._top,this._right);
			corners[6]=BoundFrustum.get3PlaneInterPoint(this._far,this._top,this._left);
			corners[7]=BoundFrustum.get3PlaneInterPoint(this._far,this._bottom,this._left);
		}

		/**
		*与点的位置关系。返回-1,包涵;0,相交;1,不相交
		*@param point 点。
		*/
		__proto.ContainsPoint=function(point){
			var result=Plane.PlaneIntersectionType_Front;
			var planeResult=Plane.PlaneIntersectionType_Front;
			for (var i=0;i < 6;i++){
				switch(i){
					case 0:
						planeResult=Collision.intersectsPlaneAndPoint(this._near,point);
						break ;
					case 1:
						planeResult=Collision.intersectsPlaneAndPoint(this._far,point);
						break ;
					case 2:
						planeResult=Collision.intersectsPlaneAndPoint(this._left,point);
						break ;
					case 3:
						planeResult=Collision.intersectsPlaneAndPoint(this._right,point);
						break ;
					case 4:
						planeResult=Collision.intersectsPlaneAndPoint(this._top,point);
						break ;
					case 5:
						planeResult=Collision.intersectsPlaneAndPoint(this._bottom,point);
						break ;
					}
				switch(planeResult){
					case Plane.PlaneIntersectionType_Back:
						return 0;
					case Plane.PlaneIntersectionType_Intersecting:
						result=Plane.PlaneIntersectionType_Intersecting;
						break ;
					}
			}
			switch(result){
				case Plane.PlaneIntersectionType_Intersecting:
					return 2;
				default :
					return 1;
				}
		}

		/**
		*与包围盒的位置关系。返回-1,包涵;0,相交;1,不相交
		*@param box 包围盒。
		*/
		__proto.ContainsBoundBox=function(box){
			var plane;
			var result=1;
			for (var i=0;i < 6;i++){
				plane=this.getPlane(i);
				this._getBoxToPlanePVertexNVertex(box,plane.normal,BoundFrustum._tempV30,BoundFrustum._tempV31);
				if (Collision.intersectsPlaneAndPoint(plane,BoundFrustum._tempV30)==Plane.PlaneIntersectionType_Back)
					return 0;
				if (Collision.intersectsPlaneAndPoint(plane,BoundFrustum._tempV31)==Plane.PlaneIntersectionType_Back)
					result=2;
			}
			return result;
		}

		/**
		*与包围球的位置关系。返回-1,包涵;0,相交;1,不相交
		*@param sphere 包围球。
		*/
		__proto.ContainsBoundSphere=function(sphere){
			var result=Plane.PlaneIntersectionType_Front;
			var planeResult=Plane.PlaneIntersectionType_Front;
			for (var i=0;i < 6;i++){
				switch(i){
					case 0:
						planeResult=Collision.intersectsPlaneAndSphere(this._near,sphere);
						break ;
					case 1:
						planeResult=Collision.intersectsPlaneAndSphere(this._far,sphere);
						break ;
					case 2:
						planeResult=Collision.intersectsPlaneAndSphere(this._left,sphere);
						break ;
					case 3:
						planeResult=Collision.intersectsPlaneAndSphere(this._right,sphere);
						break ;
					case 4:
						planeResult=Collision.intersectsPlaneAndSphere(this._top,sphere);
						break ;
					case 5:
						planeResult=Collision.intersectsPlaneAndSphere(this._bottom,sphere);
						break ;
					}
				switch(planeResult){
					case Plane.PlaneIntersectionType_Back:
						return 0;
					case Plane.PlaneIntersectionType_Intersecting:
						result=Plane.PlaneIntersectionType_Intersecting;
						break ;
					}
			}
			switch(result){
				case Plane.PlaneIntersectionType_Intersecting:
					return 2;
				default :
					return 1;
				}
		}

		/**
		*@private
		*/
		__proto._getBoxToPlanePVertexNVertex=function(box,planeNormal,outP,outN){
			var boxMin=box.min;
			var boxMinE=boxMin.elements;
			var boxMax=box.max;
			var boxMaxE=boxMax.elements;
			var planeNorE=planeNormal.elements;
			var planeNorEX=planeNorE[0];
			var planeNorEY=planeNorE[1];
			var planeNorEZ=planeNorE[2];
			outP=boxMin;
			var outPE=outP.elements;
			if (planeNorEX >=0)
				outPE[0]=boxMaxE[0];
			if (planeNorEY >=0)
				outPE[1]=boxMaxE[1];
			if (planeNorEZ >=0)
				outPE[2]=boxMaxE[2];
			outN=boxMax;
			var outNE=outN.elements;
			if (planeNorEX >=0)
				outNE[0]=boxMinE[0];
			if (planeNorEY >=0)
				outNE[1]=boxMinE[1];
			if (planeNorEZ >=0)
				outNE[2]=boxMinE[2];
		}

		/**
		*获取底平面。
		*@return 底平面。
		*/
		__getset(0,__proto,'bottom',function(){
			return this._bottom;
		});

		/**
		*设置描述矩阵。
		*@param matrix 描述矩阵。
		*/
		/**
		*获取描述矩阵。
		*@return 描述矩阵。
		*/
		__getset(0,__proto,'matrix',function(){
			return this._matrix;
			},function(matrix){
			this._matrix=matrix;
			BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
		});

		/**
		*获取顶平面。
		*@return 顶平面。
		*/
		__getset(0,__proto,'top',function(){
			return this._top;
		});

		/**
		*获取近平面。
		*@return 近平面。
		*/
		__getset(0,__proto,'near',function(){
			return this._near;
		});

		/**
		*获取远平面。
		*@return 远平面。
		*/
		__getset(0,__proto,'far',function(){
			return this._far;
		});

		/**
		*获取左平面。
		*@return 左平面。
		*/
		__getset(0,__proto,'left',function(){
			return this._left;
		});

		/**
		*获取右平面。
		*@return 右平面。
		*/
		__getset(0,__proto,'right',function(){
			return this._right;
		});

		BoundFrustum._getPlanesFromMatrix=function(m,np,fp,lp,rp,tp,bp){
			var matrixE=m.elements;
			var m11=matrixE[0];
			var m12=matrixE[1];
			var m13=matrixE[2];
			var m14=matrixE[3];
			var m21=matrixE[4];
			var m22=matrixE[5];
			var m23=matrixE[6];
			var m24=matrixE[7];
			var m31=matrixE[8];
			var m32=matrixE[9];
			var m33=matrixE[10];
			var m34=matrixE[11];
			var m41=matrixE[12];
			var m42=matrixE[13];
			var m43=matrixE[14];
			var m44=matrixE[15];
			var nearNorE=np.normal.elements;
			nearNorE[0]=m13;
			nearNorE[1]=m23;
			nearNorE[2]=m33;
			np.distance=m43;
			np.normalize();
			var farNorE=fp.normal.elements;
			farNorE[0]=m14-m13;
			farNorE[1]=m24-m23;
			farNorE[2]=m34-m33;
			fp.distance=m44-m43;
			fp.normalize();
			var leftNorE=lp.normal.elements;
			leftNorE[0]=m14+m11;
			leftNorE[1]=m24+m21;
			leftNorE[2]=m34+m31;
			lp.distance=m44+m41;
			lp.normalize();
			var rightNorE=rp.normal.elements;
			rightNorE[0]=m14-m11;
			rightNorE[1]=m24-m21;
			rightNorE[2]=m34-m31;
			rp.distance=m44-m41;
			rp.normalize();
			var topNorE=tp.normal.elements;
			topNorE[0]=m14-m12;
			topNorE[1]=m24-m22;
			topNorE[2]=m34-m32;
			tp.distance=m44-m42;
			tp.normalize();
			var bottomNorE=bp.normal.elements;
			bottomNorE[0]=m14+m12;
			bottomNorE[1]=m24+m22;
			bottomNorE[2]=m34+m32;
			bp.distance=m44+m42;
			bp.normalize();
		}

		BoundFrustum.get3PlaneInterPoint=function(p1,p2,p3){
			var p1Nor=p1.normal;
			var p2Nor=p2.normal;
			var p3Nor=p3.normal;
			Vector3.cross(p2Nor,p3Nor,BoundFrustum._tempV30);
			Vector3.cross(p3Nor,p1Nor,BoundFrustum._tempV31);
			Vector3.cross(p1Nor,p2Nor,BoundFrustum._tempV32);
			var a=Vector3.dot(p1Nor,BoundFrustum._tempV30);
			var b=Vector3.dot(p2Nor,BoundFrustum._tempV31);
			var c=Vector3.dot(p3Nor,BoundFrustum._tempV32);
			Vector3.scale(BoundFrustum._tempV30,-p1.distance / a,BoundFrustum._tempV33);
			Vector3.scale(BoundFrustum._tempV31,-p2.distance / b,BoundFrustum._tempV34);
			Vector3.scale(BoundFrustum._tempV32,-p3.distance / c,BoundFrustum._tempV35);
			Vector3.add(BoundFrustum._tempV33,BoundFrustum._tempV34,BoundFrustum._tempV36);
			Vector3.add(BoundFrustum._tempV35,BoundFrustum._tempV36,BoundFrustum._tempV37);
			var v=BoundFrustum._tempV37;
			return v;
		}

		__static(BoundFrustum,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();},'_tempV37',function(){return this._tempV37=new Vector3();}
		]);
		return BoundFrustum;
	})()


	/**
	*<code>BoundSphere</code> 类用于创建包围球。
	*/
	//class laya.d3.math.BoundSphere
	var BoundSphere1=(function(){
		function BoundSphere(center,radius){
			this.center=null;
			this.radius=NaN;
			this.center=center;
			this.radius=radius;
		}

		__class(BoundSphere,'laya.d3.math.BoundSphere',null,'BoundSphere1');
		var __proto=BoundSphere.prototype;
		__proto.toDefault=function(){
			this.center.toDefault();
			this.radius=0;
		}

		BoundSphere.createFromSubPoints=function(points,start,count,out){
			if (points==null){
				throw new Error("points");
			}
			if (start < 0 || start >=points.length){
				throw new Error("start"+start+"Must be in the range [0, "+(points.length-1)+"]");
			}
			if (count < 0 || (start+count)> points.length){
				throw new Error("count"+count+"Must be in the range <= "+points.length+"}");
			};
			var upperEnd=start+count;
			var center=BoundSphere._tempVector3;
			center.elements[0]=0;
			center.elements[1]=0;
			center.elements[2]=0;
			for (var i=start;i < upperEnd;++i){
				Vector3.add(points[i],center,center);
			};
			var outCenter=out.center;
			Vector3.scale(center,1 / count,outCenter);
			var radius=0.0;
			for (i=start;i < upperEnd;++i){
				var distance=Vector3.distanceSquared(outCenter,points[i]);
				if (distance > radius)
					radius=distance;
			}
			out.radius=Math.sqrt(radius);
		}

		BoundSphere.createfromPoints=function(points,out){
			if (points==null){
				throw new Error("points");
			}
			BoundSphere.createFromSubPoints(points,0,points.length,out);
		}

		__static(BoundSphere,
		['_tempVector3',function(){return this._tempVector3=new Vector3();}
		]);
		return BoundSphere;
	})()


	/**
	*<code>Collision</code> 类用于检测碰撞。
	*/
	//class laya.d3.math.Collision
	var Collision=(function(){
		/**
		*创建一个 <code>Collision</code> 实例。
		*/
		function Collision(){}
		__class(Collision,'laya.d3.math.Collision');
		Collision.distancePlaneToPoint=function(plane,point){
			var dot=Vector3.dot(plane.normal,point);
			return dot-plane.distance;
		}

		Collision.distanceBoxToPoint=function(box,point){
			var boxMine=box.min.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMaxe=box.max.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			var pointe=point.elements;
			var pointeX=pointe[0];
			var pointeY=pointe[1];
			var pointeZ=pointe[2];
			var distance=0;
			if (pointeX < boxMineX)
				distance+=(boxMineX-pointeX)*(boxMineX-pointeX);
			if (pointeX > boxMaxeX)
				distance+=(boxMaxeX-pointeX)*(boxMaxeX-pointeX);
			if (pointeY < boxMineY)
				distance+=(boxMineY-pointeY)*(boxMineY-pointeY);
			if (pointeY > boxMaxeY)
				distance+=(boxMaxeY-pointeY)*(boxMaxeY-pointeY);
			if (pointeZ < boxMineZ)
				distance+=(boxMineZ-pointeZ)*(boxMineZ-pointeZ);
			if (pointeZ > boxMaxeZ)
				distance+=(boxMaxeZ-pointeZ)*(boxMaxeZ-pointeZ);
			return Math.sqrt(distance);
		}

		Collision.distanceBoxToBox=function(box1,box2){
			var box1Mine=box1.min.elements;
			var box1MineX=box1Mine[0];
			var box1MineY=box1Mine[1];
			var box1MineZ=box1Mine[2];
			var box1Maxe=box1.max.elements;
			var box1MaxeX=box1Maxe[0];
			var box1MaxeY=box1Maxe[1];
			var box1MaxeZ=box1Maxe[2];
			var box2Mine=box2.min.elements;
			var box2MineX=box2Mine[0];
			var box2MineY=box2Mine[1];
			var box2MineZ=box2Mine[2];
			var box2Maxe=box2.max.elements;
			var box2MaxeX=box2Maxe[0];
			var box2MaxeY=box2Maxe[1];
			var box2MaxeZ=box2Maxe[2];
			var distance=0;
			var delta=NaN;
			if (box1MineX > box2MaxeX){
				delta=box1MineX-box2MaxeX;
				distance+=delta *delta;
			}
			else if(box2MineX > box1MaxeX){
				delta=box2MineX-box1MaxeX;
				distance+=delta *delta;
			}
			if (box1MineY > box2MaxeY){
				delta=box1MineY-box2MaxeY;
				distance+=delta *delta;
			}
			else if(box2MineY > box1MaxeY){
				delta=box2MineY-box1MaxeY;
				distance+=delta *delta;
			}
			if (box1MineZ > box2MaxeZ){
				delta=box1MineZ-box2MaxeZ;
				distance+=delta *delta;
			}
			else if(box2MineZ > box1MaxeZ){
				delta=box2MineZ-box1MaxeZ;
				distance+=delta *delta;
			}
			return Math.sqrt(distance);
		}

		Collision.distanceSphereToPoint=function(sphere,point){
			var distance=Math.sqrt(Vector3.distanceSquared(sphere.center,point));
			distance-=sphere.radius;
			return Math.max(distance,0);
		}

		Collision.distanceSphereToSphere=function(sphere1,sphere2){
			var distance=Math.sqrt(Vector3.distanceSquared(sphere1.center,sphere2.center));
			distance-=sphere1.radius+sphere2.radius;
			return Math.max(distance,0);
		}

		Collision.intersectsRayAndPoint=function(ray,point){
			Vector3.subtract(ray.origin,point,Collision._tempV30);
			var b=Vector3.dot(Collision._tempV30,ray.direction);
			var c=Vector3.dot(Collision._tempV30,Collision._tempV30)-MathUtils3D.zeroTolerance;
			if (c > 0 && b > 0)
				return false;
			var discriminant=b *b-c;
			if (discriminant < 0)
				return false;
			return true;
		}

		Collision.intersectsRayAndRay=function(ray1,ray2,out){
			var ray1o=ray1.origin;
			var ray1oe=ray1o.elements;
			var ray1oeX=ray1oe[0];
			var ray1oeY=ray1oe[1];
			var ray1oeZ=ray1oe[2];
			var ray1d=ray1.direction;
			var ray1de=ray1d.elements;
			var ray1deX=ray1de[0];
			var ray1deY=ray1de[1];
			var ray1deZ=ray1de[2];
			var ray2o=ray2.origin;
			var ray2oe=ray2o.elements;
			var ray2oeX=ray2oe[0];
			var ray2oeY=ray2oe[1];
			var ray2oeZ=ray2oe[2];
			var ray2d=ray2.direction;
			var ray2de=ray2d.elements;
			var ray2deX=ray2de[0];
			var ray2deY=ray2de[1];
			var ray2deZ=ray2de[2];
			Vector3.cross(ray1d,ray2d,Collision._tempV30);
			var tempV3e=Collision._tempV30.elements;
			var denominator=Vector3.scalarLength(Collision._tempV30);
			if (MathUtils3D.isZero(denominator)){
				if (MathUtils3D.nearEqual(ray2oeX,ray1oeX)&& MathUtils3D.nearEqual(ray2oeY,ray1oeY)&& MathUtils3D.nearEqual(ray2oeZ,ray1oeZ)){
					out=Vector3.ZERO;
					return true;
				}
			}
			denominator=denominator *denominator;
			var m11=ray2oeX-ray1oeX;
			var m12=ray2oeY-ray1oeY;
			var m13=ray2oeZ-ray1oeZ;
			var m21=ray2deX;
			var m22=ray2deY;
			var m23=ray2deZ;
			var m31=tempV3e[0];
			var m32=tempV3e[1];
			var m33=tempV3e[2];
			var dets=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
			m21=ray1deX;
			m22=ray1deY;
			m23=ray1deZ;
			var dett=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
			var s=dets / denominator;
			var t=dett / denominator;
			Vector3.scale(ray1d,s,Collision._tempV30);
			Vector3.scale(ray2d,s,Collision._tempV31);
			Vector3.add(ray1o,Collision._tempV30,Collision._tempV32);
			Vector3.add(ray2o,Collision._tempV31,Collision._tempV33);
			var point1e=Collision._tempV32.elements;
			var point2e=Collision._tempV33.elements;
			if (!MathUtils3D.nearEqual(point2e[0],point1e[0])|| !MathUtils3D.nearEqual(point2e[1],point1e[1])|| !MathUtils3D.nearEqual(point2e[2],point1e[2])){
				out=Vector3.ZERO;
				return false;
			}
			out=Collision._tempV32;
			return true;
		}

		Collision.intersectsRayAndPlaneRD=function(ray,plane,out){
			var planeNor=plane.normal;
			var direction=Vector3.dot(planeNor,ray.direction);
			if (MathUtils3D.isZero(direction)){
				out=0;
				return false;
			};
			var position=Vector3.dot(planeNor,ray.origin);
			out=(-plane.distance-position)/ direction;
			if (out < 0){
				out=0;
				return false;
			}
			return true;
		}

		Collision.intersectsRayAndPlaneRP=function(ray,plane,out){
			var distance=NaN;
			if (!Collision.intersectsRayAndPlaneRD(ray,plane,distance)){
				out=Vector3.ZERO;
				return false;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
			out=Collision._tempV31;
			return true;
		}

		Collision.intersectsRayAndBoxRD=function(ray,box,out){
			var rayoe=ray.origin.elements;;
			var rayoeX=rayoe[0];
			var rayoeY=rayoe[1];
			var rayoeZ=rayoe[2];
			var rayde=ray.direction.elements;
			var raydeX=rayde[0];
			var raydeY=rayde[1];
			var raydeZ=rayde[2];
			var boxMine=box.min.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMaxe=box.max.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			out=0;
			var tmax=MathUtils3D.MaxValue;
			if (MathUtils3D.isZero(raydeX)){
				if (rayoeX < boxMineX || rayoeX > boxMaxeX){
					out=0;
					return false;
				}
				}else{
				var inverse=1 / raydeX;
				var t1=(boxMineX-rayoeX)*inverse;
				var t2=(boxMaxeX-rayoeX)*inverse;
				if (t1 > t2){
					var temp=t1;
					t1=t2;
					t2=temp;
				}
				out=Math.max(t1,out);
				tmax=Math.min(t2,tmax);
				if (out > tmax){
					out=0;
					return false;
				}
			}
			if (MathUtils3D.isZero(raydeY)){
				if (rayoeY < boxMineY || rayoeY > boxMaxeY){
					out=0;
					return false;
				}
				}else{
				var inverse1=1 / raydeY;
				var t3=(boxMineY-rayoeY)*inverse1;
				var t4=(boxMaxeY-rayoeY)*inverse1;
				if (t3 > t4){
					var temp1=t3;
					t3=t4;
					t4=temp1;
				}
				out=Math.max(t3,out);
				tmax=Math.min(t4,tmax);
				if (out > tmax){
					out=0;
					return false;
				}
			}
			if (MathUtils3D.isZero(raydeZ)){
				if (rayoeZ < boxMineZ || rayoeZ > boxMaxeZ){
					out=0;
					return false;
				}
				}else{
				var inverse2=1 / raydeZ;
				var t5=(boxMineZ-rayoeZ)*inverse2;
				var t6=(boxMaxeZ-rayoeZ)*inverse2;
				if (t5 > t6){
					var temp2=t5;
					t5=t6;
					t6=temp2;
				}
				out=Math.max(t5,out);
				tmax=Math.min(t6,tmax);
				if (out > tmax){
					out=0;
					return false;
				}
			}
			return true;
		}

		Collision.intersectsRayAndBoxRP=function(ray,box,out){
			var distance=NaN;
			if (!Collision.intersectsRayAndBoxRD(ray,box,distance)){
				out=Vector3.ZERO;
				return false;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
			out=Collision._tempV31;
			return true;
		}

		Collision.intersectsRayAndSphereRD=function(ray,sphere,out){
			var sphereR=sphere.radius;
			Vector3.subtract(ray.origin,sphere.center,Collision._tempV30);
			var b=Vector3.dot(Collision._tempV30,ray.direction);
			var c=Vector3.dot(Collision._tempV30,Collision._tempV30)-(sphereR *sphereR);
			if (c > 0 && b > 0){
				out=0;
				return false;
			};
			var discriminant=b *b-c;
			if (discriminant < 0){
				out=0;
				return false;
			}
			out=-b-Math.sqrt(discriminant);
			if (out < 0)
				out=0;
			return true;
		}

		Collision.intersectsRayAndSphereRP=function(ray,sphere,out){
			var distance=NaN;
			if (!Collision.intersectsRayAndSphereRD(ray,sphere,distance)){
				out=Vector3.ZERO;
				return false;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
			out=Collision._tempV31;
			return true;
		}

		Collision.intersectsPlaneAndPoint=function(plane,point){
			var distance=Vector3.dot(plane.normal,point)+plane.distance;
			if (distance > 0)
				return Plane.PlaneIntersectionType_Front;
			else if (distance < 0)
			return Plane.PlaneIntersectionType_Back;
			else
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsPlaneAndPlane=function(plane1,plane2){
			Vector3.cross(plane1.normal,plane2.normal,Collision._tempV30);
			var denominator=Vector3.dot(Collision._tempV30,Collision._tempV30);
			if (MathUtils3D.isZero(denominator))
				return false;
			return true;
		}

		Collision.intersectsPlaneAndPlaneRL=function(plane1,plane2,line){
			var plane1nor=plane1.normal;
			var plane2nor=plane2.normal;
			Vector3.cross(plane1nor,plane2nor,Collision._tempV34);
			var denominator=Vector3.dot(Collision._tempV34,Collision._tempV34);
			if (MathUtils3D.isZero(denominator))
				return false;
			Vector3.scale(plane2nor,plane1.distance,Collision._tempV30);
			Vector3.scale(plane1nor,plane2.distance,Collision._tempV31);
			Vector3.subtract(Collision._tempV30,Collision._tempV31,Collision._tempV32);
			Vector3.cross(Collision._tempV32,Collision._tempV34,Collision._tempV33);
			Vector3.normalize(Collision._tempV34,Collision._tempV34);
			line=new Ray1(Collision._tempV33,Collision._tempV34);
			return true;
		}

		Collision.intersectsPlaneAndBox=function(plane,box){
			var planeD=plane.distance;
			var planeNor=plane.normal;
			var planeNore=planeNor.elements;
			var planeNoreX=planeNore[0];
			var planeNoreY=planeNore[1];
			var planeNoreZ=planeNore[2];
			var boxMine=box.min.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMaxe=box.max.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			Collision._tempV30.elements[0]=(planeNoreX > 0)? boxMineX :boxMaxeX;
			Collision._tempV30.elements[1]=(planeNoreY > 0)? boxMineY :boxMaxeY;
			Collision._tempV30.elements[2]=(planeNoreZ > 0)? boxMineZ :boxMaxeZ;
			Collision._tempV31.elements[0]=(planeNoreX > 0)? boxMaxeX :boxMineX;
			Collision._tempV31.elements[1]=(planeNoreY > 0)? boxMaxeY :boxMineY;
			Collision._tempV31.elements[2]=(planeNoreZ > 0)? boxMaxeZ :boxMineZ;
			var distance=Vector3.dot(planeNor,Collision._tempV30);
			if (distance+planeD > 0)
				return Plane.PlaneIntersectionType_Front;
			distance=Vector3.dot(planeNor,Collision._tempV31);
			if (distance+planeD < 0)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsPlaneAndSphere=function(plane,sphere){
			var sphereR=sphere.radius;
			var distance=Vector3.dot(plane.normal,sphere.center)+plane.distance;
			if (distance > sphereR)
				return Plane.PlaneIntersectionType_Front;
			if (distance <-sphereR)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsBoxAndBox=function(box1,box2){
			var box1Mine=box1.min.elements;
			var box1MineY=box1Mine[1];
			var box1MineZ=box1Mine[2];
			var box1Maxe=box1.max.elements;
			var box1MaxeY=box1Maxe[1];
			var box1MaxeZ=box1Maxe[2];
			var box2Mine=box2.min.elements;
			var box2MineY=box2Mine[1];
			var box2MineZ=box2Mine[2];
			var box2Maxe=box2.max.elements;
			var box2MaxeY=box2Maxe[1];
			var box2MaxeZ=box2Maxe[2];
			if (box1Mine[0] > box2Maxe[0] || box2Mine[0] > box1Maxe[0])
				return false;
			if (box1Mine[1] > box2Maxe[1] || box2Mine[1] > box1Maxe[1])
				return false;
			if (box1Mine[2] > box2Maxe[2] || box2Mine[2] > box1Maxe[2])
				return false;
			return true;
		}

		Collision.intersectsBoxAndSphere=function(box,sphere){
			var sphereC=sphere.center;
			var sphereR=sphere.radius;
			Vector3.Clamp(sphereC,box.min,box.max,Collision._tempV30);
			var distance=Vector3.distanceSquared(sphereC,Collision._tempV30);
			return distance <=sphereR *sphereR;
		}

		Collision.intersectsSphereAndSphere=function(sphere1,sphere2){
			var radiisum=sphere1.radius+sphere2.radius;
			return Vector3.distanceSquared(sphere1.center,sphere2.center)<=radiisum *radiisum;
		}

		__static(Collision,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();}
		]);
		return Collision;
	})()


	/**
	*<code>ContainmentType</code> 类用于定义空间物体位置关系。
	*/
	//class laya.d3.math.ContainmentType
	var ContainmentType=(function(){
		function ContainmentType(){};
		__class(ContainmentType,'laya.d3.math.ContainmentType');
		ContainmentType.Disjoint=0;
		ContainmentType.Contains=1;
		ContainmentType.Intersects=2;
		return ContainmentType;
	})()


	/**
	*<code>MathUtils</code> 类用于创建数学工具。
	*/
	//class laya.d3.math.MathUtils3D
	var MathUtils3D=(function(){
		/**
		*创建一个 <code>MathUtils</code> 实例。
		*/
		function MathUtils3D(){}
		__class(MathUtils3D,'laya.d3.math.MathUtils3D');
		MathUtils3D.isZero=function(v){
			return Math.abs(v)< MathUtils3D.zeroTolerance;
		}

		MathUtils3D.nearEqual=function(n1,n2){
			if (MathUtils3D.isZero(n1-n2))
				return true;
			return false;
		}

		__static(MathUtils3D,
		['zeroTolerance',function(){return this.zeroTolerance=1e-6;},'MaxValue',function(){return this.MaxValue=3.40282347e+38;},'MinValue',function(){return this.MinValue=-3.40282347e+38;}
		]);
		return MathUtils3D;
	})()


	/**
	*<code>Matrix3x3</code> 类用于创建3x3矩阵。
	*/
	//class laya.d3.math.Matrix3x3
	var Matrix3x3=(function(){
		function Matrix3x3(){
			//this.elements=null;
			var e=this.elements=new Float32Array(9);
			e[0]=1;
			e[1]=0;
			e[2]=0;
			e[3]=0;
			e[4]=1;
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		__class(Matrix3x3,'laya.d3.math.Matrix3x3');
		var __proto=Matrix3x3.prototype;
		/**
		*计算3x3矩阵的行列式
		*@return 矩阵的行列式
		*/
		__proto.determinant=function(){
			var f=this.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			return a00 *(a22 *a11-a12 *a21)+a01 *(-a22 *a10+a12 *a20)+a02 *(a21 *a10-a11 *a20);
		}

		/**
		*通过一个二维向量转换3x3矩阵
		*@param tra 转换向量
		*@param out 输出矩阵
		*/
		__proto.translate=function(trans,out){
			var e=out.elements;
			var f=this.elements;
			var g=trans.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var x=g[0],y=g[1];
			e[0]=a00;
			e[1]=a01;
			e[2]=a02;
			e[3]=a10;
			e[4]=a11;
			e[5]=a12;
			e[6]=x *a00+y *a10+a20;
			e[7]=x *a01+y *a11+a21;
			e[8]=x *a02+y *a12+a22;
		}

		/**
		*根据指定角度旋转3x3矩阵
		*@param rad 旋转角度
		*@param out 输出矩阵
		*/
		__proto.rotate=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var s=Math.sin(rad);
			var c=Math.cos(rad);
			e[0]=c *a00+s *a10;
			e[1]=c *a01+s *a11;
			e[2]=c *a02+s *a12;
			e[3]=c *a10-s *a00;
			e[4]=c *a11-s *a01;
			e[5]=c *a12-s *a02;
			e[6]=a20;
			e[7]=a21;
			e[8]=a22;
		}

		/**
		*根据制定缩放3x3矩阵
		*@param scale 缩放值
		*@param out 输出矩阵
		*/
		__proto.scale=function(scale,out){
			var e=out.elements;
			var f=this.elements;
			var g=scale.elements;
			var x=g[0],y=g[1];
			e[0]=x *f[0];
			e[1]=x *f[1];
			e[2]=x *f[2];
			e[3]=y *f[3];
			e[4]=y *f[4];
			e[5]=y *f[5];
			e[6]=f[6];
			e[7]=f[7];
			e[8]=f[8];
		}

		/**
		*计算3x3矩阵的逆矩阵
		*@param out 输出的逆矩阵
		*/
		__proto.invert=function(out){
			var e=out.elements;
			var f=this.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var b01=a22 *a11-a12 *a21;
			var b11=-a22 *a10+a12 *a20;
			var b21=a21 *a10-a11 *a20;
			var det=a00 *b01+a01 *b11+a02 *b21;
			if (!det){
				out=null;
			}
			det=1.0 / det;
			e[0]=b01 *det;
			e[1]=(-a22 *a01+a02 *a21)*det;
			e[2]=(a12 *a01-a02 *a11)*det;
			e[3]=b11 *det;
			e[4]=(a22 *a00-a02 *a20)*det;
			e[5]=(-a12 *a00+a02 *a10)*det;
			e[6]=b21 *det;
			e[7]=(-a21 *a00+a01 *a20)*det;
			e[8]=(a11 *a00-a01 *a10)*det;
		}

		/**
		*计算3x3矩阵的转置矩阵
		*@param out 输出矩阵
		*/
		__proto.transpose=function(out){
			var e=out.elements;
			var f=this.elements;
			if (out===this){
				var a01=f[1],a02=f[2],a12=f[5];
				e[1]=f[3];
				e[2]=f[6];
				e[3]=a01;
				e[5]=f[7];
				e[6]=a02;
				e[7]=a12;
				}else {
				e[0]=f[0];
				e[1]=f[3];
				e[2]=f[6];
				e[3]=f[1];
				e[4]=f[4];
				e[5]=f[7];
				e[6]=f[2];
				e[7]=f[5];
				e[8]=f[8];
			}
		}

		/**设置已有的矩阵为单位矩阵*/
		__proto.identity=function(){
			var e=this.elements;
			e[0]=1;
			e[1]=0;
			e[2]=0;
			e[3]=0;
			e[4]=1;
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		/**
		*克隆一个3x3矩阵
		*@param out 输出的3x3矩阵
		*/
		__proto.cloneTo=function(out){
			var i,s,d;
			s=this.elements;
			d=out.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 9;++i){
				d[i]=s[i];
			}
		}

		/**
		*从一个3x3矩阵复制
		*@param sou 源3x3矩阵
		*/
		__proto.copyFrom=function(sou){
			var i,s,d;
			s=sou.elements;
			d=this.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 9;++i){
				d[i]=s[i];
			}
		}

		/**
		*从一个数组复制
		*@param sou 源Float32Array数组
		*/
		__proto.copyFromArray=function(sou){
			var i,d;
			d=this.elements;
			if (sou===d){
				return;
			}
			for (i=0;i < 9;++i){
				d[i]=sou[i];
			}
		}

		Matrix3x3.createFromTranslation=function(trans,out){
			var e=out.elements;
			var g=trans.elements;
			out[0]=1;
			out[1]=0;
			out[2]=0;
			out[3]=0;
			out[4]=1;
			out[5]=0;
			out[6]=g[0];
			out[7]=g[1];
			out[8]=1;
		}

		Matrix3x3.createFromRotation=function(rad,out){
			var e=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			e[0]=c;
			e[1]=s;
			e[2]=0;
			e[3]=-s;
			e[4]=c;
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		Matrix3x3.createFromScaling=function(scale,out){
			var e=out.elements;
			var g=scale.elements;
			e[0]=g[0];
			e[1]=0;
			e[2]=0;
			e[3]=0;
			e[4]=g[1];
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		Matrix3x3.createFromMatrix4x4=function(sou,out){
			out[0]=sou[0];
			out[1]=sou[1];
			out[2]=sou[2];
			out[3]=sou[4];
			out[4]=sou[5];
			out[5]=sou[6];
			out[6]=sou[8];
			out[7]=sou[9];
			out[8]=sou[10];
		}

		Matrix3x3.multiply=function(left,right,out){
			var e=out.elements;
			var f=left.elements;
			var g=right.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var b00=g[0],b01=g[1],b02=g[2];
			var b10=g[3],b11=g[4],b12=g[5];
			var b20=g[6],b21=g[7],b22=g[8];
			e[0]=b00 *a00+b01 *a10+b02 *a20;
			e[1]=b00 *a01+b01 *a11+b02 *a21;
			e[2]=b00 *a02+b01 *a12+b02 *a22;
			e[3]=b10 *a00+b11 *a10+b12 *a20;
			e[4]=b10 *a01+b11 *a11+b12 *a21;
			e[5]=b10 *a02+b11 *a12+b12 *a22;
			e[6]=b20 *a00+b21 *a10+b22 *a20;
			e[7]=b20 *a01+b21 *a11+b22 *a21;
			e[8]=b20 *a02+b21 *a12+b22 *a22;
		}

		Matrix3x3.DEFAULT=new Matrix3x3();
		return Matrix3x3;
	})()


	/**
	*<code>Matrix4x4</code> 类用于创建4x4矩阵。
	*/
	//class laya.d3.math.Matrix4x4
	var Matrix4x4=(function(){
		function Matrix4x4(m11,m12,m13,m14,m21,m22,m23,m24,m31,m32,m33,m34,m41,m42,m43,m44){
			//this.elements=null;
			(m11===void 0)&& (m11=1);
			(m12===void 0)&& (m12=0);
			(m13===void 0)&& (m13=0);
			(m14===void 0)&& (m14=0);
			(m21===void 0)&& (m21=0);
			(m22===void 0)&& (m22=1);
			(m23===void 0)&& (m23=0);
			(m24===void 0)&& (m24=0);
			(m31===void 0)&& (m31=0);
			(m32===void 0)&& (m32=0);
			(m33===void 0)&& (m33=1);
			(m34===void 0)&& (m34=0);
			(m41===void 0)&& (m41=0);
			(m42===void 0)&& (m42=0);
			(m43===void 0)&& (m43=0);
			(m44===void 0)&& (m44=1);
			var e=this.elements=new Float32Array(16);
			e[0]=m11;
			e[1]=m12;
			e[2]=m13;
			e[3]=m14;
			e[4]=m21;
			e[5]=m22;
			e[6]=m23;
			e[7]=m24;
			e[8]=m31;
			e[9]=m32;
			e[10]=m33;
			e[11]=m34;
			e[12]=m41;
			e[13]=m42;
			e[14]=m43;
			e[15]=m44;
		}

		__class(Matrix4x4,'laya.d3.math.Matrix4x4');
		var __proto=Matrix4x4.prototype;
		/**
		*判断两个4x4矩阵的值是否相等。
		*@param other 4x4矩阵
		*/
		__proto.equalsOtherMatrix=function(other){
			var e=this.elements;
			var oe=other.elements;
			return (MathUtils3D.nearEqual(e[0],oe[0])&&
			MathUtils3D.nearEqual(e[1],oe[1])&&
			MathUtils3D.nearEqual(e[2],oe[2])&&
			MathUtils3D.nearEqual(e[3],oe[3])&&
			MathUtils3D.nearEqual(e[4],oe[4])&&
			MathUtils3D.nearEqual(e[5],oe[5])&&
			MathUtils3D.nearEqual(e[6],oe[6])&&
			MathUtils3D.nearEqual(e[7],oe[7])&&
			MathUtils3D.nearEqual(e[8],oe[8])&&
			MathUtils3D.nearEqual(e[9],oe[9])&&
			MathUtils3D.nearEqual(e[10],oe[10])&&
			MathUtils3D.nearEqual(e[11],oe[11])&&
			MathUtils3D.nearEqual(e[12],oe[12])&&
			MathUtils3D.nearEqual(e[13],oe[13])&&
			MathUtils3D.nearEqual(e[14],oe[14])&&
			MathUtils3D.nearEqual(e[15],oe[15]));
		}

		/**
		*分解矩阵
		*@param translation 平移
		*@param rotation 旋转
		*@param scale 缩放
		*@return 是否成功
		*/
		__proto.decompose=function(translation,rotation,scale){
			var me=this.elements;
			var te=translation.elements;
			var re=rotation.elements;
			var se=scale.elements;
			te[0]=me[12];
			te[1]=me[13];
			te[2]=me[14];
			se[0]=Math.sqrt((me[0] *me[0])+(me[1] *me[1])+(me[2] *me[2]));
			se[1]=Math.sqrt((me[4] *me[4])+(me[5] *me[5])+(me[6] *me[6]));
			se[2]=Math.sqrt((me[8] *me[8])+(me[9] *me[9])+(me[10] *me[10]));
			if (MathUtils3D.isZero(se[0])|| MathUtils3D.isZero(se[1])|| MathUtils3D.isZero(se[2])){
				re[0]=re[1]=re[2]=0;
				re[3]=1;
				return false;
			};
			var rotationmatrix=new Matrix4x4();
			var rme=rotationmatrix.elements;
			rme[0]=me[0] / se[0];
			rme[1]=me[1] / se[0];
			rme[2]=me[2] / se[0];
			rme[4]=me[4] / se[1];
			rme[5]=me[5] / se[1];
			rme[6]=me[6] / se[1];
			rme[8]=me[8] / se[2];
			rme[9]=me[9] / se[2];
			rme[10]=me[10] / se[2];
			rotationmatrix[15]=1;
			Quaternion1.createFromMatrix4x4(rotationmatrix,rotation);
			return true;
		}

		/**归一化矩阵 */
		__proto.normalize=function(){
			var v=this.elements;
			var c=v[0],d=v[1],e=v[2],g=Math.sqrt(c *c+d *d+e *e);
			if (g){
				if (g==1)
					return;
				}else {
				v[0]=0;
				v[1]=0;
				v[2]=0;
				return;
			}
			g=1 / g;
			v[0]=c *g;
			v[1]=d *g;
			v[2]=e *g;
		}

		/**计算矩阵的转置矩阵*/
		__proto.transpose=function(){
			var e,t;
			e=this.elements;
			t=e[1];
			e[1]=e[4];
			e[4]=t;
			t=e[2];
			e[2]=e[8];
			e[8]=t;
			t=e[3];
			e[3]=e[12];
			e[12]=t;
			t=e[6];
			e[6]=e[9];
			e[9]=t;
			t=e[7];
			e[7]=e[13];
			e[13]=t;
			t=e[11];
			e[11]=e[14];
			e[14]=t;
			return this;
		}

		/**
		*计算一个矩阵的逆矩阵
		*@param out 输出矩阵
		*/
		__proto.invert=function(out){
			var ae=this.elements;
			var oe=out.elements;
			var a00=ae[0],a01=ae[1],a02=ae[2],a03=ae[3],a10=ae[4],a11=ae[5],a12=ae[6],a13=ae[7],a20=ae[8],a21=ae[9],a22=ae[10],a23=ae[11],a30=ae[12],a31=ae[13],a32=ae[14],a33=ae[15],
			b00=a00 *a11-a01 *a10,b01=a00 *a12-a02 *a10,b02=a00 *a13-a03 *a10,b03=a01 *a12-a02 *a11,b04=a01 *a13-a03 *a11,b05=a02 *a13-a03 *a12,b06=a20 *a31-a21 *a30,b07=a20 *a32-a22 *a30,b08=a20 *a33-a23 *a30,b09=a21 *a32-a22 *a31,b10=a21 *a33-a23 *a31,b11=a22 *a33-a23 *a32,
			det=b00 *b11-b01 *b10+b02 *b09+b03 *b08-b04 *b07+b05 *b06;
			if (Math.abs(det)===0.0){
				return;
			}
			det=1.0 / det;
			oe[0]=(a11 *b11-a12 *b10+a13 *b09)*det;
			oe[1]=(a02 *b10-a01 *b11-a03 *b09)*det;
			oe[2]=(a31 *b05-a32 *b04+a33 *b03)*det;
			oe[3]=(a22 *b04-a21 *b05-a23 *b03)*det;
			oe[4]=(a12 *b08-a10 *b11-a13 *b07)*det;
			oe[5]=(a00 *b11-a02 *b08+a03 *b07)*det;
			oe[6]=(a32 *b02-a30 *b05-a33 *b01)*det;
			oe[7]=(a20 *b05-a22 *b02+a23 *b01)*det;
			oe[8]=(a10 *b10-a11 *b08+a13 *b06)*det;
			oe[9]=(a01 *b08-a00 *b10-a03 *b06)*det;
			oe[10]=(a30 *b04-a31 *b02+a33 *b00)*det;
			oe[11]=(a21 *b02-a20 *b04-a23 *b00)*det;
			oe[12]=(a11 *b07-a10 *b09-a12 *b06)*det;
			oe[13]=(a00 *b09-a01 *b07+a02 *b06)*det;
			oe[14]=(a31 *b01-a30 *b03-a32 *b00)*det;
			oe[15]=(a20 *b03-a21 *b01+a22 *b00)*det;
		}

		/**设置矩阵为单位矩阵*/
		__proto.identity=function(){
			var e=this.elements;
			e[1]=e[2]=e[3]=e[4]=e[6]=e[7]=e[8]=e[9]=e[11]=e[12]=e[13]=e[14]=0;
			e[0]=e[5]=e[10]=e[15]=1;
		}

		/**
		*克隆一个4x4矩阵
		*@param out 输出的4x4矩阵
		*/
		__proto.cloneTo=function(out){
			var i,s,d;
			s=this.elements;
			d=out.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 16;++i){
				d[i]=s[i];
			}
		}

		/**
		*从一个4x4矩阵复制
		*@param sou 源4x4矩阵
		*/
		__proto.copyFrom=function(sou){
			var i,s,d;
			s=sou.elements;
			d=this.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 16;++i){
				d[i]=s[i];
			}
		}

		/**
		*从一个数组复制
		*@param sou 源Float32Array数组
		*/
		__proto.copyFromArray=function(sou){
			var i,d;
			d=this.elements;
			if (sou===d){
				return;
			}
			for (i=0;i < 16;++i){
				d[i]=sou[i];
			}
		}

		Matrix4x4.createRotationX=function(rad,out){
			var oe=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			oe[1]=oe[2]=oe[3]=oe[4]=oe[7]=oe[8]=oe[11]=oe[12]=oe[13]=oe[14]=0;
			oe[0]=oe[15]=1;
			oe[5]=oe[10]=c;
			oe[6]=s;
			oe[9]=-s;
		}

		Matrix4x4.createRotationY=function(rad,out){
			var oe=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			oe[1]=oe[3]=oe[4]=oe[6]=oe[7]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
			oe[5]=oe[15]=1;
			oe[0]=oe[10]=c;
			oe[2]=-s;
			oe[8]=s;
		}

		Matrix4x4.createRotationZ=function(rad,out){
			var oe=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			oe[2]=oe[3]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
			oe[10]=oe[15]=1;
			oe[0]=oe[5]=c;
			oe[1]=s;
			oe[4]=-s;
		}

		Matrix4x4.createTranslate=function(trans,out){
			var te=trans.elements;
			var oe=out.elements;
			oe[4]=oe[8]=oe[1]=oe[9]=oe[2]=oe[6]=oe[3]=oe[7]=oe[11]=0;
			oe[0]=oe[5]=oe[10]=oe[15]=1;
			oe[12]=te[0];
			oe[13]=te[1];
			oe[14]=te[2];
		}

		Matrix4x4.createScaling=function(scale,out){
			var se=scale.elements;
			var oe=out.elements;
			oe[0]=se[0];
			oe[5]=se[1];
			oe[10]=se[2];
			oe[1]=oe[4]=oe[8]=oe[12]=oe[9]=oe[13]=oe[2]=oe[6]=oe[14]=oe[3]=oe[7]=oe[11]=0;
			oe[15]=1;
		}

		Matrix4x4.multiply=function(left,right,out){
			var i,e,a,b,ai0,ai1,ai2,ai3;
			e=out.elements;
			a=left.elements;
			b=right.elements;
			if (e===b){
				b=new Float32Array(16);
				for (i=0;i < 16;++i){
					b[i]=e[i];
				}
			}
			for (i=0;i < 4;i++){
				ai0=a[i];
				ai1=a[i+4];
				ai2=a[i+8];
				ai3=a[i+12];
				e[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
				e[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
				e[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
				e[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
			}
		}

		Matrix4x4.createFromQuaternion=function(rotation,out){
			var e=out.elements;
			var q=rotation.elements;
			var x=q[0],y=q[1],z=q[2],w=q[3];
			var x2=x+x;
			var y2=y+y;
			var z2=z+z;
			var xx=x *x2;
			var yx=y *x2;
			var yy=y *y2;
			var zx=z *x2;
			var zy=z *y2;
			var zz=z *z2;
			var wx=w *x2;
			var wy=w *y2;
			var wz=w *z2;
			e[0]=1-yy-zz;
			e[1]=yx+wz;
			e[2]=zx-wy;
			e[3]=0;
			e[4]=yx-wz;
			e[5]=1-xx-zz;
			e[6]=zy+wx;
			e[7]=0;
			e[8]=zx+wy;
			e[9]=zy-wx;
			e[10]=1-xx-yy;
			e[11]=0;
			e[12]=0;
			e[13]=0;
			e[14]=0;
			out[15]=1;
		}

		Matrix4x4.createAffineTransformation=function(trans,rot,scale,out){
			var te=trans.elements;
			var re=rot.elements;
			var se=scale.elements;
			var oe=out.elements;
			var x=re[0],y=re[1],z=re[2],w=re[3],x2=x+x,y2=y+y,z2=z+z;
			var xx=x *x2,xy=x *y2,xz=x *z2,yy=y *y2,yz=y *z2,zz=z *z2;
			var wx=w *x2,wy=w *y2,wz=w *z2,sx=se[0],sy=se[1],sz=se[2];
			oe[0]=(1-(yy+zz))*sx;
			oe[1]=(xy+wz)*sx;
			oe[2]=(xz-wy)*sx;
			oe[3]=0;
			oe[4]=(xy-wz)*sy;
			oe[5]=(1-(xx+zz))*sy;
			oe[6]=(yz+wx)*sy;
			oe[7]=0;
			oe[8]=(xz+wy)*sz;
			oe[9]=(yz-wx)*sz;
			oe[10]=(1-(xx+yy))*sz;
			oe[11]=0;
			oe[12]=te[0];
			oe[13]=te[1];
			oe[14]=te[2];
			oe[15]=1;
		}

		Matrix4x4.createLookAt=function(eye,center,up,out){
			var ee=eye.elements;
			var ce=center.elements;
			var ue=up.elements;
			var oe=out.elements;
			var x0,x1,x2,y0,y1,y2,z0,z1,z2,len,eyex=ee[0],eyey=ee[1],eyez=ee[2],upx=ue[0],upy=ue[1],upz=ue[2],centerx=ce[0],centery=ce[1],centerz=ce[2];
			if (Math.abs(eyex-centerx)< MathUtils3D.zeroTolerance && Math.abs(eyey-centery)< MathUtils3D.zeroTolerance && Math.abs(eyez-centerz)< MathUtils3D.zeroTolerance){
				out.identity();
				return;
			}
			z0=eyex-centerx;
			z1=eyey-centery;
			z2=eyez-centerz;
			len=1 / Math.sqrt(z0 *z0+z1 *z1+z2 *z2);
			z0 *=len;
			z1 *=len;
			z2 *=len;
			x0=upy *z2-upz *z1;
			x1=upz *z0-upx *z2;
			x2=upx *z1-upy *z0;
			len=Math.sqrt(x0 *x0+x1 *x1+x2 *x2);
			if (!len){
				x0=x1=x2=0;
				}else {
				len=1 / len;
				x0 *=len;
				x1 *=len;
				x2 *=len;
			}
			y0=z1 *x2-z2 *x1;
			y1=z2 *x0-z0 *x2;
			y2=z0 *x1-z1 *x0;
			len=Math.sqrt(y0 *y0+y1 *y1+y2 *y2);
			if (!len){
				y0=y1=y2=0;
				}else {
				len=1 / len;
				y0 *=len;
				y1 *=len;
				y2 *=len;
			}
			oe[0]=x0;
			oe[1]=y0;
			oe[2]=z0;
			oe[3]=0;
			oe[4]=x1;
			oe[5]=y1;
			oe[6]=z1;
			oe[7]=0;
			oe[8]=x2;
			oe[9]=y2;
			oe[10]=z2;
			oe[11]=0;
			oe[12]=-(x0 *eyex+x1 *eyey+x2 *eyez);
			oe[13]=-(y0 *eyex+y1 *eyey+y2 *eyez);
			oe[14]=-(z0 *eyex+z1 *eyey+z2 *eyez);
			oe[15]=1;
		}

		Matrix4x4.createPerspective=function(fov,aspect,near,far,out){
			var oe=out.elements;
			var f=1.0 / Math.tan(fov / 2),nf=1 / (near-far);
			oe[0]=f / aspect;
			oe[5]=f;
			oe[10]=(far+near)*nf;
			oe[11]=-1;
			oe[14]=(2 *far *near)*nf;
			oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[12]=oe[13]=oe[15]=0;
		}

		Matrix4x4.createOrthogonal=function(left,right,bottom,top,near,far,out){
			var oe=out.elements;
			var lr=1 / (left-right);
			var bt=1 / (bottom-top);
			var nf=1 / (near-far);
			oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=0;
			oe[15]=1;
			oe[0]=-2 *lr;
			oe[5]=-2 *bt;
			oe[10]=2 *nf;
			oe[12]=(left+right)*lr;
			oe[13]=(top+bottom)*bt;
			oe[14]=(far+near)*nf;
		}

		Matrix4x4.TEMP=new Matrix4x4();
		Matrix4x4.DEFAULT=new Matrix4x4();
		return Matrix4x4;
	})()


	/**
	*<code>Plane</code> 类用于创建平面。
	*/
	//class laya.d3.math.Plane
	var Plane=(function(){
		function Plane(normal,d){
			this.normal=null;
			this.distance=NaN;
			(d===void 0)&& (d=0);
			this.normal=normal;
			this.distance=d;
		}

		__class(Plane,'laya.d3.math.Plane');
		var __proto=Plane.prototype;
		/**
		*更改平面法线向量的系数，使之成单位长度。
		*/
		__proto.normalize=function(){
			var normalE=this.normal.elements;
			var normalEX=normalE[0];
			var normalEY=normalE[1];
			var normalEZ=normalE[2];
			var magnitude=1 / Math.sqrt(normalEX *normalEX+normalEY *normalEY+normalEZ *normalEZ);
			normalE[0]=normalEX *magnitude;
			normalE[1]=normalEY *magnitude;
			normalE[2]=normalEZ *magnitude;
			this.distance *=magnitude;
		}

		Plane.createPlaneBy3P=function(point1,point2,point3){
			var point1e=point1.elements;
			var point2e=point2.elements;
			var point3e=point3.elements;
			var x1=point2e[0]-point1e[0];
			var y1=point2e[1]-point1e[1];
			var z1=point2e[2]-point1e[2];
			var x2=point3e[0]-point1e[0];
			var y2=point3e[1]-point1e[1];
			var z2=point3e[2]-point1e[2];
			var yz=(y1 *z2)-(z1 *y2);
			var xz=(z1 *x2)-(x1 *z2);
			var xy=(x1 *y2)-(y1 *x2);
			var invPyth=1 / (Math.sqrt((yz *yz)+(xz *xz)+(xy *xy)));
			var x=yz *invPyth;
			var y=xz *invPyth;
			var z=xy *invPyth;
			var TEMPVec3e=Plane._TEMPVec3.elements;
			TEMPVec3e[0]=x;
			TEMPVec3e[1]=y;
			TEMPVec3e[2]=z;
			var d=-((x *point1e[0])+(y *point1e[1])+(z *point1e[2]));
			var plane=new Plane(Plane._TEMPVec3,d);
			return plane;
		}

		Plane.PlaneIntersectionType_Back=0;
		Plane.PlaneIntersectionType_Front=1;
		Plane.PlaneIntersectionType_Intersecting=2;
		__static(Plane,
		['_TEMPVec3',function(){return this._TEMPVec3=new Vector3();}
		]);
		return Plane;
	})()


	/**
	*<code>Quaternion</code> 类用于创建四元数。
	*/
	//class laya.d3.math.Quaternion
	var Quaternion1=(function(){
		function Quaternion(x,y,z,w){
			this.elements=new Float32Array(4);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(w===void 0)&& (w=1);
			this.elements[0]=x;
			this.elements[1]=y;
			this.elements[2]=z;
			this.elements[3]=w;
		}

		__class(Quaternion,'laya.d3.math.Quaternion',null,'Quaternion1');
		var __proto=Quaternion.prototype;
		/**
		*根据缩放值缩放四元数
		*@param scale 缩放值
		*@param out 输出四元数
		*/
		__proto.scaling=function(scaling,out){
			var e=out.elements;
			var f=this.elements;
			e[0]=f[0] *scaling;
			e[1]=f[1] *scaling;
			e[2]=f[2] *scaling;
			e[3]=f[3] *scaling;
		}

		/**
		*归一化四元数
		*@param out 输出四元数
		*/
		__proto.normalize=function(out){
			var e=out.elements;
			var f=this.elements;
			var x=f[0],y=f[1],z=f[2],w=f[3];
			var len=x *x+y *y+z *z+w *w;
			if (len > 0){
				len=1 / Math.sqrt(len);
				e[0]=x *len;
				e[1]=y *len;
				e[2]=z *len;
				e[3]=w *len;
			}
		}

		/**
		*计算四元数的长度
		*@return 长度
		*/
		__proto.length=function(){
			var f=this.elements;
			var x=f[0],y=f[1],z=f[2],w=f[3];
			return Math.sqrt(x *x+y *y+z *z+w *w);
		}

		/**
		*根据绕X轴的角度旋转四元数
		*@param rad 角度
		*@param out 输出四元数
		*/
		__proto.rotateX=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			rad *=0.5;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3];
			var bx=Math.sin(rad),bw=Math.cos(rad);
			e[0]=ax *bw+aw *bx;
			e[1]=ay *bw+az *bx;
			e[2]=az *bw-ay *bx;
			e[3]=aw *bw-ax *bx;
		}

		/**
		*根据绕Y轴的制定角度旋转四元数
		*@param rad 角度
		*@param out 输出四元数
		*/
		__proto.rotateY=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			rad *=0.5;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3],by=Math.sin(rad),bw=Math.cos(rad);
			e[0]=ax *bw-az *by;
			e[1]=ay *bw+aw *by;
			e[2]=az *bw+ax *by;
			e[3]=aw *bw-ay *by;
		}

		/**
		*根据绕Z轴的制定角度旋转四元数
		*@param rad 角度
		*@param out 输出四元数
		*/
		__proto.rotateZ=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			rad *=0.5;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3],bz=Math.sin(rad),bw=Math.cos(rad);
			e[0]=ax *bw+ay *bz;
			e[1]=ay *bw-ax *bz;
			e[2]=az *bw+aw *bz;
			e[3]=aw *bw-az *bz;
		}

		/**
		*分解四元数到欧拉角（顺序为Yaw、Pitch、Roll），参考自http://xboxforums.create.msdn.com/forums/p/4574/23988.aspx#23988,问题绕X轴翻转超过±90度时有，会产生瞬间反转
		*@param quaternion 源四元数
		*@param out 欧拉角值
		*/
		__proto.getYawPitchRoll=function(out){
			Vector3.transformQuat(Vector3.ForwardRH,this,Quaternion.TEMPVector31);
			Vector3.transformQuat(Vector3.Up,this,Quaternion.TEMPVector32);
			var upe=Quaternion.TEMPVector32.elements;
			Quaternion.angleTo(Vector3.ZERO,Quaternion.TEMPVector31,Quaternion.TEMPVector33);
			var anglee=Quaternion.TEMPVector33.elements;
			if (anglee[0]==Math.PI / 2){
				anglee[1]=Quaternion.arcTanAngle(upe[2],upe[0]);
				anglee[2]=0;
				}else if (anglee[0]==-Math.PI / 2){
				anglee[1]=Quaternion.arcTanAngle(-upe[2],-upe[0]);
				anglee[2]=0;
				}else {
				Matrix4x4.createRotationY(-anglee[1],Quaternion.TEMPMatrix0);
				Matrix4x4.createRotationX(-anglee[0],Quaternion.TEMPMatrix1);
				Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix0,Quaternion.TEMPVector32);
				Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix1,Quaternion.TEMPVector32);
				anglee[2]=Quaternion.arcTanAngle(upe[1],-upe[0]);
			}
			if (anglee[1] <=-Math.PI)
				anglee[1]=Math.PI;
			if (anglee[2] <=-Math.PI)
				anglee[2]=Math.PI;
			if (anglee[1] >=Math.PI && anglee[2] >=Math.PI){
				anglee[1]=0;
				anglee[2]=0;
				anglee[0]=Math.PI-anglee[0];
			};
			var oe=out.elements;
			oe[0]=anglee[1];
			oe[1]=anglee[0];
			oe[2]=anglee[2];
		}

		/**
		*求四元数的逆
		*@param out 输出四元数
		*/
		__proto.invert=function(out){
			var e=out.elements;
			var f=this.elements;
			var a0=f[0],a1=f[1],a2=f[2],a3=f[3];
			var dot=a0 *a0+a1 *a1+a2 *a2+a3 *a3;
			var invDot=dot ? 1.0 / dot :0;
			e[0]=-a0 *invDot;
			e[1]=-a1 *invDot;
			e[2]=-a2 *invDot;
			e[3]=a3 *invDot;
		}

		/**
		*设置四元数为单位算数
		*@param out 输出四元数
		*/
		__proto.identity=function(){
			var e=this.elements;
			e[0]=0;
			e[1]=0;
			e[2]=0;
			e[3]=1;
		}

		/**
		*克隆一个四元数
		*@param out 输出的四元数
		*/
		__proto.cloneTo=function(out){
			var i,s,d;
			s=this.elements;
			d=out.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 4;++i){
				d[i]=s[i];
			}
		}

		/**
		*从一个四元数复制
		*@param sou 源四元数
		*/
		__proto.copyFrom=function(sou){
			var i,s,d;
			s=sou.elements;
			d=this.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 4;++i){
				d[i]=s[i];
			}
		}

		/**
		*从一个数组复制
		*@param sou 源Float32Array数组
		*/
		__proto.copyFromArray=function(sou){
			var i,d;
			d=this.elements;
			if (sou===d){
				return;
			}
			for (i=0;i < 4;++i){
				d[i]=sou[i];
			}
		}

		/**
		*获取四元数的x值
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
		});

		/**
		*获取四元数的y值
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
		});

		/**
		*获取四元数的z值
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
		});

		/**
		*获取四元数的w值
		*/
		__getset(0,__proto,'w',function(){
			return this.elements[3];
		});

		Quaternion.createFromYawPitchRoll=function(yaw,pitch,roll,out){
			var halfRoll=roll *0.5;
			var halfPitch=pitch *0.5;
			var halfYaw=yaw *0.5;
			var sinRoll=Math.sin(halfRoll);
			var cosRoll=Math.cos(halfRoll);
			var sinPitch=Math.sin(halfPitch);
			var cosPitch=Math.cos(halfPitch);
			var sinYaw=Math.sin(halfYaw);
			var cosYaw=Math.cos(halfYaw);
			var oe=out.elements;
			oe[0]=(cosYaw *sinPitch *cosRoll)+(sinYaw *cosPitch *sinRoll);
			oe[1]=(sinYaw *cosPitch *cosRoll)-(cosYaw *sinPitch *sinRoll);
			oe[2]=(cosYaw *cosPitch *sinRoll)-(sinYaw *sinPitch *cosRoll);
			oe[3]=(cosYaw *cosPitch *cosRoll)+(sinYaw *sinPitch *sinRoll);
		}

		Quaternion.multiply=function(left,right,out){
			var le=left.elements;
			var re=right.elements;
			var oe=out.elements;
			var lx=le[0];
			var ly=le[1];
			var lz=le[2];
			var lw=le[3];
			var rx=re[0];
			var ry=re[1];
			var rz=re[2];
			var rw=re[3];
			var a=(ly *rz-lz *ry);
			var b=(lz *rx-lx *rz);
			var c=(lx *ry-ly *rx);
			var d=(lx *rx+ly *ry+lz *rz);
			oe[0]=(lx *rw+rx *lw)+a;
			oe[1]=(ly *rw+ry *lw)+b;
			oe[2]=(lz *rw+rz *lw)+c;
			oe[3]=lw *rw-d;
		}

		Quaternion.arcTanAngle=function(x,y){
			if (x==0){
				if (y==1)
					return Math.PI / 2;
				return-Math.PI / 2;
			}
			if (x > 0)
				return Math.atan(y / x);
			if (x < 0){
				if (y > 0)
					return Math.atan(y / x)+Math.PI;
				return Math.atan(y / x)-Math.PI;
			}
			return 0;
		}

		Quaternion.angleTo=function(from,location,angle){
			Vector3.subtract(location,from,Quaternion.TEMPVector30);
			Vector3.normalize(Quaternion.TEMPVector30,Quaternion.TEMPVector30);
			angle.elements[0]=Math.asin(Quaternion.TEMPVector30.y);
			angle.elements[1]=Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z,-Quaternion.TEMPVector30.x);
		}

		Quaternion.createFromAxisAngle=function(axis,rad,out){
			var e=out.elements;
			var f=axis.elements;
			rad=rad *0.5;
			var s=Math.sin(rad);
			e[0]=s *f[0];
			e[1]=s *f[1];
			e[2]=s *f[2];
			e[3]=Math.cos(rad);
		}

		Quaternion.createFromMatrix3x3=function(sou,out){
			var e=out.elements;
			var f=sou.elements;
			var fTrace=f[0]+f[4]+f[8];
			var fRoot;
			if (fTrace > 0.0){
				fRoot=Math.sqrt(fTrace+1.0);
				e[3]=0.5 *fRoot;
				fRoot=0.5 / fRoot;
				e[0]=(f[5]-f[7])*fRoot;
				e[1]=(f[6]-f[2])*fRoot;
				e[2]=(f[1]-f[3])*fRoot;
				}else {
				var i=0;
				if (f[4] > f[0])
					i=1;
				if (f[8] > f[i *3+i])
					i=2;
				var j=(i+1)% 3;
				var k=(i+2)% 3;
				fRoot=Math.sqrt(f[i *3+i]-f[j *3+j]-f[k *3+k]+1.0);
				e[i]=0.5 *fRoot;
				fRoot=0.5 / fRoot;
				e[3]=(f[j *3+k]-f[k *3+j])*fRoot;
				e[j]=(f[j *3+i]+f[i *3+j])*fRoot;
				e[k]=(f[k *3+i]+f[i *3+k])*fRoot;
			}
			return;
		}

		Quaternion.createFromMatrix4x4=function(mat,out){
			var me=mat.elements;
			var oe=out.elements;
			var sqrt;
			var half;
			var scale=me[0]+me[5]+me[10];
			if (scale > 0.0){
				sqrt=Math.sqrt(scale+1.0);
				oe[3]=sqrt *0.5;
				sqrt=0.5 / sqrt;
				oe[0]=(me[6]-me[9])*sqrt;
				oe[1]=(me[8]-me[2])*sqrt;
				oe[2]=(me[1]-me[4])*sqrt;
				}else if ((me[0] >=me[5])&& (me[0] >=me[10])){
				sqrt=Math.sqrt(1.0+me[0]-me[5]-me[10]);
				half=0.5 / sqrt;
				oe[0]=0.5 *sqrt;
				oe[1]=(me[1]+me[4])*half;
				oe[2]=(me[2]+me[8])*half;
				oe[3]=(me[6]-me[9])*half;
				}else if (me[5] > me[10]){
				sqrt=Math.sqrt(1.0+me[5]-me[0]-me[10]);
				half=0.5 / sqrt;
				oe[0]=(me[4]+me[1])*half;
				oe[1]=0.5 *sqrt;
				oe[2]=(me[9]+me[6])*half;
				oe[3]=(me[8]-me[2])*half;
				}else {
				sqrt=Math.sqrt(1.0+me[10]-me[0]-me[5]);
				half=0.5 / sqrt;
				oe[0]=(me[8]+me[2])*half;
				oe[1]=(me[9]+me[6])*half;
				oe[2]=0.5 *sqrt;
				oe[3]=(me[1]-me[4])*half;
			}
		}

		Quaternion.slerp=function(left,right,t,out){
			var a=left.elements;
			var b=right.elements;
			var oe=out.elements;
			var ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3];
			var omega,cosom,sinom,scale0,scale1;
			cosom=ax *bx+ay *by+az *bz+aw *bw;
			if (cosom < 0.0){
				cosom=-cosom;
				bx=-bx;
				by=-by;
				bz=-bz;
				bw=-bw;
			}
			if ((1.0-cosom)> 0.000001){
				omega=Math.acos(cosom);
				sinom=Math.sin(omega);
				scale0=Math.sin((1.0-t)*omega)/ sinom;
				scale1=Math.sin(t *omega)/ sinom;
				}else {
				scale0=1.0-t;
				scale1=t;
			}
			oe[0]=scale0 *ax+scale1 *bx;
			oe[1]=scale0 *ay+scale1 *by;
			oe[2]=scale0 *az+scale1 *bz;
			oe[3]=scale0 *aw+scale1 *bw;
			return oe;
		}

		Quaternion.lerp=function(left,right,t,out){
			var e=out.elements;
			var f=left.elements;
			var g=right.elements;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
			e[3]=aw+t *(g[3]-aw);
		}

		Quaternion.add=function(left,right,out){
			var e=out.elements;
			var f=left.elements;
			var g=right.elements;
			e[0]=f[0]+g[0];
			e[1]=f[1]+g[1];
			e[2]=f[2]+g[2];
			e[3]=f[3]+g[3];
		}

		Quaternion.dot=function(left,right){
			var f=left.elements;
			var g=right.elements;
			return f[0] *g[0]+f[1] *g[1]+f[2] *g[2]+f[3] *g[3];
		}

		Quaternion.DEFAULT=new Quaternion();
		__static(Quaternion,
		['TEMPVector30',function(){return this.TEMPVector30=new Vector3();},'TEMPVector31',function(){return this.TEMPVector31=new Vector3();},'TEMPVector32',function(){return this.TEMPVector32=new Vector3();},'TEMPVector33',function(){return this.TEMPVector33=new Vector3();},'TEMPMatrix0',function(){return this.TEMPMatrix0=new Matrix4x4();},'TEMPMatrix1',function(){return this.TEMPMatrix1=new Matrix4x4();}
		]);
		return Quaternion;
	})()


	/**
	*<code>Ray</code> 类用于创建射线。
	*/
	//class laya.d3.math.Ray
	var Ray1=(function(){
		function Ray(origin,direction){
			this.origin=null;
			this.direction=null;
			this.origin=origin;
			this.direction=direction;
		}

		__class(Ray,'laya.d3.math.Ray',null,'Ray1');
		return Ray;
	})()


	/**
	*<code>Vector2</code> 类用于创建二维向量。
	*/
	//class laya.d3.math.Vector2
	var Vector2=(function(){
		function Vector2(x,y){
			this.elements=new Float32Array(2);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			var v=this.elements;
			v[0]=x;
			v[1]=y;
		}

		__class(Vector2,'laya.d3.math.Vector2');
		var __proto=Vector2.prototype;
		/**
		*从一个克隆二维向量克隆。
		*@param v 源二维向量。
		*/
		__proto.clone=function(v){
			var out=this.elements,s=v.elements;
			out[0]=s[0];
			out[1]=s[1];
		}

		/**
		*获取X轴坐标。
		*@return x X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
		});

		/**
		*获取Y轴坐标。
		*@return y Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
		});

		__static(Vector2,
		['ZERO',function(){return this.ZERO=new Vector2(0.0,0.0);},'ONE',function(){return this.ONE=new Vector2(1.0,1.0);}
		]);
		return Vector2;
	})()


	/**
	*<code>Vector3</code> 类用于创建三维向量。
	*/
	//class laya.d3.math.Vector3
	var Vector3=(function(){
		function Vector3(x,y,z){
			this.elements=new Float32Array(3);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			var v=this.elements;
			v[0]=x;
			v[1]=y;
			v[2]=z;
		}

		__class(Vector3,'laya.d3.math.Vector3');
		var __proto=Vector3.prototype;
		/**
		*从一个三维向量复制。
		*@param v 源向量。
		*/
		__proto.copyFrom=function(v){
			var e=this.elements,s=v.elements;
			e[0]=s[0];
			e[1]=s[1];
			e[2]=s[2];
			return this;
		}

		/**
		*克隆三维向量。
		*@return 输出三维向量。
		*/
		__proto.clone=function(){
			var out=new Vector3();
			var oe=out.elements,s=this.elements;
			oe[0]=s[0];
			oe[1]=s[1];
			oe[2]=s[2];
			return out;
		}

		/**
		*克隆三维向量。
		*@param dest 输出三维向量。
		*/
		__proto.cloneTo=function(dest){
			var oe=dest.elements,s=this.elements;
			oe[0]=s[0];
			oe[1]=s[1];
			oe[2]=s[2];
		}

		__proto.toDefault=function(){
			this.elements[0]=0;
			this.elements[1]=0;
			this.elements[2]=0;
		}

		/**
		*设置X轴坐标。
		*@param x X轴坐标。
		*/
		/**
		*获取X轴坐标。
		*@return x X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
			},function(value){
			this.elements[0]=value;
		});

		/**
		*设置Y轴坐标。
		*@param y Y轴坐标。
		*/
		/**
		*获取Y轴坐标。
		*@return y Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
			},function(value){
			this.elements[1]=value;
		});

		/**
		*设置Z轴坐标。
		*@param z Z轴坐标。
		*/
		/**
		*获取Z轴坐标。
		*@return z Z轴坐标。
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
			},function(value){
			this.elements[2]=value;
		});

		Vector3.distanceSquared=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			return (x *x)+(y *y)+(z *z);
		}

		Vector3.min=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.min(f[0],g[0]);
			e[1]=Math.min(f[1],g[1]);
			e[2]=Math.min(f[2],g[2]);
		}

		Vector3.max=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.max(f[0],g[0]);
			e[1]=Math.max(f[1],g[1]);
			e[2]=Math.max(f[2],g[2]);
		}

		Vector3.transformQuat=function(source,rotation,out){
			var destination=out.elements;
			var se=source.elements;
			var re=rotation.elements;
			var x=se[0],y=se[1],z=se[2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],
			ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
			destination[0]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
			destination[1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
			destination[2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
		}

		Vector3.scalarLength=function(a){
			var f=a.elements;
			var x=f[0],y=f[1],z=f[2];
			return Math.sqrt(x *x+y *y+z *z);
		}

		Vector3.normalize=function(s,out){
			var se=s.elements;
			var oe=out.elements;
			var x=se[0],y=se[1],z=se[2];
			var len=x *x+y *y+z *z;
			if (len > 0){
				len=1 / Math.sqrt(len);
				oe[0]=se[0] *len;
				oe[1]=se[1] *len;
				oe[2]=se[2] *len;
			}
		}

		Vector3.multiply=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=f[0] *g[0];
			e[1]=f[1] *g[1];
			e[2]=f[2] *g[2];
		}

		Vector3.scale=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			e[0]=f[0] *b;
			e[1]=f[1] *b;
			e[2]=f[2] *b;
		}

		Vector3.lerp=function(a,b,t,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements;
			var ax=f[0],ay=f[1],az=f[2];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
		}

		Vector3.transformV3ToV3=function(vector,transform,result){
			var intermediate=new Vector4();
			Vector3.transformV3ToV4(vector,transform,intermediate);
			var intermediateElem=intermediate.elements;
			var resultElem=result.elements;
			resultElem[0]=intermediateElem[0];
			resultElem[1]=intermediateElem[1];
			resultElem[2]=intermediateElem[2];
		}

		Vector3.transformV3ToV4=function(vector,transform,result){
			var vectorElem=vector.elements;
			var vectorX=vectorElem[0];
			var vectorY=vectorElem[1];
			var vectorZ=vectorElem[2];
			var transformElem=transform.elements;
			var resultElem=result.elements;
			resultElem[0]=(vectorX *transformElem[0])+(vectorY *transformElem[4])+(vectorZ *transformElem[8])+transformElem[12];
			resultElem[1]=(vectorX *transformElem[1])+(vectorY *transformElem[5])+(vectorZ *transformElem[9])+transformElem[13];
			resultElem[2]=(vectorX *transformElem[2])+(vectorY *transformElem[6])+(vectorZ *transformElem[10])+transformElem[14];
			resultElem[3]=(vectorX *transformElem[3])+(vectorY *transformElem[7])+(vectorZ *transformElem[11])+transformElem[15];
		}

		Vector3.transformCoordinate=function(coordinate,transform,result){
			var vectorElem=Vector3.TEMPVec4.elements;
			var coordinateElem=coordinate.elements;
			var coordinateX=coordinateElem[0];
			var coordinateY=coordinateElem[1];
			var coordinateZ=coordinateElem[2];
			var transformElem=transform.elements;
			vectorElem[0]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12];
			vectorElem[1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13];
			vectorElem[2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14];
			vectorElem[3]=1.0 / ((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
			var resultElem=result.elements;
			resultElem[0]=vectorElem[0] *vectorElem[3];
			resultElem[1]=vectorElem[1] *vectorElem[3];
			resultElem[2]=vectorElem[2] *vectorElem[3];
		}

		Vector3.Clamp=function(value,min,max,out){
			var valuee=value.elements;
			var x=valuee[0];
			var y=valuee[1];
			var z=valuee[2];
			var mine=min.elements;
			var mineX=mine[0];
			var mineY=mine[1];
			var mineZ=mine[2];
			var maxe=max.elements;
			var maxeX=maxe[0];
			var maxeY=maxe[1];
			var maxeZ=maxe[2];
			var oute=out.elements;
			x=(x > maxeX)? maxeX :x;
			x=(x < mineX)? mineX :x;
			y=(y > maxeY)? maxeY :y;
			y=(y < mineY)? mineY :y;
			z=(z > maxeZ)? maxeZ :z;
			z=(z < mineZ)? mineZ :z;
			oute[0]=x;
			oute[1]=y;
			oute[2]=z;
		}

		Vector3.add=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=f[0]+g[0];
			e[1]=f[1]+g[1];
			e[2]=f[2]+g[2];
		}

		Vector3.subtract=function(a,b,o){
			var oe=o.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0]-be[0];
			oe[1]=ae[1]-be[1];
			oe[2]=ae[2]-be[2];
		}

		Vector3.cross=function(a,b,o){
			var ae=a.elements;
			var be=b.elements;
			var oe=o.elements;
			var ax=ae[0],ay=ae[1],az=ae[2],bx=be[0],by=be[1],bz=be[2];
			oe[0]=ay *bz-az *by;
			oe[1]=az *bx-ax *bz;
			oe[2]=ax *by-ay *bx;
		}

		Vector3.dot=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2]);
			return r;
		}

		__static(Vector3,
		['TEMPVec4',function(){return this.TEMPVec4=new Vector4();},'ZERO',function(){return this.ZERO=new Vector3(0.0,0.0,0.0);},'ONE',function(){return this.ONE=new Vector3(1.0,1.0,1.0);},'UnitX',function(){return this.UnitX=new Vector3(1,0,0);},'UnitY',function(){return this.UnitY=new Vector3(0,1,0);},'UnitZ',function(){return this.UnitZ=new Vector3(0,0,1);},'ForwardRH',function(){return this.ForwardRH=new Vector3(0,0,-1);},'ForwardLH',function(){return this.ForwardLH=new Vector3(0,0,1);},'Up',function(){return this.Up=new Vector3(0,1,0);}
		]);
		return Vector3;
	})()


	/**
	*<code>Vector4</code> 类用于创建四维向量。
	*/
	//class laya.d3.math.Vector4
	var Vector4=(function(){
		function Vector4(x,y,z,w){
			this.elements=new Float32Array(4);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(w===void 0)&& (w=0);
			var v=this.elements;
			v[0]=x;
			v[1]=y;
			v[2]=z;
			v[3]=w;
		}

		__class(Vector4,'laya.d3.math.Vector4');
		var __proto=Vector4.prototype;
		/**
		*从一个四维向量复制。
		*@param v 源向量。
		*/
		__proto.copyFrom=function(v){
			var e=this.elements,s=v.elements;
			e[0]=s[0];
			e[1]=s[1];
			e[2]=s[2];
			e[3]=s[3];
			return this;
		}

		/**
		*获取X轴坐标。
		*@return x X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
		});

		/**
		*获取Y轴坐标。
		*@return y Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
		});

		/**
		*获取Z轴坐标。
		*@return z Z轴坐标。
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
		});

		/**
		*获取W轴坐标。
		*@return w W轴坐标。
		*/
		__getset(0,__proto,'w',function(){
			return this.elements[3];
		});

		Vector4.lerp=function(a,b,t,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
			e[3]=aw+t *(g[3]-aw);
		}

		__static(Vector4,
		['ZERO',function(){return this.ZERO=new Vector4();}
		]);
		return Vector4;
	})()


	/**
	*<code>Viewport</code> 类用于创建视口。
	*/
	//class laya.d3.math.Viewport
	var Viewport=(function(){
		function Viewport(x,y,width,height){
			//this.x=NaN;
			//this.y=NaN;
			//this.width=NaN;
			//this.height=NaN;
			//this.minDepth=NaN;
			//this.maxDepth=NaN;
			this.minDepth=-1.0;
			this.maxDepth=1.0;
			this.x=x;
			this.y=y;
			this.width=width;
			this.height=height;
		}

		__class(Viewport,'laya.d3.math.Viewport');
		var __proto=Viewport.prototype;
		/**
		*变换一个三维向量。
		*@param source 源三维向量。
		*@param matrix 变换矩阵。
		*@param vector 输出三维向量。
		*/
		__proto.project=function(source,matrix,out){
			Vector3.transformV3ToV3(source,matrix,out);
			var sourceEleme=source.elements;
			var matrixEleme=matrix.elements;
			var outEleme=out.elements;
			var a=(((sourceEleme[0] *matrixEleme[3])+(sourceEleme[1] *matrixEleme[7]))+(sourceEleme[2] *matrixEleme[11]))+matrixEleme[15];
			if (a!==1.0){
				outEleme[0]=outEleme[0] / a;
				outEleme[1]=outEleme[1] / a;
				outEleme[2]=outEleme[2] / a;
			}
			outEleme[0]=(((outEleme[0]+1.0)*0.5)*this.width)+this.x;
			outEleme[1]=(((-outEleme[1]+1.0)*0.5)*this.height)+this.y;
			outEleme[2]=(outEleme[2] *(this.maxDepth-this.minDepth))+this.minDepth;
		}

		/**
		*反变换一个三维向量。
		*@param source 源三维向量。
		*@param matrix 变换矩阵。
		*@param vector 输出三维向量。
		*/
		__proto.unprojectFromMat=function(source,matrix,out){
			var sourceEleme=source.elements;
			var matrixEleme=matrix.elements;
			var outEleme=out.elements;
			outEleme[0]=(((sourceEleme[0]-this.x)/ (this.width))*2.0)-1.0;
			outEleme[1]=-((((sourceEleme[1]-this.y)/ (this.height))*2.0)-1.0);
			var halfDepth=(this.maxDepth-this.minDepth)/ 2;
			outEleme[2]=(sourceEleme[2]-this.minDepth-halfDepth)/ halfDepth;
			var a=(((outEleme[0] *matrixEleme[3])+(outEleme[1] *matrixEleme[7]))+(outEleme[2] *matrixEleme[11]))+matrixEleme[15];
			Vector3.transformV3ToV3(out,matrix,out);
			if (a!==1.0){
				outEleme[0]=outEleme[0] / a;
				outEleme[1]=outEleme[1] / a;
				outEleme[2]=outEleme[2] / a;
			}
		}

		/**
		*反变换一个三维向量。
		*@param source 源三维向量。
		*@param projection 透视投影矩阵。
		*@param view 视图矩阵。
		*@param world 世界矩阵,可设置为null。
		*@param out 输出向量。
		*/
		__proto.unprojectFromWVP=function(source,projection,view,world,out){
			Matrix4x4.multiply(projection,view,Viewport._tempMatrix4x4);
			(world)&& (Matrix4x4.multiply(Viewport._tempMatrix4x4,world,Viewport._tempMatrix4x4));
			Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4);
			this.unprojectFromMat(source,Viewport._tempMatrix4x4,out);
		}

		__static(Viewport,
		['_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();}
		]);
		return Viewport;
	})()


	/**
	*@private
	*<code>SubMesh</code> 类用于创建子网格数据模板。
	*/
	//class laya.d3.resource.models.SubMesh
	var SubMesh=(function(){
		function SubMesh(mesh){
			this._ib=null;
			this._materialIndex=-1;
			this._numberIndices=0;
			this._vb=null;
			this._mesh=null;
			this._boneIndex=null;
			this._bufferUsage={};
			this._finalBufferUsageDic=null;
			this._isVertexbaked=false;
			this._indexOfHost=0;
			this.verticesIndices=null;
			this._mesh=mesh;
		}

		__class(SubMesh,'laya.d3.resource.models.SubMesh');
		var __proto=SubMesh.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true,"laya.resource.IDispose":true})
		__proto.getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vb;
			else
			return null;
		}

		__proto.getIndexBuffer=function(){
			return this._ib;
		}

		/**
		*@private
		*/
		__proto._getShader=function(state,vertexBuffer,material){
			if (!material)
				return null;
			var def=0;
			var shaderAttribute=vertexBuffer.vertexDeclaration.shaderAttribute;
			(shaderAttribute.UV)&& (def |=material.shaderDef);
			(shaderAttribute.COLOR)&& (def |=0x20);
			(state.scene.enableFog)&& (def |=0x20000);
			def > 0 && state.shaderDefs.addInt(def);
			var shader=material.getShader(state);
			return shader;
		}

		/**
		*@private
		*渲染。
		*@param state 渲染状态。
		*/
		__proto._render=function(state){
			var mesh=this._mesh,vb=this._vb,ib=this._ib;
			var material=this.getMaterial((state.owner).meshRender.shadredMaterials);
			if (material.normalTexture && !vb.vertexDeclaration.shaderAttribute["TANGENT0"]){
				var vertexDatas=vb.getData();
				var newVertexDatas=Utils3D.generateTangent(vertexDatas,vb.vertexDeclaration.vertexStride / 4,vb.vertexDeclaration.shaderAttribute["POSITION"][4] / 4,vb.vertexDeclaration.shaderAttribute["UV"][4] / 4,ib.getData());
				var vertexDeclaration=Utils3D.getVertexTangentDeclaration(vb.vertexDeclaration.getVertexElements());
				var newVB=VertexBuffer3D.create(vertexDeclaration,0x88E4);
				newVB.setData(newVertexDatas);
				vb.dispose();
				vb=this._vb=newVB;
				this._bufferUsage["TANGENT0"]=newVB;
			}
			if (ib===null)return false;
			vb._bind();
			ib._bind();
			if (material){
				var shader=this._getShader(state,vb,material);
				var presz=state.shaderValue.length;
				state.shaderValue.pushArray(vb.vertexDeclaration.shaderValues);
				var meshSprite=state.owner;
				var worldMat=meshSprite.transform.worldMatrix;
				state.shaderValue.pushValue("MATRIX1",worldMat.elements,-1);
				Matrix4x4.multiply(state.projectionViewMatrix,worldMat,state.owner.wvpMatrix);
				state.shaderValue.pushValue("MVPMATRIX",meshSprite.wvpMatrix.elements,-1);
				if (!material.upload(state,this._finalBufferUsageDic,shader)){
					state.shaderValue.length=presz;
					return false;
				}
				state.shaderValue.length=presz;
			}
			state.context.drawElements(0x0004,this._numberIndices,0x1403,0);
			Stat.drawCall++;
			Stat.trianglesFaces+=this._numberIndices / 3;
			return true;
		}

		/**
		*@private
		*/
		__proto._setBoneDic=function(boneDic){
			this._boneIndex=boneDic;
			this._mesh.disableUseFullBone();
		}

		/**
		*获取材质。
		*@param 材质队列。
		*@return 材质。
		*/
		__proto.getMaterial=function(materials){
			return this._materialIndex >=0 ? materials[this._materialIndex] :null;
		}

		/**
		*设置索引缓冲。
		*@param value 索引缓冲。
		*@param elementCount 索引的个数。
		*/
		__proto.setIB=function(value,elementCount){
			this._ib=value;
			this._numberIndices=elementCount;
		}

		/**
		*获取索引缓冲。
		*@return 索引缓冲。
		*/
		__proto.getIB=function(){
			return this._ib;
		}

		/**
		*设置顶点缓冲。
		*@param vb 顶点缓冲。
		*/
		__proto.setVB=function(vb){
			this._vb=vb;
		}

		/**
		*获取顶点缓冲。
		*@return 顶点缓冲。
		*/
		__proto.getVB=function(){
			return this._vb;
		}

		__proto.getBakedVertexs=function(index,transform){
			if (index===0){
				var byteSizeInFloat=4;
				var vb=this._vb;
				var bakedVertexes=vb.getData().slice();
				var vertexDeclaration=vb.vertexDeclaration;
				var positionOffset=vertexDeclaration.shaderAttribute["POSITION"][4] / byteSizeInFloat;
				var normalOffset=vertexDeclaration.shaderAttribute["NORMAL"][4] / byteSizeInFloat;
				for (var i=0;i < bakedVertexes.length;i+=vertexDeclaration.vertexStride / byteSizeInFloat){
					var posOffset=i+positionOffset;
					var norOffset=i+normalOffset;
					Utils3D.transformVector3ArrayToVector3ArrayCoordinate(bakedVertexes,posOffset,transform,bakedVertexes,posOffset);
					Utils3D.transformVector3ArrayToVector3ArrayCoordinate(bakedVertexes,normalOffset,transform,bakedVertexes,normalOffset);
				}
				this._isVertexbaked=true;
				return bakedVertexes;
			}else
			return null;
		}

		__proto.getBakedIndices=function(){
			return this._ib.getData();
		}

		/**
		*<p>彻底清理资源。</p>
		*<p><b>注意：</b>会强制解锁清理。</p>
		*/
		__proto.dispose=function(){
			this._mesh=null;
			this._boneIndex=null;
			this._ib.dispose();
			this._vb.dispose();
		}

		__getset(0,__proto,'VertexBufferCount',function(){
			return 1;
		});

		/**
		*获取在宿主中的序列。
		*@return 序列。
		*/
		__getset(0,__proto,'indexOfHost',function(){
			return this._indexOfHost;
		});

		/**
		*设置材质
		*@param value 材质ID。
		*/
		/**
		*获取材质
		*@return 材质ID。
		*/
		__getset(0,__proto,'material',function(){
			return this._materialIndex;
			},function(value){
			this._materialIndex=value;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._ib.indexCount/3;
		});

		return SubMesh;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.shader.ShaderDefines
	var ShaderDefines=(function(){
		function ShaderDefines(name2int,int2name,int2nameMap){
			this._value=0;
			//this._name2int=null;
			//this._int2name=null;
			//this._int2nameMap=null;
			this._name2int=name2int;
			this._int2name=int2name;
			this._int2nameMap=int2nameMap;
		}

		__class(ShaderDefines,'laya.webgl.shader.ShaderDefines');
		var __proto=ShaderDefines.prototype;
		__proto.add=function(value){
			if ((typeof value=='string'))value=this._name2int[value];
			this._value |=value;
			return this._value;
		}

		__proto.addInt=function(value){
			this._value |=value;
			return this._value;
		}

		__proto.remove=function(value){
			if ((typeof value=='string'))value=this._name2int[value];
			this._value &=(~value);
			return this._value;
		}

		__proto.isDefine=function(def){
			return (this._value & def)===def;
		}

		__proto.getValue=function(){
			return this._value;
		}

		__proto.setValue=function(value){
			this._value=value;
		}

		__proto.toNameDic=function(){
			var r=this._int2nameMap[this._value];
			return r?r:ShaderDefines._toText(this._value,this._int2name,this._int2nameMap);
		}

		ShaderDefines._reg=function(name,value,_name2int,_int2name){
			_name2int[name]=value;
			_int2name[value]=name;
		}

		ShaderDefines._toText=function(value,_int2name,_int2nameMap){
			var r=_int2nameMap[value];
			if (r)return r;
			var o={};
			var d=1;
			for (var i=0;i < 32;i++){
				d=1 << i;
				if (d > value)break ;
				if (value & d){
					var name=_int2name[d];
					name && (o[name]="");
				}
			}
			_int2nameMap[value]=o;
			return o;
		}

		ShaderDefines._toInt=function(names,_name2int){
			var words=names.split('.');
			var num=0;
			for (var i=0,n=words.length;i < n;i++){
				var value=_name2int[words[i]];
				if (!value)throw new Error("Defines to int err:"+names+"/"+words[i]);
				num |=value;
			}
			return num;
		}

		return ShaderDefines;
	})()


	//class laya.d3.utils.Size
	var Size=(function(){
		function Size(width,height){
			this._width=0;
			this._height=0;
			this._width=width;
			this._height=height;
		}

		__class(Size,'laya.d3.utils.Size');
		var __proto=Size.prototype;
		__getset(0,__proto,'width',function(){
			if (this._width===-1)
				return RenderState.clientWidth;
			return this._width;
		});

		__getset(0,__proto,'height',function(){
			if (this._height===-1)
				return RenderState.clientHeight;
			return this._height;
		});

		__getset(1,Size,'fullScreen',function(){
			return new Size(-1,-1);
		});

		return Size;
	})()


	/**
	*<code>Utils3D</code> 类用于创建3D工具。
	*/
	//class laya.d3.utils.Utils3D
	var Utils3D=(function(){
		function Utils3D(){};
		__class(Utils3D,'laya.d3.utils.Utils3D');
		Utils3D._getTexturePath=function(path){
			var extenIndex=path.length-4;
			if (path.indexOf(".dds")==extenIndex || path.indexOf(".tga")==extenIndex || path.indexOf(".exr")==extenIndex || path.indexOf(".DDS")==extenIndex || path.indexOf(".TGA")==extenIndex || path.indexOf(".EXR")==extenIndex)
				path=path.substr(0,extenIndex)+".png";
			return path=URL.formatURL(path);
		}

		Utils3D._rotationTransformScaleSkinAnimation=function(tx,ty,tz,qx,qy,qz,qw,sx,sy,sz,outArray,outOffset){
			var re=Utils3D._tempArray16_0;
			var se=Utils3D._tempArray16_1;
			var tse=Utils3D._tempArray16_2;
			var x2=qx+qx;
			var y2=qy+qy;
			var z2=qz+qz;
			var xx=qx *x2;
			var yx=qy *x2;
			var yy=qy *y2;
			var zx=qz *x2;
			var zy=qz *y2;
			var zz=qz *z2;
			var wx=qw *x2;
			var wy=qw *y2;
			var wz=qw *z2;
			re[15]=1;
			re[0]=1-yy-zz;
			re[1]=yx+wz;
			re[2]=zx-wy;
			re[4]=yx-wz;
			re[5]=1-xx-zz;
			re[6]=zy+wx;
			re[8]=zx+wy;
			re[9]=zy-wx;
			re[10]=1-xx-yy;
			se[15]=1;
			se[0]=sx;
			se[5]=sy;
			se[10]=sz;
			var i,a,b,e,ai0,ai1,ai2,ai3;
			for (i=0;i < 4;i++){
				ai0=re[i];
				ai1=re[i+4];
				ai2=re[i+8];
				ai3=re[i+12];
				tse[i]=ai0;
				tse[i+4]=ai1;
				tse[i+8]=ai2;
				tse[i+12]=ai0 *tx+ai1 *ty+ai2 *tz+ai3;
			}
			for (i=0;i < 4;i++){
				ai0=tse[i];
				ai1=tse[i+4];
				ai2=tse[i+8];
				ai3=tse[i+12];
				outArray[i+outOffset]=ai0 *se[0]+ai1 *se[1]+ai2 *se[2]+ai3 *se[3];
				outArray[i+outOffset+4]=ai0 *se[4]+ai1 *se[5]+ai2 *se[6]+ai3 *se[7];
				outArray[i+outOffset+8]=ai0 *se[8]+ai1 *se[9]+ai2 *se[10]+ai3 *se[11];
				outArray[i+outOffset+12]=ai0 *se[12]+ai1 *se[13]+ai2 *se[14]+ai3 *se[15];
			}
		}

		Utils3D._parseHierarchyProp=function(node,prop,value){
			switch (prop){
				case "translate":
					node.transform.localPosition=new Vector3(value[0],value[1],value[2]);
					break ;
				case "rotation":
					node.transform.localRotation=new Quaternion1(value[0],value[1],value[2],value[3]);
					break ;
				case "scale":
					node.transform.localScale=new Vector3(value[0],value[1],value[2]);
					break ;
				}
		}

		Utils3D._parseHierarchyNode=function(instanceParams){
			if (instanceParams)
				return new MeshSprite3D(Mesh.load(instanceParams.loadPath));
			else
			return new Sprite3D1();
		}

		Utils3D._parseMaterial=function(material,prop,value){
			switch (prop){
				case "ambientColor":
					material.ambientColor=new Vector3(value[0],value[1],value[2]);
					break ;
				case "diffuseColor":
					material.diffuseColor=new Vector3(value[0],value[1],value[2]);
					break ;
				case "specularColor":
					material.specularColor=new Vector4(value[0],value[1],value[2],value[3]);
					break ;
				case "reflectColor":
					material.reflectColor=new Vector3(value[0],value[1],value[2]);
					break ;
				case "diffuseTexture":
					(value.texture2D)&& (Laya.loader.load(Utils3D._getTexturePath(value.texture2D),Handler.create(null,function(tex){
						(tex.bitmap).enableMerageInAtlas=false;
						(tex.bitmap).mipmap=true;
						(tex.bitmap).repeat=true;
						material.diffuseTexture=tex;
					})));
					break ;
				case "normalTexture":
					(value.texture2D)&& (Laya.loader.load(Utils3D._getTexturePath(value.texture2D),Handler.create(null,function(tex){
						(tex.bitmap).enableMerageInAtlas=false;
						(tex.bitmap).mipmap=true;
						(tex.bitmap).repeat=true;
						material.normalTexture=tex;
					})));
					break ;
				case "specularTexture":
					(value.texture2D)&& (Laya.loader.load(Utils3D._getTexturePath(value.texture2D),Handler.create(null,function(tex){
						(tex.bitmap).enableMerageInAtlas=false;
						(tex.bitmap).mipmap=true;
						(tex.bitmap).repeat=true;
						material.specularTexture=tex;
					})));
					break ;
				case "emissiveTexture":
					(value.texture2D)&& (Laya.loader.load(Utils3D._getTexturePath(value.texture2D),Handler.create(null,function(tex){
						(tex.bitmap).enableMerageInAtlas=false;
						(tex.bitmap).mipmap=true;
						(tex.bitmap).repeat=true;
						material.emissiveTexture=tex;
					})));
					break ;
				case "ambientTexture":
					(value.texture2D)&& (Laya.loader.load(Utils3D._getTexturePath(value.texture2D),Handler.create(null,function(tex){
						(tex.bitmap).enableMerageInAtlas=false;
						(tex.bitmap).mipmap=true;
						(tex.bitmap).repeat=true;
						material.ambientTexture=tex;
					})));
					break ;
				case "reflectTexture":
					(value.texture2D)&& (Laya.loader.load(Utils3D._getTexturePath(value.texture2D),Handler.create(null,function(tex){
						(tex.bitmap).enableMerageInAtlas=false;
						(tex.bitmap).mipmap=true;
						(tex.bitmap).repeat=true;
						material.reflectTexture=tex;
					})));
					break ;
				}
		}

		Utils3D._computeSkinAnimationData=function(bones,curData,exData,bonesDatas,animationDatas){
			var offset=0;
			var matOffset=0;
			var len=exData.length / 2;
			var i;
			var parentOffset;
			var boneLength=bones.length;
			for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
				laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+7],curData[offset+8],curData[offset+9],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+0],curData[offset+1],curData[offset+2],bonesDatas,matOffset);
				if (i !=0){
					parentOffset=bones[i].parentIndex *16;
					laya.d3.utils.Utils3D.mulMatrixByArray(bonesDatas,parentOffset,bonesDatas,matOffset,bonesDatas,matOffset);
				}
			}
			for (i=0;i < len;i+=16){
				laya.d3.utils.Utils3D.mulMatrixByArrayFast(bonesDatas,i,exData,len+i,animationDatas,i);
			}
		}

		Utils3D._computeRootAnimationData=function(bones,curData,animationDatas){
			for (var i=0,offset=0,matOffset=0,boneLength=bones.length;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++)
			laya.d3.utils.Utils3D.createAffineTransformationArray(curData[offset+0],curData[offset+1],curData[offset+2],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+7],curData[offset+8],curData[offset+9],animationDatas,matOffset);
		}

		Utils3D.generateTangent=function(vertexDatas,vertexStride,positionOffset,uvOffset,indices){
			var tangentElementCount=3;
			var newVertexStride=vertexStride+tangentElementCount;
			var tangentVertexDatas=new Float32Array(newVertexStride *(vertexDatas.length / vertexStride));
			for (var i=0;i < indices.length;i+=3){
				var index1=indices[i+0];
				var index2=indices[i+1];
				var index3=indices[i+2];
				var position1Offset=vertexStride *index1+positionOffset;
				var position1=Utils3D._tempVector3_0;
				position1.x=vertexDatas[position1Offset+0];
				position1.y=vertexDatas[position1Offset+1];
				position1.z=vertexDatas[position1Offset+2];
				var position2Offset=vertexStride *index2+positionOffset;
				var position2=Utils3D._tempVector3_1;
				position2.x=vertexDatas[position2Offset+0];
				position2.y=vertexDatas[position2Offset+1];
				position2.z=vertexDatas[position2Offset+2];
				var position3Offset=vertexStride *index3+positionOffset;
				var position3=Utils3D._tempVector3_2;
				position3.x=vertexDatas[position3Offset+0];
				position3.y=vertexDatas[position3Offset+1];
				position3.z=vertexDatas[position3Offset+2];
				var uv1Offset=vertexStride *index1+uvOffset;
				var UV1X=vertexDatas[uv1Offset+0];
				var UV1Y=vertexDatas[uv1Offset+1];
				var uv2Offset=vertexStride *index2+uvOffset;
				var UV2X=vertexDatas[uv2Offset+0];
				var UV2Y=vertexDatas[uv2Offset+1];
				var uv3Offset=vertexStride *index3+uvOffset;
				var UV3X=vertexDatas[uv3Offset+0];
				var UV3Y=vertexDatas[uv3Offset+1];
				var lengthP2ToP1=Utils3D._tempVector3_3;
				Vector3.subtract(position2,position1,lengthP2ToP1);
				var lengthP3ToP1=Utils3D._tempVector3_4;
				Vector3.subtract(position3,position1,lengthP3ToP1);
				Vector3.scale(lengthP2ToP1,UV3Y-UV1Y,lengthP2ToP1);
				Vector3.scale(lengthP3ToP1,UV2Y-UV1Y,lengthP3ToP1);
				var tangent=Utils3D._tempVector3_5;
				Vector3.subtract(lengthP2ToP1,lengthP3ToP1,tangent);
				Vector3.scale(tangent,1.0 / ((UV2X-UV1X)*(UV3Y-UV1Y)-(UV2Y-UV1Y)*(UV3X-UV1X)),tangent);
				var j=0;
				for (j=0;j < vertexStride;j++)
				tangentVertexDatas[newVertexStride *index1+j]=vertexDatas[vertexStride *index1+j];
				for (j=0;j < tangentElementCount;j++)
				tangentVertexDatas[newVertexStride *index1+vertexStride+j]=+tangent.elements[j];
				for (j=0;j < vertexStride;j++)
				tangentVertexDatas[newVertexStride *index2+j]=vertexDatas[vertexStride *index2+j];
				for (j=0;j < tangentElementCount;j++)
				tangentVertexDatas[newVertexStride *index2+vertexStride+j]=+tangent.elements[j];
				for (j=0;j < vertexStride;j++)
				tangentVertexDatas[newVertexStride *index3+j]=vertexDatas[vertexStride *index3+j];
				for (j=0;j < tangentElementCount;j++)
				tangentVertexDatas[newVertexStride *index3+vertexStride+j]=+tangent.elements[j];
			}
			for (i=0;i < tangentVertexDatas.length;i+=newVertexStride){
				var tangentStartIndex=newVertexStride *i+vertexStride;
				var t=Utils3D._tempVector3_6;
				t.x=tangentVertexDatas[tangentStartIndex+0];
				t.y=tangentVertexDatas[tangentStartIndex+1];
				t.z=tangentVertexDatas[tangentStartIndex+2];
				Vector3.normalize(t,t);
				tangentVertexDatas[tangentStartIndex+0]=t.x;
				tangentVertexDatas[tangentStartIndex+1]=t.y;
				tangentVertexDatas[tangentStartIndex+2]=t.z;
			}
			return tangentVertexDatas;
		}

		Utils3D.getVertexTangentDeclaration=function(vertexElements){
			var position=false,normal=false,color=false,texcoord=false,blendWeight=false,blendIndex=false;
			for (var i=0;i < vertexElements.length;i++){
				switch ((vertexElements [i]).elementUsage){
					case "POSITION":
						position=true;
						break ;
					case "NORMAL":
						normal=true;
						break ;
					case "COLOR":
						color=true;
						break ;
					case "UV":
						texcoord=true;
						break ;
					case "BLENDWEIGHT":
						blendWeight=true;
						break ;
					case "BLENDINDICES":
						blendIndex=true;
						break ;
					}
			};
			var vertexDeclaration;
			if (position && normal && color && texcoord && blendWeight && blendIndex)
				vertexDeclaration=VertexPositionNormalColorTextureSkinTangent.vertexDeclaration;
			else if (position && normal && texcoord && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalTextureSkinTangent.vertexDeclaration;
			else if (position && normal && color && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorSkinTangent.vertexDeclaration;
			else if (position && normal && color && texcoord)
			vertexDeclaration=VertexPositionNormalColorTextureTangent.vertexDeclaration;
			else if (position && normal && texcoord)
			vertexDeclaration=VertexPositionNormalTextureTangent.vertexDeclaration;
			else if (position && normal && color)
			vertexDeclaration=VertexPositionNormalColorTangent.vertexDeclaration;
			return vertexDeclaration;
		}

		Utils3D.mulMatrixByArray=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
			var i,ai0,ai1,ai2,ai3;
			if (outArray===rightArray){
				rightArray=Utils3D._tempArray16_3;
				for (i=0;i < 16;++i){
					rightArray[i]=outArray[outOffset+i];
				}
				rightOffset=0;
			}
			for (i=0;i < 4;i++){
				ai0=leftArray[leftOffset+i];
				ai1=leftArray[leftOffset+i+4];
				ai2=leftArray[leftOffset+i+8];
				ai3=leftArray[leftOffset+i+12];
				outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
				outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
				outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
				outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
			}
		}

		Utils3D.mulMatrixByArrayFast=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
			var i,ai0,ai1,ai2,ai3;
			for (i=0;i < 4;i++){
				ai0=leftArray[leftOffset+i];
				ai1=leftArray[leftOffset+i+4];
				ai2=leftArray[leftOffset+i+8];
				ai3=leftArray[leftOffset+i+12];
				outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
				outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
				outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
				outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
			}
		}

		Utils3D.createAffineTransformationArray=function(tX,tY,tZ,rX,rY,rZ,rW,sX,sY,sZ,outArray,outOffset){
			var x2=rX+rX,y2=rY+rY,z2=rZ+rZ;
			var xx=rX *x2,xy=rX *y2,xz=rX *z2,yy=rY *y2,yz=rY *z2,zz=rZ *z2;
			var wx=rW *x2,wy=rW *y2,wz=rW *z2;
			outArray[outOffset+0]=(1-(yy+zz))*sX;
			outArray[outOffset+1]=(xy+wz)*sX;
			outArray[outOffset+2]=(xz-wy)*sX;
			outArray[outOffset+3]=0;
			outArray[outOffset+4]=(xy-wz)*sY;
			outArray[outOffset+5]=(1-(xx+zz))*sY;
			outArray[outOffset+6]=(yz+wx)*sY;
			outArray[outOffset+7]=0;
			outArray[outOffset+8]=(xz+wy)*sZ;
			outArray[outOffset+9]=(yz-wx)*sZ;
			outArray[outOffset+10]=(1-(xx+yy))*sZ;
			outArray[outOffset+11]=0;
			outArray[outOffset+12]=tX;
			outArray[outOffset+13]=tY;
			outArray[outOffset+14]=tZ;
			outArray[outOffset+15]=1;
		}

		Utils3D.transformVector3ArrayToVector3ArrayCoordinate=function(source,sourceOffset,transform,result,resultOffset){
			var vectorElem=Utils3D._tempArray4_0;
			var coordinateX=source[sourceOffset+0];
			var coordinateY=source[sourceOffset+1];
			var coordinateZ=source[sourceOffset+2];
			var transformElem=transform.elements;
			vectorElem[0]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12];
			vectorElem[1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13];
			vectorElem[2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14];
			vectorElem[3]=1.0 / ((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
			result[resultOffset+0]=vectorElem[0] *vectorElem[3];
			result[resultOffset+1]=vectorElem[1] *vectorElem[3];
			result[resultOffset+2]=vectorElem[2] *vectorElem[3];
		}

		Utils3D.convert3DCoordTo2DScreenCoord=function(source,out){
			var se=source.elements;
			var oe=out.elements;
			oe[0]=-RenderState.clientWidth / 2+se[0];
			oe[1]=RenderState.clientHeight / 2-se[1];
			oe[2]=se[2];
		}

		Utils3D._tempVector3_0=new Vector3();
		Utils3D._tempVector3_1=new Vector3();
		Utils3D._tempVector3_2=new Vector3();
		Utils3D._tempVector3_3=new Vector3();
		Utils3D._tempVector3_4=new Vector3();
		Utils3D._tempVector3_5=new Vector3();
		Utils3D._tempVector3_6=new Vector3();
		Utils3D._tempArray4_0=new Float32Array(4);
		Utils3D._tempArray16_0=new Float32Array(16);
		Utils3D._tempArray16_1=new Float32Array(16);
		Utils3D._tempArray16_2=new Float32Array(16);
		Utils3D._tempArray16_3=new Float32Array(16);
		__static(Utils3D,
		['_typeToFunO',function(){return this._typeToFunO={"INT16":"writeInt16","SHORT":"writeInt16","UINT16":"writeUint16","UINT32":"writeUint32","FLOAT32":"writeFloat32","INT":"writeInt32","UINT":"writeUint32","BYTE":"writeByte","STRING":"writeUTFString"};}
		]);
		return Utils3D;
	})()


	/**
	*<code>BitmapFont</code> 是位图字体类，用于定义位图字体信息。
	*/
	//class laya.display.BitmapFont
	var BitmapFont=(function(){
		function BitmapFont(){
			this.fontSize=12;
			this.autoScaleSize=false;
			this._texture=null;
			this._fontCharDic={};
			this._complete=null;
			this._path=null;
			this._maxHeight=0;
			this._maxWidth=0;
			this._spaceWidth=10;
			this._leftPadding=0;
			this._rightPadding=0;
			this._letterSpacing=0;
		}

		__class(BitmapFont,'laya.display.BitmapFont');
		var __proto=BitmapFont.prototype;
		/**
		*通过指定位图字体文件路径，加载位图字体文件。
		*@param path 位图字体文件的路径。
		*@param complete 加载完成的回调，通知上层字体文件已经完成加载并解析。
		*/
		__proto.loadFont=function(path,complete){
			this._path=path;
			this._complete=complete;
			Laya.loader.load([{url:this._path,type:"xml"},{url:this._path.replace(".fnt",".png"),type:"image"}],Handler.create(this,this.onLoaded));
		}

		__proto.onLoaded=function(){
			this.parseFont(Loader.getRes(this._path),Loader.getRes(this._path.replace(".fnt",".png")));
			this._complete && this._complete.run();
		}

		/**
		*解析字体文件。
		*@param xml 字体文件XML。
		*@param texture 字体的纹理。
		*/
		__proto.parseFont=function(xml,texture){
			if (xml==null || texture==null)return;
			this._texture=texture;
			var tX=0;
			var tScale=1;
			var tInfo=xml.getElementsByTagName("info");
			this.fontSize=parseInt(tInfo[0].attributes["size"].nodeValue);
			var tPadding=tInfo[0].attributes["padding"].nodeValue;
			var tPaddingArray=tPadding.split(",");
			var tUpPadding=parseInt(tPaddingArray[0]);
			var tDownPadding=parseInt(tPaddingArray[2]);
			this._leftPadding=parseInt(tPaddingArray[3]);
			this._rightPadding=parseInt(tPaddingArray[1]);
			var chars=xml.getElementsByTagName("char");
			var i=0;
			for (i=0;i < chars.length;i++){
				var tAttribute=chars[i].attributes;
				var tId=parseInt(tAttribute["id"].nodeValue);
				var xOffset=parseInt(tAttribute["xoffset"].nodeValue)/ tScale;
				var yOffset=parseInt(tAttribute["yoffset"].nodeValue)/ tScale;
				var xAdvance=parseInt(tAttribute["xadvance"].nodeValue)/ tScale;
				var region=new Rectangle();
				region.x=parseInt(tAttribute["x"].nodeValue);
				region.y=parseInt(tAttribute["y"].nodeValue);
				region.width=parseInt(tAttribute["width"].nodeValue);
				region.height=parseInt(tAttribute["height"].nodeValue);
				var tTexture=Texture.create(texture,region.x,region.y,region.width,region.height,xOffset,yOffset);
				this._maxHeight=Math.max(this._maxHeight,tUpPadding+tDownPadding+tTexture.height);
				this._maxWidth=Math.max(this._maxWidth,tTexture.width);
				this._fontCharDic[tId]=tTexture;
			}
			if (this.getCharTexture(" "))this.setSpaceWidth(this.getCharWidth(" "));
		}

		/**
		*获取指定字符的字体纹理对象。
		*@param char 字符。
		*@return 指定的字体纹理对象。
		*/
		__proto.getCharTexture=function(char){
			return this._fontCharDic[char.charCodeAt(0)];
		}

		/**
		*销毁位图字体，调用Text.unregisterBitmapFont 时，默认会销毁。
		*/
		__proto.destroy=function(){
			var tTexture=null;
			for (var p in this._fontCharDic){
				tTexture=this._fontCharDic[p];
				if (tTexture)tTexture.destroy();
				delete this._fontCharDic[p];
			}
			this._texture.destroy();
		}

		/**
		*设置空格的宽（如果字体库有空格，这里就可以不用设置了）。
		*@param spaceWidth 宽度，单位为像素。
		*/
		__proto.setSpaceWidth=function(spaceWidth){
			this._spaceWidth=spaceWidth;
		}

		/**
		*获取指定字符的宽度。
		*@param char 字符。
		*@return 宽度。
		*/
		__proto.getCharWidth=function(char){
			if (char==" ")return this._spaceWidth+this._letterSpacing;
			var tTexture=this.getCharTexture(char)
			if (tTexture)return tTexture.width+tTexture.offsetX *2+this._letterSpacing;
			return 0;
		}

		/**
		*获取指定文本内容的宽度。
		*@param text 文本内容。
		*@return 宽度。
		*/
		__proto.getTextWidth=function(text){
			var tWidth=0;
			for (var i=0,n=text.length;i < n;i++){
				tWidth+=this.getCharWidth(text.charAt(i));
			}
			return tWidth;
		}

		/**
		*获取最大字符宽度。
		*/
		__proto.getMaxWidth=function(){
			return this._maxWidth+this._letterSpacing;
		}

		/**
		*获取最大字符高度。
		*/
		__proto.getMaxHeight=function(){
			return this._maxHeight;
		}

		/**
		*@private
		*将指定的文本绘制到指定的显示对象上。
		*/
		__proto.drawText=function(text,sprite,drawX,drawY,align,width){
			var tWidth=0;
			var tTexture;
			for (var i=0,n=text.length;i < n;i++){
				tWidth+=this.getCharWidth(text.charAt(i));
			};
			var dx=this._leftPadding;
			align==="center" && (dx=(width-tWidth)/ 2);
			align==="right" && (dx=(width-tWidth)-this._rightPadding);
			var tX=0;
			for (i=0,n=text.length;i < n;i++){
				tTexture=this.getCharTexture(text.charAt(i));
				if (tTexture)sprite.graphics.drawTexture(tTexture,drawX+tX+dx,drawY,tTexture.width,tTexture.height);
				tX+=this.getCharWidth(text.charAt(i));
			}
		}

		/**
		*设置字符之间的间距（以像素为单位）。
		*/
		/**
		*获取字符之间的间距（以像素为单位）。
		*/
		__getset(0,__proto,'letterSpacing',function(){
			return this._letterSpacing;
			},function(value){
			this._letterSpacing=value;
		});

		return BitmapFont;
	})()


	/**
	*@private
	*<code>Style</code> 类是元素样式定义类。
	*/
	//class laya.display.css.Style
	var Style=(function(){
		function Style(){
			this.alpha=1;
			this.visible=true;
			this.scrollRect=null;
			this.blendMode=null;
			this._type=0;
			this._tf=Style._TF_EMPTY;
		}

		__class(Style,'laya.display.css.Style');
		var __proto=Style.prototype;
		__proto.getTransform=function(){
			return this._tf;
		}

		__proto.setTransform=function(value){
			this._tf=value==='none' || !value ? Style._TF_EMPTY :value;
		}

		__proto.setTranslateX=function(value){
			this._tf===Style._TF_EMPTY && (this._tf=Style._createTransform());
			this._tf.translateX=value;
		}

		__proto.setTranslateY=function(value){
			this._tf===Style._TF_EMPTY && (this._tf=Style._createTransform());
			this._tf.translateY=value;
		}

		__proto.setScaleX=function(value){
			this._tf===Style._TF_EMPTY && (this._tf=Style._createTransform());
			this._tf.scaleX=value;
		}

		__proto.setScaleY=function(value){
			this._tf===Style._TF_EMPTY && (this._tf=Style._createTransform());
			this._tf.scaleY=value;
		}

		__proto.setRotate=function(value){
			this._tf===Style._TF_EMPTY && (this._tf=Style._createTransform());
			this._tf.rotate=value;
		}

		__proto.setSkewX=function(value){
			this._tf===Style._TF_EMPTY && (this._tf=Style._createTransform());
			this._tf.skewX=value;
		}

		__proto.setSkewY=function(value){
			this._tf===Style._TF_EMPTY && (this._tf=Style._createTransform());
			this._tf.skewY=value;
		}

		/**销毁此对象。*/
		__proto.destroy=function(){
			this.scrollRect=null;
		}

		/**@private */
		__proto.render=function(sprite,context,x,y){}
		/**@private */
		__proto.getCSSStyle=function(){
			return CSSStyle.EMPTY;
		}

		/**@private */
		__proto._enableLayout=function(){
			return false;
		}

		/**表示元素是否显示为块级元素。*/
		__getset(0,__proto,'block',function(){
			return (this._type & 0x1)!=0;
		});

		/**表示元素的上内边距。*/
		__getset(0,__proto,'paddingTop',function(){
			return 0;
		});

		/**X 轴缩放值。*/
		__getset(0,__proto,'scaleX',function(){
			return this._tf.scaleX;
			},function(value){
			this.setScaleX(value);
		});

		/**Y 轴缩放值。*/
		__getset(0,__proto,'scaleY',function(){
			return this._tf.scaleY;
			},function(value){
			this.setScaleY(value);
		});

		/**元素应用的 2D 或 3D 转换的值。该属性允许我们对元素进行旋转、缩放、移动或倾斜。*/
		__getset(0,__proto,'transform',function(){
			return this.getTransform();
			},function(value){
			this.setTransform(value);
		});

		/**定义转换，只是用 X 轴的值。*/
		__getset(0,__proto,'translateX',function(){
			return this._tf.translateX;
			},function(value){
			this.setTranslateX(value);
		});

		/**定义转换，只是用 Y 轴的值。*/
		__getset(0,__proto,'translateY',function(){
			return this._tf.translateY;
			},function(value){
			this.setTranslateY(value);
		});

		/**定义旋转角度。*/
		__getset(0,__proto,'rotate',function(){
			return this._tf.rotate;
			},function(value){
			this.setRotate(value);
		});

		/**定义沿着 X 轴的 2D 倾斜转换。*/
		__getset(0,__proto,'skewX',function(){
			return this._tf.skewX;
			},function(value){
			this.setSkewX(value);
		});

		/**定义沿着 Y 轴的 2D 倾斜转换。*/
		__getset(0,__proto,'skewY',function(){
			return this._tf.skewY;
			},function(value){
			this.setSkewY(value);
		});

		/**是否为绝对定位。*/
		__getset(0,__proto,'absolute',function(){
			return true;
		});

		/**表示元素的左内边距。*/
		__getset(0,__proto,'paddingLeft',function(){
			return 0;
		});

		Style.__init__=function(){
			Style._TF_EMPTY=Style._createTransform();
			Style.EMPTY=new Style();
		}

		Style._createTransform=function(){
			return {translateX:0,translateY:0,scaleX:1,scaleY:1,rotate:0,skewX:0,skewY:0};
		}

		Style.EMPTY=null
		Style._TF_EMPTY=null
		return Style;
	})()


	/**
	*@private
	*<code>Font</code> 类是字体显示定义类。
	*/
	//class laya.display.css.Font
	var Font=(function(){
		function Font(src){
			this._type=0;
			this._weight=0;
			this._decoration=null;
			this._text=null;
			this.indent=0;
			this._color=Color.create(Font.defaultColor);
			this.family=Font.defaultFamily;
			this.stroke=Font._STROKE;
			this.size=Font.defaultSize;
			src && src!==Font.EMPTY && src.copyTo(this);
		}

		__class(Font,'laya.display.css.Font');
		var __proto=Font.prototype;
		/**
		*字体样式字符串。
		*/
		__proto.set=function(value){
			this._text=null;
			var strs=value.split(' ');
			for (var i=0,n=strs.length;i < n;i++){
				var str=strs[i];
				switch (str){
					case 'italic':
						this.italic=true;
						continue ;
					case 'bold':
						this.bold=true;
						continue ;
					}
				if (str.indexOf('px')> 0){
					this.size=parseInt(str);
					this.family=strs[i+1];
					i++;
					continue ;
				}
			}
		}

		/**
		*返回字体样式字符串。
		*@return 字体样式字符串。
		*/
		__proto.toString=function(){
			this._text=""
			this.italic && (this._text+="italic ");
			this.bold && (this._text+="bold ");
			return this._text+=this.size+"px "+this.family;
		}

		/**
		*将当前的属性值复制到传入的 <code>Font</code> 对象。
		*@param dec 一个 Font 对象。
		*/
		__proto.copyTo=function(dec){
			dec._type=this._type;
			dec._text=this._text;
			dec._weight=this._weight;
			dec._color=this._color;
			dec.family=this.family;
			dec.stroke=this.stroke !=Font._STROKE ? this.stroke.slice():Font._STROKE;
			dec.indent=this.indent;
			dec.size=this.size;
		}

		/**
		*表示颜色字符串。
		*/
		__getset(0,__proto,'color',function(){
			return this._color.strColor;
			},function(value){
			this._color=Color.create(value);
		});

		/**
		*规定添加到文本的修饰。
		*/
		__getset(0,__proto,'decoration',function(){
			return this._decoration ? this._decoration.value :"none";
			},function(value){
			var strs=value.split(' ');
			this._decoration || (this._decoration={});
			switch (strs[0]){
				case '_':
					this._decoration.type='underline'
					break ;
				case '-':
					this._decoration.type='line-through'
					break ;
				case 'overline':
					this._decoration.type='overline'
					break ;
				default :
					this._decoration.type=strs[0];
				}
			strs[1] && (this._decoration.color=Color.create(strs));
			this._decoration.value=value;
		});

		/**
		*表示是否为斜体。
		*/
		__getset(0,__proto,'italic',function(){
			return (this._type & 0x200)!==0;
			},function(value){
			value ? (this._type |=0x200):(this._type &=~0x200);
		});

		/**
		*表示是否为粗体。
		*/
		__getset(0,__proto,'bold',function(){
			return (this._type & 0x800)!==0;
			},function(value){
			value ? (this._type |=0x800):(this._type &=~0x800);
		});

		/**
		*表示是否为密码格式。
		*/
		__getset(0,__proto,'password',function(){
			return (this._type & 0x400)!==0;
			},function(value){
			value ? (this._type |=0x400):(this._type &=~0x400);
		});

		/**
		*文本的粗细。
		*/
		__getset(0,__proto,'weight',function(){
			return ""+this._weight;
			},function(value){
			var weight=0;
			switch (value){
				case 'normal':
					break ;
				case 'bold':
					this.bold=true;
					weight=700;
					break ;
				case 'bolder':
					weight=800;
					break ;
				case 'lighter':
					weight=100;
					break ;
				default :
					weight=parseInt(value);
				}
			this._weight=weight;
			this._text=null;
		});

		Font.__init__=function(){
			Font.EMPTY=new Font(null);
		}

		Font.EMPTY=null
		Font.defaultColor="#000000";
		Font.defaultSize=12;
		Font.defaultFamily="Arial";
		Font.defaultFont="12px Arial";
		Font._STROKE=[0,"#000000"];
		Font._ITALIC=0x200;
		Font._PASSWORD=0x400;
		Font._BOLD=0x800;
		return Font;
	})()


	/**
	*<p><code>KeyBoardManager</code> 是键盘事件管理类。</p>
	*<p>该类从浏览器中接收键盘事件，并派发该事件。
	*派发事件时若 Stage.focus 为空则只从 Stage 上派发该事件，否则将从 Stage.focus 对象开始一直冒泡派发该事件。
	*所以在 Laya.stage 上监听键盘事件一定能够收到，如果在其他地方监听，则必须处在Stage.focus的冒泡链上才能收到该事件。</p>
	*<p>用户可以通过代码 Laya.stage.focus=someNode 的方式来设置focus对象。</p>
	*<p>用户可统一的根据事件对象中 e.keyCode 来判断按键类型，该属性兼容了不同浏览器的实现。</p>
	*/
	//class laya.events.KeyBoardManager
	var KeyBoardManager=(function(){
		function KeyBoardManager(){};
		__class(KeyBoardManager,'laya.events.KeyBoardManager');
		KeyBoardManager.__init__=function(){
			KeyBoardManager._addEvent("keydown");
			KeyBoardManager._addEvent("keypress");
			KeyBoardManager._addEvent("keyup");
		}

		KeyBoardManager._addEvent=function(type){
			Browser.document.addEventListener(type,function(e){
				laya.events.KeyBoardManager._dispatch(e,type);
			},true);
		}

		KeyBoardManager._dispatch=function(e,type){
			if (!KeyBoardManager.enabled)return;
			KeyBoardManager._event._stoped=false;
			KeyBoardManager._event.nativeEvent=e;
			KeyBoardManager._event.keyCode=e.keyCode || e.which || e.charCode;
			if (type==="keydown")KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode]=true;
			else if (type==="keyup")KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode]=null;
			var target=(Laya.stage.focus && (Laya.stage.focus.event !=null))? Laya.stage.focus :Laya.stage;
			var ct=target;
			while (ct){
				ct.event(type,KeyBoardManager._event.setTo(type,ct,target));
				ct=ct.parent;
			}
		}

		KeyBoardManager.hasKeyDown=function(key){
			return KeyBoardManager._pressKeys[key];
		}

		KeyBoardManager._pressKeys={};
		KeyBoardManager.enabled=true;
		__static(KeyBoardManager,
		['_event',function(){return this._event=new Event();}
		]);
		return KeyBoardManager;
	})()


	/**
	*<code>MouseManager</code> 是鼠标、触摸交互管理器。
	*/
	//class laya.events.MouseManager
	var MouseManager=(function(){
		function MouseManager(){
			this.mouseX=0;
			this.mouseY=0;
			this.disableMouseEvent=false;
			this.mouseDownTime=0;
			this._stage=null;
			this._target=null;
			this._lastOvers=[];
			this._currOvers=[];
			this._lastClickTimer=0;
			this._lastMoveTimer=0;
			this._isDoubleClick=false;
			this._isLeftMouse=false;
			this._eventList=[];
			this._event=new Event();
			this._matrix=new Matrix();
			this._point=new Point();
			this._rect=new Rectangle();
		}

		__class(MouseManager,'laya.events.MouseManager');
		var __proto=MouseManager.prototype;
		/**
		*@private
		*初始化。
		*/
		__proto.__init__=function(stage,canvas){
			this._stage=stage;
			var _this=this;
			var list=this._eventList;
			canvas.oncontextmenu=function (e){
				if (MouseManager.enabled)return false;
			}
			canvas.addEventListener('mousedown',function(e){
				if (MouseManager.enabled){
					e.preventDefault();
					list.push(e);
					_this.mouseDownTime=Browser.now();
				}
			});
			canvas.addEventListener('mouseup',function(e){
				if (MouseManager.enabled){
					e.preventDefault();
					list.push(e);
					_this.mouseDownTime=-Browser.now();
				}
			},true);
			canvas.addEventListener('mousemove',function(e){
				if (MouseManager.enabled){
					e.preventDefault();
					var now=Browser.now();
					if (now-_this._lastMoveTimer < 10)return;
					_this._lastMoveTimer=now;
					list.push(e);
				}
			},true);
			canvas.addEventListener("mouseout",function(e){
				if (MouseManager.enabled)list.push(e);
			})
			canvas.addEventListener("mouseover",function(e){
				if (MouseManager.enabled)list.push(e);
			})
			canvas.addEventListener("touchstart",function(e){
				if (MouseManager.enabled){
					if(!Input.IOS_IFRAME)e.preventDefault();
					list.push(e);
					_this.mouseDownTime=Browser.now();
				}
			});
			canvas.addEventListener("touchend",function(e){
				if (MouseManager.enabled){
					if(!Input.IOS_IFRAME)e.preventDefault();
					list.push(e);
					_this.mouseDownTime=-Browser.now();
				}
			},true);
			canvas.addEventListener("touchmove",function(e){
				if (MouseManager.enabled){
					e.preventDefault();
					list.push(e);
				}
			},true);
			canvas.addEventListener('mousewheel',function(e){
				if (MouseManager.enabled)list.push(e);
			});
			canvas.addEventListener('DOMMouseScroll',function(e){
				if (MouseManager.enabled)list.push(e);
			});
		}

		__proto.initEvent=function(e,nativeEvent){
			var _this=this;
			_this._event._stoped=false;
			_this._event.nativeEvent=nativeEvent || e;
			_this._target=null;
			this._point.setTo(e.clientX,e.clientY);
			this._stage._canvasTransform.invertTransformPoint(this._point);
			_this.mouseX=this._point.x;
			_this.mouseY=this._point.y;
			_this._event.touchId=e.identifier;
		}

		__proto.checkMouseWheel=function(e){
			this._event.delta=e.wheelDelta ? e.wheelDelta *0.025 :-e.detail;
			for (var i=0,n=this._lastOvers.length;i < n;i++){
				var ele=this._lastOvers[i];
				ele.event("mousewheel",this._event.setTo("mousewheel",ele,this._target));
			}
		}

		__proto.checkMouseOut=function(){
			if (this.disableMouseEvent)return;
			for (var i=0,n=this._lastOvers.length;i < n;i++){
				var ele=this._lastOvers[i];
				if (!ele.destroyed && this._currOvers.indexOf(ele)< 0){
					ele._set$P("$_MOUSEOVER",false);
					ele.event("mouseout",this._event.setTo("mouseout",ele,this._target));
				}
			};
			var temp=this._lastOvers;
			this._lastOvers=this._currOvers;
			this._currOvers=temp;
			this._currOvers.length=0;
		}

		__proto.onMouseMove=function(ele){
			this.sendMouseMove(ele);
			this._event._stoped=false;
			this.sendMouseOver(this._target);
		}

		__proto.sendMouseMove=function(ele){
			ele.event("mousemove",this._event.setTo("mousemove",ele,this._target));
			!this._event._stoped && ele.parent && this.sendMouseMove(ele.parent);
		}

		__proto.sendMouseOver=function(ele){
			if (ele.parent){
				if (!ele._get$P("$_MOUSEOVER")){
					ele._set$P("$_MOUSEOVER",true);
					ele.event("mouseover",this._event.setTo("mouseover",ele,this._target));
				}
				this._currOvers.push(ele);
			}
			!this._event._stoped && ele.parent && this.sendMouseOver(ele.parent);
		}

		__proto.onMouseDown=function(ele){
			if (this._isLeftMouse){
				ele._set$P("$_MOUSEDOWN",true);
				ele.event("mousedown",this._event.setTo("mousedown",ele,this._target));
				}else {
				ele._set$P("$_RIGHTMOUSEDOWN",true);
				ele.event("rightmousedown",this._event.setTo("rightmousedown",ele,this._target));
			}
			!this._event._stoped && ele.parent && this.onMouseDown(ele.parent);
		}

		__proto.onMouseUp=function(ele){
			var type=this._isLeftMouse ? "mouseup" :"rightmouseup";
			this.sendMouseUp(ele,type);
			this._event._stoped=false;
			this.sendClick(this._target,type);
		}

		__proto.sendMouseUp=function(ele,type){
			ele.event(type,this._event.setTo(type,ele,this._target));
			!this._event._stoped && ele.parent && this.sendMouseUp(ele.parent,type);
		}

		__proto.sendClick=function(ele,type){
			if (ele.destroyed)return;
			if (type==="mouseup" && ele._get$P("$_MOUSEDOWN")){
				ele._set$P("$_MOUSEDOWN",false);
				ele.event("click",this._event.setTo("click",ele,this._target));
				this._isDoubleClick && ele.event("doubleclick",this._event.setTo("doubleclick",ele,this._target));
				}else if (type==="rightmouseup" && ele._get$P("$_RIGHTMOUSEDOWN")){
				ele._set$P("$_RIGHTMOUSEDOWN",false);
				ele.event("rightclick",this._event.setTo("rightclick",ele,this._target));
			}
			!this._event._stoped && ele.parent && this.sendClick(ele.parent,type);
		}

		__proto.check=function(sp,mouseX,mouseY,callBack){
			var transform=sp.transform || this._matrix;
			var pivotX=sp.pivotX;
			var pivotY=sp.pivotY;
			if (pivotX===0 && pivotY===0){
				transform.setTranslate(sp.x,sp.y);
				}else {
				if (transform===this._matrix){
					transform.setTranslate(sp.x-pivotX,sp.y-pivotY);
					}else {
					var cos=transform.cos;
					var sin=transform.sin;
					transform.setTranslate(sp.x-(pivotX *cos-pivotY *sin)*sp.scaleX,sp.y-(pivotX *sin+pivotY *cos)*sp.scaleY);
				}
			}
			transform.invertTransformPoint(this._point.setTo(mouseX,mouseY));
			transform.setTranslate(0,0);
			mouseX=this._point.x;
			mouseY=this._point.y;
			var scrollRect=sp.scrollRect;
			if (scrollRect){
				this._rect.setTo(0,0,scrollRect.width,scrollRect.height);
				var isHit=this._rect.contains(mouseX,mouseY);
				if (!isHit)return false;
			}
			if (!this.disableMouseEvent){
				var flag=false;
				if (sp.hitTestPrior && !sp.mouseThrough && !this.hitTest(sp,mouseX,mouseY)){
					return false;
				}
				for (var i=sp._childs.length-1;i >-1;i--){
					var child=sp._childs[i];
					if (!child.destroyed && child.mouseEnabled && child.visible){
						flag=this.check(child,mouseX+(scrollRect ? scrollRect.x :0),mouseY+(scrollRect ? scrollRect.y :0),callBack);
						if (flag)return true;
					}
				}
			}
			isHit=this.hitTest(sp,mouseX,mouseY);
			if (isHit){
				this._target=sp;
				callBack.call(this,sp);
				}else if (callBack===this.onMouseUp && sp===this._stage){
				this._target=this._stage;
				callBack.call(this,this._target);
			}
			return isHit;
		}

		__proto.hitTest=function(sp,mouseX,mouseY){
			var isHit=false;
			if ((sp.hitArea instanceof laya.utils.HitArea )){
				return sp.hitArea.isHit(mouseX,mouseY);
			}
			if (sp.width > 0 && sp.height > 0 || sp.mouseThrough || sp.hitArea){
				var hitRect=this._rect;
				if (!sp.mouseThrough){
					if (sp.hitArea)hitRect=sp.hitArea;
					else hitRect.setTo(0,0,sp.width,sp.height);
					isHit=hitRect.contains(mouseX,mouseY);
					}else {
					isHit=sp.getGraphicBounds().contains(mouseX,mouseY);
				}
			}
			return isHit;
		}

		/**
		*执行事件处理。
		*/
		__proto.runEvent=function(){
			var len=this._eventList.length;
			if (!len)return;
			var _this=this;
			var i=0;
			while (i < len){
				var evt=this._eventList[i];
				switch (evt.type){
					case 'mousedown':
						if (!MouseManager._isTouchRespond){
							_this._isLeftMouse=evt.button===0;
							_this.initEvent(evt);
							_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseDown);
						}
						else
						MouseManager._isTouchRespond=false;
						break ;
					case 'mouseup':
						_this._isLeftMouse=evt.button===0;
						var now=Browser.now();
						_this._isDoubleClick=(now-_this._lastClickTimer)< 300;
						_this._lastClickTimer=now;
						_this.initEvent(evt);
						_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseUp);
						break ;
					case 'mousemove':
						_this.initEvent(evt);
						_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseMove);
						_this.checkMouseOut();
						break ;
					case "touchstart":
						MouseManager._isTouchRespond=true;
						_this._isLeftMouse=true;
						var touches=evt.changedTouches;
						for (var j=0,n=touches.length;j < n;j++){
							_this.initEvent(touches[j],evt);
							_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseDown);
						}
						break ;
					case "touchend":
						MouseManager._isTouchRespond=true;
						_this._isLeftMouse=true;
						now=Browser.now();
						_this._isDoubleClick=(now-_this._lastClickTimer)< 300;
						_this._lastClickTimer=now;
						var touchends=evt.changedTouches;
						for (j=0,n=touchends.length;j < n;j++){
							_this.initEvent(touchends[j],evt);
							_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseUp);
						}
						break ;
					case "touchmove":;
						var touchemoves=evt.changedTouches;
						for (j=0,n=touchemoves.length;j < n;j++){
							_this.initEvent(touchemoves[j],evt);
							_this.check(_this._stage,_this.mouseX,_this.mouseY,_this.onMouseMove);
						}
						_this.checkMouseOut();
						break ;
					case "wheel":
					case "mousewheel":
					case "DOMMouseScroll":
						_this.checkMouseWheel(evt);
						break ;
					case "mouseout":
						_this._stage.event("mouseout",_this._event.setTo("mouseout",_this._stage,_this._stage));
						break ;
					case "mouseover":
						_this._stage.event("mouseover",_this._event.setTo("mouseover",_this._stage,_this._stage));
						break ;
					}
				i++;
			}
			this._eventList.length=0;
		}

		MouseManager.enabled=true;
		MouseManager._isTouchRespond=false;
		__static(MouseManager,
		['instance',function(){return this.instance=new MouseManager();}
		]);
		return MouseManager;
	})()


	/**
	*<code>Filter</code> 是滤镜基类。
	*/
	//class laya.filters.Filter
	var Filter=(function(){
		function Filter(){
			this._action=null;
		}

		__class(Filter,'laya.filters.Filter');
		var __proto=Filter.prototype;
		Laya.imps(__proto,{"laya.filters.IFilter":true})
		/**@private */
		__proto.callNative=function(sp){}
		/**@private 滤镜类型。*/
		__getset(0,__proto,'type',function(){return-1});
		/**@private 滤镜动作。*/
		__getset(0,__proto,'action',function(){return this._action });
		Filter.BLUR=0x10;
		Filter.COLOR=0x20;
		Filter.GLOW=0x08;
		Filter._filterStart=null
		Filter._filterEnd=null
		Filter._EndTarget=null
		Filter._recycleScope=null
		Filter._filter=null
		Filter._useSrc=null
		Filter._endSrc=null
		Filter._useOut=null
		Filter._endOut=null
		return Filter;
	})()


	/**
	*<code>ColorFilterAction</code> 是一个颜色滤镜应用类。
	*/
	//class laya.filters.ColorFilterAction
	var ColorFilterAction=(function(){
		function ColorFilterAction(){
			this.data=null;
		}

		__class(ColorFilterAction,'laya.filters.ColorFilterAction');
		var __proto=ColorFilterAction.prototype;
		Laya.imps(__proto,{"laya.filters.IFilterAction":true})
		/**
		*给指定的对象应用颜色滤镜。
		*@param srcCanvas 需要应用画布对象。
		*@return 应用了滤镜后的画布对象。
		*/
		__proto.apply=function(srcCanvas){
			var ctx=srcCanvas.ctx.ctx;
			var canvas=srcCanvas.ctx.ctx.canvas;
			if (canvas.width==0 || canvas.height==0)return canvas;
			var imgdata=ctx.getImageData(0,0,canvas.width,canvas.height);
			var data=imgdata.data;
			var nData;
			for (var i=0,n=data.length;i < n;i+=4){
				nData=this.getColor(data[i],data[i+1],data[i+2],data[i+3]);
				if (data[i+3]==0)continue ;
				data[i]=nData[0];
				data[i+1]=nData[1];
				data[i+2]=nData[2];
				data[i+3]=nData[3];
			}
			ctx.putImageData(imgdata,0,0);
			return srcCanvas;
		}

		__proto.getColor=function(red,green,blue,alpha){
			var rst=[];
			if (this.data._mat && this.data._alpha){
				var mat=this.data._mat;
				var tempAlpha=this.data._alpha;
				rst[0]=mat[0] *red+mat[1] *green+mat[2] *blue+mat[3] *alpha+tempAlpha[0];
				rst[1]=mat[4] *red+mat[5] *green+mat[6] *blue+mat[7] *alpha+tempAlpha[1];
				rst[2]=mat[8] *red+mat[9] *green+mat[10] *blue+mat[11] *alpha+tempAlpha[2];
				rst[3]=mat[12] *red+mat[13] *green+mat[14] *blue+mat[15] *alpha+tempAlpha[3];
			}
			return rst;
		}

		return ColorFilterAction;
	})()


	//class laya.filters.webgl.FilterActionGL
	var FilterActionGL=(function(){
		function FilterActionGL(){}
		__class(FilterActionGL,'laya.filters.webgl.FilterActionGL');
		var __proto=FilterActionGL.prototype;
		Laya.imps(__proto,{"laya.filters.IFilterActionGL":true})
		__proto.setValue=function(shader){}
		__proto.setValueMix=function(shader){}
		__proto.apply3d=function(scope,sprite,context,x,y){return null;}
		__proto.apply=function(srcCanvas){return null;}
		__getset(0,__proto,'typeMix',function(){
			return 0;
		});

		return FilterActionGL;
	})()


	/**
	*@private
	*/
	//class laya.maths.Arith
	var Arith=(function(){
		function Arith(){};
		__class(Arith,'laya.maths.Arith');
		Arith.formatR=function(r){
			if (r > Math.PI)r-=Math.PI *2;
			if (r <-Math.PI)r+=Math.PI *2;
			return r;
		}

		Arith.isPOT=function(w,h){
			return (w > 0 && (w & (w-1))===0 && h > 0 && (h & (h-1))===0);
		}

		Arith.setMatToArray=function(mat,array){
			mat.a,mat.b,0,0,mat.c,mat.d,0,0,0,0,1,0,mat.tx+20,mat.ty+20,0,1
			array[0]=mat.a;
			array[1]=mat.b;
			array[4]=mat.c;
			array[5]=mat.d;
			array[12]=mat.tx;
			array[13]=mat.ty;
		}

		return Arith;
	})()


	/**
	*@private
	*计算贝塞尔曲线的工具类。
	*/
	//class laya.maths.Bezier
	var Bezier=(function(){
		function Bezier(){
			this._controlPoints=[new Point(),new Point(),new Point()];
			this._calFun=this.getPoint2;
		}

		__class(Bezier,'laya.maths.Bezier');
		var __proto=Bezier.prototype;
		/**@private */
		__proto._switchPoint=function(x,y){
			var tPoint=this._controlPoints.shift();
			tPoint.setTo(x,y);
			this._controlPoints.push(tPoint);
		}

		/**
		*计算二次贝塞尔点。
		*@param t
		*@param rst
		*
		*/
		__proto.getPoint2=function(t,rst){
			var p1=this._controlPoints[0];
			var p2=this._controlPoints[1];
			var p3=this._controlPoints[2];
			var lineX=Math.pow((1-t),2)*p1.x+2 *t *(1-t)*p2.x+Math.pow(t,2)*p3.x;
			var lineY=Math.pow((1-t),2)*p1.y+2 *t *(1-t)*p2.y+Math.pow(t,2)*p3.y;
			rst.push(lineX,lineY);
		}

		/**
		*计算三次贝塞尔点
		*@param t
		*@param rst
		*
		*/
		__proto.getPoint3=function(t,rst){
			var p1=this._controlPoints[0];
			var p2=this._controlPoints[1];
			var p3=this._controlPoints[2];
			var p4=this._controlPoints[3];
			var lineX=Math.pow((1-t),3)*p1.x+3 *p2.x *t *(1-t)*(1-t)+3 *p3.x *t *t *(1-t)+p4.x *Math.pow(t,3);
			var lineY=Math.pow((1-t),3)*p1.y+3 *p2.y *t *(1-t)*(1-t)+3 *p3.y *t *t *(1-t)+p4.y *Math.pow(t,3);
			rst.push(lineX,lineY);
		}

		/**
		*计算贝塞尔点序列
		*@param count
		*@param rst
		*
		*/
		__proto.insertPoints=function(count,rst){
			var i=NaN;
			count=count > 0 ? count :5;
			var dLen=NaN;
			dLen=1 / count;
			for (i=0;i <=1;i+=dLen){
				this._calFun(i,rst);
			}
		}

		/**
		*获取贝塞尔曲线上的点。
		*@param pList 控制点[x0,y0,x1,y1...]
		*@param inSertCount 每次曲线的插值数量
		*@return
		*
		*/
		__proto.getBezierPoints=function(pList,inSertCount,count){
			(inSertCount===void 0)&& (inSertCount=5);
			(count===void 0)&& (count=2);
			var i=0,len=0;
			len=pList.length;
			if (len < (count+1)*2)return [];
			var rst;
			rst=[];
			switch (count){
				case 2:
					this._calFun=this.getPoint2;
					break ;
				case 3:
					this._calFun=this.getPoint3;
					break ;
				default :
					return [];
				}
			for (i=0;i < count *2;i+=2){
				this._switchPoint(pList[i],pList[i+1]);
			}
			for (i=count *2;i < len;i+=2){
				this._switchPoint(pList[i],pList[i+1]);
				if ((i / 2)% count==0)
					this.insertPoints(inSertCount,rst);
			}
			return rst;
		}

		__static(Bezier,
		['I',function(){return this.I=new Bezier();}
		]);
		return Bezier;
	})()


	/**
	*@private
	*凸包算法。
	*/
	//class laya.maths.GrahamScan
	var GrahamScan=(function(){
		function GrahamScan(){};
		__class(GrahamScan,'laya.maths.GrahamScan');
		GrahamScan.multiply=function(p1,p2,p0){
			return ((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));
		}

		GrahamScan.dis=function(p1,p2){
			return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);
		}

		GrahamScan._getPoints=function(count,tempUse,rst){
			(tempUse===void 0)&& (tempUse=false);
			if (!GrahamScan._mPointList)GrahamScan._mPointList=[];
			while (GrahamScan._mPointList.length < count)GrahamScan._mPointList.push(new Point());
			if (!rst)rst=[];
			rst.length=0;
			if (tempUse){
				GrahamScan.getFrom(rst,GrahamScan._mPointList,count);
				}else {
				GrahamScan.getFromR(rst,GrahamScan._mPointList,count);
			}
			return rst;
		}

		GrahamScan.getFrom=function(rst,src,count){
			var i=0;
			for (i=0;i < count;i++){
				rst.push(src[i]);
			}
			return rst;
		}

		GrahamScan.getFromR=function(rst,src,count){
			var i=0;
			for (i=0;i < count;i++){
				rst.push(src.pop());
			}
			return rst;
		}

		GrahamScan.pListToPointList=function(pList,tempUse){
			(tempUse===void 0)&& (tempUse=false);
			var i=0,len=pList.length / 2,rst=GrahamScan._getPoints(len,tempUse,GrahamScan._tempPointList);
			for (i=0;i < len;i++){
				rst[i].setTo(pList[i+i],pList[i+i+1]);
			}
			return rst;
		}

		GrahamScan.pointListToPlist=function(pointList){
			var i=0,len=pointList.length,rst=GrahamScan._temPList,tPoint;
			rst.length=0;
			for (i=0;i < len;i++){
				tPoint=pointList[i];
				rst.push(tPoint.x,tPoint.y);
			}
			return rst;
		}

		GrahamScan.scanPList=function(pList){
			return Utils.copyArray(pList,GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList,true))));
		}

		GrahamScan.scan=function(PointSet){
			var i=0,j=0,k=0,top=2,tmp,n=PointSet.length,ch;
			var _tmpDic={};
			var key;
			ch=GrahamScan._temArr;
			ch.length=0;
			n=PointSet.length;
			for (i=n-1;i >=0;i--){
				tmp=PointSet[i];
				key=tmp.x+"_"+tmp.y;
				if (!_tmpDic.hasOwnProperty(key)){
					_tmpDic[key]=true;
					ch.push(tmp);
				}
			}
			n=ch.length;
			Utils.copyArray(PointSet,ch);
			for (i=1;i < n;i++)
			if ((PointSet[i].y < PointSet[k].y)|| ((PointSet[i].y==PointSet[k].y)&& (PointSet[i].x < PointSet[k].x)))
				k=i;
			tmp=PointSet[0];
			PointSet[0]=PointSet[k];
			PointSet[k]=tmp;
			for (i=1;i < n-1;i++){
				k=i;
				for (j=i+1;j < n;j++)
				if ((GrahamScan.multiply(PointSet[j],PointSet[k],PointSet[0])> 0)|| ((GrahamScan.multiply(PointSet[j],PointSet[k],PointSet[0])==0)&& (GrahamScan.dis(PointSet[0],PointSet[j])< GrahamScan.dis(PointSet[0],PointSet[k]))))
					k=j;
				tmp=PointSet[i];
				PointSet[i]=PointSet[k];
				PointSet[k]=tmp;
			}
			ch=GrahamScan._temArr;
			ch.length=0;
			if (PointSet.length < 3){
				return Utils.copyArray(ch,PointSet);
			}
			ch.push(PointSet[0],PointSet[1],PointSet[2]);
			for (i=3;i < n;i++){
				while (ch.length >=2 && GrahamScan.multiply(PointSet[i],ch[ch.length-1],ch[ch.length-2])>=0)ch.pop();
				PointSet[i] && ch.push(PointSet[i]);
			}
			return ch;
		}

		GrahamScan._mPointList=null
		GrahamScan._tempPointList=[];
		GrahamScan._temPList=[];
		GrahamScan._temArr=[];
		return GrahamScan;
	})()


	/**
	*@private
	*<code>MathUtil</code> 是一个数据处理工具类。
	*/
	//class laya.maths.MathUtil
	var MathUtil=(function(){
		function MathUtil(){};
		__class(MathUtil,'laya.maths.MathUtil');
		MathUtil.subtractVector3=function(l,r,o){
			o[0]=l[0]-r[0];
			o[1]=l[1]-r[1];
			o[2]=l[2]-r[2];
		}

		MathUtil.lerp=function(left,right,amount){
			return left *(1-amount)+right *amount;
		}

		MathUtil.scaleVector3=function(f,b,e){
			e[0]=f[0] *b;
			e[1]=f[1] *b;
			e[2]=f[2] *b;
		}

		MathUtil.lerpVector3=function(l,r,t,o){
			var ax=l[0],ay=l[1],az=l[2];
			o[0]=ax+t *(r[0]-ax);
			o[1]=ay+t *(r[1]-ay);
			o[2]=az+t *(r[2]-az);
		}

		MathUtil.lerpVector4=function(l,r,t,o){
			var ax=l[0],ay=l[1],az=l[2],aw=l[3];
			o[0]=ax+t *(r[0]-ax);
			o[1]=ay+t *(r[1]-ay);
			o[2]=az+t *(r[2]-az);
			o[3]=aw+t *(r[3]-aw);
		}

		MathUtil.slerpQuaternionArray=function(a,Offset1,b,Offset2,t,out,Offset3){
			var ax=a[Offset1+0],ay=a[Offset1+1],az=a[Offset1+2],aw=a[Offset1+3],bx=b[Offset2+0],by=b[Offset2+1],bz=b[Offset2+2],bw=b[Offset2+3];
			var omega,cosom,sinom,scale0,scale1;
			cosom=ax *bx+ay *by+az *bz+aw *bw;
			if (cosom < 0.0){
				cosom=-cosom;
				bx=-bx;
				by=-by;
				bz=-bz;
				bw=-bw;
			}
			if ((1.0-cosom)> 0.000001){
				omega=Math.acos(cosom);
				sinom=Math.sin(omega);
				scale0=Math.sin((1.0-t)*omega)/ sinom;
				scale1=Math.sin(t *omega)/ sinom;
				}else {
				scale0=1.0-t;
				scale1=t;
			}
			out[Offset3+0]=scale0 *ax+scale1 *bx;
			out[Offset3+1]=scale0 *ay+scale1 *by;
			out[Offset3+2]=scale0 *az+scale1 *bz;
			out[Offset3+3]=scale0 *aw+scale1 *bw;
			return out;
		}

		MathUtil.getRotation=function(x0,y0,x1,y1){
			return Math.atan2(y1-y0,x1-x0)/ Math.PI *180;
		}

		MathUtil.sortBigFirst=function(a,b){
			if (a==b)
				return 0;
			return b > a ? 1 :-1;
		}

		MathUtil.sortSmallFirst=function(a,b){
			if (a==b)
				return 0;
			return b > a ?-1 :1;
		}

		MathUtil.sortNumBigFirst=function(a,b){
			return parseFloat(b)-parseFloat(a);
		}

		MathUtil.sortNumSmallFirst=function(a,b){
			return parseFloat(a)-parseFloat(b);
		}

		MathUtil.sortByKey=function(key,bigFirst,forceNum){
			(bigFirst===void 0)&& (bigFirst=false);
			(forceNum===void 0)&& (forceNum=true);
			var _sortFun;
			if (bigFirst){
				_sortFun=forceNum ? MathUtil.sortNumBigFirst :MathUtil.sortBigFirst;
				}else {
				_sortFun=forceNum ? MathUtil.sortNumSmallFirst :MathUtil.sortSmallFirst;
			}
			return function (a,b){
				return _sortFun(a[key],b[key]);
			}
		}

		return MathUtil;
	})()


	/**
	*<code>Matrix</code> 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。
	*/
	//class laya.maths.Matrix
	var Matrix=(function(){
		function Matrix(a,b,c,d,tx,ty){
			this.cos=1;
			this.sin=0;
			//this.a=NaN;
			//this.b=NaN;
			//this.c=NaN;
			//this.d=NaN;
			//this.tx=NaN;
			//this.ty=NaN;
			this.inPool=false;
			this.bTransform=false;
			(a===void 0)&& (a=1);
			(b===void 0)&& (b=0);
			(c===void 0)&& (c=0);
			(d===void 0)&& (d=1);
			(tx===void 0)&& (tx=0);
			(ty===void 0)&& (ty=0);
			this.a=a;
			this.b=b;
			this.c=c;
			this.d=d;
			this.tx=tx;
			this.ty=ty;
			this._checkTransform();
		}

		__class(Matrix,'laya.maths.Matrix');
		var __proto=Matrix.prototype;
		/**
		*为每个矩阵属性设置一个值。
		*@return 返回当前矩形。
		*/
		__proto.identity=function(){
			this.a=this.d=1;
			this.b=this.tx=this.ty=this.c=0;
			this.bTransform=false;
			return this;
		}

		/**@private*/
		__proto._checkTransform=function(){
			return this.bTransform=(this.a!==1 || this.b!==0 || this.c!==0 || this.d!==1);
		}

		/**
		*设置沿 x 、y 轴平移每个点的距离。
		*@param x 沿 x 轴平移每个点的距离。
		*@param y 沿 y 轴平移每个点的距离。
		*@return 返回对象本身
		*/
		__proto.setTranslate=function(x,y){
			this.tx=x;
			this.ty=y;
			return this;
		}

		/**
		*沿 x 和 y 轴平移矩阵，由 x 和 y 参数指定。
		*@param x 沿 x 轴向右移动的量（以像素为单位）。
		*@param y 沿 y 轴向下移动的量（以像素为单位）。
		*@return 返回此矩形。
		*/
		__proto.translate=function(x,y){
			this.tx+=x;
			this.ty+=y;
			return this;
		}

		/**
		*对矩阵应用缩放转换。
		*@param x 用于沿 x 轴缩放对象的乘数。
		*@param y 用于沿 y 轴缩放对象的乘数。
		*/
		__proto.scale=function(x,y){
			this.a *=x;
			this.d *=y;
			this.c *=x;
			this.b *=y;
			this.tx *=x;
			this.ty *=y;
			this.bTransform=true;
		}

		/**
		*对 Matrix 对象应用旋转转换。
		*@param angle 以弧度为单位的旋转角度。
		*/
		__proto.rotate=function(angle){
			var cos=this.cos=Math.cos(angle);
			var sin=this.sin=Math.sin(angle);
			var a1=this.a;
			var c1=this.c;
			var tx1=this.tx;
			this.a=a1 *cos-this.b *sin;
			this.b=a1 *sin+this.b *cos;
			this.c=c1 *cos-this.d *sin;
			this.d=c1 *sin+this.d *cos;
			this.tx=tx1 *cos-this.ty *sin;
			this.ty=tx1 *sin+this.ty *cos;
			this.bTransform=true;
		}

		/**
		*对 Matrix 对象应用倾斜转换。
		*@param x 沿着 X 轴的 2D 倾斜弧度。
		*@param y 沿着 Y 轴的 2D 倾斜弧度。
		*@return 当前 Matrix 对象。
		*/
		__proto.skew=function(x,y){
			var tanX=Math.tan(x);
			var tanY=Math.tan(y);
			var a1=this.a;
			var b1=this.b;
			this.a+=tanY *this.c;
			this.b+=tanY *this.d;
			this.c+=tanX *a1;
			this.d+=tanX *b1;
			return this;
		}

		/**
		*对指定的点应用当前矩阵的逆转化并返回此点。
		*@param out 待转化的点 Point 对象。
		*@return 返回out
		*/
		__proto.invertTransformPoint=function(out){
			var a1=this.a;
			var b1=this.b;
			var c1=this.c;
			var d1=this.d;
			var tx1=this.tx;
			var n=a1 *d1-b1 *c1;
			var a2=d1 / n;
			var b2=-b1 / n;
			var c2=-c1 / n;
			var d2=a1 / n;
			var tx2=(c1 *this.ty-d1 *tx1)/ n;
			var ty2=-(a1 *this.ty-b1 *tx1)/ n;
			return out.setTo(a2 *out.x+c2 *out.y+tx2,b2 *out.x+d2 *out.y+ty2);
		}

		/**
		*将 Matrix 对象表示的几何转换应用于指定点。
		*@param out 用来设定输出结果的点。
		*@return 返回out
		*/
		__proto.transformPoint=function(out){
			return out.setTo(this.a *out.x+this.c *out.y+this.tx,this.b *out.x+this.d *out.y+this.ty);
		}

		/**
		*@private
		*将 Matrix 对象表示的几何转换应用于指定点。
		*@param data 点集合。
		*@param out 存储应用转化的点的列表。
		*@return 返回out数组
		*/
		__proto.transformPointArray=function(data,out){
			var len=data.length;
			for (var i=0;i < len;i+=2){
				var x=data[i],y=data[i+1];
				out[i]=this.a *x+this.c *y+this.tx;
				out[i+1]=this.b *x+this.d *y+this.ty;
			}
			return out;
		}

		/**
		*@private
		*将 Matrix 对象表示的几何缩放转换应用于指定点。
		*@param data 点集合。
		*@param out 存储应用转化的点的列表。
		*@return 返回out数组
		*/
		__proto.transformPointArrayScale=function(data,out){
			var len=data.length;
			for (var i=0;i < len;i+=2){
				var x=data[i],y=data[i+1];
				out[i]=this.a *x+this.c *y;
				out[i+1]=this.b *x+this.d *y;
			}
			return out;
		}

		/**
		*获取 X 轴缩放值。
		*@return X 轴缩放值。
		*/
		__proto.getScaleX=function(){
			return this.b===0 ? this.a :Math.sqrt(this.a *this.a+this.b *this.b);
		}

		/**
		*获取 Y 轴缩放值。
		*@return Y 轴缩放值。
		*/
		__proto.getScaleY=function(){
			return this.c===0 ? this.d :Math.sqrt(this.c *this.c+this.d *this.d);
		}

		/**
		*执行原始矩阵的逆转换。
		*@return 当前矩阵对象。
		*/
		__proto.invert=function(){
			var a1=this.a;
			var b1=this.b;
			var c1=this.c;
			var d1=this.d;
			var tx1=this.tx;
			var n=a1 *d1-b1 *c1;
			this.a=d1 / n;
			this.b=-b1 / n;
			this.c=-c1 / n;
			this.d=a1 / n;
			this.tx=(c1 *this.ty-d1 *tx1)/ n;
			this.ty=-(a1 *this.ty-b1 *tx1)/ n;
			return this;
		}

		/**
		*将 Matrix 的成员设置为指定值。
		*@param a 缩放或旋转图像时影响像素沿 x 轴定位的值。
		*@param b 旋转或倾斜图像时影响像素沿 y 轴定位的值。
		*@param c 旋转或倾斜图像时影响像素沿 x 轴定位的值。
		*@param d 缩放或旋转图像时影响像素沿 y 轴定位的值。
		*@param tx 沿 x 轴平移每个点的距离。
		*@param ty 沿 y 轴平移每个点的距离。
		*@return 当前矩阵对象。
		*/
		__proto.setTo=function(a,b,c,d,tx,ty){
			this.a=a,this.b=b,this.c=c,this.d=d,this.tx=tx,this.ty=ty;
			return this;
		}

		/**
		*将指定矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
		*@param matrix 要连接到源矩阵的矩阵。
		*@return 当前矩阵。
		*/
		__proto.concat=function(matrix){
			var a=this.a;
			var c=this.c;
			var tx=this.tx;
			this.a=a *matrix.a+this.b *matrix.c;
			this.b=a *matrix.b+this.b *matrix.d;
			this.c=c *matrix.a+this.d *matrix.c;
			this.d=c *matrix.b+this.d *matrix.d;
			this.tx=tx *matrix.a+this.ty *matrix.c+matrix.tx;
			this.ty=tx *matrix.b+this.ty *matrix.d+matrix.ty;
			return this;
		}

		/**
		*返回一个新的 Matrix 对象，它是此矩阵的克隆，带有与所含对象完全相同的副本。
		*@return 一个 Matrix 对象。
		*/
		__proto.clone=function(){
			var no=Matrix._cache;
			var dec=!no._length ? (new Matrix()):no[--no._length];
			dec.a=this.a;
			dec.b=this.b;
			dec.c=this.c;
			dec.d=this.d;
			dec.tx=this.tx;
			dec.ty=this.ty;
			dec.bTransform=this.bTransform;
			return dec;
		}

		/**
		*将当前 Matrix 对象中的所有矩阵数据复制到指定的 Matrix 对象中。
		*@param dec 要复制当前矩阵数据的 Matrix 对象。
		*@return 已复制当前矩阵数据的 Matrix 对象。
		*/
		__proto.copyTo=function(dec){
			dec.a=this.a;
			dec.b=this.b;
			dec.c=this.c;
			dec.d=this.d;
			dec.tx=this.tx;
			dec.ty=this.ty;
			dec.bTransform=this.bTransform;
			return dec;
		}

		/**
		*返回列出该 Matrix 对象属性的文本值。
		*@return 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
		*/
		__proto.toString=function(){
			return this.a+","+this.b+","+this.c+","+this.d+","+this.tx+","+this.ty;
		}

		/**
		*销毁此对象。
		*/
		__proto.destroy=function(){
			if (this.inPool)return;
			var cache=Matrix._cache;
			this.inPool=true;
			cache._length || (cache._length=0);
			cache[cache._length++]=this;
			this.a=this.d=1;
			this.b=this.c=this.tx=this.ty=0;
			this.bTransform=false;
		}

		Matrix.mul=function(m1,m2,out){
			var aa=m1.a,ab=m1.b,ac=m1.c,ad=m1.d,atx=m1.tx,aty=m1.ty;
			var ba=m2.a,bb=m2.b,bc=m2.c,bd=m2.d,btx=m2.tx,bty=m2.ty;
			if (bb!==0 || bc!==0){
				out.a=aa *ba+ab *bc;
				out.b=aa *bb+ab *bd;
				out.c=ac *ba+ad *bc;
				out.d=ac *bb+ad *bd;
				out.tx=ba *atx+bc *aty+btx;
				out.ty=bb *atx+bd *aty+bty;
				}else {
				out.a=aa *ba;
				out.b=ab *bd;
				out.c=ac *ba;
				out.d=ad *bd;
				out.tx=ba *atx+btx;
				out.ty=bd *aty+bty;
			}
			return out;
		}

		Matrix.mulPre=function(m1,ba,bb,bc,bd,btx,bty,out){
			var aa=m1.a,ab=m1.b,ac=m1.c,ad=m1.d,atx=m1.tx,aty=m1.ty;
			if (bb!==0 || bc!==0){
				out.a=aa *ba+ab *bc;
				out.b=aa *bb+ab *bd;
				out.c=ac *ba+ad *bc;
				out.d=ac *bb+ad *bd;
				out.tx=ba *atx+bc *aty+btx;
				out.ty=bb *atx+bd *aty+bty;
				}else {
				out.a=aa *ba;
				out.b=ab *bd;
				out.c=ac *ba;
				out.d=ad *bd;
				out.tx=ba *atx+btx;
				out.ty=bd *aty+bty;
			}
			return out;
		}

		Matrix.mulPos=function(m1,aa,ab,ac,ad,atx,aty,out){
			var ba=m1.a,bb=m1.b,bc=m1.c,bd=m1.d,btx=m1.tx,bty=m1.ty;
			if (bb!==0 || bc!==0){
				out.a=aa *ba+ab *bc;
				out.b=aa *bb+ab *bd;
				out.c=ac *ba+ad *bc;
				out.d=ac *bb+ad *bd;
				out.tx=ba *atx+bc *aty+btx;
				out.ty=bb *atx+bd *aty+bty;
				}else {
				out.a=aa *ba;
				out.b=ab *bd;
				out.c=ac *ba;
				out.d=ad *bd;
				out.tx=ba *atx+btx;
				out.ty=bd *aty+bty;
			}
			return out;
		}

		Matrix.preMul=function(parent,self,out){
			var pa=parent.a,pb=parent.b,pc=parent.c,pd=parent.d;
			var na=self.a,nb=self.b,nc=self.c,nd=self.d,ntx=self.tx,nty=self.ty;
			out.a=na *pa;
			out.b=out.c=0;
			out.d=nd *pd;
			out.tx=ntx *pa+parent.tx;
			out.ty=nty *pd+parent.ty;
			if (nb!==0 || nc!==0 || pb!==0 || pc!==0){
				out.a+=nb *pc;
				out.d+=nc *pb;
				out.b+=na *pb+nb *pd;
				out.c+=nc *pa+nd *pc;
				out.tx+=nty *pc;
				out.ty+=ntx *pb;
			}
			return out;
		}

		Matrix.preMulXY=function(parent,x,y,out){
			var pa=parent.a,pb=parent.b,pc=parent.c,pd=parent.d;
			out.a=pa;
			out.b=pb;
			out.c=pc;
			out.d=pd;
			out.tx=x *pa+parent.tx+y *pc;
			out.ty=y *pd+parent.ty+x *pb;
			return out;
		}

		Matrix.create=function(){
			var cache=Matrix._cache;
			var mat=!cache._length ? (new Matrix()):cache[--cache._length];
			mat.inPool=false;
			return mat;
		}

		Matrix.EMPTY=new Matrix();
		Matrix.TEMP=new Matrix();
		Matrix._cache=[];
		return Matrix;
	})()


	/**
	*<code>Point</code> 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
	*/
	//class laya.maths.Point
	var Point=(function(){
		function Point(x,y){
			//this.x=NaN;
			//this.y=NaN;
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			this.x=x;
			this.y=y;
		}

		__class(Point,'laya.maths.Point');
		var __proto=Point.prototype;
		/**
		*将 <code>Point</code> 的成员设置为指定值。
		*@param x 水平坐标。
		*@param y 垂直坐标。
		*@return 当前 Point 对象。
		*/
		__proto.setTo=function(x,y){
			this.x=x;
			this.y=y;
			return this;
		}

		/**
		*计算当前点和目标x，y点的距离
		*@param x 水平坐标。
		*@param y 垂直坐标。
		*@return 返回之间的距离
		*/
		__proto.distance=function(x,y){
			return Math.sqrt((this.x-x)*(this.x-x)+(this.y-y)*(this.y-y));
		}

		/**返回包含 x 和 y 坐标的值的字符串。*/
		__proto.toString=function(){
			return this.x+","+this.y;
		}

		/**
		*标准化向量
		*/
		__proto.normalize=function(){
			var d=Math.sqrt(this.x *this.x+this.y *this.y);
			if (d > 0){
				var id=1.0 / d;
				this.x *=id;
				this.y *=id;
			}
		}

		Point.TEMP=new Point();
		Point.EMPTY=new Point();
		return Point;
	})()


	/**
	*<code>Rectangle</code> 对象是按其位置（由它左上角的点 (x,y)确定）以及宽度和高度定义的区域。
	*/
	//class laya.maths.Rectangle
	var Rectangle=(function(){
		function Rectangle(x,y,width,height){
			//this.x=NaN;
			//this.y=NaN;
			//this.width=NaN;
			//this.height=NaN;
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			this.x=x;
			this.y=y;
			this.width=width;
			this.height=height;
		}

		__class(Rectangle,'laya.maths.Rectangle');
		var __proto=Rectangle.prototype;
		/**
		*将 Rectangle 的属性设置为指定值。
		*@param x x 矩形左上角的 X 轴坐标。
		*@param y x 矩形左上角的 Y 轴坐标。
		*@param width 矩形的宽度。
		*@param height 矩形的高。
		*@return 返回属性值修改后的矩形对象本身。
		*/
		__proto.setTo=function(x,y,width,height){
			this.x=x;
			this.y=y;
			this.width=width;
			this.height=height;
			return this;
		}

		/**
		*复制 source 对象的属性值到此矩形对象中。
		*@param sourceRect 源 Rectangle 对象。
		*@return 返回属性值修改后的矩形对象本身。
		*/
		__proto.copyFrom=function(source){
			this.x=source.x;
			this.y=source.y;
			this.width=source.width;
			this.height=source.height;
			return this;
		}

		/**
		*检测此矩形对象是否包含指定的点。
		*@param x 点的 X 轴坐标值（水平位置）。
		*@param y 点的 Y 轴坐标值（垂直位置）。
		*@return 如果 Rectangle 对象包含指定的点，则值为 true；否则为 false。
		*/
		__proto.contains=function(x,y){
			if (this.width <=0 || this.height <=0)return false;
			if (x >=this.x && x < this.right){
				if (y >=this.y && y < this.bottom){
					return true;
				}
			}
			return false;
		}

		/**
		*检测传入的矩形对象是否与此对象相交。
		*@param rect Rectangle 对象。
		*@return 如果传入的矩形对象与此对象相交，则返回 true 值，否则返回 false。
		*/
		__proto.intersects=function(rect){
			return !(rect.x > this.right || rect.right < this.x || rect.y > this.bottom || rect.bottom < this.y);
		}

		/**
		*获取此对象与传入的矩形对象的相交区域。并将相交区域赋值给传入的输出矩形对象。
		*@param rect 待比较的矩形区域。
		*@param out 待输出的矩形区域。建议：尽量用此对象复用对象，减少对象创建消耗。
		*@return 返回相交的矩形区域对象。
		*/
		__proto.intersection=function(rect,out){
			if (!this.intersects(rect))return null;
			out || (out=new Rectangle());
			out.x=Math.max(this.x,rect.x);
			out.y=Math.max(this.y,rect.y);
			out.width=Math.min(this.right,rect.right)-out.x;
			out.height=Math.min(this.bottom,rect.bottom)-out.y;
			return out;
		}

		/**
		*矩形联合，通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。
		*@param 目标矩形对象。
		*@param out 待输出结果的矩形对象。建议：尽量用此对象复用对象，减少对象创建消耗。
		*@return 两个矩形后联合的 Rectangle 对象 out 。
		*/
		__proto.union=function(source,out){
			out || (out=new Rectangle());
			this.clone(out);
			if (source.width <=0 || source.height <=0)return out;
			out.addPoint(source.x,source.y);
			out.addPoint(source.right,source.bottom);
			return this;
		}

		/**
		*返回一个 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
		*@param out 待输出的矩形对象。建议：尽量用此对象复用对象，减少对象创建消耗。
		*@return Rectangle 对象 out ，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
		*/
		__proto.clone=function(out){
			out || (out=new Rectangle());
			out.x=this.x;
			out.y=this.y;
			out.width=this.width;
			out.height=this.height;
			return out;
		}

		/**
		*当前 Rectangle 对象的水平位置 x 和垂直位置 y 以及高度 width 和宽度 height 以逗号连接成的字符串。
		*/
		__proto.toString=function(){
			return this.x+","+this.y+","+this.width+","+this.height;
		}

		/**
		*检测传入的 Rectangle 对象的属性是否与当前 Rectangle 对象的属性 x、y、width、height 属性值都相等。
		*@param rect 待比较的 Rectangle 对象。
		*@return 如果判断的属性都相等，则返回 true ,否则返回 false。
		*/
		__proto.equals=function(rect){
			if (!rect || rect.x!==this.x || rect.y!==this.y || rect.width!==this.width || rect.height!==this.height)return false;
			return true;
		}

		/**
		*在当前矩形区域中加一个点。
		*@param x 点的 X 坐标。
		*@param y 点的 Y 坐标。
		*@return 返回此 Rectangle 对象。
		*/
		__proto.addPoint=function(x,y){
			this.x > x && (this.width+=this.x-x,this.x=x);
			this.y > y && (this.height+=this.y-y,this.y=y);
			if (this.width < x-this.x)this.width=x-this.x;
			if (this.height < y-this.y)this.height=y-this.y;
			return this;
		}

		/**
		*@private
		*返回代表当前矩形的顶点数据。
		*@return 顶点数据。
		*/
		__proto._getBoundPoints=function(){
			var rst=Rectangle._temB;
			rst.length=0;
			if (this.width==0 || this.height==0)return rst;
			rst.push(this.x,this.y,this.x+this.width,this.y,this.x,this.y+this.height,this.x+this.width,this.y+this.height);
			return rst;
		}

		/**确定此 Rectangle 对象是否为空。*/
		__proto.isEmpty=function(){
			if (this.width <=0 || this.height <=0)return true;
			return false;
		}

		/**此矩形的右边距。 x 和 width 属性的和。*/
		__getset(0,__proto,'right',function(){
			return this.x+this.width;
		});

		/**此矩形的底边距。y 和 height 属性的和。*/
		__getset(0,__proto,'bottom',function(){
			return this.y+this.height;
		});

		Rectangle._getBoundPointS=function(x,y,width,height){
			var rst=Rectangle._temA;
			rst.length=0;
			if (width==0 || height==0)return rst;
			rst.push(x,y,x+width,y,x,y+height,x+width,y+height);
			return rst;
		}

		Rectangle._getWrapRec=function(pointList,rst){
			if (!pointList || pointList.length < 1)return rst ? rst.setTo(0,0,0,0):Rectangle.TEMP.setTo(0,0,0,0);
			rst=rst ? rst :new Rectangle();
			var i,len=pointList.length,minX,maxX,minY,maxY,tPoint=Point.TEMP;
			minX=minY=99999;
			maxX=maxY=-minX;
			for (i=0;i < len;i+=2){
				tPoint.x=pointList[i];
				tPoint.y=pointList[i+1];
				minX=minX < tPoint.x ? minX :tPoint.x;
				minY=minY < tPoint.y ? minY :tPoint.y;
				maxX=maxX > tPoint.x ? maxX :tPoint.x;
				maxY=maxY > tPoint.y ? maxY :tPoint.y;
			}
			return rst.setTo(minX,minY,maxX-minX,maxY-minY);
		}

		Rectangle.EMPTY=new Rectangle();
		Rectangle.TEMP=new Rectangle();
		Rectangle._temB=[];
		Rectangle._temA=[];
		return Rectangle;
	})()


	/**
	*<code>SoundManager</code> 是一个声音管理类。
	*/
	//class laya.media.SoundManager
	var SoundManager=(function(){
		function SoundManager(){};
		__class(SoundManager,'laya.media.SoundManager');
		/**
		*设置是否失去焦点后自动停止背景音乐。
		*@param v Boolean 值。
		*
		*/
		/**
		*表示是否失去焦点后自动停止背景音乐。
		*@return
		*/
		__getset(1,SoundManager,'autoStopMusic',function(){
			return SoundManager._autoStopMusic;
			},function(v){
			Laya.stage.off("blur",null,SoundManager._stageOnBlur);
			Laya.stage.off("focus",null,SoundManager._stageOnFocus);
			SoundManager._autoStopMusic=v;
			if (v){
				Laya.stage.on("blur",null,SoundManager._stageOnBlur);
				Laya.stage.on("focus",null,SoundManager._stageOnFocus);
			}
		});

		/**
		*表示是否静音。
		*/
		__getset(1,SoundManager,'muted',function(){
			return SoundManager._muted;
			},function(value){
			if (value){
				SoundManager.stopAll();
			}
			SoundManager._muted=value;
		});

		/**表示是否使音效静音。*/
		__getset(1,SoundManager,'soundMuted',function(){
			return SoundManager._soundMuted;
			},function(value){
			SoundManager._soundMuted=value;
		});

		/**表示是否使背景音乐静音。*/
		__getset(1,SoundManager,'musicMuted',function(){
			return SoundManager._musicMuted;
			},function(value){
			if (value){
				if (SoundManager._tMusic)
					SoundManager.stopSound(SoundManager._tMusic);
				SoundManager._musicMuted=value;
				}else {
				SoundManager._musicMuted=value;
				if (SoundManager._tMusic){
					SoundManager.playMusic(SoundManager._tMusic);
				}
			}
		});

		SoundManager.addChannel=function(channel){
			if (SoundManager._channels.indexOf(channel)>=0)return;
			SoundManager._channels.push(channel);
		}

		SoundManager.removeChannel=function(channel){
			var i=0;
			for (i=SoundManager._channels.length-1;i >=0;i--){
				if (SoundManager._channels[i]==channel){
					SoundManager._channels.splice(i,1);
				}
			}
		}

		SoundManager._stageOnBlur=function(){
			if (SoundManager._musicChannel){
				if (!SoundManager._musicChannel.isStopped){
					SoundManager._blurPaused=true;
					SoundManager._musicLoops=SoundManager._musicChannel.loops;
					SoundManager._musicCompleteHandler=SoundManager._musicChannel.completeHandler;
					SoundManager._musicPosition=SoundManager._musicChannel.position;
					SoundManager._musicChannel.stop();
				}
			}
		}

		SoundManager._stageOnFocus=function(){
			if (SoundManager._blurPaused){
				SoundManager.playMusic(SoundManager._tMusic,SoundManager._musicLoops,SoundManager._musicCompleteHandler,SoundManager._musicPosition);
				SoundManager._blurPaused=false;
			}
		}

		SoundManager.playSound=function(url,loops,complete,soundClass,startTime){
			(loops===void 0)&& (loops=1);
			(startTime===void 0)&& (startTime=0);
			if (SoundManager._muted)
				return null;
			if (url==SoundManager._tMusic){
				if (SoundManager._musicMuted)return null;
				}else {
				if (SoundManager._soundMuted)return null;
			};
			var tSound=Laya.loader.getRes(url);
			if (!soundClass)soundClass=SoundManager._soundClass;
			if (!tSound){
				tSound=new soundClass();
				tSound.load(url);
				Loader.cacheRes(url,tSound);
			};
			var channel;
			channel=tSound.play(startTime,loops);
			channel.url=url;
			channel.volume=(url==SoundManager._tMusic)? SoundManager.musicVolume :SoundManager.soundVolume;
			channel.completeHandler=complete;
			return channel;
		}

		SoundManager.destroySound=function(url){
			var tSound=Laya.loader.getRes(url);
			if (tSound){
				Loader.clearRes(url);
				tSound.dispose();
			}
		}

		SoundManager.playMusic=function(url,loops,complete,startTime){
			(loops===void 0)&& (loops=0);
			(startTime===void 0)&& (startTime=0);
			SoundManager._tMusic=url;
			if (SoundManager._musicChannel)
				SoundManager._musicChannel.stop();
			return SoundManager._musicChannel=SoundManager.playSound(url,loops,complete,null,startTime);
		}

		SoundManager.stopSound=function(url){
			var i=0;
			var channel;
			for (i=SoundManager._channels.length-1;i >=0;i--){
				channel=SoundManager._channels[i];
				if (channel.url==url){
					channel.stop();
				}
			}
		}

		SoundManager.stopAll=function(){
			var i=0;
			var channel;
			for (i=SoundManager._channels.length-1;i >=0;i--){
				channel=SoundManager._channels[i];
				channel.stop();
			}
		}

		SoundManager.stopMusic=function(){
			if (SoundManager._musicChannel)
				SoundManager._musicChannel.stop();
		}

		SoundManager.setSoundVolume=function(volume,url){
			if (url){
				SoundManager._setVolume(url,volume);
				}else {
				SoundManager.soundVolume=volume;
			}
		}

		SoundManager.setMusicVolume=function(volume){
			SoundManager.musicVolume=volume;
			SoundManager._setVolume(SoundManager._tMusic,volume);
		}

		SoundManager._setVolume=function(url,volume){
			var i=0;
			var channel;
			for (i=SoundManager._channels.length-1;i >=0;i--){
				channel=SoundManager._channels[i];
				if (channel.url==url){
					channel.volume=volume;
				}
			}
		}

		SoundManager.musicVolume=1;
		SoundManager.soundVolume=1;
		SoundManager._muted=false;
		SoundManager._soundMuted=false;
		SoundManager._musicMuted=false;
		SoundManager._tMusic=null;
		SoundManager._musicChannel=null;
		SoundManager._channels=[];
		SoundManager._autoStopMusic=false;
		SoundManager._blurPaused=false;
		SoundManager._musicLoops=0;
		SoundManager._musicPosition=0;
		SoundManager._musicCompleteHandler=null;
		SoundManager._soundClass=null
		return SoundManager;
	})()


	/**
	*<p> <code>URL</code> 类用于定义地址信息。</p>
	*/
	//class laya.net.URL
	var URL=(function(){
		function URL(url){
			this._url=null;
			this._path=null;
			this._url=URL.formatURL(url);
			this._path=URL.getPath(url);
		}

		__class(URL,'laya.net.URL');
		var __proto=URL.prototype;
		/**格式化后的地址。*/
		__getset(0,__proto,'url',function(){
			return this._url;
		});

		/**地址的路径。*/
		__getset(0,__proto,'path',function(){
			return this._path;
		});

		URL.formatURL=function(url,base){
			if (URL.customFormat !=null)url=URL.customFormat(url,base);
			if (!url)return "null path";
			if (Render.isConchApp==false){
				URL.version[url] && (url+="?v="+URL.version[url]);
			}
			if (url.charAt(0)=='~')return URL.rootPath+url.substring(1);
			if (URL.isAbsolute(url))return url;
			var retVal=(base || URL.basePath)+url;
			return retVal;
		}

		URL.formatRelativePath=function(value){
			if (value.indexOf("../")>-1){
				var parts=value.split("/");
				for (var i=0,len=parts.length;i < len;i++){
					if (parts[i]=='..'){
						parts.splice(i-1,2);
						i-=2;
					}
				}
				return parts.join('/');
			}
			return value;
		}

		URL.isAbsolute=function(url){
			return url.indexOf(":")> 0 || url.charAt(0)=='/';
		}

		URL.getPath=function(url){
			var ofs=url.lastIndexOf('/');
			return ofs > 0 ? url.substr(0,ofs+1):"";
		}

		URL.getFileName=function(url){
			var ofs=url.lastIndexOf('/');
			return ofs > 0 ? url.substr(ofs+1):url;
		}

		URL.version={};
		URL.basePath="";
		URL.rootPath="";
		URL.customFormat=null
		return URL;
	})()


	/**
	*@private
	*<code>Render</code> 是渲染管理类。它是一个单例，可以使用 Laya.render 访问。
	*/
	//class laya.renders.Render
	var Render=(function(){
		/**
		*初始化引擎。
		*@param width 游戏窗口宽度。
		*@param height 游戏窗口高度。
		*/
		function Render(width,height){
			var style=Render._mainCanvas.source.style;
			style.position='absolute';
			style.top=style.left="0px";
			style.background="#000000";
			Render._mainCanvas.source.id="layaCanvas";
			var isWebGl=laya.renders.Render.isWebGL;
			isWebGl && Render.WebGL.init(Render._mainCanvas,width,height);
			Browser.container.appendChild(Render._mainCanvas.source);
			Render._context=new RenderContext(width,height,isWebGl ? null :Render._mainCanvas);
			Render._context.ctx.setIsMainContext();
			Browser.window.requestAnimationFrame(loop);
			function loop (){
				Laya.stage._loop();
				Browser.window.requestAnimationFrame(loop);
			}
		}

		__class(Render,'laya.renders.Render');
		var __proto=Render.prototype;
		/**@private */
		__proto._enterFrame=function(e){
			Laya.stage._loop();
		}

		/**是否是加速器 只读*/
		__getset(1,Render,'isConchApp',function(){
			return (window.ConchRenderType & 0x04)==0x04;
		});

		/**加速器模式下设置是否是节点模式 如果是否就是非节点模式 默认为canvas模式 如果设置了isConchWebGL则是webGL模式*/
		__getset(1,Render,'isConchNode',function(){
			return (window.ConchRenderType & 5)==5;
			},function(b){
			if (b){
				window.ConchRenderType |=0x01;
				}else {
				window.ConchRenderType &=~ 0x01;
			}
		});

		/**目前使用的渲染器。*/
		__getset(1,Render,'context',function(){
			return Render._context;
		});

		/**加速器模式下设置是否是WebGL模式*/
		__getset(1,Render,'isConchWebGL',function(){
			return window.ConchRenderType==6;
			},function(b){
			if (b){
				Render.isConchNode=false;
				window.ConchRenderType |=0x02;
				}else {
				window.ConchRenderType &=~ 0x02;
			}
		});

		/**渲染使用的原生画布引用。 */
		__getset(1,Render,'canvas',function(){
			return Render._mainCanvas.source;
		});

		Render._context=null
		Render._mainCanvas=null
		Render.WebGL=null
		Render.NODE=0x01;
		Render.WEBGL=0x02;
		Render.CONCH=0x04;
		Render.isWebGL=false;
		Render.is3DMode=false;
		Render.optimizeTextureMemory=function(url,texture){
			return true;
		}

		Render.__init$=function(){
			window.ConchRenderType=window.ConchRenderType||1;;
			window.ConchRenderType|=(!window.conch?0:0x04);;
		}

		return Render;
	})()


	/**
	*@private
	*渲染环境
	*/
	//class laya.renders.RenderContext
	var RenderContext=(function(){
		function RenderContext(width,height,canvas){
			this.x=0;
			this.y=0;
			//this.canvas=null;
			//this.ctx=null;
			this._drawTexture=function(x,y,args){
				if (args[0].loaded)this.ctx.drawTexture(args[0],args[1],args[2],args[3],args[4],x,y);
			}
			this._fillTexture=function(x,y,args){
				if (args[0].loaded){
					var texture=args[0];
					var ctxi=this.ctx;
					var pat;
					if (Render.isWebGL){
						var tSprite=args[7];
						if (tSprite){
							if (args[6]){
								tSprite.initTexture(texture,args[1],args[2],args[3],args[4],args[6].x,args[6].y);
								}else {
								tSprite.initTexture(texture,args[1],args[2],args[3],args[4],0,0);
							};
							var ctx=this.ctx;
							tSprite.render(ctx,x,y);
						}
						return;
					}
					if (!Render.isConchApp){
						if (texture.uv !=Texture.DEF_UV){
							var canvas=new HTMLCanvas("2D");
							canvas.getContext('2d');
							canvas.size(texture.width,texture.height);
							canvas.context.drawTexture(texture,0,0,texture.width,texture.height,0,0);
							args[0]=texture=new Texture(canvas);
						}
						pat=args[7] ? args[7] :args[7]=ctxi.createPattern(texture.bitmap.source,args[5]);
						}else {
						if (texture.uv !=Texture.DEF_UV){
							var w=texture.bitmap.width,h=texture.bitmap.height,uv=texture.uv;
							pat=args[7] ? args[7] :args[7]=ctxi.createPattern(texture.bitmap.source,args[5],uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h);
							}else {
							pat=args[7] ? args[7] :args[7]=ctxi.createPattern(texture.bitmap.source,args[5]);
						}
					};
					var oX=x+args[1],oY=y+args[2];
					var sX=0,sY=0;
					if (args[6]){
						oX+=args[6].x % texture.width;
						oY+=args[6].y % texture.height;
						sX-=args[6].x % texture.width;
						sY-=args[6].y % texture.height;
					}
					ctxi.translate(oX,oY);
					ctxi.fillStyle=pat;
					ctxi.fillRect(sX,sY,args[3],args[4]);
					ctxi.translate(-oX,-oY);
				}else {}
			}
			this._drawTextureWithTransform=function(x,y,args){
				if (args[0].loaded)this.ctx.drawTextureWithTransform(args[0],args[1],args[2],args[3],args[4],args[5],x,y);
			}
			this._fillQuadrangle=function(x,y,args){
				this.ctx.fillQuadrangle(args[0],args[1],args[2],args[3],args[4]);
			}
			this._drawRect=function(x,y,args){
				var ctx=this.ctx;
				if (args[4] !=null){
					ctx.fillStyle=args[4];
					ctx.fillRect(x+args[0],y+args[1],args[2],args[3],null);
				}
				if (args[5] !=null){
					ctx.strokeStyle=args[5];
					ctx.lineWidth=args[6];
					ctx.strokeRect(x+args[0],y+args[1],args[2],args[3],args[6]);
				}
			}
			this._drawPie=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(args[8]);
				ctx.beginPath();
				if (Render.isWebGL){
					ctx.movePath(args[0]+x,args[1]+y);
					ctx.moveTo(0,0);
					}else {
					ctx.moveTo(x+args[0],y+args[1]);
				}
				ctx.arc(x+args[0],y+args[1],args[2],args[3],args[4]);
				ctx.closePath();
				this._fillAndStroke(args[5],args[6],args[7],true);
			}
			this._clipRect=function(x,y,args){
				this.ctx.clipRect(x+args[0],y+args[1],args[2],args[3]);
			}
			this._fillRect=function(x,y,args){
				this.ctx.fillRect(x+args[0],y+args[1],args[2],args[3],args[4]);
			}
			this._drawCircle=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(args[6]);
				Stat.drawCall++;
				ctx.beginPath();
				Render.isWebGL && ctx.movePath(args[0]+x,args[1]+y);
				ctx.arc(args[0]+x,args[1]+y,args[2],0,RenderContext.PI2);
				ctx.closePath();
				this._fillAndStroke(args[3],args[4],args[5],true);
			}
			this._fillCircle=function(x,y,args){
				Stat.drawCall++;
				var ctx=this.ctx;
				ctx.beginPath();
				ctx.fillStyle=args[3];
				ctx.arc(args[0]+x,args[1]+y,args[2],0,RenderContext.PI2);
				ctx.fill();
			}
			this._setShader=function(x,y,args){
				this.ctx.setShader(args[0]);
			}
			this._drawLine=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(args[6]);
				ctx.beginPath();
				ctx.strokeStyle=args[4];
				ctx.lineWidth=args[5];
				if (Render.isWebGL){
					ctx.movePath(x,y);
					ctx.moveTo(args[0],args[1]);
					ctx.lineTo(args[2],args[3]);
					}else {
					ctx.moveTo(x+args[0],y+args[1]);
					ctx.lineTo(x+args[2],y+args[3]);
				}
				ctx.stroke();
			}
			this._drawLines=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(args[5]);
				ctx.beginPath();
				x+=args[0],y+=args[1];
				Render.isWebGL && ctx.movePath(x,y);
				ctx.strokeStyle=args[3];
				ctx.lineWidth=args[4];
				var points=args[2];
				var i=2,n=points.length;
				if (Render.isWebGL){
					ctx.moveTo(points[0],points[1]);
					while (i < n){
						ctx.lineTo(points[i++],points[i++]);
					}
					}else {
					ctx.moveTo(x+points[0],y+points[1]);
					while (i < n){
						ctx.lineTo(x+points[i++],y+points[i++]);
					}
				}
				ctx.stroke();
			}
			this._drawLinesWebGL=function(x,y,args){
				this.ctx.drawLines(x+this.x+args[0],y+this.y+args[1],args[2],args[3],args[4]);
			}
			this._drawCurves=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(-1);
				ctx.beginPath();
				ctx.strokeStyle=args[3];
				ctx.lineWidth=args[4];
				var points=args[2];
				x+=args[0],y+=args[1];
				ctx.moveTo(x+points[0],y+points[1]);
				var i=2,n=points.length;
				while (i < n){
					ctx.quadraticCurveTo(x+points[i++],y+points[i++],x+points[i++],y+points[i++]);
				}
				ctx.stroke();
			}
			this._draw=function(x,y,args){
				args[0].call(null,this,x,y);
			}
			this._transformByMatrix=function(x,y,args){
				this.ctx.transformByMatrix(args[0]);
			}
			this._setTransform=function(x,y,args){
				this.ctx.setTransform(args[0],args[1],args[2],args[3],args[4],args[5]);
			}
			this._setTransformByMatrix=function(x,y,args){
				this.ctx.setTransformByMatrix(args[0]);
			}
			this._save=function(x,y,args){
				this.ctx.save();
			}
			this._restore=function(x,y,args){
				this.ctx.restore();
			}
			this._translate=function(x,y,args){
				this.ctx.translate(args[0],args[1]);
			}
			this._transform=function(x,y,args){
				this.ctx.translate(args[1]+x,args[2]+y);
				var mat=args[0];
				this.ctx.transform(mat.a,mat.b,mat.c,mat.d,mat.tx,mat.ty);
				this.ctx.translate(-x-args[1],-y-args[2]);
			}
			this._rotate=function(x,y,args){
				this.ctx.translate(args[1]+x,args[2]+y);
				this.ctx.rotate(args[0]);
				this.ctx.translate(-x-args[1],-y-args[2]);
			}
			this._scale=function(x,y,args){
				this.ctx.translate(args[2]+x,args[3]+y);
				this.ctx.scale(args[0],args[1]);
				this.ctx.translate(-x-args[2],-y-args[3]);
			}
			this._alpha=function(x,y,args){
				this.ctx.globalAlpha *=args[0];
			}
			this._setAlpha=function(x,y,args){
				this.ctx.globalAlpha=args[0];
			}
			this._fillText=function(x,y,args){
				this.ctx.fillText(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5]);
			}
			this._strokeText=function(x,y,args){
				this.ctx.strokeText(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5],args[6]);
			}
			this._fillBorderText=function(x,y,args){
				this.ctx.fillBorderText(args[0],args[1]+x,args[2]+y,args[3],args[4],args[5],args[6],args[7]);
			}
			this._blendMode=function(x,y,args){
				this.ctx.globalCompositeOperation=args[0];
			}
			this._beginClip=function(x,y,args){
				this.ctx.beginClip && this.ctx.beginClip(x+args[0],y+args[1],args[2],args[3]);
			}
			this._setIBVB=function(x,y,args){
				this.ctx.setIBVB(args[0]+x,args[1]+y,args[2],args[3],args[4],args[5],args[6],args[7]);
			}
			this._fillTrangles=function(x,y,args){
				this.ctx.fillTrangles(args[0],args[1]+x,args[2]+y,args[3],args[4]);
			}
			this._drawPath=function(x,y,args){
				var ctx=this.ctx;
				Render.isWebGL && ctx.setPathId(-1);
				ctx.beginPath();
				x+=args[0],y+=args[1];
				var paths=args[2];
				for (var i=0,n=paths.length;i < n;i++){
					var path=paths[i];
					switch (path[0]){
						case "moveTo":
							ctx.moveTo(x+path[1],y+path[2]);
							break ;
						case "lineTo":
							ctx.lineTo(x+path[1],y+path[2]);
							break ;
						case "arcTo":
							ctx.arcTo(x+path[1],y+path[2],x+path[3],y+path[4],path[5]);
							break ;
						case "closePath":
							ctx.closePath();
							break ;
						}
				};
				var brush=args[3];
				if (brush !=null){
					ctx.fillStyle=brush.fillStyle;
					ctx.fill();
				};
				var pen=args[4];
				if (pen !=null){
					ctx.strokeStyle=pen.strokeStyle;
					ctx.lineWidth=pen.lineWidth || 1;
					ctx.lineJoin=pen.lineJoin;
					ctx.lineCap=pen.lineCap;
					ctx.miterLimit=pen.miterLimit;
					ctx.stroke();
				}
			}
			this.drawPoly=function(x,y,args){
				this.ctx.drawPoly(x+this.x+args[0],y+this.y+args[1],args[2],args[3],args[4],args[5],args[6]);
			}
			this._drawPoly=function(x,y,args){
				var ctx=this.ctx;
				var points=args[2];
				var i=2,n=points.length;
				if (Render.isWebGL){
					ctx.setPathId(args[6]);
					ctx.beginPath();
					x+=args[0],y+=args[1];
					ctx.movePath(x,y);
					ctx.moveTo(points[0],points[1]);
					while (i < n){
						ctx.lineTo(points[i++],points[i++]);
					}
					}else {
					ctx.beginPath();
					x+=args[0],y+=args[1];
					ctx.moveTo(x+points[0],y+points[1]);
					while (i < n){
						ctx.lineTo(x+points[i++],y+points[i++]);
					}
				}
				ctx.closePath();
				this._fillAndStroke(args[3],args[4],args[5],args[7]);
			}
			this._drawSkin=function(x,y,args){
				var tSprite=args[0];
				if (tSprite){
					var ctx=this.ctx;
					tSprite.render(ctx,x,y);
				}
			}
			this._drawParticle=function(x,y,args){
				this.ctx.drawParticle(x+this.x,y+this.y,args[0]);
			}
			if (canvas){
				this.ctx=canvas.getContext('2d');
				}else {
				canvas=HTMLCanvas.create("3D");
				this.ctx=RunDriver.createWebGLContext2D(canvas);
				canvas._setContext(this.ctx);
			}
			canvas.size(width,height);
			this.canvas=canvas;
		}

		__class(RenderContext,'laya.renders.RenderContext');
		var __proto=RenderContext.prototype;
		/**销毁当前渲染环境*/
		__proto.destroy=function(){
			if (this.canvas){
				this.canvas.destroy();
				this.canvas=null;
			}
			if (this.ctx){
				this.ctx.destroy();
				this.ctx=null;
			}
		}

		__proto.drawTexture=function(tex,x,y,width,height){
			if (tex.loaded)this.ctx.drawTexture(tex,x,y,width,height,this.x,this.y);
		}

		__proto.drawTextureWithTransform=function(tex,x,y,width,height,m){
			if (tex.loaded)this.ctx.drawTextureWithTransform(tex,x,y,width,height,m,this.x,this.y);
		}

		__proto.fillQuadrangle=function(tex,x,y,point4,m){
			this.ctx.fillQuadrangle(tex,x,y,point4,m);
		}

		__proto.drawCanvas=function(canvas,x,y,width,height){
			this.ctx.drawCanvas(canvas,x+this.x,y+this.y,width,height);
		}

		__proto.drawRect=function(x,y,width,height,color,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var ctx=this.ctx;
			ctx.strokeStyle=color;
			ctx.lineWidth=lineWidth;
			ctx.strokeRect(x+this.x,y+this.y,width,height,lineWidth);
		}

		__proto._fillAndStroke=function(fillColor,strokeColor,lineWidth,isConvexPolygon){
			(isConvexPolygon===void 0)&& (isConvexPolygon=false);
			var ctx=this.ctx;
			if (fillColor !=null){
				ctx.fillStyle=fillColor;
				if (Render.isWebGL){
					ctx.fill(isConvexPolygon);
					}else {
					ctx.fill();
				}
			}
			if (strokeColor !=null && lineWidth > 0){
				ctx.strokeStyle=strokeColor;
				ctx.lineWidth=lineWidth;
				ctx.stroke();
			}
		}

		//ctx.translate(-x-args[0],-y-args[1]);
		__proto.clipRect=function(x,y,width,height){
			this.ctx.clipRect(x+this.x,y+this.y,width,height);
		}

		__proto.fillRect=function(x,y,width,height,fillStyle){
			this.ctx.fillRect(x+this.x,y+this.y,width,height,fillStyle);
		}

		__proto.drawCircle=function(x,y,radius,color,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			Stat.drawCall++;
			var ctx=this.ctx;
			ctx.beginPath();
			ctx.strokeStyle=color;
			ctx.lineWidth=lineWidth;
			ctx.arc(x+this.x,y+this.y,radius,0,RenderContext.PI2);
			ctx.stroke();
		}

		__proto.fillCircle=function(x,y,radius,color){
			Stat.drawCall++;
			var ctx=this.ctx;
			ctx.beginPath();
			ctx.fillStyle=color;
			ctx.arc(x+this.x,y+this.y,radius,0,RenderContext.PI2);
			ctx.fill();
		}

		__proto.setShader=function(shader){
			this.ctx.setShader(shader);
		}

		__proto.drawLine=function(fromX,fromY,toX,toY,color,lineWidth){
			(lineWidth===void 0)&& (lineWidth=1);
			var ctx=this.ctx;
			ctx.beginPath();
			ctx.strokeStyle=color;
			ctx.lineWidth=lineWidth;
			ctx.moveTo(this.x+fromX,this.y+fromY);
			ctx.lineTo(this.x+toX,this.y+toY);
			ctx.stroke();
		}

		__proto.clear=function(){
			this.ctx.clear();
		}

		__proto.transformByMatrix=function(value){
			this.ctx.transformByMatrix(value);
		}

		__proto.setTransform=function(a,b,c,d,tx,ty){
			this.ctx.setTransform(a,b,c,d,tx,ty);
		}

		__proto.setTransformByMatrix=function(value){
			this.ctx.setTransformByMatrix(value);
		}

		__proto.save=function(){
			this.ctx.save();
		}

		__proto.restore=function(){
			this.ctx.restore();
		}

		__proto.translate=function(x,y){
			this.ctx.translate(x,y);
		}

		__proto.transform=function(a,b,c,d,tx,ty){
			this.ctx.transform(a,b,c,d,tx,ty);
		}

		__proto.rotate=function(angle){
			this.ctx.rotate(angle);
		}

		__proto.scale=function(scaleX,scaleY){
			this.ctx.scale(scaleX,scaleY);
		}

		__proto.alpha=function(value){
			this.ctx.globalAlpha *=value;
		}

		__proto.setAlpha=function(value){
			this.ctx.globalAlpha=value;
		}

		__proto.fillWords=function(words,x,y,font,color){
			this.ctx.fillWords(words,x,y,font,color);
		}

		__proto.fillText=function(text,x,y,font,color,textAlign){
			this.ctx.fillText(text,x+this.x,y+this.y,font,color,textAlign);
		}

		__proto.strokeText=function(text,x,y,font,color,lineWidth,textAlign){
			this.ctx.strokeText(text,x+this.x,y+this.y,font,color,lineWidth,textAlign);
		}

		__proto.blendMode=function(type){
			this.ctx.globalCompositeOperation=type;
		}

		__proto.flush=function(){
			this.ctx.flush && this.ctx.flush();
		}

		__proto.addRenderObject=function(o){
			this.ctx.addRenderObject(o);
		}

		__proto.beginClip=function(x,y,w,h){
			this.ctx.beginClip && this.ctx.beginClip(x,y,w,h);
		}

		__proto.endClip=function(){
			this.ctx.endClip && this.ctx.endClip();
		}

		__proto.fillTrangles=function(x,y,args){
			this.ctx.fillTrangles(args[0],args[1],args[2],args[3],args.length > 4 ? args[4] :null);
		}

		RenderContext.PI2=2 *Math.PI;
		return RenderContext;
	})()


	/**
	*@private
	*精灵渲染器
	*/
	//class laya.renders.RenderSprite
	var RenderSprite=(function(){
		function RenderSprite(type,next){
			//this._next=null;
			//this._fun=null;
			this._next=next || RenderSprite.NORENDER;
			switch (type){
				case 0:
					this._fun=this._no;
					return;
				case 0x01:
					this._fun=this._image;
					return;
				case 0x02:
					this._fun=this._alpha;
					return;
				case 0x04:
					this._fun=this._transform;
					return;
				case 0x20:
					this._fun=this._blend;
					return;
				case 0x08:
					this._fun=this._canvas;
					return;
				case 0x40:
					this._fun=this._clip;
					return;
				case 0x80:
					this._fun=this._style;
					return;
				case 0x100:
					this._fun=this._graphics;
					return;
				case 0x800:
					this._fun=this._childs;
					return;
				case 0x200:
					this._fun=this._custom;
					return;
				case 0x01 | 0x100:
					this._fun=this._image2;
					return;
				case 0x01 | 0x04 | 0x100:
					this._fun=this._image2;
					return;
				case 0x10:
					this._fun=Filter._filter;
					return;
				case 0x11111:
					this._fun=RenderSprite._initRenderFun;
					return;
				}
			this.onCreate(type);
		}

		__class(RenderSprite,'laya.renders.RenderSprite');
		var __proto=RenderSprite.prototype;
		__proto.onCreate=function(type){}
		__proto._style=function(sprite,context,x,y){
			sprite._style.render(sprite,context,x,y);
			var next=this._next;
			next._fun.call(next,sprite,context,x,y);
		}

		__proto._no=function(sprite,context,x,y){}
		__proto._custom=function(sprite,context,x,y){
			sprite.customRender(context,x,y);
			var tf=sprite._style._tf;
			this._next._fun.call(this._next,sprite,context,x-tf.translateX,y-tf.translateY);
		}

		__proto._clip=function(sprite,context,x,y){
			var next=this._next;
			if (next==RenderSprite.NORENDER)return;
			var r=sprite._style.scrollRect;
			context.ctx.save();
			context.ctx.clipRect(x,y,r.width,r.height);
			next._fun.call(next,sprite,context,x-r.x,y-r.y);
			context.ctx.restore();
		}

		__proto._blend=function(sprite,context,x,y){
			var style=sprite._style;
			if (style.blendMode){
				context.ctx.globalCompositeOperation=style.blendMode;
			};
			var next=this._next;
			next._fun.call(next,sprite,context,x,y);
			var mask=sprite.mask;
			if (mask){
				context.ctx.globalCompositeOperation="destination-in";
				if (mask.numChildren > 0 || !mask.graphics._isOnlyOne()){
					mask.cacheAsBitmap=true;
				}
				mask.render(context,x,y);
			}
			context.ctx.globalCompositeOperation="source-over";
		}

		__proto._graphics=function(sprite,context,x,y){
			var tf=sprite._style._tf;
			sprite._graphics && sprite._graphics._render(sprite,context,x-tf.translateX,y-tf.translateY);
			var next=this._next;
			next._fun.call(next,sprite,context,x,y);
		}

		__proto._image=function(sprite,context,x,y){
			var style=sprite._style;
			context.ctx.drawTexture2(x,y,style._tf.translateX,style._tf.translateY,sprite.transform,style.alpha,style.blendMode,sprite._graphics._one);
		}

		__proto._image2=function(sprite,context,x,y){
			var tf=sprite._style._tf;
			context.ctx.drawTexture2(x,y,tf.translateX,tf.translateY,sprite.transform,1,null,sprite._graphics._one);
		}

		__proto._alpha=function(sprite,context,x,y){
			var style=sprite._style;
			var alpha;
			if ((alpha=style.alpha)> 0.01){
				var temp=context.ctx.globalAlpha;
				context.ctx.globalAlpha *=alpha;
				var next=this._next;
				next._fun.call(next,sprite,context,x,y);
				context.ctx.globalAlpha=temp;
			}
		}

		__proto._transform=function(sprite,context,x,y){
			var transform=sprite.transform,_next=this._next;
			if (transform && _next !=RenderSprite.NORENDER){
				context.save();
				context.transform(transform.a,transform.b,transform.c,transform.d,transform.tx+x,transform.ty+y);
				_next._fun.call(_next,sprite,context,0,0);
				context.restore();
			}else
			_next._fun.call(_next,sprite,context,x,y);
		}

		__proto._childs=function(sprite,context,x,y){
			var style=sprite._style;
			x+=-style._tf.translateX+style.paddingLeft;
			y+=-style._tf.translateY+style.paddingTop;
			var words=sprite._getWords();
			words && context.fillWords(words,x,y,(style).font,(style).color);
			var childs=sprite._childs,n=childs.length,ele;
			if (!sprite.optimizeScrollRect || sprite.scrollRect==null){
				for (var i=0;i < n;++i)
				(ele=(childs [i]))._style.visible && ele.render(context,x,y);
				}else {
				var rect=sprite.scrollRect;
				for (i=0;i < n;++i){
					ele=childs [i];
					if (ele._style.visible && rect.intersects(Rectangle.TEMP.setTo(ele.x,ele.y,ele.width,ele.height)))
						ele.render(context,x,y);
				}
			}
		}

		__proto._canvas=function(sprite,context,x,y){
			var _cacheCanvas=sprite._$P.cacheCanvas;
			var _next=this._next;
			if (!_cacheCanvas){
				_next._fun.call(_next,sprite,tx,x,y);
				return;
			};
			var tx=_cacheCanvas.ctx;
			var _repaint=sprite._needRepaint()|| (!tx);
			var canvas;
			var left;
			var top;
			var tRec;
			_cacheCanvas.type==='bitmap' ? (Stat.canvasBitmap++):(Stat.canvasNormal++);
			if (_repaint){
				if (!_cacheCanvas._cacheRec)
					_cacheCanvas._cacheRec=new Rectangle();
				var w,h;
				tRec=sprite.getSelfBounds();
				if (Render.isWebGL && _cacheCanvas.type==='bitmap' && (tRec.width > 2048 || tRec.height > 2048)){
					console.log("cache bitmap size larger than 2048,cache ignored");
					_next._fun.call(_next,sprite,tx,x,y);
					return;
				}
				tRec.x-=sprite.pivotX;
				tRec.y-=sprite.pivotY;
				tRec.x-=10;
				tRec.y-=10;
				tRec.width+=20;
				tRec.height+=20;
				tRec.x=Math.floor(tRec.x+x)-x;
				tRec.y=Math.floor(tRec.y+y)-y;
				tRec.width=Math.floor(tRec.width);
				tRec.height=Math.floor(tRec.height);
				_cacheCanvas._cacheRec.copyFrom(tRec);
				tRec=_cacheCanvas._cacheRec;
				var scaleX=Render.isWebGL?1:Browser.pixelRatio *Laya.stage.clientScaleX;
				var scaleY=Render.isWebGL?1:Browser.pixelRatio *Laya.stage.clientScaleY;
				if (!Render.isWebGL){
					var chainScaleX=1;
					var chainScaleY=1;
					var tar;
					tar=sprite;
					while (tar && tar !=Laya.stage){
						chainScaleX *=tar.scaleX;
						chainScaleY *=tar.scaleY;
						tar=tar.parent;
					}
					if (chainScaleX > 1)scaleX *=chainScaleX;
					if (chainScaleY > 1)scaleY *=chainScaleY;
				}
				w=tRec.width *scaleX;
				h=tRec.height *scaleY;
				left=tRec.x;
				top=tRec.y;
				if (!tx){
					tx=_cacheCanvas.ctx=Pool.getItem("RenderContext")||new RenderContext(w,h,HTMLCanvas.create("AUTO"));
					tx.ctx.sprite=sprite;
				}
				canvas=tx.canvas;
				if (_cacheCanvas.type==='bitmap')canvas.context.asBitmap=true;
				canvas.clear();
				(canvas.width !=w || canvas.height !=h)&& canvas.size(w,h);
				var t;
				if (scaleX!=1||scaleY!=1){
					var ctx=(tx).ctx;
					ctx.save();
					ctx.scale(scaleX,scaleY);
					if (!Render.isConchWebGL&&Render.isConchApp){
						t=sprite._$P.cf;
						t&&ctx.setFilterMatrix&&ctx.setFilterMatrix(t._mat,t._alpha);
					}
					_next._fun.call(_next,sprite,tx,-left,-top);
					ctx.restore();
					if(!Render.isConchApp||Render.isConchWebGL)sprite._applyFilters();
					}else {
					ctx=(tx).ctx;
					if (!Render.isConchWebGL&&Render.isConchApp){
						t=sprite._$P.cf;
						t&&ctx.setFilterMatrix&&ctx.setFilterMatrix(t._mat,t._alpha);
					}
					_next._fun.call(_next,sprite,tx,-left,-top);
					if(!Render.isConchApp||Render.isConchWebGL)sprite._applyFilters();
				}
				if (sprite._$P.staticCache)_cacheCanvas.reCache=false;
				Stat.canvasReCache++;
				}else {
				tRec=_cacheCanvas._cacheRec;
				left=tRec.x;
				top=tRec.y;
				canvas=tx.canvas;
			}
			context.drawCanvas(canvas,x+left,y+top,tRec.width,tRec.height);
		}

		RenderSprite.__init__=function(){
			var i=0,len=0;
			var initRender;
			initRender=RunDriver.createRenderSprite(0x11111,null);
			len=RenderSprite.renders.length=0x800 *2;
			for (i=0;i < len;i++)
			RenderSprite.renders[i]=initRender;
			RenderSprite.renders[0]=RunDriver.createRenderSprite(0,null);
			function _initSame (value,o){
				var n=0;
				for (var i=0;i < value.length;i++){
					n |=value[i];
					RenderSprite.renders[n]=o;
				}
			}
			_initSame([0x01,0x100,0x04,0x02],new RenderSprite(0x01,null));
			RenderSprite.renders[0x01 | 0x100]=RunDriver.createRenderSprite(0x01 | 0x100,null);
			RenderSprite.renders[0x01 | 0x04 | 0x100]=new RenderSprite(0x01 | 0x04 | 0x100,null);
		}

		RenderSprite._initRenderFun=function(sprite,context,x,y){
			var type=sprite._renderType;
			var r=RenderSprite.renders[type]=RenderSprite._getTypeRender(type);
			r._fun(sprite,context,x,y);
		}

		RenderSprite._getTypeRender=function(type){
			var rst=null;
			var tType=0x800;
			while (tType > 1){
				if (tType & type)
					rst=RunDriver.createRenderSprite(tType,rst);
				tType=tType >> 1;
			}
			return rst;
		}

		RenderSprite.IMAGE=0x01;
		RenderSprite.ALPHA=0x02;
		RenderSprite.TRANSFORM=0x04;
		RenderSprite.CANVAS=0x08;
		RenderSprite.FILTERS=0x10;
		RenderSprite.BLEND=0x20;
		RenderSprite.CLIP=0x40;
		RenderSprite.STYLE=0x80;
		RenderSprite.GRAPHICS=0x100;
		RenderSprite.CUSTOM=0x200;
		RenderSprite.CHILDS=0x800;
		RenderSprite.INIT=0x11111;
		RenderSprite.renders=[];
		RenderSprite.NORENDER=new RenderSprite(0,null);
		return RenderSprite;
	})()


	/**
	*@private
	*Context扩展类
	*/
	//class laya.resource.Context
	var Context=(function(){
		function Context(){
			//this._canvas=null;
			this._repaint=false;
		}

		__class(Context,'laya.resource.Context');
		var __proto=Context.prototype;
		__proto.setIsMainContext=function(){}
		/***@private */
		__proto.drawCanvas=function(canvas,x,y,width,height){
			Stat.drawCall++;
			this.drawImage(canvas.source,x,y,width,height);
		}

		/***@private */
		__proto.fillRect=function(x,y,width,height,style){
			Stat.drawCall++;
			style && (this.fillStyle=style);
			this.__fillRect(x,y,width,height);
		}

		/***@private */
		__proto.fillText=function(text,x,y,font,color,textAlign){
			Stat.drawCall++;
			if (arguments.length > 3 && font !=null){
				this.font=font;
				this.fillStyle=color;
				this.textAlign=textAlign;
				this.textBaseline="top";
			}
			this.__fillText(text,x,y);
		}

		/***@private */
		__proto.fillBorderText=function(text,x,y,font,fillColor,borderColor,lineWidth,textAlign){
			Stat.drawCall++;
			this.font=font;
			this.fillStyle=fillColor;
			this.textBaseline="top";
			this.strokeStyle=borderColor;
			this.lineWidth=lineWidth;
			this.textAlign=textAlign;
			this.__strokeText(text,x,y);
			this.__fillText(text,x,y);
		}

		/***@private */
		__proto.strokeText=function(text,x,y,font,color,lineWidth,textAlign){
			Stat.drawCall++;
			if (arguments.length > 3 && font !=null){
				this.font=font;
				this.strokeStyle=color;
				this.lineWidth=lineWidth;
				this.textAlign=textAlign;
				this.textBaseline="top";
			}
			this.__strokeText(text,x,y);
		}

		/***@private */
		__proto.transformByMatrix=function(value){
			this.transform(value.a,value.b,value.c,value.d,value.tx,value.ty);
		}

		/***@private */
		__proto.setTransformByMatrix=function(value){
			this.setTransform(value.a,value.b,value.c,value.d,value.tx,value.ty);
		}

		/***@private */
		__proto.clipRect=function(x,y,width,height){
			Stat.drawCall++;
			this.beginPath();
			this.rect(x,y,width,height);
			this.clip();
		}

		/***@private */
		__proto.drawTexture=function(tex,x,y,width,height,tx,ty){
			Stat.drawCall++;
			var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
			this.drawImage(tex.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,x+tx,y+ty,width,height);
		}

		/***@private */
		__proto.drawTextureWithTransform=function(tex,x,y,width,height,m,tx,ty){
			Stat.drawCall++;
			var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
			this.save();
			this.transform(m.a,m.b,m.c,m.d,m.tx+tx,m.ty+ty);
			this.drawImage(tex.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,x ,y,width,height);
			this.restore();
		}

		/***@private */
		__proto.drawTexture2=function(x,y,pivotX,pivotY,m,alpha,blendMode,args2){
			'use strict';
			var tex=args2[0];
			if (!(tex.loaded && tex.bitmap && tex.source)){
				return;
			}
			Stat.drawCall++;
			var alphaChanged=alpha!==1;
			if (alphaChanged){
				var temp=this.globalAlpha;
				this.globalAlpha *=alpha;
			};
			var uv=tex.uv,w=tex.bitmap.width,h=tex.bitmap.height;
			if (m){
				this.save();
				this.transform(m.a,m.b,m.c,m.d,m.tx+x,m.ty+y);
				this.drawImage(tex.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,args2[1]-pivotX ,args2[2]-pivotY,args2[3],args2[4]);
				this.restore();
				}else {
				this.drawImage(tex.source,uv[0] *w,uv[1] *h,(uv[2]-uv[0])*w,(uv[5]-uv[3])*h,args2[1]-pivotX+x ,args2[2]-pivotY+y,args2[3],args2[4]);
			}
			if (alphaChanged)this.globalAlpha=temp;
		}

		/***@private */
		__proto.flush=function(){
			return 0;
		}

		/***@private */
		__proto.fillWords=function(words,x,y,font,color){
			font && (this.font=font);
			color && (this.fillStyle=color);
			var _this=this;
			this.textBaseline="top";
			this.textAlign='left';
			for (var i=0,n=words.length;i < n;i++){
				var a=words[i];
				this.__fillText(a.char,a.x+x,a.y+y);
			}
		}

		/***@private */
		__proto.destroy=function(){
			this.canvas.width=this.canvas.height=0;
		}

		/***@private */
		__proto.clear=function(){
			this.clearRect(0,0,this._canvas.width,this._canvas.height);
			this._repaint=false;
		}

		Context.__init__=function(){
			var from=laya.resource.Context.prototype;
			var to=CanvasRenderingContext2D.prototype;
			to.__fillText=to.fillText;
			to.__fillRect=to.fillRect;
			to.__strokeText=to.strokeText;
			var funs=['fillWords','setIsMainContext','fillRect','strokeText','fillText','transformByMatrix','setTransformByMatrix','clipRect','drawTexture','drawTexture2','drawTextureWithTransform','flush','clear','destroy','drawCanvas','fillBorderText'];
			funs.forEach(function(i){
				to[i]=from[i];
			});
		}

		Context._default=new Context();
		return Context;
	})()


	/**
	*<code>ResourceManager</code> 是资源管理类。它用于资源的载入、获取、销毁。
	*/
	//class laya.resource.ResourceManager
	var ResourceManager=(function(){
		function ResourceManager(){
			this._id=0;
			this._name=null;
			this._resources=null;
			this._memorySize=0;
			this._garbageCollectionRate=NaN;
			this._isOverflow=false;
			this.autoRelease=false;
			this.autoReleaseMaxSize=0;
			this._id=++ResourceManager._uniqueIDCounter;
			this._name="Content Manager";
			ResourceManager._isResourceManagersSorted=false;
			this._memorySize=0;
			this._isOverflow=false;
			this.autoRelease=false;
			this.autoReleaseMaxSize=1024 *1024 *512;
			this._garbageCollectionRate=0.2;
			ResourceManager._resourceManagers.push(this);
			this._resources=[];
		}

		__class(ResourceManager,'laya.resource.ResourceManager');
		var __proto=ResourceManager.prototype;
		Laya.imps(__proto,{"laya.resource.IDispose":true})
		/**
		*获取指定索引的资源 Resource 对象。
		*@param 索引。
		*@return 资源 Resource 对象。
		*/
		__proto.getResourceByIndex=function(index){
			return this._resources[index];
		}

		/**
		*获取此管理器所管理的资源个数。
		*@return 资源个数。
		*/
		__proto.getResourcesLength=function(){
			return this._resources.length;
		}

		/**
		*添加指定资源。
		*@param resource 需要添加的资源 Resource 对象。
		*@return 是否添加成功。
		*/
		__proto.addResource=function(resource){
			if (resource.resourceManager)
				resource.resourceManager.removeResource(resource);
			var index=this._resources.indexOf(resource);
			if (index===-1){
				resource._resourceManager=this;
				this._resources.push(resource);
				this.addSize(resource.memorySize);
				return true;
			}
			return false;
		}

		/**
		*移除指定资源。
		*@param resource 需要移除的资源 Resource 对象
		*@return 是否移除成功。
		*/
		__proto.removeResource=function(resource){
			var index=this._resources.indexOf(resource);
			if (index!==-1){
				this._resources.splice(index,1);
				resource._resourceManager=null;
				this._memorySize-=resource.memorySize;
				return true;
			}
			return false;
		}

		/**
		*卸载此资源管理器载入的资源。
		*/
		__proto.unload=function(){
			var tempResources=this._resources.slice(0,this._resources.length);
			for (var i=0;i < tempResources.length;i++){
				var resource=tempResources[i];
				resource.dispose();
			}
			tempResources.length=0;
		}

		/**
		*设置唯一名字。
		*@param newName 名字，如果名字重复则自动加上“-copy”。
		*/
		__proto.setUniqueName=function(newName){
			var isUnique=true;
			for (var i=0;i < ResourceManager._resourceManagers.length;i++){
				if (ResourceManager._resourceManagers[i]._name!==newName || ResourceManager._resourceManagers[i]===this)
					continue ;
				isUnique=false;
				return;
			}
			if (isUnique){
				if (this.name !=newName){
					this.name=newName;
					ResourceManager._isResourceManagersSorted=false;
				}
				}else{
				this.setUniqueName(newName.concat("-copy"));
			}
		}

		/**释放资源。*/
		__proto.dispose=function(){
			if (this===ResourceManager._systemResourceManager)
				throw new Error("systemResourceManager不能被释放！");
			ResourceManager._resourceManagers.splice(ResourceManager._resourceManagers.indexOf(this),1);
			ResourceManager._isResourceManagersSorted=false;
			var tempResources=this._resources.slice(0,this._resources.length);
			for (var i=0;i < tempResources.length;i++){
				var resource=tempResources[i];
				resource.resourceManager.removeResource(resource);
				resource.dispose();
			}
			tempResources.length=0;
		}

		/**
		*增加内存。
		*@param add 需要增加的内存大小。
		*/
		__proto.addSize=function(add){
			if (add){
				if (this.autoRelease && add > 0)
					((this._memorySize+add)> this.autoReleaseMaxSize)&& (this.garbageCollection((1-this._garbageCollectionRate)*this.autoReleaseMaxSize));
				this._memorySize+=add;
			}
		}

		/**
		*垃圾回收。
		*@param reserveSize 保留尺寸。
		*/
		__proto.garbageCollection=function(reserveSize){
			var all=this._resources;
			all=all.slice();
			all.sort(function(a,b){
				if (!a || !b)
					throw new Error("a或b不能为空！");
				if (a.released && b.released)
					return 0;
				else if (a.released)
				return 1;
				else if (b.released)
				return-1;
				return a.lastUseFrameCount-b.lastUseFrameCount;
			});
			var currentFrameCount=Stat.loopCount;
			for (var i=0,n=all.length;i < n;i++){
				var resou=all[i];
				if (currentFrameCount-resou.lastUseFrameCount > 1){
					resou.releaseResource();
					}else {
					if (this._memorySize >=reserveSize)
						this._isOverflow=true;
					return;
				}
				if (this._memorySize < reserveSize){
					this._isOverflow=false;
					return;
				}
			}
		}

		/**
		*唯一标识 ID 。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*名字。
		*/
		__getset(0,__proto,'name',function(){
			return this._name;
			},function(value){
			if ((value || value!=="")&& this._name!==value){
				this._name=value;
				ResourceManager._isResourceManagersSorted=false;
			}
		});

		/**
		*此管理器所管理资源的累计内存，以字节为单位。
		*/
		__getset(0,__proto,'memorySize',function(){
			return this._memorySize;
		});

		/**
		*排序后的资源管理器列表。
		*/
		__getset(1,ResourceManager,'sortedResourceManagersByName',function(){
			if (!ResourceManager._isResourceManagersSorted){
				ResourceManager._isResourceManagersSorted=true;
				ResourceManager._resourceManagers.sort(ResourceManager.compareResourceManagersByName);
			}
			return ResourceManager._resourceManagers;
		});

		/**
		*系统资源管理器。
		*/
		__getset(1,ResourceManager,'systemResourceManager',function(){
			(ResourceManager._systemResourceManager===null)&& (ResourceManager._systemResourceManager=new ResourceManager(),ResourceManager._systemResourceManager._name="System Resource Manager");
			return ResourceManager._systemResourceManager;
		});

		ResourceManager.__init__=function(){
			ResourceManager.currentResourceManager=ResourceManager.systemResourceManager;
		}

		ResourceManager.getLoadedResourceManagerByIndex=function(index){
			return ResourceManager._resourceManagers[index];
		}

		ResourceManager.getLoadedResourceManagersCount=function(){
			return ResourceManager._resourceManagers.length;
		}

		ResourceManager.recreateContentManagers=function(force){
			(force===void 0)&& (force=false);
			var temp=ResourceManager.currentResourceManager;
			for (var i=0;i < ResourceManager._resourceManagers.length;i++){
				ResourceManager.currentResourceManager=ResourceManager._resourceManagers[i];
				for (var j=0;j < ResourceManager.currentResourceManager._resources.length;j++){
					ResourceManager.currentResourceManager._resources[j].releaseResource(force);
					ResourceManager.currentResourceManager._resources[j].activeResource(force);
				}
			}
			ResourceManager.currentResourceManager=temp;
		}

		ResourceManager.releaseContentManagers=function(force){
			(force===void 0)&& (force=false);
			var temp=ResourceManager.currentResourceManager;
			for (var i=0;i < ResourceManager._resourceManagers.length;i++){
				ResourceManager.currentResourceManager=ResourceManager._resourceManagers[i];
				for (var j=0;j < ResourceManager.currentResourceManager._resources.length;j++){
					var resource=ResourceManager.currentResourceManager._resources[j];
					(!resource.released)&& (resource.releaseResource(force));
				}
			}
			ResourceManager.currentResourceManager=temp;
		}

		ResourceManager.compareResourceManagersByName=function(left,right){
			if (left==right)
				return 0;
			var x=left._name;
			var y=right._name;
			if (x==null){
				if (y==null)
					return 0;
				else
				return-1;
				}else {
				if (y==null)
					return 1;
				else {
					var retval=x.localeCompare(y);
					if (retval !=0)
						return retval;
					else {
						right.setUniqueName(y);
						y=right._name;
						return x.localeCompare(y);
					}
				}
			}
		}

		ResourceManager._uniqueIDCounter=0;
		ResourceManager._systemResourceManager=null
		ResourceManager._isResourceManagersSorted=false;
		ResourceManager._resourceManagers=[];
		ResourceManager.currentResourceManager=null
		return ResourceManager;
	})()


	/**
	*@private
	*/
	//class laya.system.System
	var System=(function(){
		function System(){};
		__class(System,'laya.system.System');
		System.changeDefinition=function(name,classObj){
			Laya[name]=classObj;
			var str=name+"=classObj";
			eval(str);
		}

		System.__init__=function(){
			if (Render.isConchApp){
				conch.disableConchResManager();
				conch.disableConchAutoRestoreLostedDevice();
			}
		}

		return System;
	})()


	/**
	*<code>LayoutStyle</code> 是一个布局样式类。
	*/
	//class laya.ui.LayoutStyle
	var LayoutStyle=(function(){
		function LayoutStyle(){
			this.enable=false;
			this.top=NaN;
			this.bottom=NaN;
			this.left=NaN;
			this.right=NaN;
			this.centerX=NaN;
			this.centerY=NaN;
			this.anchorX=NaN;
			this.anchorY=NaN;
		}

		__class(LayoutStyle,'laya.ui.LayoutStyle');
		__static(LayoutStyle,
		['EMPTY',function(){return this.EMPTY=new LayoutStyle();}
		]);
		return LayoutStyle;
	})()


	/**
	*<code>UIUtils</code> 是文本工具集。
	*/
	//class laya.ui.UIUtils
	var UIUtils=(function(){
		function UIUtils(){};
		__class(UIUtils,'laya.ui.UIUtils');
		UIUtils.fillArray=function(arr,str,type){
			var temp=arr.concat();
			if (str){
				var a=str.split(",");
				for (var i=0,n=Math.min(temp.length,a.length);i < n;i++){
					var value=a[i];
					temp[i]=(value=="true" ? true :(value=="false" ? false :value));
					if (type !=null)temp[i]=type(value);
				}
			}
			return temp;
		}

		UIUtils.toColor=function(color){
			var str=color.toString("16");
			while (str.length < 6)str="0"+str;
			return "#"+str;
		}

		UIUtils.gray=function(traget,isGray){
			(isGray===void 0)&& (isGray=true);
			if (isGray){
				UIUtils.addFilter(traget,UIUtils.grayFilter);
				}else {
				UIUtils.clearFilter(traget,ColorFilter);
			}
		}

		UIUtils.addFilter=function(target,filter){
			var filters=target.filters || [];
			filters.push(filter);
			target.filters=filters;
		}

		UIUtils.clearFilter=function(target,filterType){
			var filters=target.filters;
			if (filters !=null && filters.length > 0){
				for (var i=filters.length-1;i >-1;i--){
					var filter=filters[i];
					if (Laya.__typeof(filter,filterType))filters.splice(i,1);
				}
				target.filters=filters;
			}
		}

		__static(UIUtils,
		['grayFilter',function(){return this.grayFilter=new ColorFilter([0.3086,0.6094,0.082,0,0,0.3086,0.6094,0.082,0,0,0.3086,0.6094,0.082,0,0,0,0,0,1,0]);}
		]);
		return UIUtils;
	})()


	SoundManager;
	/**
	*<code>Browser</code> 是浏览器代理类。封装浏览器及原生 js 提供的一些功能。
	*/
	//class laya.utils.Browser
	var Browser=(function(){
		function Browser(){};
		__class(Browser,'laya.utils.Browser');
		/**浏览器可视宽度。*/
		__getset(1,Browser,'clientWidth',function(){
			Browser.__init__();
			return Browser.window.innerWidth || Browser.document.body.clientWidth;
		});

		/**浏览器可视高度。*/
		__getset(1,Browser,'clientHeight',function(){
			Browser.__init__();
			return Browser.window.innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight;
		});

		/**浏览器原生 window 对象的引用。*/
		__getset(1,Browser,'window',function(){
			Browser.__init__();
			return Browser._window;
		});

		/**设备像素比。*/
		__getset(1,Browser,'pixelRatio',function(){
			Browser.__init__();
			return RunDriver.getPixelRatio();
		});

		/**浏览器物理宽度，。*/
		__getset(1,Browser,'width',function(){
			Browser.__init__();
			return ((Laya.stage && Laya.stage.canvasRotation)? Browser.clientHeight :Browser.clientWidth)*Browser.pixelRatio;
		});

		/**浏览器物理高度。*/
		__getset(1,Browser,'height',function(){
			Browser.__init__();
			return ((Laya.stage && Laya.stage.canvasRotation)? Browser.clientWidth :Browser.clientHeight)*Browser.pixelRatio;
		});

		/**画布容器，用来盛放画布的容器。方便对画布进行控制*/
		__getset(1,Browser,'container',function(){
			Browser.__init__();
			if (!Browser._container){
				Browser._container=Browser.createElement("div");
				Browser._container.id="layaContainer";
				Browser._container.style.cssText="width:100%;height:100%";
				Browser.document.body.appendChild(Browser._container);
			}
			return Browser._container;
			},function(value){
			Browser._container=value;
		});

		/**浏览器原生 document 对象的引用。*/
		__getset(1,Browser,'document',function(){
			Browser.__init__();
			return Browser._document;
		});

		Browser.__init__=function(){
			if (Browser._window)return;
			Browser._window=RunDriver.getWindow();
			Browser._document=Browser.window.document;
			Browser.document.__createElement=Browser.document.createElement;
			window.requestAnimationFrame=(function(){return window.requestAnimationFrame || window.webkitRequestAnimationFrame ||window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||function (c){return window.setTimeout(c,1000 / 60);};})();
			var $BS=window.document.body.style;$BS.margin=0;$BS.overflow='hidden';;
			var metas=window.document.getElementsByTagName('meta');;
			var i=0,flag=false,content='width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no';;
			while(i<metas.length){var meta=metas[i];if(meta.name=='viewport'){meta.content=content;flag=true;break;}i++;};
			if(!flag){meta=document.createElement('meta');meta.name='viewport',meta.content=content;document.getElementsByTagName('head')[0].appendChild(meta);};
			Browser.userAgent=/*[SAFE]*/ Browser.window.navigator.userAgent;
			Browser.u=/*[SAFE]*/ Browser.userAgent;
			Browser.onIOS=/*[SAFE]*/ !!Browser.u.match(/\(i[^;]+;(U;)? CPU.+Mac OS X/);
			Browser.onMobile=/*[SAFE]*/ Browser.u.indexOf("Mobile")>-1;
			Browser.onIPhone=/*[SAFE]*/ Browser.u.indexOf("iPhone")>-1;
			Browser.onIPad=/*[SAFE]*/ Browser.u.indexOf("iPad")>-1;
			Browser.onAndriod=/*[SAFE]*/ Browser.u.indexOf('Android')>-1 || Browser.u.indexOf('Adr')>-1;
			Browser.onWP=/*[SAFE]*/ Browser.u.indexOf("Windows Phone")>-1;
			Browser.onQQBrowser=/*[SAFE]*/ Browser.u.indexOf("QQBrowser")>-1;
			Browser.onMQQBrowser=/*[SAFE]*/ Browser.u.indexOf("MQQBrowser")>-1;
			Browser.onWeiXin=/*[SAFE]*/ Browser.u.indexOf('MicroMessenger')>-1;
			Browser.onPC=/*[SAFE]*/ !Browser.onMobile;
			Browser.onSafari=/*[SAFE]*/ ! !Browser.u.match(/Version\/\d\.\d\x20Mobile\/\S+\x20Safari/);
			Browser.httpProtocol=/*[SAFE]*/ Browser.window.location.protocol=="http:";
			Browser.webAudioEnabled=/*[SAFE]*/ Browser.window["AudioContext"] || Browser.window["webkitAudioContext"] || Browser.window["mozAudioContext"] ? true :false;
			Browser.soundType=/*[SAFE]*/ Browser.webAudioEnabled ? "WEBAUDIOSOUND" :"AUDIOSOUND";
			Sound=Browser.webAudioEnabled?WebAudioSound:AudioSound;;
			if (Browser.webAudioEnabled)WebAudioSound.initWebAudio();;
			Browser.enableTouch=(('ontouchstart' in window)|| window.DocumentTouch && document instanceof DocumentTouch);
			window.focus();
			SoundManager._soundClass=Sound;;
			Render._mainCanvas=Render._mainCanvas||HTMLCanvas.create('2D');
			if (Browser.canvas)return;
			Browser.canvas=HTMLCanvas.create('2D');
			Browser.context=Browser.canvas.getContext('2d');
		}

		Browser.createElement=function(type){
			Browser.__init__();
			return Browser.document.__createElement(type);
		}

		Browser.getElementById=function(type){
			Browser.__init__();
			return Browser.document.getElementById(type);
		}

		Browser.removeElement=function(ele){
			if (ele && ele.parentNode)ele.parentNode.removeChild(ele);
		}

		Browser.now=function(){
			return RunDriver.now();
		}

		Browser._window=null
		Browser._document=null
		Browser._container=null
		Browser.userAgent=null
		Browser.u=null
		Browser.onIOS=false;
		Browser.onMobile=false;
		Browser.onIPhone=false;
		Browser.onIPad=false;
		Browser.onAndriod=false;
		Browser.onWP=false;
		Browser.onQQBrowser=false;
		Browser.onMQQBrowser=false;
		Browser.onSafari=false;
		Browser.onWeiXin=false;
		Browser.onPC=false;
		Browser.httpProtocol=false;
		Browser.webAudioEnabled=false;
		Browser.soundType=null
		Browser.enableTouch=false;
		Browser.canvas=null
		Browser.context=null
		Browser.__init$=function(){
			AudioSound;
			WebAudioSound;
		}

		return Browser;
	})()


	/**
	*
	*<code>Byte</code> 类提供用于优化读取、写入以及处理二进制数据的方法和属性。
	*/
	//class laya.utils.Byte
	var Byte=(function(){
		function Byte(data){
			this._xd_=true;
			this._allocated_=8;
			//this._d_=null;
			//this._u8d_=null;
			this._pos_=0;
			this._length=0;
			if (data){
				this._u8d_=new Uint8Array(data);
				this._d_=new DataView(this._u8d_.buffer);
				this._length=this._d_.byteLength;
				}else {
				this.___resizeBuffer(this._allocated_);
			}
		}

		__class(Byte,'laya.utils.Byte');
		var __proto=Byte.prototype;
		/**@private */
		__proto.___resizeBuffer=function(len){
			try {
				var newByteView=new Uint8Array(len);
				if (this._u8d_ !=null){
					if (this._u8d_.length <=len)newByteView.set(this._u8d_);
					else newByteView.set(this._u8d_.subarray(0,len));
				}
				this._u8d_=newByteView;
				this._d_=new DataView(newByteView.buffer);
				}catch (err){
				throw "___resizeBuffer err:"+len;
			}
		}

		/**
		*读取字符型值。
		*@return
		*/
		__proto.getString=function(){
			return this.rUTF(this.getUint16());
		}

		/**
		*从指定的位置读取指定长度的数据用于创建一个 Float32Array 对象并返回此对象。
		*@param start 开始位置。
		*@param len 需要读取的字节长度。
		*@return 读出的 Float32Array 对象。
		*/
		__proto.getFloat32Array=function(start,len){
			var v=new Float32Array(this._d_.buffer.slice(start,start+len));
			this._pos_+=len;
			return v;
		}

		/**
		*从指定的位置读取指定长度的数据用于创建一个 Uint8Array 对象并返回此对象。
		*@param start 开始位置。
		*@param len 需要读取的字节长度。
		*@return 读出的 Uint8Array 对象。
		*/
		__proto.getUint8Array=function(start,len){
			var v=new Uint8Array(this._d_.buffer.slice(start,start+len));
			this._pos_+=len;
			return v;
		}

		/**
		*从指定的位置读取指定长度的数据用于创建一个 Int16Array 对象并返回此对象。
		*@param start 开始位置。
		*@param len 需要读取的字节长度。
		*@return 读出的 Uint8Array 对象。
		*/
		__proto.getInt16Array=function(start,len){
			var v=new Int16Array(this._d_.buffer.slice(start,start+len));
			this._pos_+=len;
			return v;
		}

		/**
		*在指定字节偏移量位置处读取 Float32 值。
		*@return Float32 值。
		*/
		__proto.getFloat32=function(){
			var v=this._d_.getFloat32(this._pos_,this._xd_);
			this._pos_+=4;
			return v;
		}

		/**
		*在当前字节偏移量位置处写入 Float32 值。
		*@param value 需要写入的 Float32 值。
		*/
		__proto.writeFloat32=function(value){
			this.ensureWrite(this._pos_+4);
			this._d_.setFloat32(this._pos_,value,this._xd_);
			this._pos_+=4;
		}

		/**
		*在当前字节偏移量位置处读取 Int32 值。
		*@return Int32 值。
		*/
		__proto.getInt32=function(){
			var float=this._d_.getInt32(this._pos_,this._xd_);
			this._pos_+=4;
			return float;
		}

		/**
		*在当前字节偏移量位置处读取 Uint32 值。
		*@return Uint32 值。
		*/
		__proto.getUint32=function(){
			var v=this._d_.getUint32(this._pos_,this._xd_);
			this._pos_+=4;
			return v;
		}

		/**
		*在当前字节偏移量位置处写入 Int32 值。
		*@param value 需要写入的 Int32 值。
		*/
		__proto.writeInt32=function(value){
			this.ensureWrite(this._pos_+4);
			this._d_.setInt32(this._pos_,value,this._xd_);
			this._pos_+=4;
		}

		/**
		*在当前字节偏移量位置处写入 Uint32 值。
		*@param value 需要写入的 Uint32 值。
		*/
		__proto.writeUint32=function(value){
			this.ensureWrite(this._pos_+4);
			this._d_.setUint32(this._pos_,value,this._xd_);
			this._pos_+=4;
		}

		/**
		*在当前字节偏移量位置处读取 Int16 值。
		*@return Int16 值。
		*/
		__proto.getInt16=function(){
			var us=this._d_.getInt16(this._pos_,this._xd_);
			this._pos_+=2;
			return us;
		}

		/**
		*在当前字节偏移量位置处读取 Uint16 值。
		*@return Uint16 值。
		*/
		__proto.getUint16=function(){
			var us=this._d_.getUint16(this._pos_,this._xd_);
			this._pos_+=2;
			return us;
		}

		/**
		*在当前字节偏移量位置处写入 Uint16 值。
		*@param value 需要写入的Uint16 值。
		*/
		__proto.writeUint16=function(value){
			this.ensureWrite(this._pos_+2);
			this._d_.setUint16(this._pos_,value,this._xd_);
			this._pos_+=2;
		}

		/**
		*在当前字节偏移量位置处写入 Int16 值。
		*@param value 需要写入的 Int16 值。
		*/
		__proto.writeInt16=function(value){
			this.ensureWrite(this._pos_+2);
			this._d_.setInt16(this._pos_,value,this._xd_);
			this._pos_+=2;
		}

		/**
		*在当前字节偏移量位置处读取 Uint8 值。
		*@return Uint8 值。
		*/
		__proto.getUint8=function(){
			return this._d_.getUint8(this._pos_++);
		}

		/**
		*在当前字节偏移量位置处写入 Uint8 值。
		*@param value 需要写入的 Uint8 值。
		*/
		__proto.writeUint8=function(value){
			this.ensureWrite(this._pos_+1);
			this._d_.setUint8(this._pos_,value,this._xd_);
			this._pos_++;
		}

		/**
		*@private
		*在指定位置处读取 Uint8 值。
		*@param pos 字节读取位置。
		*@return Uint8 值。
		*/
		__proto._getUInt8=function(pos){
			return this._d_.getUint8(pos);
		}

		/**
		*@private
		*在指定位置处读取 Uint16 值。
		*@param pos 字节读取位置。
		*@return Uint16 值。
		*/
		__proto._getUint16=function(pos){
			return this._d_.getUint16(pos,this._xd_);
		}

		/**
		*@private
		*使用 getFloat32()读取6个值，用于创建并返回一个 Matrix 对象。
		*@return Matrix 对象。
		*/
		__proto._getMatrix=function(){
			var rst=new Matrix(this.getFloat32(),this.getFloat32(),this.getFloat32(),this.getFloat32(),this.getFloat32(),this.getFloat32());
			return rst;
		}

		/**
		*@private
		*读取指定长度的 UTF 型字符串。
		*@param len 需要读取的长度。
		*@return 读出的字符串。
		*/
		__proto.rUTF=function(len){
			var v="",max=this._pos_+len,c=0,c2=0,c3=0,f=String.fromCharCode;
			var u=this._u8d_,i=0;
			while (this._pos_ < max){
				c=u[this._pos_++];
				if (c < 0x80){
					if (c !=0){
						v+=f(c);
					}
					}else if (c < 0xE0){
					v+=f(((c & 0x3F)<< 6)| (u[this._pos_++] & 0x7F));
					}else if (c < 0xF0){
					c2=u[this._pos_++];
					v+=f(((c & 0x1F)<< 12)| ((c2 & 0x7F)<< 6)| (u[this._pos_++] & 0x7F));
					}else {
					c2=u[this._pos_++];
					c3=u[this._pos_++];
					v+=f(((c & 0x0F)<< 18)| ((c2 & 0x7F)<< 12)| ((c3 << 6)& 0x7F)| (u[this._pos_++] & 0x7F));
				}
				i++;
			}
			return v;
		}

		/**
		*字符串读取。
		*@param len
		*@return
		*/
		__proto.getCustomString=function(len){
			var v="",ulen=0,c=0,c2=0,f=String.fromCharCode;
			var u=this._u8d_,i=0;
			while (len > 0){
				c=u[this._pos_];
				if (c < 0x80){
					v+=f(c);
					this._pos_++;
					len--;
					}else {
					ulen=c-0x80;
					this._pos_++;
					len-=ulen;
					while (ulen > 0){
						c=u[this._pos_++];
						c2=u[this._pos_++];
						v+=f((c2 << 8)| c);
						ulen--;
					}
				}
			}
			return v;
		}

		/**
		*清除数据。
		*/
		__proto.clear=function(){
			this._pos_=0;
			this.length=0;
		}

		/**
		*@private
		*获取此对象的 ArrayBuffer 引用。
		*@return
		*/
		__proto.__getBuffer=function(){
			return this._d_.buffer;
		}

		/**
		*写入字符串，该方法写的字符串要使用 readUTFBytes 方法读取。
		*@param value 要写入的字符串。
		*/
		__proto.writeUTFBytes=function(value){
			value=value+"";
			for (var i=0,sz=value.length;i < sz;i++){
				var c=value.charCodeAt(i);
				if (c <=0x7F){
					this.writeByte(c);
					}else if (c <=0x7FF){
					this.writeByte(0xC0 | (c >> 6));
					this.writeByte(0x80 | (c & 63));
					}else if (c <=0xFFFF){
					this.writeByte(0xE0 | (c >> 12));
					this.writeByte(0x80 | ((c >> 6)& 63));
					this.writeByte(0x80 | (c & 63));
					}else {
					this.writeByte(0xF0 | (c >> 18));
					this.writeByte(0x80 | ((c >> 12)& 63));
					this.writeByte(0x80 | ((c >> 6)& 63));
					this.writeByte(0x80 | (c & 63));
				}
			}
		}

		/**
		*将 UTF-8 字符串写入字节流。
		*@param value 要写入的字符串值。
		*/
		__proto.writeUTFString=function(value){
			var tPos=0;
			tPos=this.pos;
			this.writeUint16(1);
			this.writeUTFBytes(value);
			var dPos=0;
			dPos=this.pos-tPos-2;
			this._d_.setUint16(tPos,dPos,this._xd_);
		}

		/**
		*读取 UTF-8 字符串。
		*@return 读出的字符串。
		*/
		__proto.readUTFString=function(){
			var tPos=0;
			tPos=this.pos;
			var len=0;
			len=this.getUint16();
			return this.readUTFBytes(len);
		}

		/**
		*读字符串，必须是 writeUTFBytes 方法写入的字符串。
		*@param len 要读的buffer长度,默认将读取缓冲区全部数据。
		*@return 读取的字符串。
		*/
		__proto.readUTFBytes=function(len){
			(len===void 0)&& (len=-1);
			if(len==0)return "";
			len=len > 0 ? len :this.bytesAvailable;
			return this.rUTF(len);
		}

		/**
		*在字节流中写入一个字节。
		*@param value
		*/
		__proto.writeByte=function(value){
			this.ensureWrite(this._pos_+1);
			this._d_.setInt8(this._pos_,value);
			this._pos_+=1;
		}

		/**
		*在字节流中读一个字节。
		*/
		__proto.readByte=function(){
			return this._d_.getInt8(this._pos_++);
		}

		/**
		*指定该字节流的长度。
		*@param lengthToEnsure 指定的长度。
		*/
		__proto.ensureWrite=function(lengthToEnsure){
			if (this._length < lengthToEnsure)this._length=lengthToEnsure;
			if (this._allocated_ < lengthToEnsure)this.length=lengthToEnsure;
		}

		/**
		*写入指定的 Arraybuffer 对象。
		*@param arraybuffer 需要写入的 Arraybuffer 对象。
		*@param offset 偏移量（以字节为单位）
		*@param length 长度（以字节为单位）
		*/
		__proto.writeArrayBuffer=function(arraybuffer,offset,length){
			(offset===void 0)&& (offset=0);
			(length===void 0)&& (length=0);
			if (offset < 0 || length < 0)throw "writeArrayBuffer error - Out of bounds";
			if (length==0)length=arraybuffer.byteLength-offset;
			this.ensureWrite(this._pos_+length);
			var uint8array=new Uint8Array(arraybuffer);
			this._u8d_.set(uint8array.subarray(offset,offset+length),this._pos_);
			this._pos_+=length;
		}

		/**
		*获取此对象的 ArrayBuffer数据,数据只包含有效数据部分 。
		*/
		__getset(0,__proto,'buffer',function(){
			var rstBuffer=this._d_.buffer;
			if (rstBuffer.byteLength==this.length)return rstBuffer;
			return rstBuffer.slice(0,this.length);
		});

		/**
		*字节顺序。
		*/
		__getset(0,__proto,'endian',function(){
			return this._xd_ ? "littleEndian" :"bigEndian";
			},function(endianStr){
			this._xd_=(endianStr=="littleEndian");
		});

		/**
		*可从字节流的当前位置到末尾读取的数据的字节数。
		*/
		__getset(0,__proto,'bytesAvailable',function(){
			return this.length-this._pos_;
		});

		/**
		*字节长度。
		*/
		__getset(0,__proto,'length',function(){
			return this._length;
			},function(value){
			if (this._allocated_ < value)
				this.___resizeBuffer(this._allocated_=Math.floor(Math.max(value,this._allocated_ *2)));
			else if (this._allocated_ > value)
			this.___resizeBuffer(this._allocated_=value);
			this._length=value;
		});

		/**
		*当前读取到的位置。
		*/
		__getset(0,__proto,'pos',function(){
			return this._pos_;
			},function(value){
			this._pos_=value;
			this._d_.byteOffset=value;
		});

		Byte.getSystemEndian=function(){
			if (!Byte._sysEndian){
				var buffer=new ArrayBuffer(2);
				new DataView(buffer).setInt16(0,256,true);
				Byte._sysEndian=(new Int16Array(buffer))[0]===256 ? "littleEndian" :"bigEndian";
			}
			return Byte._sysEndian;
		}

		Byte.BIG_ENDIAN="bigEndian";
		Byte.LITTLE_ENDIAN="littleEndian";
		Byte._sysEndian=null;
		return Byte;
	})()


	/**
	*对象缓存统一管理类
	*/
	//class laya.utils.CacheManger
	var CacheManger=(function(){
		function CacheManger(){}
		__class(CacheManger,'laya.utils.CacheManger');
		CacheManger.regCacheByFunction=function(disposeFunction,getCacheListFunction){
			CacheManger.unRegCacheByFunction(disposeFunction,getCacheListFunction);
			var cache;
			cache={
				tryDispose:disposeFunction,
				getCacheList:getCacheListFunction
			};
			CacheManger._cacheList.push(cache);
		}

		CacheManger.unRegCacheByFunction=function(disposeFunction,getCacheListFunction){
			var i=0,len=0;
			len=CacheManger._cacheList.length;
			for (i=0;i < len;i++){
				if (CacheManger._cacheList[i].tryDispose==disposeFunction && CacheManger._cacheList[i].getCacheList==getCacheListFunction){
					CacheManger._cacheList.splice(i,1);
					return;
				}
			}
		}

		CacheManger.forceDispose=function(){
			var i=0,len=CacheManger._cacheList.length;
			for(i=0;i<len;i++){
				CacheManger._cacheList[i].tryDispose(true);
			}
		}

		CacheManger.beginCheck=function(waitTime){
			(waitTime===void 0)&& (waitTime=15000);
			Laya.timer.loop(waitTime,null,CacheManger._checkLoop);
		}

		CacheManger.stopCheck=function(){
			Laya.timer.clear(null,CacheManger._checkLoop);
		}

		CacheManger._checkLoop=function(){
			var cacheList=CacheManger._cacheList;
			if (cacheList.length < 1)return;
			var tTime=Browser.now();
			var count=0;
			var len=0;
			len=count=cacheList.length;
			while (count > 0){
				CacheManger._index++;
				CacheManger._index=CacheManger._index % len;
				cacheList[CacheManger._index].tryDispose(false);
				if (Browser.now()-tTime > CacheManger.loopTimeLimit)break ;
				count--;
			}
		}

		CacheManger.loopTimeLimit=2;
		CacheManger._cacheList=[];
		CacheManger._index=0;
		return CacheManger;
	})()


	/**
	*<code>ClassUtils</code> 是一个类工具类。
	*/
	//class laya.utils.ClassUtils
	var ClassUtils=(function(){
		function ClassUtils(){};
		__class(ClassUtils,'laya.utils.ClassUtils');
		ClassUtils.regClass=function(className,classDef){
			ClassUtils._classMap[className]=classDef;
		}

		ClassUtils.getRegClass=function(className){
			return ClassUtils._classMap[className];
		}

		ClassUtils.getInstance=function(className){
			var compClass=ClassUtils.getClass(className);
			if (compClass)return new compClass();
			else console.log("[error] Undefined class:",className);
			return null;
		}

		ClassUtils.createByJson=function(json,node,root,customHandler,instanceHandler){
			if ((typeof json=='string'))json=JSON.parse(json);
			var props=json.props;
			if (!node){
				node=instanceHandler ? instanceHandler.runWith(json.instanceParams):ClassUtils.getInstance(props.runtime || json.type);
				if (!node)return null;
			};
			var child=json.child;
			if (child){
				for (var i=0,n=child.length;i < n;i++){
					var data=child[i];
					if (data.props.name==="render" && node["_$set_itemRender"])node.itemRender=data;
					else{
						if (data.type=="Graphic"){
							ClassUtils.addGraphicsToSprite(data,node);
						}else
						if (ClassUtils.isDrawType(data.type)){
							ClassUtils.addGraphicToSprite(data,node,true);
							}else{
							var tChild=ClassUtils.createByJson(data,null,root,customHandler,instanceHandler)
							if (tChild.name=="mask"){
								node.mask=tChild;
								}else{
								node.addChild(tChild);
							}
						}
					}
				}
			}
			if (props){
				for (var prop in props){
					var value=props[prop];
					if (prop==="var" && root){
						root[value]=node;
						}else if ((value instanceof Array)&& (typeof (node[prop])=='function')){
						node[prop].apply(node,value);
						}else {
						node[prop]=value;
					}
				}
			};
			var customProps=json.customProps;
			if (customHandler && customProps){
				for (prop in customProps){
					value=customProps[prop];
					customHandler.runWith([node,prop,value]);
				}
			}
			if (node["created"])node.created();
			return node;
		}

		ClassUtils.addGraphicsToSprite=function(graphicO,sprite){
			var graphics;
			graphics=graphicO.child;
			if (!graphics || graphics.length < 1)return;
			var g;
			g=ClassUtils._getGraphicsFromSprite(graphicO,sprite);
			var ox=0;
			var oy=0;
			if (graphicO.props){
				ox=ClassUtils._getObjVar(graphicO.props,"x",0);
				oy=ClassUtils._getObjVar(graphicO.props,"y",0);
			}
			if (ox !=0 && oy !=0){
				g.translate(ox,oy);
			};
			var i=0,len=0;
			len=graphics.length;
			for (i=0;i < len;i++){
				ClassUtils._addGraphicToGraphics(graphics[i],g);
			}
			if (ox !=0 && oy !=0){
				g.translate(-ox,-oy);
			}
		}

		ClassUtils.addGraphicToSprite=function(graphicO,sprite,isChild){
			(isChild===void 0)&& (isChild=false);
			var g;
			g=isChild?ClassUtils._getGraphicsFromSprite(graphicO,sprite):sprite.graphics;
			ClassUtils._addGraphicToGraphics(graphicO,g);
		}

		ClassUtils._getGraphicsFromSprite=function(dataO,sprite){
			var g;
			if(!dataO||!dataO.props)return sprite.graphics;
			var propsName;
			propsName=dataO.props.name;
			switch(propsName){
				case "hit":
				case "unHit":;
					var hitArea;
					if (!sprite.hitArea){
						sprite.hitArea=new HitArea();
					}
					hitArea=sprite.hitArea;
					if (!hitArea[propsName]){
						hitArea[propsName]=new Graphics();
					}
					g=hitArea[propsName];
					break ;
				default :
				}
			if (!g)g=sprite.graphics;
			return g;
		}

		ClassUtils._addGraphicToGraphics=function(graphicO,graphic){
			var propsO;
			propsO=graphicO.props;
			if (!propsO)return;
			var drawConfig;
			drawConfig=ClassUtils.DrawTypeDic[graphicO.type];
			if(!drawConfig)return;
			var g;
			g=graphic;
			if (graphicO.type=="Image"){
				var tex;
				tex=Loader.getRes(propsO.skin);
				if (tex){
					var param;
					param=ClassUtils._getParams(propsO,drawConfig[1]);
					var m;
					if (propsO.hasOwnProperty("pivotX")||propsO.hasOwnProperty("pivotY")){
						m=m || new Matrix();
						m.translate(-ClassUtils._getObjVar(propsO,"pivotX",0),-ClassUtils._getObjVar(propsO,"pivotY",0));
					};
					var sx=ClassUtils._getObjVar(propsO,"scaleX",1),sy=ClassUtils._getObjVar(propsO,"scaleY",1);
					var rotate=ClassUtils._getObjVar(propsO,"rotation",0);
					var skewX=ClassUtils._getObjVar(propsO,"skewX",0);
					var skewY=ClassUtils._getObjVar(propsO,"skewY",0);
					if (sx !=1 || sy !=1 || rotate !=0){
						m=m || new Matrix();
						m.scale(sx,sy);
						m.rotate(rotate *0.0174532922222222);
					}
					if (m){
						m.translate(param[0],param[1]);
						param[0]=param[1]=0;
					}
					g.drawTexture(tex,param[0],param[1],param[2],param[3],m);
				}
				}else{
				g[drawConfig[0]].apply(g,ClassUtils._getParams(propsO,drawConfig[1],drawConfig[2]));
			}
		}

		ClassUtils._adptLineData=function(params){
			params[2]=parseFloat(params[0])+parseFloat(params[2]);
			params[3]=parseFloat(params[1])+parseFloat(params[3]);
			return params;
		}

		ClassUtils._adptTextureData=function(params){
			params[0]=Loader.getRes(params[0]);
			return params;
		}

		ClassUtils._adptLinesData=function(params){
			params[2]=ClassUtils._getPointListByStr(params[2]);
			return params;
		}

		ClassUtils.isDrawType=function(type){
			if (type=="Image")return false;
			return ClassUtils.DrawTypeDic.hasOwnProperty(type);
		}

		ClassUtils._getParams=function(obj,params,adptFun){
			var rst;
			rst=ClassUtils._temParam;
			rst.length=params.length;
			var i=0,len=0;
			len=params.length;
			for (i=0;i < len;i++){
				rst[i]=ClassUtils._getObjVar(obj,params[i][0],params[i][1]);
			}
			if (adptFun && ClassUtils[adptFun]){
				rst=ClassUtils[adptFun](rst);
			}
			return rst;
		}

		ClassUtils._getPointListByStr=function(str){
			var pointArr;
			pointArr=str.split(",");
			var i=0,len=0;
			len=pointArr.length;
			for (i=0;i < len;i++){
				pointArr[i]=parseFloat(pointArr[i]);
			}
			return pointArr;
		}

		ClassUtils._getObjVar=function(obj,key,noValue){
			if (obj.hasOwnProperty(key)){
				return obj[key];
			}
			return noValue;
		}

		ClassUtils._temParam=[];
		ClassUtils._classMap={'Sprite':'laya.display.Sprite','Text':'laya.display.Text','Animation':'laya.display.Animation','Skeleton':'laya.ani.bone.Skeleton','Particle2D':'laya.particle.Particle2D','div':'laya.html.dom.HTMLDivElement','img':'laya.html.dom.HTMLImageElement','span':'laya.html.dom.HTMLElement','br':'laya.html.dom.HTMLBrElement','style':'laya.html.dom.HTMLStyleElement','font':'laya.html.dom.HTMLElement','a':'laya.html.dom.HTMLElement','#text':'laya.html.dom.HTMLElement'};
		ClassUtils.getClass=function(className){
			var classObject=ClassUtils._classMap[className] || className;
			if ((typeof classObject=='string'))return Laya["__classmap"][classObject];
			return classObject;
		}

		__static(ClassUtils,
		['DrawTypeDic',function(){return this.DrawTypeDic={
				"Rect":["drawRect",
				[["x",0],["y",0],["width",0],["height",0],["fillColor",null],["lineColor",null],["lineWidth",1]]],
				"Circle":["drawCircle",
				[["x",0],["y",0],["radius",0],["fillColor",null],["lineColor",null],["lineWidth",1]]],
				"Pie":["drawPie",
				[["x",0],["y",0],["radius",0],["startAngle",0],["endAngle",0],["fillColor",null],["lineColor",null],["lineWidth",1]]],
				"Image":["drawTexture",
				[["x",0],["y",0],["width",0],["height",0]]],
				"DrawTexture":["drawTexture",
				[["skin",null],["x",0],["y",0],["width",0],["height",0]],
				"_adptTextureData"],
				"FillTexture":["fillTexture",
				[["skin",null],["x",0],["y",0],["width",0],["height",0],["repeat",null]],
				"_adptTextureData"],
				"FillText":["fillText",
				[["text",""],["x",0],["y",0],["font",null],["color",null],["textAlign",null]]],
				"Line":["drawLine",
				[["x",0],["y",0],["toX",0],["toY",0],["lineColor",null],["lineWidth",0]],
				"_adptLineData"],
				"Lines":["drawLines",
				[["x",0],["y",0],["points",""],["lineColor",null],["lineWidth",0]],
				"_adptLinesData"],
				"Curves":["drawCurves",
				[["x",0],["y",0],["points",""],["lineColor",null],["lineWidth",0]],
				"_adptLinesData"],
				"Poly":["drawPoly",
				[["x",0],["y",0],["points",""],["fillColor",null],["lineColor",null],["lineWidth",1]],
				"_adptLinesData"]
		};}

		]);
		return ClassUtils;
	})()


	/**
	*<code>Color</code> 是一个颜色值处理类。
	*/
	//class laya.utils.Color
	var Color=(function(){
		function Color(str){
			this._color=[];
			//this.strColor=null;
			//this.numColor=0;
			//this._drawStyle=null;
			if ((typeof str=='string')){
				this.strColor=str;
				if (str===null)str="#000000";
				str.charAt(0)=='#' && (str=str.substr(1));
				var color=this.numColor=parseInt(str,16);
				var flag=(str.length==8);
				if (flag){
					this._color=[parseInt(str.substr(0,2),16)/ 255,((0x00FF0000 & color)>> 16)/ 255,((0x0000FF00 & color)>> 8)/ 255,(0x000000FF & color)/ 255];
					return;
				}
				}else {
				color=this.numColor=str;
				this.strColor=Utils.toHexColor(color);
			}
			this._color=[((0xFF0000 & color)>> 16)/ 255,((0xFF00 & color)>> 8)/ 255,(0xFF & color)/ 255,1];
			(this._color).__id=++Color._COLODID;
		}

		__class(Color,'laya.utils.Color');
		Color._initDefault=function(){
			Color._DEFAULT={};
			for (var i in Color._COLOR_MAP)Color._SAVE[i]=Color._DEFAULT[i]=new Color(Color._COLOR_MAP[i]);
			return Color._DEFAULT;
		}

		Color._initSaveMap=function(){
			Color._SAVE_SIZE=0;
			Color._SAVE={};
			for (var i in Color._DEFAULT)Color._SAVE[i]=Color._DEFAULT[i];
		}

		Color.create=function(str){
			var color=Color._SAVE[str+""];
			if (color !=null)return color;
			(Color._SAVE_SIZE < 1000)|| Color._initSaveMap();
			return Color._SAVE[str+""]=new Color(str);
		}

		Color._SAVE={};
		Color._SAVE_SIZE=0;
		Color._COLOR_MAP={"white":'#FFFFFF',"red":'#FF0000',"green":'#00FF00',"blue":'#0000FF',"black":'#000000',"yellow":'#FFFF00','gray':'#AAAAAA'};
		Color._DEFAULT=Color._initDefault();
		Color._COLODID=1;
		return Color;
	})()


	/**
	*<code>Dictionary</code> 是一个字典型的数据存取类。
	*/
	//class laya.utils.Dictionary
	var Dictionary=(function(){
		function Dictionary(){
			this._values=[];
			this._keys=[];
		}

		__class(Dictionary,'laya.utils.Dictionary');
		var __proto=Dictionary.prototype;
		/**
		*给指定的键名设置值。
		*@param key 键名。
		*@param value 值。
		*/
		__proto.set=function(key,value){
			var index=this.indexOf(key);
			if (index >=0){
				this._values[index]=value;
				return;
			}
			this._keys.push(key);
			this._values.push(value);
		}

		/**
		*获取指定对象的键名索引。
		*@param key 键名对象。
		*@return 键名索引。
		*/
		__proto.indexOf=function(key){
			var index=this._keys.indexOf(key);
			if (index >=0)return index;
			key=((typeof key=='string'))? Number(key):(((typeof key=='number'))? key.toString():key);
			return this._keys.indexOf(key);
		}

		/**
		*返回指定键名的值。
		*@param key 键名对象。
		*@return 指定键名的值。
		*/
		__proto.get=function(key){
			var index=this.indexOf(key);
			return index < 0 ? null :this._values[index];
		}

		/**
		*移除指定键名的值。
		*@param key 键名对象。
		*@return 是否成功移除。
		*/
		__proto.remove=function(key){
			var index=this.indexOf(key);
			if (index >=0){
				this._keys.splice(index,1);
				this._values.splice(index,1);
				return true;
			}
			return false;
		}

		/**
		*清除此对象的键名列表和键值列表。
		*/
		__proto.clear=function(){
			this._values.length=0;
			this._keys.length=0;
		}

		/**
		*获取所有的子元素列表。
		*/
		__getset(0,__proto,'values',function(){
			return this._values;
		});

		/**
		*获取所有的子元素键名列表。
		*/
		__getset(0,__proto,'keys',function(){
			return this._keys;
		});

		return Dictionary;
	})()


	/**
	*<code>Dragging</code> 类是触摸滑动控件。
	*/
	//class laya.utils.Dragging
	var Dragging=(function(){
		function Dragging(){
			//this.target=null;
			this.ratio=0.92;
			this.maxOffset=60;
			//this.area=null;
			//this.hasInertia=false;
			//this.elasticDistance=NaN;
			//this.elasticBackTime=NaN;
			//this.data=null;
			this._dragging=false;
			this._clickOnly=true;
			//this._elasticRateX=NaN;
			//this._elasticRateY=NaN;
			//this._lastX=NaN;
			//this._lastY=NaN;
			//this._offsetX=NaN;
			//this._offsetY=NaN;
			//this._offsets=null;
			//this._disableMouseEvent=false;
			//this._tween=null;
		}

		__class(Dragging,'laya.utils.Dragging');
		var __proto=Dragging.prototype;
		/**
		*开始拖拽。
		*@param target 待拖拽的 <code>Sprite</code> 对象。
		*@param area 滑动范围。
		*@param hasInertia 拖动是否有惯性。
		*@param elasticDistance 橡皮筋最大值。
		*@param elasticBackTime 橡皮筋回弹时间，单位为毫秒。
		*@param data 事件携带数据。
		*@param disableMouseEvent 鼠标事件是否有效。
		*/
		__proto.start=function(target,area,hasInertia,elasticDistance,elasticBackTime,data,disableMouseEvent){
			this.clearTimer();
			this.target=target;
			this.area=area;
			this.hasInertia=hasInertia;
			this.elasticDistance=elasticDistance;
			this.elasticBackTime=elasticBackTime;
			this.data=data;
			this._disableMouseEvent=disableMouseEvent;
			this._clickOnly=true;
			this._dragging=true;
			this._elasticRateX=this._elasticRateY=1;
			this._lastX=Laya.stage.mouseX;
			this._lastY=Laya.stage.mouseY;
			Laya.stage.on("mouseup",this,this.onStageMouseUp);
			Laya.stage.on("mouseout",this,this.onStageMouseUp);
			Laya.timer.frameLoop(1,this,this.loop);
		}

		/**
		*清除计时器。
		*/
		__proto.clearTimer=function(){
			Laya.timer.clear(this,this.loop);
			Laya.timer.clear(this,this.tweenMove);
			if (this._tween){
				this._tween.recover();
				this._tween=null;
			}
		}

		/**
		*停止拖拽。
		*/
		__proto.stop=function(){
			if (this._dragging){
				MouseManager.instance.disableMouseEvent=false;
				Laya.stage.off("mouseup",this,this.onStageMouseUp);
				Laya.stage.off("mouseout",this,this.onStageMouseUp);
				this._dragging=false;
				this.target && this.area && this.backToArea();
				this.clear();
			}
		}

		/**
		*拖拽的循环处理函数。
		*/
		__proto.loop=function(){
			var mouseX=Laya.stage.mouseX;
			var mouseY=Laya.stage.mouseY;
			var offsetX=mouseX-this._lastX;
			var offsetY=mouseY-this._lastY;
			if (this._clickOnly){
				if (Math.abs(offsetX *Laya.stage._canvasTransform.getScaleX())> 1 || Math.abs(offsetY *Laya.stage._canvasTransform.getScaleY())> 1){
					this._clickOnly=false;
					this._offsets || (this._offsets=[]);
					this._offsets.length=0;
					this.target.event("dragstart",this.data);
					MouseManager.instance.disableMouseEvent=this._disableMouseEvent;
					this.target._set$P("$_MOUSEDOWN",false);
				}else return;
				}else {
				this._offsets.push(offsetX,offsetY);
			}
			if (offsetX===0 && offsetY===0)return;
			this._lastX=mouseX;
			this._lastY=mouseY;
			this.target.x+=offsetX *this._elasticRateX;
			this.target.y+=offsetY *this._elasticRateY;
			this.area && this.checkArea();
			this.target.event("dragmove",this.data);
		}

		/**
		*拖拽区域检测。
		*/
		__proto.checkArea=function(){
			if (this.elasticDistance <=0){
				this.backToArea();
				}else {
				if (this.target.x < this.area.x){
					var offsetX=this.area.x-this.target.x;
					}else if (this.target.x > this.area.x+this.area.width){
					offsetX=this.target.x-this.area.x-this.area.width;
					}else {
					offsetX=0;
				}
				this._elasticRateX=Math.max(0,1-(offsetX / this.elasticDistance));
				if (this.target.y < this.area.y){
					var offsetY=this.area.y-this.target.y;
					}else if (this.target.y > this.area.y+this.area.height){
					offsetY=this.target.y-this.area.y-this.area.height;
					}else {
					offsetY=0;
				}
				this._elasticRateY=Math.max(0,1-(offsetY / this.elasticDistance));
			}
		}

		/**
		*移动至设定的拖拽区域。
		*/
		__proto.backToArea=function(){
			this.target.x=Math.min(Math.max(this.target.x,this.area.x),this.area.x+this.area.width);
			this.target.y=Math.min(Math.max(this.target.y,this.area.y),this.area.y+this.area.height);
		}

		/**
		*舞台的抬起事件侦听函数。
		*@param e Event 对象。
		*/
		__proto.onStageMouseUp=function(e){
			MouseManager.instance.disableMouseEvent=false;
			Laya.stage.off("mouseup",this,this.onStageMouseUp);
			Laya.stage.off("mouseout",this,this.onStageMouseUp);
			Laya.timer.clear(this,this.loop);
			if (this._clickOnly || !this.target)return;
			if (this.hasInertia){
				if (this._offsets.length < 1){
					this._offsets.push(Laya.stage.mouseX-this._lastX,Laya.stage.mouseY-this._lastY);
				}
				this._offsetX=this._offsetY=0;
				var len=this._offsets.length;
				var n=Math.min(len,6);
				var m=this._offsets.length-n;
				for (var i=len-1;i > m;i--){
					this._offsetY+=this._offsets[i--];
					this._offsetX+=this._offsets[i];
				}
				this._offsetX=this._offsetX / n *2;
				this._offsetY=this._offsetY / n *2;
				if (Math.abs(this._offsetX)> this.maxOffset)this._offsetX=this._offsetX > 0 ? this.maxOffset :-this.maxOffset;
				if (Math.abs(this._offsetY)> this.maxOffset)this._offsetY=this._offsetY > 0 ? this.maxOffset :-this.maxOffset;
				Laya.timer.frameLoop(1,this,this.tweenMove);
				}else if (this.elasticDistance > 0){
				this.checkElastic();
				}else {
				this.clear();
			}
		}

		/**
		*橡皮筋效果检测。
		*/
		__proto.checkElastic=function(){
			var tx=NaN;
			var ty=NaN;
			if (this.target.x < this.area.x)tx=this.area.x;
			else if (this.target.x > this.area.x+this.area.width)tx=this.area.x+this.area.width;
			if (this.target.y < this.area.y)ty=this.area.y;
			else if (this.target.y > this.area.y+this.area.height)ty=this.area.y+this.area.height;
			if (!isNaN(tx)|| !isNaN(ty)){
				var obj={};
				if (!isNaN(tx))obj.x=tx;
				if (!isNaN(ty))obj.y=ty;
				this._tween=Tween.to(this.target,obj,this.elasticBackTime,Ease.sineOut,Handler.create(this,this.clear),0,false,false);
				}else {
				this.clear();
			}
		}

		/**
		*移动。
		*/
		__proto.tweenMove=function(){
			this._offsetX *=this.ratio *this._elasticRateX;
			this._offsetY *=this.ratio *this._elasticRateY;
			this.target.x+=this._offsetX;
			this.target.y+=this._offsetY;
			this.area && this.checkArea();
			this.target.event("dragmove",this.data);
			if ((Math.abs(this._offsetX)< 1 && Math.abs(this._offsetY)< 1)|| this._elasticRateX < 0.5 || this._elasticRateY < 0.5){
				Laya.timer.clear(this,this.tweenMove);
				if (this.elasticDistance > 0)this.checkElastic();
				else this.clear();
			}
		}

		/**
		*结束拖拽。
		*/
		__proto.clear=function(){
			if (this.target){
				this.clearTimer();
				var sp=this.target;
				this.target=null;
				sp.event("dragend",this.data);
			}
		}

		return Dragging;
	})()


	/**
	*<code>Ease</code> 类定义了缓动函数，以便实现 <code>Tween</code> 动画的缓动效果。
	*/
	//class laya.utils.Ease
	var Ease=(function(){
		function Ease(){};
		__class(Ease,'laya.utils.Ease');
		Ease.linearNone=function(t,b,c,d){
			return c *t / d+b;
		}

		Ease.linearIn=function(t,b,c,d){
			return c *t / d+b;
		}

		Ease.linearInOut=function(t,b,c,d){
			return c *t / d+b;
		}

		Ease.linearOut=function(t,b,c,d){
			return c *t / d+b;
		}

		Ease.bounceIn=function(t,b,c,d){
			return c-Ease.bounceOut(d-t,0,c,d)+b;
		}

		Ease.bounceInOut=function(t,b,c,d){
			if (t < d *0.5)return Ease.bounceIn(t *2,0,c,d)*.5+b;
			else return Ease.bounceOut(t *2-d,0,c,d)*.5+c *.5+b;
		}

		Ease.bounceOut=function(t,b,c,d){
			if ((t /=d)< (1 / 2.75))return c *(7.5625 *t *t)+b;
			else if (t < (2 / 2.75))return c *(7.5625 *(t-=(1.5 / 2.75))*t+.75)+b;
			else if (t < (2.5 / 2.75))return c *(7.5625 *(t-=(2.25 / 2.75))*t+.9375)+b;
			else return c *(7.5625 *(t-=(2.625 / 2.75))*t+.984375)+b;
		}

		Ease.backIn=function(t,b,c,d,s){
			(s===void 0)&& (s=1.70158);
			return c *(t /=d)*t *((s+1)*t-s)+b;
		}

		Ease.backInOut=function(t,b,c,d,s){
			(s===void 0)&& (s=1.70158);
			if ((t /=d *0.5)< 1)return c *0.5 *(t *t *(((s *=(1.525))+1)*t-s))+b;
			return c / 2 *((t-=2)*t *(((s *=(1.525))+1)*t+s)+2)+b;
		}

		Ease.backOut=function(t,b,c,d,s){
			(s===void 0)&& (s=1.70158);
			return c *((t=t / d-1)*t *((s+1)*t+s)+1)+b;
		}

		Ease.elasticIn=function(t,b,c,d,a,p){
			(a===void 0)&& (a=0);
			(p===void 0)&& (p=0);
			var s;
			if (t==0)return b;
			if ((t /=d)==1)return b+c;
			if (!p)p=d *.3;
			if (!a || (c > 0 && a < c)|| (c < 0 && a <-c)){
				a=c;
				s=p / 4;
			}else s=p / Ease.PI2 *Math.asin(c / a);
			return-(a *Math.pow(2,10 *(t-=1))*Math.sin((t *d-s)*Ease.PI2 / p))+b;
		}

		Ease.elasticInOut=function(t,b,c,d,a,p){
			(a===void 0)&& (a=0);
			(p===void 0)&& (p=0);
			var s;
			if (t==0)return b;
			if ((t /=d *0.5)==2)return b+c;
			if (!p)p=d *(.3 *1.5);
			if (!a || (c > 0 && a < c)|| (c < 0 && a <-c)){
				a=c;
				s=p / 4;
			}else s=p / Ease.PI2 *Math.asin(c / a);
			if (t < 1)return-.5 *(a *Math.pow(2,10 *(t-=1))*Math.sin((t *d-s)*Ease.PI2 / p))+b;
			return a *Math.pow(2,-10 *(t-=1))*Math.sin((t *d-s)*Ease.PI2 / p)*.5+c+b;
		}

		Ease.elasticOut=function(t,b,c,d,a,p){
			(a===void 0)&& (a=0);
			(p===void 0)&& (p=0);
			var s;
			if (t==0)return b;
			if ((t /=d)==1)return b+c;
			if (!p)p=d *.3;
			if (!a || (c > 0 && a < c)|| (c < 0 && a <-c)){
				a=c;
				s=p / 4;
			}else s=p / Ease.PI2 *Math.asin(c / a);
			return (a *Math.pow(2,-10 *t)*Math.sin((t *d-s)*Ease.PI2 / p)+c+b);
		}

		Ease.strongIn=function(t,b,c,d){
			return c *(t /=d)*t *t *t *t+b;
		}

		Ease.strongInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t *t *t *t+b;
			return c *0.5 *((t-=2)*t *t *t *t+2)+b;
		}

		Ease.strongOut=function(t,b,c,d){
			return c *((t=t / d-1)*t *t *t *t+1)+b;
		}

		Ease.sineInOut=function(t,b,c,d){
			return-c *0.5 *(Math.cos(Math.PI *t / d)-1)+b;
		}

		Ease.sineIn=function(t,b,c,d){
			return-c *Math.cos(t / d *Ease.HALF_PI)+c+b;
		}

		Ease.sineOut=function(t,b,c,d){
			return c *Math.sin(t / d *Ease.HALF_PI)+b;
		}

		Ease.quintIn=function(t,b,c,d){
			return c *(t /=d)*t *t *t *t+b;
		}

		Ease.quintInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t *t *t *t+b;
			return c *0.5 *((t-=2)*t *t *t *t+2)+b;
		}

		Ease.quintOut=function(t,b,c,d){
			return c *((t=t / d-1)*t *t *t *t+1)+b;
		}

		Ease.quartIn=function(t,b,c,d){
			return c *(t /=d)*t *t *t+b;
		}

		Ease.quartInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t *t *t+b;
			return-c *0.5 *((t-=2)*t *t *t-2)+b;
		}

		Ease.quartOut=function(t,b,c,d){
			return-c *((t=t / d-1)*t *t *t-1)+b;
		}

		Ease.cubicIn=function(t,b,c,d){
			return c *(t /=d)*t *t+b;
		}

		Ease.cubicInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t *t+b;
			return c *0.5 *((t-=2)*t *t+2)+b;
		}

		Ease.cubicOut=function(t,b,c,d){
			return c *((t=t / d-1)*t *t+1)+b;
		}

		Ease.quadIn=function(t,b,c,d){
			return c *(t /=d)*t+b;
		}

		Ease.quadInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return c *0.5 *t *t+b;
			return-c *0.5 *((--t)*(t-2)-1)+b;
		}

		Ease.quadOut=function(t,b,c,d){
			return-c *(t /=d)*(t-2)+b;
		}

		Ease.expoIn=function(t,b,c,d){
			return (t==0)? b :c *Math.pow(2,10 *(t / d-1))+b-c *0.001;
		}

		Ease.expoInOut=function(t,b,c,d){
			if (t==0)return b;
			if (t==d)return b+c;
			if ((t /=d *0.5)< 1)return c *0.5 *Math.pow(2,10 *(t-1))+b;
			return c *0.5 *(-Math.pow(2,-10 *--t)+2)+b;
		}

		Ease.expoOut=function(t,b,c,d){
			return (t==d)? b+c :c *(-Math.pow(2,-10 *t / d)+1)+b;
		}

		Ease.circIn=function(t,b,c,d){
			return-c *(Math.sqrt(1-(t /=d)*t)-1)+b;
		}

		Ease.circInOut=function(t,b,c,d){
			if ((t /=d *0.5)< 1)return-c *0.5 *(Math.sqrt(1-t *t)-1)+b;
			return c *0.5 *(Math.sqrt(1-(t-=2)*t)+1)+b;
		}

		Ease.circOut=function(t,b,c,d){
			return c *Math.sqrt(1-(t=t / d-1)*t)+b;
		}

		Ease.HALF_PI=Math.PI *0.5;
		Ease.PI2=Math.PI *2;
		return Ease;
	})()


	/**
	*鼠标点击区域类
	*/
	//class laya.utils.HitArea
	var HitArea=(function(){
		function HitArea(){
			this.hit=null;
			this.unHit=null;
		}

		__class(HitArea,'laya.utils.HitArea');
		var __proto=HitArea.prototype;
		/**
		*是否包含某个点
		*@param x
		*@param y
		*@return
		*
		*/
		__proto.isHit=function(x,y){
			if (!HitArea.isHitGraphic(x,y,this.hit))return false;
			return !HitArea.isHitGraphic(x,y,this.unHit);
		}

		HitArea.isHitGraphic=function(x,y,graphic){
			if (!graphic)return false;
			var cmds;
			cmds=graphic.cmds;
			if (!cmds&&graphic._one){
				cmds=HitArea._tCmds;
				cmds.length=1;
				cmds[0]=graphic._one;
			}
			if (!cmds)return false;
			var i=0,len=0;
			len=cmds.length;
			var cmd;
			for (i=0;i < len;i++){
				cmd=cmds[i];
				if (!cmd)continue ;
				var context=Render._context;
				switch (cmd.callee){
					case context._translate:
					case 6:
						x-=cmd[0];
						y-=cmd[1];
					default :
					}
				if (HitArea.isHitCmd(x,y,cmd))return true;
			}
			return false;
		}

		HitArea.isHitCmd=function(x,y,cmd){
			if (!cmd)return false;
			var context=Render._context;
			switch (cmd.callee){
				case context._drawRect:
				case 13:
					HitArea._rec.setTo(cmd[0],cmd[1],cmd[2],cmd[3]);
					return HitArea._rec.contains(x,y);
					break ;
				case context._drawCircle:
				case context._fillCircle:
				case 14:;
					var d=NaN;
					x-=cmd[0];
					y-=cmd[1];
					d=x *x+y *y;
					return d < cmd[2] *cmd[2];
					break ;
				case context._drawPoly:
				case 18:
					x-=cmd[0];
					y-=cmd[1];
					return HitArea.ptInPolygon(x,y,cmd[2]);
					break ;
				default :
					return false;
				}
			return false;
		}

		HitArea.ptInPolygon=function(x,y,areaPoints){
			var p;
			p=HitArea._ptPoint;
			p.setTo(x,y);
			var nCross=0;
			var p1x=NaN,p1y=NaN,p2x=NaN,p2y=NaN;
			var len=0;
			len=areaPoints.length;
			for (var i=0;i < len;i+=2){
				p1x=areaPoints[i];
				p1y=areaPoints[i+1];
				p2x=areaPoints[(i+2)% len];
				p2y=areaPoints[(i+3)% len];
				var p1=areaPoints[i];
				var p2=areaPoints[(i+1)% areaPoints.length];
				if (p1y==p2y)
					continue ;
				if (p.y < Math.min(p1y,p2y))
					continue ;
				if (p.y >=Math.max(p1y,p2y))
					continue ;
				var x=(p.y-p1y)*(p2x-p1x)/ (p2y-p1y)+p1x;
				if (x > p.x){
					nCross++;
				}
			}
			return (nCross % 2==1);
		}

		HitArea._tCmds=[];
		__static(HitArea,
		['_rec',function(){return this._rec=new Rectangle();},'_ptPoint',function(){return this._ptPoint=new Point();}
		]);
		return HitArea;
	})()


	/**
	*<code>HTMLChar</code> 是一个 HTML 字符类。
	*/
	//class laya.utils.HTMLChar
	var HTMLChar=(function(){
		function HTMLChar(char,w,h,style){
			//this._sprite=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._w=NaN;
			//this._h=NaN;
			//this.isWord=false;
			//this.char=null;
			//this.charNum=NaN;
			//this.style=null;
			this.char=char;
			this.charNum=char.charCodeAt(0);
			this._x=this._y=0;
			this.width=w;
			this.height=h;
			this.style=style;
			this.isWord=!HTMLChar._isWordRegExp.test(char);
		}

		__class(HTMLChar,'laya.utils.HTMLChar');
		var __proto=HTMLChar.prototype;
		Laya.imps(__proto,{"laya.display.ILayout":true})
		/**
		*设置与此对象绑定的显示对象 <code>Sprite</code> 。
		*@param sprite 显示对象 <code>Sprite</code> 。
		*/
		__proto.setSprite=function(sprite){
			this._sprite=sprite;
		}

		/**
		*获取与此对象绑定的显示对象 <code>Sprite</code>。
		*@return
		*/
		__proto.getSprite=function(){
			return this._sprite;
		}

		/**@private */
		__proto._isChar=function(){
			return true;
		}

		/**@private */
		__proto._getCSSStyle=function(){
			return this.style;
		}

		/**
		*此对象存储的 X 轴坐标值。
		*当设置此值时，如果此对象有绑定的 Sprite 对象，则改变 Sprite 对象的属性 x 的值。
		*/
		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			if (this._sprite){
				this._sprite.x=value;
			}
			this._x=value;
		});

		/**
		*此对象存储的 Y 轴坐标值。
		*当设置此值时，如果此对象有绑定的 Sprite 对象，则改变 Sprite 对象的属性 y 的值。
		*/
		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			if (this._sprite){
				this._sprite.y=value;
			}
			this._y=value;
		});

		/**
		*宽度。
		*/
		__getset(0,__proto,'width',function(){
			return this._w;
			},function(value){
			this._w=value;
		});

		/**
		*高度。
		*/
		__getset(0,__proto,'height',function(){
			return this._h;
			},function(value){
			this._h=value;
		});

		HTMLChar._isWordRegExp=new RegExp("[\\w\.]","");
		return HTMLChar;
	})()


	/**
	*<code>Log</code> 类用于在界面内显示日志记录信息。
	*/
	//class laya.utils.Log
	var Log=(function(){
		function Log(){};
		__class(Log,'laya.utils.Log');
		Log.enable=function(){
			if (!Log._logdiv){
				Log._logdiv=Browser.window.document.createElement('div');
				Browser.window.document.body.appendChild(Log._logdiv);
				Log._logdiv.style.cssText="pointer-events:none;border:white;overflow:hidden;z-index:1000000;background:rgba(100,100,100,0.6);color:white;position: absolute;left:0px;top:0px;width:50%;height:50%;";
			}
		}

		Log.toggle=function(){
			var style=Log._logdiv.style;
			if (style.width=="1px"){
				style.width=style.height="50%";
				}else {
				style.width=style.height="1px";
			}
		}

		Log.print=function(value){
			if (Log._logdiv){
				if (Log._count >=Log.maxCount)Log.clear();
				Log._count++;
				Log._logdiv.innerText+=value+"\n";
				Log._logdiv.scrollTop=Log._logdiv.scrollHeight;
			}
		}

		Log.clear=function(){
			Log._logdiv.innerText="";
			Log._count=0;
		}

		Log._logdiv=null
		Log._count=0;
		Log.maxCount=20;
		return Log;
	})()


	/**
	*<code>Pool</code> 是对象池类，用于对象的存贮、重复使用。
	*/
	//class laya.utils.Pool
	var Pool=(function(){
		function Pool(){};
		__class(Pool,'laya.utils.Pool');
		Pool.getPoolBySign=function(sign){
			return Pool._poolDic[sign] || (Pool._poolDic[sign]=[]);
		}

		Pool.clearBySign=function(sign){
			if (Pool._poolDic[sign])Pool._poolDic[sign].length=0;
		}

		Pool.recover=function(sign,item){
			if (item["__InPool"])return;
			item["__InPool"]=true;
			Pool.getPoolBySign(sign).push(item);
		}

		Pool.getItemByClass=function(sign,cls){
			var pool=Pool.getPoolBySign(sign);
			var rst=pool.length ? pool.pop():new cls();
			rst["__InPool"]=false;
			return rst;
		}

		Pool.getItemByCreateFun=function(sign,createFun){
			var pool=Pool.getPoolBySign(sign);
			var rst=pool.length ? pool.pop():createFun();
			rst["__InPool"]=false;
			return rst;
		}

		Pool.getItem=function(sign){
			var pool=Pool.getPoolBySign(sign);
			var rst=pool.length ? pool.pop():null;
			if (rst){
				rst["__InPool"]=false;
			}
			return rst;
		}

		Pool._poolDic={};
		Pool.InPoolSign="__InPool";
		return Pool;
	})()


	/**
	*<code>Stat</code> 用于显示帧率统计信息。
	*/
	//class laya.utils.Stat
	var Stat=(function(){
		function Stat(){};
		__class(Stat,'laya.utils.Stat');
		/**
		*点击帧频显示区域的处理函数。
		*/
		__getset(1,Stat,'onclick',null,function(fn){
			Stat._canvas.source.onclick=fn;
			Stat._canvas.source.style.pointerEvents='';
		});

		Stat.show=function(x,y){
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			if (Render.isConchApp){
				conch.showFPS&&conch.showFPS(x,y);
				return;
			};
			var pixel=Browser.pixelRatio;
			Stat._width=pixel *120;
			Stat._vx=pixel *70;
			Stat._view[0]={title:"FPS(Canvas)",value:"_fpsStr",color:"yellow",units:"int"};
			Stat._view[1]={title:"Sprite",value:"spriteCount",color:"white",units:"int"};
			Stat._view[2]={title:"DrawCall",value:"drawCall",color:"white",units:"int"};
			Stat._view[3]={title:"CurMem",value:"currentMemorySize",color:"yellow",units:"M"};
			if (Render.isWebGL){
				Stat._view[4]={title:"Shader",value:"shaderCall",color:"white",units:"int"};
				if (!Render.is3DMode){
					Stat._view[0].title="FPS(WebGL)";
					Stat._view[5]={title:"Canvas",value:"_canvasStr",color:"white",units:"int"};
					}else {
					Stat._view[0].title="FPS(3D)";
					Stat._view[5]={title:"TriFaces",value:"trianglesFaces",color:"white",units:"int"};
				}
				}else {
				Stat._view[4]={title:"Canvas",value:"_canvasStr",color:"white",units:"int"};
			}
			Stat._fontSize=12 *pixel;
			for (var i=0;i < Stat._view.length;i++){
				Stat._view[i].x=4;
				Stat._view[i].y=i *Stat._fontSize+2 *pixel;
			}
			Stat._height=pixel *(Stat._view.length *12+3 *pixel);
			if (!Stat._canvas){
				Stat._canvas=new HTMLCanvas('2D');
				Stat._canvas.size(Stat._width,Stat._height);
				Stat._ctx=Stat._canvas.getContext('2d');
				Stat._ctx.textBaseline="top";
				Stat._ctx.font=Stat._fontSize+"px Sans-serif";
				Stat._canvas.source.style.cssText="pointer-events:none;background:rgba(150,150,150,0.8);z-index:100000;position: absolute;left:"+x+"px;top:"+y+"px;width:"+(Stat._width / pixel)+"px;height:"+(Stat._height / pixel)+"px;";
			}
			Stat._first=true;
			Stat.loop();
			Stat._first=false;
			Browser.container.appendChild(Stat._canvas.source);
			Stat.enable();
		}

		Stat.enable=function(){
			Laya.timer.frameLoop(1,Stat,Stat.loop);
		}

		Stat.hide=function(){
			Browser.removeElement(Stat._canvas.source);
			Laya.timer.clear(Stat,Stat.loop);
		}

		Stat.clear=function(){
			Stat.trianglesFaces=Stat.drawCall=Stat.shaderCall=Stat.spriteCount=Stat.canvasNormal=Stat.canvasBitmap=Stat.canvasReCache=0;
		}

		Stat.loop=function(){
			Stat._count++;
			var timer=Browser.now();
			if (timer-Stat._timer < 1000)return;
			var count=Stat._count;
			Stat.FPS=Math.round((count *1000)/ (timer-Stat._timer));
			if (Stat._canvas){
				Stat.trianglesFaces=Math.round(Stat.trianglesFaces / count);
				Stat.drawCall=Math.round(Stat.drawCall / count)-2;
				Stat.shaderCall=Math.round(Stat.shaderCall / count);
				Stat.spriteCount=Math.round(Stat.spriteCount / count)-1;
				Stat.canvasNormal=Math.round(Stat.canvasNormal / count);
				Stat.canvasBitmap=Math.round(Stat.canvasBitmap / count);
				Stat.canvasReCache=Math.ceil(Stat.canvasReCache / count);
				Stat._fpsStr=Stat.FPS+(Stat.renderSlow ? " slow" :"");
				Stat._canvasStr=Stat.canvasReCache+"/"+Stat.canvasNormal+"/"+Stat.canvasBitmap;
				Stat.currentMemorySize=ResourceManager.systemResourceManager.memorySize;
				var ctx=Stat._ctx;
				ctx.clearRect(Stat._first ? 0 :Stat._vx,0,Stat._width,Stat._height);
				for (var i=0;i < Stat._view.length;i++){
					var one=Stat._view[i];
					if (Stat._first){
						ctx.fillStyle="white";
						ctx.fillText(one.title,one.x,one.y,null,null,null);
					}
					ctx.fillStyle=one.color;
					var value=Stat[one.value];
					(one.units=="M")&& (value=Math.floor(value / (1024 *1024)*100)/ 100+" M");
					ctx.fillText(value+"",one.x+Stat._vx,one.y,null,null,null);
				}
				Stat.clear();
			}
			Stat._count=0;
			Stat._timer=timer;
		}

		Stat.loopCount=0;
		Stat.shaderCall=0;
		Stat.drawCall=0;
		Stat.trianglesFaces=0;
		Stat.spriteCount=0;
		Stat.FPS=0;
		Stat.canvasNormal=0;
		Stat.canvasBitmap=0;
		Stat.canvasReCache=0;
		Stat.renderSlow=false;
		Stat.currentMemorySize=0;
		Stat._fpsStr=null
		Stat._canvasStr=null
		Stat._canvas=null
		Stat._ctx=null
		Stat._timer=0;
		Stat._count=0;
		Stat._width=120;
		Stat._height=100;
		Stat._view=[];
		Stat._fontSize=12;
		Stat._first=false;
		Stat._vx=NaN
		return Stat;
	})()


	/**
	*<code>StringKey</code> 类用于存取字符串对应的数字。
	*/
	//class laya.utils.StringKey
	var StringKey=(function(){
		function StringKey(){
			this._strs={};
			this._length=0;
		}

		__class(StringKey,'laya.utils.StringKey');
		var __proto=StringKey.prototype;
		/**
		*添加一个字符。
		*@param str 字符，将作为key 存储相应生成的数字。
		*@return 此字符对应的数字。
		*/
		__proto.add=function(str){
			var index=this._strs[str];
			if (index !=null)return index;
			return this._strs[str]=this._length++;
		}

		/**
		*获取指定字符对应的数字。
		*@param str key 字符。
		*@return 此字符对应的数字。
		*/
		__proto.get=function(str){
			var index=this._strs[str];
			return index==null ?-1 :index;
		}

		return StringKey;
	})()


	/**
	*<code>Timer</code> 是时钟管理类。它是一个单例，可以通过 Laya.timer 访问。
	*/
	//class laya.utils.Timer
	var Timer=(function(){
		var TimerHandler;
		function Timer(){
			this.scale=1;
			this.currFrame=0;
			this._mid=1;
			this._map=[];
			this._laters=[];
			this._handlers=[];
			this._temp=[];
			this._count=0;
			this.currTimer=Browser.now();
			this._lastTimer=Browser.now();
			Laya.timer && Laya.timer.frameLoop(1,this,this._update);
		}

		__class(Timer,'laya.utils.Timer');
		var __proto=Timer.prototype;
		/**
		*@private
		*帧循环处理函数。
		*/
		__proto._update=function(){
			if (this.scale <=0){
				this._lastTimer=Browser.now();
				return;
			};
			var frame=this.currFrame=this.currFrame+this.scale;
			var now=Browser.now();
			Timer.delta=now-this._lastTimer;
			var timer=this.currTimer=this.currTimer+Timer.delta *this.scale;
			this._lastTimer=now;
			var handlers=this._handlers;
			this._count=0;
			for (i=0,n=handlers.length;i < n;i++){
				handler=handlers[i];
				if (handler.method!==null){
					var t=handler.userFrame ? frame :timer;
					if (t >=handler.exeTime){
						if (handler.repeat){
							if (t > handler.exeTime){
								handler.exeTime+=handler.delay;
								handler.run(false);
								if (t > handler.exeTime){
									handler.exeTime+=Math.ceil((t-handler.exeTime)/ handler.delay)*handler.delay;
								}
							}
							}else {
							handler.run(true);
						}
					}
					}else {
					this._count++;
				}
			}
			if (this._count > 30 || frame % 200===0)this._clearHandlers();
			var laters=this._laters;
			for (var i=0,n=laters.length-1;i <=n;i++){
				var handler=laters[i];
				handler.method!==null && handler.run(false);
				this._recoverHandler(handler);
				i===n && (n=laters.length-1);
			}
			laters.length=0;
		}

		/**@private */
		__proto._clearHandlers=function(){
			var handlers=this._handlers;
			for (var i=0,n=handlers.length;i < n;i++){
				var handler=handlers[i];
				if (handler.method!==null)this._temp.push(handler);
				else this._recoverHandler(handler);
			}
			this._handlers=this._temp;
			this._temp=handlers;
			this._temp.length=0;
		}

		/**@private */
		__proto._recoverHandler=function(handler){
			this._map[handler.key]=null;
			handler.clear();
			Timer._pool.push(handler);
		}

		/**@private */
		__proto._create=function(useFrame,repeat,delay,caller,method,args,coverBefore){
			if (!delay){
				method.apply(caller,args);
				return;
			}
			if (coverBefore){
				var handler=this._getHandler(caller,method);
				if (handler){
					handler.repeat=repeat;
					handler.userFrame=useFrame;
					handler.delay=delay;
					handler.caller=caller;
					handler.method=method;
					handler.args=args;
					handler.exeTime=delay+(useFrame ? this.currFrame :this.currTimer);
					return;
				}
			}
			handler=Timer._pool.length > 0 ? Timer._pool.pop():new TimerHandler();
			handler.repeat=repeat;
			handler.userFrame=useFrame;
			handler.delay=delay;
			handler.caller=caller;
			handler.method=method;
			handler.args=args;
			handler.exeTime=delay+(useFrame ? this.currFrame :this.currTimer);
			this._indexHandler(handler);
			this._handlers.push(handler);
		}

		/**@private */
		__proto._indexHandler=function(handler){
			var caller=handler.caller;
			var method=handler.method;
			var cid=caller ? caller.$_GID || (caller.$_GID=Utils.getGID()):0;
			var mid=method.$_TID || (method.$_TID=(this._mid++)*100000);
			handler.key=cid+mid;
			this._map[handler.key]=handler;
		}

		/**
		*定时执行一次。
		*@param delay 延迟时间(单位为毫秒)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.once=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this._create(false,false,delay,caller,method,args,coverBefore);
		}

		/**
		*定时重复执行。
		*@param delay 间隔时间(单位毫秒)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.loop=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this._create(false,true,delay,caller,method,args,coverBefore);
		}

		/**
		*定时执行一次(基于帧率)。
		*@param delay 延迟几帧(单位为帧)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.frameOnce=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this._create(true,false,delay,caller,method,args,coverBefore);
		}

		/**
		*定时重复执行(基于帧率)。
		*@param delay 间隔几帧(单位为帧)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.frameLoop=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this._create(true,true,delay,caller,method,args,coverBefore);
		}

		/**返回统计信息。*/
		__proto.toString=function(){
			return "callLater:"+this._laters.length+" handlers:"+this._handlers.length+" pool:"+Timer._pool.length;
		}

		/**
		*清理定时器。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*/
		__proto.clear=function(caller,method){
			var handler=this._getHandler(caller,method);
			if (handler){
				this._map[handler.key]=null;handler.key=0;
				handler.clear();
			}
		}

		/**
		*清理对象身上的所有定时器。
		*@param caller 执行域(this)。
		*/
		__proto.clearAll=function(caller){
			for (var i=0,n=this._handlers.length;i < n;i++){
				var handler=this._handlers[i];
				if (handler.caller===caller){
					this._map[handler.key]=null;handler.key=0;
					handler.clear();
				}
			}
		}

		/**@private */
		__proto._getHandler=function(caller,method){
			var cid=caller ? caller.$_GID || (caller.$_GID=Utils.getGID()):0;
			var mid=method.$_TID || (method.$_TID=(this._mid++)*100000);
			return this._map[cid+mid];
		}

		/**
		*延迟执行。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*/
		__proto.callLater=function(caller,method,args){
			if (this._getHandler(caller,method)==null){
				if (Timer._pool.length)
					var handler=Timer._pool.pop();
				else handler=new TimerHandler();
				handler.caller=caller;
				handler.method=method;
				handler.args=args;
				this._indexHandler(handler);
				this._laters.push(handler);
			}
		}

		/**
		*立即执行 callLater 。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*/
		__proto.runCallLater=function(caller,method){
			var handler=this._getHandler(caller,method);
			if (handler && handler.method !=null){
				this._map[handler.key]=null;
				handler.run(true);
			}
		}

		Timer.delta=0;
		Timer._pool=[];
		Timer.__init$=function(){
			/**@private */
			//class TimerHandler
			TimerHandler=(function(){
				function TimerHandler(){
					this.key=0;
					this.repeat=false;
					this.delay=0;
					this.userFrame=false;
					this.exeTime=0;
					this.caller=null;
					this.method=null;
					this.args=null;
				}
				__class(TimerHandler,'');
				var __proto=TimerHandler.prototype;
				__proto.clear=function(){
					this.caller=null;
					this.method=null;
					this.args=null;
				}
				__proto.run=function(widthClear){
					var caller=this.caller;
					if (caller && caller.destroyed)return this.clear();
					var method=this.method;
					var args=this.args;
					widthClear && this.clear();
					if (method==null)return;
					args ? method.apply(caller,args):method.call(caller);
				}
				return TimerHandler;
			})()
		}

		return Timer;
	})()


	/**
	*<code>Tween</code> 是一个缓动类。使用实现目标对象属性的渐变。
	*/
	//class laya.utils.Tween
	var Tween=(function(){
		function Tween(){
			//this._complete=null;
			//this._target=null;
			//this._ease=null;
			//this._props=null;
			//this._duration=0;
			//this._delay=0;
			//this._startTimer=0;
			//this._usedTimer=0;
			//this._usedPool=false;
			this.gid=0;
			//this.update=null;
		}

		__class(Tween,'laya.utils.Tween');
		var __proto=Tween.prototype;
		/**
		*缓动对象的props属性到目标值。
		*@param target 目标对象(即将更改属性值的对象)。
		*@param props 变化的属性列表，比如{x:100,y:20}。
		*@param duration 花费的时间，单位毫秒。
		*@param ease 缓动类型，默认为匀速运动。
		*@param complete 结束回调函数。
		*@param delay 延迟执行时间。
		*@param coverBefore 是否覆盖之前的缓动。
		*@return 返回Tween对象。
		*/
		__proto.to=function(target,props,duration,ease,complete,delay,coverBefore){
			(delay===void 0)&& (delay=0);
			(coverBefore===void 0)&& (coverBefore=false);
			return this._create(target,props,duration,ease,complete,delay,coverBefore,true,false,true);
		}

		/**
		*从props属性，缓动到当前状态。
		*@param target 目标对象(即将更改属性值的对象)。
		*@param props 变化的属性列表，比如{x:100,y:20}。
		*@param duration 花费的时间，单位毫秒。
		*@param ease 缓动类型，默认为匀速运动。
		*@param complete 结束回调函数。
		*@param delay 延迟执行时间。
		*@param coverBefore 是否覆盖之前的缓动。
		*@return 返回Tween对象。
		*/
		__proto.from=function(target,props,duration,ease,complete,delay,coverBefore){
			(delay===void 0)&& (delay=0);
			(coverBefore===void 0)&& (coverBefore=false);
			return this._create(target,props,duration,ease,complete,delay,coverBefore,false,false,true);
		}

		/**@private */
		__proto._create=function(target,props,duration,ease,complete,delay,coverBefore,isTo,usePool,runNow){
			if (!target)throw new Error("Tween:target is null");
			this._target=target;
			this._duration=duration||props.duration||0;
			this._ease=ease || props.ease || Tween.easeNone;
			this._complete=complete || props.complete;
			this._delay=delay;
			this._props=[];
			this._usedTimer=0;
			this._startTimer=Browser.now();
			this._usedPool=usePool;
			this.update=props.update;
			var gid=(target.$_GID || (target.$_GID=Utils.getGID()));
			if (!Tween.tweenMap[gid]){
				Tween.tweenMap[gid]=[this];
				}else {
				if (coverBefore)Tween.clearTween(target);
				Tween.tweenMap[gid].push(this);
			}
			if (runNow){
				if (delay <=0)this.firstStart(target,props,isTo);
				else Laya.timer.once(delay,this,this.firstStart,[target,props,isTo]);
				}else {
				this._initProps(target,props,isTo);
			}
			return this;
		}

		__proto.firstStart=function(target,props,isTo){
			this._initProps(target,props,isTo);
			this._beginLoop();
		}

		__proto._initProps=function(target,props,isTo){
			for (var p in props){
				if ((typeof (target[p])=='number')){
					var start=isTo ? target[p] :props[p];
					var end=isTo ? props[p] :target[p];
					this._props.push([p,start,end-start]);
				}
			}
		}

		__proto._beginLoop=function(){
			Laya.timer.frameLoop(1,this,this._doEase);
		}

		/**执行缓动**/
		__proto._doEase=function(){
			this._updateEase(Browser.now());
		}

		/**@private */
		__proto._updateEase=function(time){
			var target=this._target;
			if (target.destroyed)return Tween.clearTween(target);
			var usedTimer=this._usedTimer=time-this._startTimer-this._delay;
			if (usedTimer < 0)return;
			if (usedTimer >=this._duration)return this.complete();
			var ratio=usedTimer > 0 ? this._ease(usedTimer,0,1,this._duration):0;
			var props=this._props;
			for (var i=0,n=props.length;i < n;i++){
				var prop=props[i];
				target[prop[0]]=prop[1]+(ratio *prop[2]);
			}
			if (this.update)this.update.run();
		}

		/**
		*立即结束缓动并到终点。
		*/
		__proto.complete=function(){
			if (!this._target)return;
			var target=this._target;
			var props=this._props;
			var handler=this._complete;
			for (var i=0,n=props.length;i < n;i++){
				var prop=props[i];
				target[prop[0]]=prop[1]+prop[2];
			}
			if (this.update)this.update.run();
			this.clear();
			handler && handler.run();
		}

		/**
		*暂停缓动，可以通过resume或restart重新开始。
		*/
		__proto.pause=function(){
			Laya.timer.clear(this,this._beginLoop);
			Laya.timer.clear(this,this._doEase);
		}

		/**
		*设置开始时间。
		*@param startTime 开始时间。
		*/
		__proto.setStartTime=function(startTime){
			this._startTimer=startTime;
		}

		/**
		*停止并清理当前缓动。
		*/
		__proto.clear=function(){
			if (this._target){
				this._remove();
				this._clear();
			}
		}

		/**
		*@private
		*/
		__proto._clear=function(){
			this.pause();
			Laya.timer.clear(this,this.firstStart);
			this._complete=null;
			this._target=null;
			this._ease=null;
			this._props=null;
			if (this._usedPool){
				this.update=null;
				Pool.recover("tween",this);
			}
		}

		/**回收到对象池。*/
		__proto.recover=function(){
			this._usedPool=true;
			this._clear();
		}

		__proto._remove=function(){
			var tweens=Tween.tweenMap[this._target.$_GID];
			if (tweens){
				for (var i=0,n=tweens.length;i < n;i++){
					if (tweens[i]===this){
						tweens.splice(i,1);
						break ;
					}
				}
			}
		}

		/**
		*重新开始暂停的缓动。
		*/
		__proto.restart=function(){
			this.pause();
			this._usedTimer=0;
			this._startTimer=Browser.now();
			var props=this._props;
			for (var i=0,n=props.length;i < n;i++){
				var prop=props[i];
				this._target[prop[0]]=prop[1];
			}
			Laya.timer.once(this._delay,this,this._beginLoop);
		}

		/**
		*恢复暂停的缓动。
		*/
		__proto.resume=function(){
			if (this._usedTimer >=this._duration)return;
			this._startTimer=Browser.now()-this._usedTimer-this._delay;
			this._beginLoop();
		}

		/**设置当前执行比例**/
		__getset(0,__proto,'progress',null,function(v){
			var uTime=v*this._duration;
			this._startTimer=Browser.now()-this._delay-uTime;
		});

		Tween.to=function(target,props,duration,ease,complete,delay,coverBefore,autoRecover){
			(delay===void 0)&& (delay=0);
			(coverBefore===void 0)&& (coverBefore=false);
			(autoRecover===void 0)&& (autoRecover=true);
			return Pool.getItemByClass("tween",Tween)._create(target,props,duration,ease,complete,delay,coverBefore,true,autoRecover,true);
		}

		Tween.from=function(target,props,duration,ease,complete,delay,coverBefore,autoRecover){
			(delay===void 0)&& (delay=0);
			(coverBefore===void 0)&& (coverBefore=false);
			(autoRecover===void 0)&& (autoRecover=true);
			return Pool.getItemByClass("tween",Tween)._create(target,props,duration,ease,complete,delay,coverBefore,false,autoRecover,true);
		}

		Tween.clearAll=function(target){
			if (!target || !target.$_GID)return;
			var tweens=Tween.tweenMap[target.$_GID];
			if (tweens){
				for (var i=0,n=tweens.length;i < n;i++){
					tweens[i]._clear();
				}
				tweens.length=0;
			}
		}

		Tween.clear=function(tween){
			tween.clear();
		}

		Tween.clearTween=function(target){
			Tween.clearAll(target);
		}

		Tween.easeNone=function(t,b,c,d){
			return c *t / d+b;
		}

		Tween.tweenMap={};
		return Tween;
	})()


	/**
	*<code>Utils</code> 是工具类。
	*/
	//class laya.utils.Utils
	var Utils=(function(){
		function Utils(){};
		__class(Utils,'laya.utils.Utils');
		Utils.toRadian=function(angle){
			return angle *Utils._pi2;
		}

		Utils.toAngle=function(radian){
			return radian *Utils._pi;
		}

		Utils.toHexColor=function(color){
			if (color < 0 || isNaN(color))return null;
			var str=color.toString(16);
			while (str.length < 6)str="0"+str;
			return "#"+str;
		}

		Utils.getGID=function(){
			return Utils._gid++;
		}

		Utils.concatArray=function(source,array){
			if (!array)return source;
			if (!source)return array;
			var i=0,len=array.length;
			for (i=0;i < len;i++){
				source.push(array[i]);
			}
			return source;
		}

		Utils.clearArray=function(array){
			if (!array)return array;
			array.length=0;
			return array;
		}

		Utils.copyArray=function(source,array){
			source || (source=[]);
			if (!array)return source;
			source.length=array.length;
			var i=0,len=array.length;
			for (i=0;i < len;i++){
				source[i]=array[i];
			}
			return source;
		}

		Utils.getGlobalRecByPoints=function(sprite,x0,y0,x1,y1){
			var newLTPoint;
			newLTPoint=new Point(x0,y0);
			newLTPoint=sprite.localToGlobal(newLTPoint);
			var newRBPoint;
			newRBPoint=new Point(x1,y1);
			newRBPoint=sprite.localToGlobal(newRBPoint);
			return Rectangle._getWrapRec([newLTPoint.x,newLTPoint.y,newRBPoint.x,newRBPoint.y]);
		}

		Utils.getGlobalPosAndScale=function(sprite){
			return Utils.getGlobalRecByPoints(sprite,0,0,1,1);
		}

		Utils.bind=function(fun,scope){
			var rst=fun;
			rst=fun.bind(scope);;
			return rst;
		}

		Utils.measureText=function(txt,font){
			return RunDriver.measureText(txt,font);
		}

		Utils.updateOrder=function(childs){
			if ((!childs)|| childs.length < 2)return false;
			var c=childs[0];
			var i=1,sz=childs.length;
			var z=c._zOrder,low=NaN,high=NaN,mid=NaN,zz=NaN;
			var repaint=false;
			for (i=1;i < sz;i++){
				c=childs [i];
				if (!c)continue ;
				if ((z=c._zOrder)< 0)z=c._zOrder;
				if (z < childs[i-1]._zOrder){
					mid=low=0;
					high=i-1;
					while (low <=high){
						mid=(low+high)>>> 1;
						if (!childs[mid])break ;
						zz=childs[mid]._zOrder;
						if (zz < 0)zz=childs[mid]._zOrder;
						if (zz < z)
							low=mid+1;
						else if (zz > z)
						high=mid-1;
						else break ;
					}
					if (z > childs[mid]._zOrder)mid++;
					var f=c.parent;
					childs.splice(i,1);
					childs.splice(mid,0,c);
					if (f && f.model){
						f.model&&f.model.removeChild(c.model);
						f.model && f.model.addChildAt(c.model,mid);
					}
					repaint=true;
				}
			}
			return repaint;
		}

		Utils.transPointList=function(points,x,y){
			var i=0,len=points.length;
			for (i=0;i < len;i+=2){
				points[i]+=x;
				points[i+1]+=y;
			}
		}

		Utils.parseInt=function(str,radix){
			(radix===void 0)&& (radix=0);
			var result=Browser.window.parseInt(str,radix);
			if (isNaN(result))return 0;
			return result;
		}

		Utils._gid=1;
		Utils._pi=180 / Math.PI;
		Utils._pi2=Math.PI / 180;
		Utils.parseXMLFromString=function(value){
			var rst;
			value=value.replace(/>\s+</g,'><');
			rst=(new DOMParser()).parseFromString(value,'text/xml');
			if (rst.firstChild.textContent.indexOf("This page contains the following errors")>-1){
				throw new Error(rst.firstChild.firstChild.textContent);
			}
			return rst;
		}

		return Utils;
	})()


	/**
	*...
	*@author
	*/
	//class laya.utils.VectorGraphManager
	var VectorGraphManager=(function(){
		function VectorGraphManager(){
			this.useDic={};
			this.shapeDic={};
			this.shapeLineDic={};
			this._id=0;
			this._checkKey=false;
			this._freeIdArray=[];
			if (Render.isWebGL){
				CacheManger.regCacheByFunction(Utils.bind(this.startDispose,this),Utils.bind(this.getCacheList,this));
			}
		}

		__class(VectorGraphManager,'laya.utils.VectorGraphManager');
		var __proto=VectorGraphManager.prototype;
		/**
		*得到个空闲的ID
		*@return
		*/
		__proto.getId=function(){
			if (this._freeIdArray.length > 0){
				return this._freeIdArray.pop();
			}
			return this._id++;
		}

		/**
		*添加一个图形到列表中
		*@param id
		*@param shape
		*/
		__proto.addShape=function(id,shape){
			this.shapeDic[id]=shape;
			if (!this.useDic[id]){
				this.useDic[id]=true;
			}
		}

		/**
		*添加一个线图形到列表中
		*@param id
		*@param Line
		*/
		__proto.addLine=function(id,Line){
			this.shapeLineDic[id]=Line;
			if (!this.shapeLineDic[id]){
				this.shapeLineDic[id]=true;
			}
		}

		/**
		*检测一个对象是否在使用中
		*@param id
		*/
		__proto.getShape=function(id){
			if (this._checkKey){
				if (this.useDic[id] !=null){
					this.useDic[id]=true;
				}
			}
		}

		/**
		*删除一个图形对象
		*@param id
		*/
		__proto.deleteShape=function(id){
			if (this.shapeDic[id]){
				this.shapeDic[id]=null;
				delete this.shapeDic[id];
			}
			if (this.shapeLineDic[id]){
				this.shapeLineDic[id]=null;
				delete this.shapeLineDic[id];
			}
			if (this.useDic[id] !=null){
				delete this.useDic[id];
			}
			this._freeIdArray.push(id);
		}

		/**
		*得到缓存列表
		*@return
		*/
		__proto.getCacheList=function(){
			var str;
			var list=[];
			for (str in this.shapeDic){
				list.push(this.shapeDic[str]);
			}
			for (str in this.shapeLineDic){
				list.push(this.shapeLineDic[str]);
			}
			return list;
		}

		/**
		*开始清理状态，准备销毁
		*/
		__proto.startDispose=function(key){
			var str;
			for (str in this.useDic){
				this.useDic[str]=false;
			}
			this._checkKey=true;
		}

		/**
		*确认销毁
		*/
		__proto.endDispose=function(){
			if (this._checkKey){
				var str;
				for (str in this.useDic){
					if (!this.useDic[str]){
						this.deleteShape(str);
					}
				}
				this._checkKey=false;
			}
		}

		VectorGraphManager.getInstance=function(){
			return VectorGraphManager.instance=VectorGraphManager.instance|| new VectorGraphManager();
		}

		VectorGraphManager.instance=null
		return VectorGraphManager;
	})()


	/**
	*@private
	*/
	//class laya.utils.WordText
	var WordText=(function(){
		function WordText(){
			this.id=NaN;
			this.save=[];
			this.toUpperCase=null;
			this.changed=false;
			this._text=null;
		}

		__class(WordText,'laya.utils.WordText');
		var __proto=WordText.prototype;
		__proto.setText=function(txt){
			this.changed=true;
			this._text=txt;
		}

		__proto.toString=function(){
			return this._text;
		}

		__proto.charCodeAt=function(i){
			return this._text ? this._text.charCodeAt(i):NaN;
		}

		__proto.charAt=function(i){
			return this._text ? this._text.charAt(i):null;
		}

		__getset(0,__proto,'length',function(){
			return this._text ? this._text.length :0;
		});

		return WordText;
	})()


	//class laya.webgl.atlas.AtlasGrid
	var AtlasGrid=(function(){
		var TexRowInfo,TexMergeTexSize;
		function AtlasGrid(width,height,atlasID){
			this._atlasID=0;
			this._width=0;
			this._height=0;
			this._texCount=0;
			this._rowInfo=null;
			this._cells=null;
			this._failSize=new TexMergeTexSize();
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			(atlasID===void 0)&& (atlasID=0);
			this._cells=null;
			this._rowInfo=null;
			this._init(width,height);
			this._atlasID=atlasID;
		}

		__class(AtlasGrid,'laya.webgl.atlas.AtlasGrid');
		var __proto=AtlasGrid.prototype;
		//------------------------------------------------------------------------------
		__proto.getAltasID=function(){
			return this._atlasID;
		}

		//------------------------------------------------------------------------------
		__proto.setAltasID=function(atlasID){
			if (atlasID >=0){
				this._atlasID=atlasID;
			}
		}

		//------------------------------------------------------------------
		__proto.addTex=function(type,width,height){
			var result=this._get(width,height);
			if (result.ret==false){
				return result;
			}
			this._fill(result.x,result.y,width,height,type);
			this._texCount++;
			return result;
		}

		//------------------------------------------------------------------------------
		__proto._release=function(){
			if (this._cells !=null){
				this._cells.length=0;
				this._cells=null;
			}
			if (this._rowInfo){
				this._rowInfo.length=0;
				this._rowInfo=null;
			}
		}

		//------------------------------------------------------------------------------
		__proto._init=function(width,height){
			this._width=width;
			this._height=height;
			this._release();
			if (this._width==0)return false;
			this._cells=new Uint8Array(this._width *this._height*3);
			this._rowInfo=__newvec(this._height);
			for (var i=0;i < this._height;i++){
				this._rowInfo[i]=new TexRowInfo();
			}
			this._clear();
			return true;
		}

		//------------------------------------------------------------------
		__proto._get=function(width,height){
			var pFillInfo=new MergeFillInfo();
			if (width >=this._failSize.width && height >=this._failSize.height){
				return pFillInfo;
			};
			var rx=-1;
			var ry=-1;
			var nWidth=this._width;
			var nHeight=this._height;
			var pCellBox=this._cells;
			for (var y=0;y < nHeight;y++){
				if (this._rowInfo[y].spaceCount < width)continue ;
				for (var x=0;x < nWidth;){
					var tm=(y *nWidth+x)*3;
					if (pCellBox[tm] !=0 || pCellBox[tm+1] < width || pCellBox[tm+2] < height){
						x+=pCellBox[tm+1];
						continue ;
					}
					rx=x;
					ry=y;
					for (var xx=0;xx < width;xx++){
						if (pCellBox[3*xx+tm+2] < height){
							rx=-1;
							break ;
						}
					}
					if (rx < 0){
						x+=pCellBox[tm+1];
						continue ;
					}
					pFillInfo.ret=true;
					pFillInfo.x=rx;
					pFillInfo.y=ry;
					return pFillInfo;
				}
			}
			return pFillInfo;
		}

		//------------------------------------------------------------------
		__proto._fill=function(x,y,w,h,type){
			var nWidth=this._width;
			var nHeghit=this._height;
			this._check((x+w)<=nWidth && (y+h)<=nHeghit);
			for (var yy=y;yy < (h+y);++yy){
				this._check(this._rowInfo[yy].spaceCount >=w);
				this._rowInfo[yy].spaceCount-=w;
				for (var xx=0;xx < w;xx++){
					var tm=(x+yy *nWidth+xx)*3;
					this._check(this._cells[tm]==0);
					this._cells[tm]=type;
					this._cells[tm+1]=w;
					this._cells[tm+2]=h;
				}
			}
			if (x > 0){
				for (yy=0;yy < h;++yy){
					var s=0;
					for (xx=x-1;xx >=0;--xx,++s){
						if (this._cells[((y+yy)*nWidth+xx)*3] !=0)break ;
					}
					for (xx=s;xx > 0;--xx){
						this._cells[((y+yy)*nWidth+x-xx)*3+1]=xx;
						this._check(xx > 0);
					}
				}
			}
			if (y > 0){
				for (xx=x;xx < (x+w);++xx){
					s=0;
					for (yy=y-1;yy >=0;--yy,s++){
						if (this._cells[(xx+yy *nWidth)*3] !=0)break ;
					}
					for (yy=s;yy > 0;--yy){
						this._cells[(xx+(y-yy)*nWidth)*3+2]=yy;
						this._check(yy > 0);
					}
				}
			}
		}

		__proto._check=function(ret){
			if (ret==false){
				console.log("xtexMerger 错误啦");
			}
		}

		//------------------------------------------------------------------
		__proto._clear=function(){
			this._texCount=0;
			for (var y=0;y < this._height;y++){
				this._rowInfo[y].spaceCount=this._width;
			}
			for (var i=0;i < this._height;i++){
				for (var j=0;j < this._width;j++){
					var tm=(i *this._width+j)*3;
					this._cells[tm]=0;
					this._cells[tm+1]=this._width-j;
					this._cells[tm+2]=this._width-i;
				}
			}
			this._failSize.width=this._width+1;
			this._failSize.height=this._height+1;
		}

		AtlasGrid.__init$=function(){
			//------------------------------------------------------------------------------
			//class TexRowInfo
			TexRowInfo=(function(){
				function TexRowInfo(){
					this.spaceCount=0;
				}
				__class(TexRowInfo,'');
				return TexRowInfo;
			})()
			//------------------------------------------------------------------------------
			//class TexMergeTexSize
			TexMergeTexSize=(function(){
				function TexMergeTexSize(){
					this.width=0;
					this.height=0;
				}
				__class(TexMergeTexSize,'');
				return TexMergeTexSize;
			})()
		}

		return AtlasGrid;
	})()


	//class laya.webgl.atlas.AtlasResourceManager
	var AtlasResourceManager=(function(){
		function AtlasResourceManager(width,height,gridSize,maxTexNum){
			this._currentAtlasCount=0;
			this._maxAtlaserCount=0;
			this._width=0;
			this._height=0;
			this._gridSize=0;
			this._gridNumX=0;
			this._gridNumY=0;
			this._init=false;
			this._curAtlasIndex=0;
			this._setAtlasParam=false;
			this._atlaserArray=null;
			this._needGC=false;
			this._setAtlasParam=true;
			this._width=width;
			this._height=height;
			this._gridSize=gridSize;
			this._maxAtlaserCount=maxTexNum;
			this._gridNumX=width / gridSize;
			this._gridNumY=height / gridSize;
			this._curAtlasIndex=0;
			this._atlaserArray=[];
		}

		__class(AtlasResourceManager,'laya.webgl.atlas.AtlasResourceManager');
		var __proto=AtlasResourceManager.prototype;
		__proto.setAtlasParam=function(width,height,gridSize,maxTexNum){
			if (this._setAtlasParam==true){
				AtlasResourceManager._sid_=0;
				this._width=width;
				this._height=height;
				this._gridSize=gridSize;
				this._maxAtlaserCount=maxTexNum;
				this._gridNumX=width / gridSize;
				this._gridNumY=height / gridSize;
				this._curAtlasIndex=0;
				this.freeAll();
				return true;
				}else {
				console.log("设置大图合集参数错误，只能在开始页面设置各种参数");
				throw-1;
				return false;
			}
			return false;
		}

		//添加 图片到大图集
		__proto.pushData=function(texture){
			var tex=texture;
			this._setAtlasParam=false;
			var bFound=false;
			var nImageGridX=(Math.ceil((texture.bitmap.width+2)/ this._gridSize));
			var nImageGridY=(Math.ceil((texture.bitmap.height+2)/ this._gridSize));
			var bSuccess=false;
			for (var k=0;k < 2;k++){
				var maxAtlaserCount=this._maxAtlaserCount;
				for (var i=0;i < maxAtlaserCount;i++){
					var altasIndex=(this._curAtlasIndex+i)% maxAtlaserCount;
					(this._atlaserArray.length-1>=altasIndex)|| (this._atlaserArray.push(new Atlaser(this._gridNumX,this._gridNumY,this._width,this._height,AtlasResourceManager._sid_++)));
					var atlas=this._atlaserArray[altasIndex];
					var bitmap=texture.bitmap;
					var webGLImageIndex=atlas.inAtlasWebGLImagesKey.indexOf(bitmap);
					var offsetX=0,offsetY=0;
					if (webGLImageIndex==-1){
						var fillInfo=atlas.addTex(1,nImageGridX,nImageGridY);
						if (fillInfo.ret){
							offsetX=fillInfo.x *this._gridSize+1;
							offsetY=fillInfo.y *this._gridSize+1;
							bitmap.lock=true;
							atlas.addToAtlasTexture((bitmap),offsetX,offsetY);
							atlas.addToAtlas(texture,offsetX,offsetY);
							bSuccess=true;
							this._curAtlasIndex=altasIndex;
							break ;
						}
						}else {
						var offset=atlas.InAtlasWebGLImagesOffsetValue[webGLImageIndex];
						offsetX=offset[0];
						offsetY=offset[1];
						atlas.addToAtlas(texture,offsetX,offsetY);
						bSuccess=true;
						this._curAtlasIndex=altasIndex;
						break ;
					}
				}
				if (bSuccess)
					break ;
				this._atlaserArray.push(new Atlaser(this._gridNumX,this._gridNumY,this._width,this._height,AtlasResourceManager._sid_++));
				this._needGC=true;
				this.garbageCollection();
				this._curAtlasIndex=this._atlaserArray.length-1;
			}
			if (!bSuccess){
				console.log(">>>AtlasManager pushData error");
			}
			return bSuccess;
		}

		__proto.addToAtlas=function(tex){
			laya.webgl.atlas.AtlasResourceManager.instance.pushData(tex);
		}

		/**
		*回收大图合集,不建议手动调用
		*@return
		*/
		__proto.garbageCollection=function(){
			if (this._needGC===true){
				var n=this._atlaserArray.length-this._maxAtlaserCount;
				for (var i=0;i < n;i++)
				this._atlaserArray[i].dispose();
				this._atlaserArray.splice(0,n);
				this._needGC=false;
			}
			return true;
		}

		__proto.freeAll=function(){
			for (var i=0,n=this._atlaserArray.length;i < n;i++){
				this._atlaserArray[i].dispose();
			}
			this._atlaserArray.length=0;
			this._curAtlasIndex=0;
		}

		__proto.getAtlaserCount=function(){
			return this._atlaserArray.length;
		}

		__proto.getAtlaserByIndex=function(index){
			return this._atlaserArray[index];
		}

		__getset(1,AtlasResourceManager,'instance',function(){
			if (!AtlasResourceManager._Instance){
				AtlasResourceManager._Instance=new AtlasResourceManager(laya.webgl.atlas.AtlasResourceManager.atlasTextureWidth,laya.webgl.atlas.AtlasResourceManager.atlasTextureHeight,16,laya.webgl.atlas.AtlasResourceManager.maxTextureCount);
			}
			return AtlasResourceManager._Instance;
		});

		__getset(1,AtlasResourceManager,'atlasLimitWidth',function(){
			return AtlasResourceManager._atlasLimitWidth;
			},function(value){
			AtlasResourceManager._atlasLimitWidth=value;
		});

		__getset(1,AtlasResourceManager,'enabled',function(){
			return AtlasResourceManager._enabled;
		});

		__getset(1,AtlasResourceManager,'atlasLimitHeight',function(){
			return AtlasResourceManager._atlasLimitHeight;
			},function(value){
			AtlasResourceManager._atlasLimitHeight=value;
		});

		AtlasResourceManager._enable=function(){
			AtlasResourceManager._enabled=true;
			Config.atlasEnable=true;
		}

		AtlasResourceManager._disable=function(){
			AtlasResourceManager._enabled=false;
			Config.atlasEnable=false;
		}

		AtlasResourceManager.__init__=function(){
			AtlasResourceManager.atlasTextureWidth=2048;
			AtlasResourceManager.atlasTextureHeight=2048;
			AtlasResourceManager.maxTextureCount=6;
			AtlasResourceManager.atlasLimitWidth=512;
			AtlasResourceManager.atlasLimitHeight=512;
		}

		AtlasResourceManager._enabled=false;
		AtlasResourceManager._atlasLimitWidth=0;
		AtlasResourceManager._atlasLimitHeight=0;
		AtlasResourceManager.gridSize=16;
		AtlasResourceManager.atlasTextureWidth=0;
		AtlasResourceManager.atlasTextureHeight=0;
		AtlasResourceManager.maxTextureCount=0;
		AtlasResourceManager._atlasRestore=0;
		AtlasResourceManager.BOARDER_TYPE_NO=0;
		AtlasResourceManager.BOARDER_TYPE_RIGHT=1;
		AtlasResourceManager.BOARDER_TYPE_LEFT=2;
		AtlasResourceManager.BOARDER_TYPE_BOTTOM=4;
		AtlasResourceManager.BOARDER_TYPE_TOP=8;
		AtlasResourceManager.BOARDER_TYPE_ALL=15;
		AtlasResourceManager._sid_=0;
		AtlasResourceManager._Instance=null;
		return AtlasResourceManager;
	})()


	//class laya.webgl.atlas.MergeFillInfo
	var MergeFillInfo=(function(){
		function MergeFillInfo(){
			this.x=0;
			this.y=0;
			this.ret=false;
			this.ret=false;
			this.x=0;
			this.y=0;
		}

		__class(MergeFillInfo,'laya.webgl.atlas.MergeFillInfo');
		return MergeFillInfo;
	})()


	;
	//class laya.webgl.canvas.BlendMode
	var BlendMode=(function(){
		function BlendMode(){};
		__class(BlendMode,'laya.webgl.canvas.BlendMode');
		BlendMode._init_=function(gl){
			BlendMode.fns=[BlendMode.BlendNormal,BlendMode.BlendAdd,BlendMode.BlendMultiply,BlendMode.BlendScreen,BlendMode.BlendOverlay,BlendMode.BlendLight,BlendMode.BlendMask];
			BlendMode.targetFns=[BlendMode.BlendNormalTarget,BlendMode.BlendAddTarget,BlendMode.BlendMultiplyTarget,BlendMode.BlendScreenTarget,BlendMode.BlendOverlayTarget,BlendMode.BlendLightTarget,BlendMode.BlendMask];
		}

		BlendMode.BlendNormal=function(gl){
			gl.blendFunc(0x0302,0x0303);
		}

		BlendMode.BlendAdd=function(gl){
			gl.blendFunc(0x0302,0x0304);
		}

		BlendMode.BlendMultiply=function(gl){
			gl.blendFunc(0x0306,0x0303);
		}

		BlendMode.BlendScreen=function(gl){
			gl.blendFunc(0x0302,1);
		}

		BlendMode.BlendOverlay=function(gl){
			gl.blendFunc(1,0x0301);
		}

		BlendMode.BlendLight=function(gl){
			gl.blendFunc(0x0302,1);
		}

		BlendMode.BlendNormalTarget=function(gl){
			gl.blendFuncSeparate(0x0302,0x0303,1,0x0303);
		}

		BlendMode.BlendAddTarget=function(gl){
			gl.blendFunc(0x0302,0x0304);
		}

		BlendMode.BlendMultiplyTarget=function(gl){
			gl.blendFunc(0x0306,0x0303);
		}

		BlendMode.BlendScreenTarget=function(gl){
			gl.blendFunc(0x0302,1);
		}

		BlendMode.BlendOverlayTarget=function(gl){
			gl.blendFunc(1,0x0301);
		}

		BlendMode.BlendLightTarget=function(gl){
			gl.blendFunc(0x0302,1);
		}

		BlendMode.BlendMask=function(gl){
			gl.blendFunc(0,0x0302);
		}

		BlendMode.activeBlendFunction=null;
		BlendMode.NAMES=["normal","add","multiply","screen","overlay","light","mask"];
		BlendMode.TOINT={"normal":0,"add":1,"multiply":2,"screen":3 ,"lighter":1,"overlay":4,"light":5,"mask":6};
		BlendMode.NORMAL="normal";
		BlendMode.ADD="add";
		BlendMode.MULTIPLY="multiply";
		BlendMode.SCREEN="screen";
		BlendMode.LIGHT="light";
		BlendMode.OVERLAY="overlay";
		BlendMode.fns=[];
		BlendMode.targetFns=[];
		return BlendMode;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.canvas.DrawStyle
	var DrawStyle=(function(){
		function DrawStyle(value){
			this._color=Color.create("black");
			this.setValue(value);
		}

		__class(DrawStyle,'laya.webgl.canvas.DrawStyle');
		var __proto=DrawStyle.prototype;
		__proto.setValue=function(value){
			if (value){
				if ((typeof value=='string')){
					this._color=Color.create(value);
					return;
				}
				if ((value instanceof laya.utils.Color )){
					this._color=value;
					return;
				}
			}
		}

		__proto.reset=function(){
			this._color=Color.create("black");
		}

		__proto.equal=function(value){
			if ((typeof value=='string'))return this._color.strColor===value;
			if ((value instanceof laya.utils.Color ))return this._color.numColor===(value).numColor;
			return false;
		}

		__proto.toColorStr=function(){
			return this._color.strColor;
		}

		DrawStyle.create=function(value){
			if (value){
				var color;
				if ((typeof value=='string'))color=Color.create(value);
				else if ((value instanceof laya.utils.Color ))color=value;
				if (color){
					return color._drawStyle || (color._drawStyle=new DrawStyle(value));
				}
			}
			return null;
		}

		DrawStyle.DEFAULT=new DrawStyle("#000000");
		return DrawStyle;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.canvas.Path
	var Path=(function(){
		function Path(){
			this._x=0;
			this._y=0;
			//this._rect=null;
			//this.ib=null;
			//this.vb=null;
			this.dirty=false;
			//this.geomatrys=null;
			//this._curGeomatry=null;
			this.offset=0;
			this.count=0;
			this.geoStart=0;
			this.tempArray=[];
			this.closePath=false;
			this.geomatrys=[];
			var gl=WebGL.mainContext;
			this.ib=IndexBuffer2D.create(0x88E8);
			this.vb=VertexBuffer2D.create(5);
		}

		__class(Path,'laya.webgl.canvas.Path');
		var __proto=Path.prototype;
		__proto.addPoint=function(pointX,pointY){
			this.tempArray.push(pointX,pointY);
		}

		__proto.getEndPointX=function(){
			return this.tempArray[this.tempArray.length-2];
		}

		__proto.getEndPointY=function(){
			return this.tempArray[this.tempArray.length-1];
		}

		__proto.polygon=function(x,y,points,color,borderWidth,borderColor){
			var geo;
			this.geomatrys.push(this._curGeomatry=geo=new Polygon(x,y,points,color,borderWidth,borderColor));
			if (!color)geo.fill=false;
			if (borderColor==undefined)geo.borderWidth=0;
			return geo;
		}

		__proto.setGeomtry=function(shape){
			this.geomatrys.push(this._curGeomatry=shape);
		}

		__proto.drawLine=function(x,y,points,width,color){
			var geo;
			if (this.closePath){
				this.geomatrys.push(this._curGeomatry=geo=new LoopLine(x,y,points,width,color));
				}else {
				this.geomatrys.push(this._curGeomatry=geo=new Line(x,y,points,width,color));
			}
			geo.fill=false;
			return geo;
		}

		__proto.update=function(){
			var si=this.ib.byteLength;
			var len=this.geomatrys.length;
			this.offset=si;
			for (var i=this.geoStart;i < len;i++){
				this.geomatrys[i].getData(this.ib,this.vb,this.vb.byteLength / (5 *4));
			}
			this.geoStart=len;
			this.count=(this.ib.byteLength-si)/ CONST3D2D.BYTES_PIDX;
		}

		__proto.reset=function(){
			this.vb.clear();
			this.ib.clear();
			this.offset=this.count=this.geoStart=0;
			this.geomatrys.length=0;
		}

		return Path;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.canvas.save.SaveBase
	var SaveBase=(function(){
		function SaveBase(){
			//this._valueName=null;
			//this._value=null;
			//this._dataObj=null;
			//this._newSubmit=false;
		}

		__class(SaveBase,'laya.webgl.canvas.save.SaveBase');
		var __proto=SaveBase.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){return false;}
		__proto.restore=function(context){
			this._dataObj[this._valueName]=this._value;
			SaveBase._cache[SaveBase._cache._length++]=this;
			this._newSubmit && (context._curSubmit=Submit.RENDERBASE);
		}

		SaveBase._createArray=function(){
			var value=[];
			value._length=0;
			return value;
		}

		SaveBase._init=function(){
			var namemap=SaveBase._namemap={};
			namemap[0x1]="ALPHA";
			namemap[0x2]="fillStyle";
			namemap[0x8]="font";
			namemap[0x100]="lineWidth";
			namemap[0x200]="strokeStyle";
			namemap[0x2000]="_mergeID";
			namemap[0x400]=
			namemap[0x800]=
			namemap[0x1000]=[];
			namemap[0x4000]="textBaseline";
			namemap[0x8000]="textAlign";
			namemap[0x10000]="_nBlendType";
			namemap[0x80000]="shader";
			namemap[0x100000]="filters";
			return namemap;
		}

		SaveBase.save=function(context,type,dataObj,newSubmit){
			if ((context._saveMark._saveuse & type)!==type){
				context._saveMark._saveuse |=type;
				var cache=SaveBase._cache;
				var o=cache._length > 0 ?cache[--cache._length] :(new SaveBase());
				o._value=dataObj[ o._valueName=SaveBase._namemap[type]];
				o._dataObj=dataObj;
				o._newSubmit=newSubmit;
				var _save=context._save;
				_save[_save._length++]=o;
			}
		}

		SaveBase._cache=laya.webgl.canvas.save.SaveBase._createArray();
		SaveBase._namemap=SaveBase._init();
		return SaveBase;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.canvas.save.SaveClipRect
	var SaveClipRect=(function(){
		function SaveClipRect(){
			//this._clipSaveRect=null;
			//this._submitScissor=null;
			this._clipRect=new Rectangle();
		}

		__class(SaveClipRect,'laya.webgl.canvas.save.SaveClipRect');
		var __proto=SaveClipRect.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){return false;}
		__proto.restore=function(context){
			context._clipRect=this._clipSaveRect;
			SaveClipRect._cache[SaveClipRect._cache._length++]=this;
			this._submitScissor.submitLength=context._submits._length-this._submitScissor.submitIndex;
			context._curSubmit=Submit.RENDERBASE;
		}

		SaveClipRect.save=function(context,submitScissor){
			if ((context._saveMark._saveuse & 0x20000)==0x20000)return;
			context._saveMark._saveuse |=0x20000;
			var cache=SaveClipRect._cache;
			var o=cache._length > 0?cache[--cache._length]:(new SaveClipRect());
			o._clipSaveRect=context._clipRect;
			context._clipRect=o._clipRect.copyFrom(context._clipRect);
			o._submitScissor=submitScissor;
			var _save=context._save;
			_save[_save._length++]=o;
		}

		SaveClipRect._cache=SaveBase._createArray();
		return SaveClipRect;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.canvas.save.SaveMark
	var SaveMark=(function(){
		function SaveMark(){
			this._saveuse=0;
			//this._preSaveMark=null;
			;
		}

		__class(SaveMark,'laya.webgl.canvas.save.SaveMark');
		var __proto=SaveMark.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){
			return true;
		}

		__proto.restore=function(context){
			context._saveMark=this._preSaveMark;
			SaveMark._no[SaveMark._no._length++]=this;
		}

		SaveMark.Create=function(context){
			var no=SaveMark._no;
			var o=no._length > 0?no[--no._length]:(new SaveMark());
			o._saveuse=0;
			o._preSaveMark=context._saveMark;
			context._saveMark=o;
			return o;
		}

		SaveMark._no=SaveBase._createArray();
		return SaveMark;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.canvas.save.SaveTransform
	var SaveTransform=(function(){
		function SaveTransform(){
			//this._savematrix=null;
			this._matrix=new Matrix();
		}

		__class(SaveTransform,'laya.webgl.canvas.save.SaveTransform');
		var __proto=SaveTransform.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){return false;}
		__proto.restore=function(context){
			context._curMat=this._savematrix;
			SaveTransform._no[SaveTransform._no._length++]=this;
		}

		SaveTransform.save=function(context){
			var _saveMark=context._saveMark;
			if ((_saveMark._saveuse & 0x800)===0x800)return;
			_saveMark._saveuse |=0x800;
			var no=SaveTransform._no;
			var o=no._length > 0?no[--no._length]:(new SaveTransform());
			o._savematrix=context._curMat;
			context._curMat=context._curMat.copyTo(o._matrix);
			var _save=context._save;
			_save[_save._length++]=o;
		}

		SaveTransform._no=SaveBase._createArray();
		return SaveTransform;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.canvas.save.SaveTranslate
	var SaveTranslate=(function(){
		function SaveTranslate(){
			//this._x=NaN;
			//this._y=NaN;
		}

		__class(SaveTranslate,'laya.webgl.canvas.save.SaveTranslate');
		var __proto=SaveTranslate.prototype;
		Laya.imps(__proto,{"laya.webgl.canvas.save.ISaveData":true})
		__proto.isSaveMark=function(){return false;}
		__proto.restore=function(context){
			var mat=context._curMat;
			context._x=this._x;
			context._y=this._y;
			SaveTranslate._no[SaveTranslate._no._length++]=this;
		}

		SaveTranslate.save=function(context){
			var no=SaveTranslate._no;
			var o=no._length > 0?no[--no._length]:(new SaveTranslate());
			o._x=context._x;
			o._y=context._y;
			var _save=context._save;
			_save[_save._length++]=o;
		}

		SaveTranslate._no=SaveBase._createArray();
		return SaveTranslate;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.resource.RenderTargetMAX
	var RenderTargetMAX=(function(){
		var OneTarget;
		function RenderTargetMAX(){
			this.targets=null;
			this.oneTargets=null;
			this.repaint=false;
			this._width=NaN;
			this._height=NaN;
			this._clipRect=new Rectangle();
		}

		__class(RenderTargetMAX,'laya.webgl.resource.RenderTargetMAX');
		var __proto=RenderTargetMAX.prototype;
		__proto.size=function(w,h){
			if (this._width===w && this._height===h)return;
			this.repaint=true;
			this._width=w;
			this._height=h;
			if (!this.oneTargets)
				this.oneTargets=new OneTarget(w,h);
			else
			this.oneTargets.target.size(w,h);
		}

		__proto._flushToTarget=function(context,target){
			var worldScissorTest=RenderState2D.worldScissorTest;
			var preworldClipRect=RenderState2D.worldClipRect;
			RenderState2D.worldClipRect=this._clipRect;
			this._clipRect.x=this._clipRect.y=0;
			this._clipRect.width=this._width;
			this._clipRect.height=this._height;
			RenderState2D.worldScissorTest=false;
			WebGL.mainContext.disable(0x0C11);
			var preAlpha=RenderState2D.worldAlpha;
			var preMatrix4=RenderState2D.worldMatrix4;
			var preMatrix=RenderState2D.worldMatrix;
			var preFilters=RenderState2D.worldFilters;
			var preShaderDefines=RenderState2D.worldShaderDefines;
			RenderState2D.worldMatrix=RenderTargetMAX._matrixDefault;
			RenderState2D.restoreTempArray();
			RenderState2D.worldMatrix4=RenderState2D.TEMPMAT4_ARRAY;
			RenderState2D.worldAlpha=1;
			RenderState2D.worldFilters=null;
			RenderState2D.worldShaderDefines=null;
			Shader.activeShader=null;
			target.start();
			Config.showCanvasMark ? target.clear(0,1,0,0.3):target.clear(0,0,0,0);
			context.flush();
			target.end();
			Shader.activeShader=null;
			RenderState2D.worldAlpha=preAlpha;
			RenderState2D.worldMatrix4=preMatrix4;
			RenderState2D.worldMatrix=preMatrix;
			RenderState2D.worldFilters=preFilters;
			RenderState2D.worldShaderDefines=preShaderDefines;
			RenderState2D.worldScissorTest=worldScissorTest
			if (worldScissorTest){
				var y=RenderState2D.height-preworldClipRect.y-preworldClipRect.height;
				WebGL.mainContext.scissor(preworldClipRect.x,y,preworldClipRect.width,preworldClipRect.height);
				WebGL.mainContext.enable(0x0C11);
			}
			RenderState2D.worldClipRect=preworldClipRect;
		}

		__proto.flush=function(context){
			if (this.repaint){
				this._flushToTarget(context,this.oneTargets.target);
				this.repaint=false;
			}
		}

		__proto.drawTo=function(context,x,y,width,height){
			context.drawTexture(this.oneTargets.target.getTexture(),x,y,width,height,0,0);
		}

		__proto.destroy=function(){
			if (this.oneTargets){
				this.oneTargets.target.destroy();
				this.oneTargets.target=null;
				this.oneTargets=null;
			}
		}

		__static(RenderTargetMAX,
		['_matrixDefault',function(){return this._matrixDefault=new Matrix();}
		]);
		RenderTargetMAX.__init$=function(){
			//class OneTarget
			OneTarget=(function(){
				function OneTarget(w,h){
					//this.x=NaN;
					//this.y=NaN;
					//this.width=NaN;
					//this.height=NaN;
					//this.target=null;
					this.width=w;
					this.height=h;
					this.target=RenderTarget2D.create(w,h);
				}
				__class(OneTarget,'');
				return OneTarget;
			})()
		}

		return RenderTargetMAX;
	})()


	/**
	*...
	*@author
	*/
	//class laya.webgl.shader.d2.fillTexture.FillTextureSprite
	var FillTextureSprite=(function(){
		function FillTextureSprite(){
			this.mVBBuffer=null;
			this.mIBBuffer=null;
			this.mVBData=null;
			this.mIBData=null;
			this.mEleNum=0;
			this.mShaderValue=null;
			this.mTexture=null;
			this.transform=null;
		}

		__class(FillTextureSprite,'laya.webgl.shader.d2.fillTexture.FillTextureSprite');
		var __proto=FillTextureSprite.prototype;
		__proto.initTexture=function(texture,x,y,width,height,offsetX,offsetY){
			this.mTexture=texture;
			if (this.mVBBuffer){
				this.mVBBuffer.dispose();
			}
			if (this.mIBBuffer){
				this.mIBBuffer.dispose();
			}
			this.mVBBuffer=VertexBuffer2D.create();
			this.mIBBuffer=IndexBuffer2D.create();
			this.mIBData=new Uint16Array();
			var tVBArray;
			var tIBArray;
			tVBArray=[];
			var w=texture.bitmap.width,h=texture.bitmap.height,uv=texture.uv;
			var tTextureX=uv[0] *w;
			var tTextureY=uv[1] *h;
			var tTextureW=(uv[2]-uv[0])*w;
			var tTextureH=(uv[5]-uv[3])*h;
			var tU=width / tTextureW;
			var tV=height / tTextureH;
			var tWidth=width;
			var tHeight=height;
			var tRed=1;
			var tGreed=1;
			var tBlue=1;
			var tAlpha=1;
			tVBArray.push(x,y,0,0,tRed,tGreed,tBlue,tAlpha);
			tVBArray.push(x+tWidth,y,tU,0,tRed,tGreed,tBlue,tAlpha);
			tVBArray.push(x+tWidth,y+tHeight,tU,tV,tRed,tGreed,tBlue,tAlpha);
			tVBArray.push(x,y+tHeight,0,tV,tRed,tGreed,tBlue,tAlpha);
			tIBArray=[];
			tIBArray.push(0,1,3,3,1,2);
			this.mEleNum=tIBArray.length;
			this.mVBData=new Float32Array(tVBArray);
			this.mIBData=new Uint16Array(tIBArray);
			this.mVBBuffer.append(this.mVBData);
			this.mIBBuffer.append(this.mIBData);
			this.mTexture=texture;
			if (this.mShaderValue==null){
				this.mShaderValue=new FillTextureShaderValue();
			}
			this.mShaderValue.u_offset[0]=-offsetX / tTextureW;
			this.mShaderValue.u_offset[1]=-offsetY / tTextureH;
			this.mShaderValue.u_texRange[0]=tTextureX / w;
			this.mShaderValue.u_texRange[1]=tTextureW / w;
			this.mShaderValue.u_texRange[2]=tTextureY / h;
			this.mShaderValue.u_texRange[3]=tTextureH / h;
		}

		__proto.render=function(context,x,y){
			if (Render.isWebGL){
				this.mShaderValue.textureHost=this.mTexture;
				context.setIBVB(x,y,this.mIBBuffer,this.mVBBuffer,this.mEleNum,this.transform,FillTextureShader.shader,this.mShaderValue,0,0);
			}
		}

		return FillTextureSprite;
	})()


	//class laya.webgl.shader.d2.Shader2D
	var Shader2D=(function(){
		function Shader2D(){
			this.ALPHA=1;
			//this.glTexture=null;
			//this.shader=null;
			//this.filters=null;
			this.shaderType=0;
			//this.colorAdd=null;
			//this.strokeStyle=null;
			//this.fillStyle=null;
			this.defines=new ShaderDefines2D();
		}

		__class(Shader2D,'laya.webgl.shader.d2.Shader2D');
		Shader2D.__init__=function(){
			Shader.addInclude("parts/ColorFilter_ps_uniform.glsl","uniform vec4 colorAlpha;\nuniform mat4 colorMat;");
			Shader.addInclude("parts/ColorFilter_ps_logic.glsl","gl_FragColor = gl_FragColor * colorMat + colorAlpha/255.0;");
			Shader.addInclude("parts/GlowFilter_ps_uniform.glsl","uniform vec4 u_color;\nuniform float u_strength;\nuniform float u_blurX;\nuniform float u_blurY;\nuniform float u_offsetX;\nuniform float u_offsetY;\nuniform float u_textW;\nuniform float u_textH;");
			Shader.addInclude("parts/GlowFilter_ps_logic.glsl","const float c_IterationTime = 10.0;\nfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\nvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\nvec2 vec2FilterDir = vec2(-(u_offsetX)/u_textW,-(u_offsetY)/u_textH);\nvec2 vec2FilterOff = vec2(u_blurX/u_textW/c_IterationTime * 2.0,u_blurY/u_textH/c_IterationTime * 2.0);\nfloat maxNum = u_blurX * u_blurY;\nvec2 vec2Off = vec2(0.0,0.0);\nfloat floatOff = c_IterationTime/2.0;\nfor(float i = 0.0;i<=c_IterationTime; ++i){\n	for(float j = 0.0;j<=c_IterationTime; ++j){\n		vec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\n		vec4Color += texture2D(texture, v_texcoord + vec2FilterDir + vec2Off)/floatIterationTotalTime;\n	}\n}\ngl_FragColor = vec4(u_color.rgb,vec4Color.a * u_strength);");
			Shader.addInclude("parts/BlurFilter_ps_logic.glsl","gl_FragColor=vec4(0.0);\ngl_FragColor += texture2D(texture, vBlurTexCoords[ 0])*0.004431848411938341;\ngl_FragColor += texture2D(texture, vBlurTexCoords[ 1])*0.05399096651318985;\ngl_FragColor += texture2D(texture, vBlurTexCoords[ 2])*0.2419707245191454;\ngl_FragColor += texture2D(texture, v_texcoord        )*0.3989422804014327;\ngl_FragColor += texture2D(texture, vBlurTexCoords[ 3])*0.2419707245191454;\ngl_FragColor += texture2D(texture, vBlurTexCoords[ 4])*0.05399096651318985;\ngl_FragColor += texture2D(texture, vBlurTexCoords[ 5])*0.004431848411938341;");
			Shader.addInclude("parts/BlurFilter_ps_uniform.glsl","varying vec2 vBlurTexCoords[6];");
			Shader.addInclude("parts/BlurFilter_vs_uniform.glsl","uniform float strength;\nvarying vec2 vBlurTexCoords[6];");
			Shader.addInclude("parts/BlurFilter_vs_logic.glsl","\nvBlurTexCoords[ 0] = v_texcoord + vec2(-0.012 * strength, 0.0);\nvBlurTexCoords[ 1] = v_texcoord + vec2(-0.008 * strength, 0.0);\nvBlurTexCoords[ 2] = v_texcoord + vec2(-0.004 * strength, 0.0);\nvBlurTexCoords[ 3] = v_texcoord + vec2( 0.004 * strength, 0.0);\nvBlurTexCoords[ 4] = v_texcoord + vec2( 0.008 * strength, 0.0);\nvBlurTexCoords[ 5] = v_texcoord + vec2( 0.012 * strength, 0.0);");
			Shader.addInclude("parts/ColorAdd_ps_uniform.glsl","uniform vec4 colorAdd;\n");
			Shader.addInclude("parts/ColorAdd_ps_logic.glsl","gl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);");
			var vs,ps;
			vs="attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\n\n#include?BLUR_FILTER  \"parts/BlurFilter_vs_uniform.glsl\";\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n  #include?BLUR_FILTER  \"parts/BlurFilter_vs_logic.glsl\";\n}";
			ps="precision mediump float;\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec4 color= texture2D(texture, v_texcoord);\n   color.a*=alpha;\n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
			Shader.preCompile(0,0x01,vs,ps,null);
			vs="attribute vec4 position;\nuniform vec2 size;\nuniform mat4 mmat;\nvoid main() {\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n}";
			ps="precision mediump float;\nuniform vec4 color;\nuniform float alpha;\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\nvoid main() {\n	vec4 a = vec4(color.r, color.g, color.b, color.a);\n	a.w = alpha;\n	gl_FragColor = a;\n	#include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n}";
			Shader.preCompile(0,0x02,vs,ps,null);
			vs="attribute vec4 position;\nattribute vec3 a_color;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nuniform vec2 u_pos;\nuniform vec2 size;\nvarying vec3 color;\nvoid main(){\n  vec4 tPos = vec4(position.x + u_pos.x,position.y + u_pos.y,position.z,position.w);\n  vec4 pos=mmat*u_mmat2*tPos;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  color=a_color;\n}";
			ps="precision mediump float;\n//precision mediump float;\nvarying vec3 color;\nuniform float alpha;\nvoid main(){\n	//vec4 a=vec4(color.r, color.g, color.b, 1);\n	//a.a*=alpha;\n    gl_FragColor=vec4(color.r, color.g, color.b, alpha);\n}";
			Shader.preCompile(0,0x04,vs,ps,null);
		}

		return Shader2D;
	})()


	/**
	*这里销毁的问题，后面待确认
	*@author ...
	*/
	//class laya.webgl.shader.d2.skinAnishader.SkinMesh
	var SkinMesh=(function(){
		function SkinMesh(){
			this.mVBBuffer=null;
			this.mIBBuffer=null;
			this.mVBData=null;
			this.mIBData=null;
			this.mEleNum=0;
			this.mShaderValue=null;
			this.mTexture=null;
			this.transform=null;
		}

		__class(SkinMesh,'laya.webgl.shader.d2.skinAnishader.SkinMesh');
		var __proto=SkinMesh.prototype;
		__proto.init=function(texture,vs,ps){
			this.mVBBuffer=VertexBuffer2D.create();
			this.mIBBuffer=IndexBuffer2D.create();
			this.mIBData=new Uint16Array();
			var tVBArray;
			var tIBArray;
			if (vs){
				tVBArray=vs;
				}else {
				tVBArray=[];
				var tWidth=texture.width;
				var tHeight=texture.height;
				var tRed=1;
				var tGreed=1;
				var tBlue=1;
				var tAlpha=1;
				tVBArray.push(0,0,0,0,tRed,tGreed,tBlue,tAlpha);
				tVBArray.push(tWidth,0,1,0,tRed,tGreed,tBlue,tAlpha);
				tVBArray.push(tWidth,tHeight,1,1,tRed,tGreed,tBlue,tAlpha);
				tVBArray.push(0,tHeight,0,1,tRed,tGreed,tBlue,tAlpha);
			}
			if (ps){
				tIBArray=ps;
				}else {
				tIBArray=[];
				tIBArray.push(0,1,3,3,1,2);
			}
			this.mEleNum=tIBArray.length;
			this.mVBData=new Float32Array(tVBArray);
			this.mIBData=new Uint16Array(tIBArray);
			this.mVBBuffer.append(this.mVBData);
			this.mIBBuffer.append(this.mIBData);
			this.mTexture=texture;
			if (this.mShaderValue==null){
				this.mShaderValue=new aniShaderValue1();
			}
		}

		__proto.render=function(context,x,y){
			if (Render.isWebGL){
				this.mShaderValue.textureHost=this.mTexture;
				(context).setIBVB(x,y,this.mIBBuffer,this.mVBBuffer,this.mEleNum,this.transform,SkinAniShader1.shader,this.mShaderValue,0,0);
			}
		}

		return SkinMesh;
	})()


	//此类可以减少代码
	//class laya.webgl.shapes.BasePoly
	var BasePoly=(function(){
		function BasePoly(x,y,width,height,edges,color,borderWidth,borderColor,round){
			//this.x=NaN;
			//this.y=NaN;
			//this.r=NaN;
			//this.width=NaN;
			//this.height=NaN;
			//this.edges=NaN;
			this.r0=0
			//this.color=0;
			//this.borderColor=NaN;
			//this.borderWidth=NaN;
			//this.round=0;
			this.fill=true;
			this.r1=Math.PI / 2;
			(round===void 0)&& (round=0);
			this.x=x;
			this.y=y;
			this.width=width;
			this.height=height;
			this.edges=edges;
			this.color=color;
			this.borderWidth=borderWidth;
			this.borderColor=borderColor;
		}

		__class(BasePoly,'laya.webgl.shapes.BasePoly');
		var __proto=BasePoly.prototype;
		Laya.imps(__proto,{"laya.webgl.shapes.IShape":true})
		__proto.getData=function(ib,vb,start){}
		__proto.sector=function(outVert,outIndex,start){
			var x=this.x,y=this.y,edges=this.edges,seg=(this.r1-this.r0)/ edges;
			var w=this.width,h=this.height,color=this.color;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			outVert.push(x,y,r,g,b);
			for (var i=0;i < edges+1;i++){
				outVert.push(x+Math.sin(seg *i+this.r0)*w,y+Math.cos(seg *i+this.r0)*h);
				outVert.push(r,g,b);
			}
			for (i=0;i < edges;i++){
				outIndex.push(start,start+i+1,start+i+2);
			}
		}

		//用于画线
		__proto.createLine2=function(p,indices,lineWidth,len,outVertex,indexCount){
			var points=p.concat();
			var result=outVertex;
			var color=this.borderColor;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			var length=points.length / 2;
			var iStart=len,w=lineWidth / 2;
			var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
			var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
			var a1,b1,c1,a2,b2,c2;
			var denom,pdist,dist;
			p1x=points[0];
			p1y=points[1];
			p2x=points[2];
			p2y=points[3];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			result.push(p1x-perpx+this.x,p1y-perpy+this.y,r,g,b,p1x+perpx+this.x,p1y+perpy+this.y,r,g,b);
			for (var i=1;i < length-1;i++){
				p1x=points[(i-1)*2];
				p1y=points[(i-1)*2+1];
				p2x=points[(i)*2];
				p2y=points[(i)*2+1];
				p3x=points[(i+1)*2];
				p3y=points[(i+1)*2+1];
				perpx=-(p1y-p2y);
				perpy=p1x-p2x;
				dist=Math.sqrt(perpx *perpx+perpy *perpy);
				perpx=perpx / dist *w;
				perpy=perpy / dist *w;
				perp2x=-(p2y-p3y);
				perp2y=p2x-p3x;
				dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
				perp2x=perp2x / dist *w;
				perp2y=perp2y / dist *w;
				a1=(-perpy+p1y)-(-perpy+p2y);
				b1=(-perpx+p2x)-(-perpx+p1x);
				c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
				a2=(-perp2y+p3y)-(-perp2y+p2y);
				b2=(-perp2x+p2x)-(-perp2x+p3x);
				c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
				denom=a1 *b2-a2 *b1;
				if (Math.abs(denom)< 0.1){
					denom+=10.1;
					result.push(p2x-perpx+this.x,p2y-perpy+this.y,r,g,b,p2x+perpx+this.x,p2y+perpy+this.y,r,g,b);
					continue ;
				}
				px=(b1 *c2-b2 *c1)/ denom;
				py=(a2 *c1-a1 *c2)/ denom;
				pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
				result.push(px+this.x,py+this.y,r,g,b,p2x-(px-p2x)+this.x,p2y-(py-p2y)+this.y,r,g,b);
			}
			p1x=points[points.length-4];
			p1y=points[points.length-3];
			p2x=points[points.length-2];
			p2y=points[points.length-1];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			result.push(p2x-perpx+this.x,p2y-perpy+this.y,r,g,b,p2x+perpx+this.x,p2y+perpy+this.y,r,g,b);
			var groupLen=indexCount;
			for (i=1;i < groupLen;i++){
				indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
			}
			return result;
		}

		//用于比如 扇形 不带两直线
		__proto.createLine=function(p,indices,lineWidth,len){
			var points=p.concat();
			var result=p;
			var color=this.borderColor;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			points.splice(0,5);
			var length=points.length / 5;
			var iStart=len,w=lineWidth / 2;
			var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
			var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
			var a1,b1,c1,a2,b2,c2;
			var denom,pdist,dist;
			p1x=points[0];
			p1y=points[1];
			p2x=points[5];
			p2y=points[6];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			result.push(p1x-perpx,p1y-perpy,r,g,b,p1x+perpx,p1y+perpy,r,g,b);
			for (var i=1;i < length-1;i++){
				p1x=points[(i-1)*5];
				p1y=points[(i-1)*5+1];
				p2x=points[(i)*5];
				p2y=points[(i)*5+1];
				p3x=points[(i+1)*5];
				p3y=points[(i+1)*5+1];
				perpx=-(p1y-p2y);
				perpy=p1x-p2x;
				dist=Math.sqrt(perpx *perpx+perpy *perpy);
				perpx=perpx / dist *w;
				perpy=perpy / dist *w;
				perp2x=-(p2y-p3y);
				perp2y=p2x-p3x;
				dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
				perp2x=perp2x / dist *w;
				perp2y=perp2y / dist *w;
				a1=(-perpy+p1y)-(-perpy+p2y);
				b1=(-perpx+p2x)-(-perpx+p1x);
				c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
				a2=(-perp2y+p3y)-(-perp2y+p2y);
				b2=(-perp2x+p2x)-(-perp2x+p3x);
				c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
				denom=a1 *b2-a2 *b1;
				if (Math.abs(denom)< 0.1){
					denom+=10.1;
					result.push(p2x-perpx,p2y-perpy,r,g,b,p2x+perpx,p2y+perpy,r,g,b);
					continue ;
				}
				px=(b1 *c2-b2 *c1)/ denom;
				py=(a2 *c1-a1 *c2)/ denom;
				pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
				result.push(px,py,r,g,b,p2x-(px-p2x),p2y-(py-p2y),r,g,b);
			}
			p1x=points[points.length-10];
			p1y=points[points.length-9];
			p2x=points[points.length-5];
			p2y=points[points.length-4];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			result.push(p2x-perpx,p2y-perpy,r,g,b,p2x+perpx,p2y+perpy,r,g,b);
			var groupLen=this.edges+1;
			for (i=1;i < groupLen;i++){
				indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
			}
			return result;
		}

		//闭合路径
		__proto.createLoopLine=function(p,indices,lineWidth,len,outVertex,outIndex){
			var points=p.concat();
			var result=outVertex ? outVertex :p;
			var color=this.borderColor;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			points.splice(0,5);
			var firstPoint=[points[0],points[1]];
			var lastPoint=[points[points.length-5],points[points.length-4]];
			var midPointX=lastPoint[0]+(firstPoint[0]-lastPoint[0])*0.5;
			var midPointY=lastPoint[1]+(firstPoint[1]-lastPoint[1])*0.5;
			points.unshift(midPointX,midPointY,0,0,0);
			points.push(midPointX,midPointY,0,0,0);
			var length=points.length / 5;
			var iStart=len,w=lineWidth / 2;
			var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
			var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
			var a1,b1,c1,a2,b2,c2;
			var denom,pdist,dist;
			p1x=points[0];
			p1y=points[1];
			p2x=points[5];
			p2y=points[6];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			result.push(p1x-perpx,p1y-perpy,r,g,b,p1x+perpx,p1y+perpy,r,g,b);
			for (var i=1;i < length-1;i++){
				p1x=points[(i-1)*5];
				p1y=points[(i-1)*5+1];
				p2x=points[(i)*5];
				p2y=points[(i)*5+1];
				p3x=points[(i+1)*5];
				p3y=points[(i+1)*5+1];
				perpx=-(p1y-p2y);
				perpy=p1x-p2x;
				dist=Math.sqrt(perpx *perpx+perpy *perpy);
				perpx=perpx / dist *w;
				perpy=perpy / dist *w;
				perp2x=-(p2y-p3y);
				perp2y=p2x-p3x;
				dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
				perp2x=perp2x / dist *w;
				perp2y=perp2y / dist *w;
				a1=(-perpy+p1y)-(-perpy+p2y);
				b1=(-perpx+p2x)-(-perpx+p1x);
				c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
				a2=(-perp2y+p3y)-(-perp2y+p2y);
				b2=(-perp2x+p2x)-(-perp2x+p3x);
				c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
				denom=a1 *b2-a2 *b1;
				if (Math.abs(denom)< 0.1){
					denom+=10.1;
					result.push(p2x-perpx,p2y-perpy,r,g,b,p2x+perpx,p2y+perpy,r,g,b);
					continue ;
				}
				px=(b1 *c2-b2 *c1)/ denom;
				py=(a2 *c1-a1 *c2)/ denom;
				pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
				result.push(px,py,r,g,b,p2x-(px-p2x),p2y-(py-p2y),r,g,b);
			}
			if (outIndex){
				indices=outIndex;
			};
			var groupLen=this.edges+1;
			for (i=1;i < groupLen;i++){
				indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
			}
			indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+1,iStart+1,iStart,iStart+(i-1)*2);
			return result;
		}

		return BasePoly;
	})()


	/**
	*...
	*@author River
	*/
	//class laya.webgl.submit.Submit
	var Submit=(function(){
		function Submit(renderType){
			//this._selfVb=null;
			//this._ib=null;
			//this._blendFn=null;
			//this._renderType=0;
			//this._vb=null;
			//this._startIdx=0;
			//this._numEle=0;
			//this.shaderValue=null;
			(renderType===void 0)&& (renderType=1);
			this._renderType=renderType;
		}

		__class(Submit,'laya.webgl.submit.Submit');
		var __proto=Submit.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.releaseRender=function(){
			var cache=Submit._cache;
			cache[cache._length++]=this;
			this.shaderValue.release();
			this._vb=null;
		}

		__proto.getRenderType=function(){
			return this._renderType;
		}

		__proto.renderSubmit=function(){
			if (this._numEle===0)return 1;
			var _tex=this.shaderValue.textureHost;
			if (_tex){
				var source=_tex.source;
				if (!_tex.bitmap || !source)
					return 1;
				this.shaderValue.texture=source;
			}
			this._vb.bind_upload(this._ib);
			var gl=WebGL.mainContext;
			this.shaderValue.upload();
			if (BlendMode.activeBlendFunction!==this._blendFn){
				gl.enable(0x0BE2);
				this._blendFn(gl);
				BlendMode.activeBlendFunction=this._blendFn;
			}
			Stat.drawCall++;
			Stat.trianglesFaces+=this._numEle / 3;
			gl.drawElements(0x0004,this._numEle,0x1403,this._startIdx);
			return 1;
		}

		Submit.__init__=function(){
			var s=Submit.RENDERBASE=new Submit(-1);
			s.shaderValue=new Value2D(0,0);
			s.shaderValue.ALPHA=-1234;
		}

		Submit.create=function(context,ib,vb,pos,sv){
			var o=Submit._cache._length ? Submit._cache[--Submit._cache._length] :new Submit();
			if (vb==null){
				vb=o._selfVb || (o._selfVb=VertexBuffer2D.create(-1));
				vb.clear();
				pos=0;
			}
			o._ib=ib;
			o._vb=vb;
			o._startIdx=pos *CONST3D2D.BYTES_PIDX;
			o._numEle=0;
			var blendType=context._nBlendType;
			o._blendFn=context._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
			o.shaderValue=sv;
			o.shaderValue.setValue(context._shader2D);
			var filters=context._shader2D.filters;
			filters && o.shaderValue.setFilters(filters);
			return o;
		}

		Submit.createShape=function(ctx,ib,vb,numEle,offset,sv){
			var o=(!Submit._cache._length)? (new Submit()):Submit._cache[--Submit._cache._length];
			o._ib=ib;
			o._vb=vb;
			o._numEle=numEle;
			o._startIdx=offset;
			o.shaderValue=sv;
			o.shaderValue.setValue(ctx._shader2D);
			var blendType=ctx._nBlendType;
			o._blendFn=ctx._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
			return o;
		}

		Submit.TYPE_2D=1;
		Submit.TYPE_CANVAS=3;
		Submit.TYPE_CMDSETRT=4;
		Submit.TYPE_CUSTOM=5;
		Submit.TYPE_BLURRT=6;
		Submit.TYPE_CMDDESTORYPRERT=7;
		Submit.TYPE_DISABLESTENCIL=8;
		Submit.TYPE_OTHERIBVB=9;
		Submit.TYPE_PRIMITIVE=10;
		Submit.TYPE_RT=11;
		Submit.TYPE_BLUR_RT=12;
		Submit.TYPE_TARGET=13;
		Submit.TYPE_CHANGE_VALUE=14;
		Submit.TYPE_SHAPE=15;
		Submit.TYPE_TEXTURE=16;
		Submit.RENDERBASE=null
		Submit._cache=(Submit._cache=[],Submit._cache._length=0,Submit._cache);
		return Submit;
	})()


	//class laya.webgl.submit.SubmitCMD
	var SubmitCMD=(function(){
		function SubmitCMD(){
			this.fun=null;
			this.args=null;
		}

		__class(SubmitCMD,'laya.webgl.submit.SubmitCMD');
		var __proto=SubmitCMD.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.renderSubmit=function(){
			this.fun.apply(null,this.args);
			return 1;
		}

		__proto.getRenderType=function(){
			return 0;
		}

		__proto.releaseRender=function(){
			var cache=SubmitCMD._cache;
			cache[cache._length++]=this;
		}

		SubmitCMD.create=function(args,fun){
			var o=SubmitCMD._cache._length?SubmitCMD._cache[--SubmitCMD._cache._length]:new SubmitCMD();
			o.fun=fun;
			o.args=args;
			return o;
		}

		SubmitCMD._cache=(SubmitCMD._cache=[],SubmitCMD._cache._length=0,SubmitCMD._cache);
		return SubmitCMD;
	})()


	//class laya.webgl.submit.SubmitCMDScope
	var SubmitCMDScope=(function(){
		function SubmitCMDScope(){
			this.variables={};
		}

		__class(SubmitCMDScope,'laya.webgl.submit.SubmitCMDScope');
		var __proto=SubmitCMDScope.prototype;
		__proto.getValue=function(name){
			return this.variables[name];
		}

		__proto.addValue=function(name,value){
			return this.variables[name]=value;
		}

		__proto.setValue=function(name,value){
			if(this.variables.hasOwnProperty(name)){
				return this.variables[name]=value;
			}
			return null;
		}

		__proto.clear=function(){
			for(var key in this.variables){
				delete this.variables[key];
			}
		}

		__proto.recycle=function(){
			this.clear();
			SubmitCMDScope.POOL.push(this);
		}

		SubmitCMDScope.create=function(){
			var scope=SubmitCMDScope.POOL.pop();
			scope||(scope=new SubmitCMDScope());
			return scope;
		}

		SubmitCMDScope.POOL=[];
		return SubmitCMDScope;
	})()


	/**
	*...
	*@author wk
	*/
	//class laya.webgl.submit.SubmitOtherIBVB
	var SubmitOtherIBVB=(function(){
		function SubmitOtherIBVB(){
			this.offset=0;
			//this._vb=null;
			//this._ib=null;
			//this._blendFn=null;
			//this._mat=null;
			//this._shader=null;
			//this._shaderValue=null;
			//this._numEle=0;
			this.startIndex=0;
			;
			this._mat=Matrix.create();
		}

		__class(SubmitOtherIBVB,'laya.webgl.submit.SubmitOtherIBVB');
		var __proto=SubmitOtherIBVB.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.releaseRender=function(){
			var cache=SubmitOtherIBVB._cache;
			cache[cache._length++]=this;
		}

		__proto.getRenderType=function(){
			return 9;
		}

		__proto.renderSubmit=function(){
			var _tex=this._shaderValue.textureHost;
			if (_tex){
				var source=_tex.source;
				if (!_tex.bitmap || !source)
					return 1;
				this._shaderValue.texture=source;
			}
			this._vb.bind_upload(this._ib);
			var w=RenderState2D.worldMatrix4;
			var wmat=Matrix.TEMP;
			Matrix.mulPre(this._mat,w[0],w[1],w[4],w[5],w[12],w[13],wmat);
			var tmp=RenderState2D.worldMatrix4=SubmitOtherIBVB.tempMatrix4;
			tmp[0]=wmat.a;
			tmp[1]=wmat.b;
			tmp[4]=wmat.c;
			tmp[5]=wmat.d;
			tmp[12]=wmat.tx;
			tmp[13]=wmat.ty;
			this._shader._offset=this.offset;
			this._shaderValue.refresh();
			this._shader.upload(this._shaderValue);
			this._shader._offset=0;
			var gl=WebGL.mainContext;
			if (BlendMode.activeBlendFunction!==this._blendFn){
				gl.enable(0x0BE2);
				this._blendFn(gl);
				BlendMode.activeBlendFunction=this._blendFn;
			}
			Stat.drawCall++;
			Stat.trianglesFaces+=this._numEle/3;
			gl.drawElements(0x0004,this._numEle,0x1403,this.startIndex);
			RenderState2D.worldMatrix4=w;
			Shader.activeShader=null;
			return 1;
		}

		SubmitOtherIBVB.create=function(context,vb,ib,numElement,shader,shaderValue,startIndex,offset){
			var o=(!SubmitOtherIBVB._cache._length)?(new SubmitOtherIBVB()):SubmitOtherIBVB._cache[--SubmitOtherIBVB._cache._length];
			o._ib=ib;
			o._vb=vb;
			o._numEle=numElement;
			o._shader=shader;
			o._shaderValue=shaderValue;
			var blendType=context._nBlendType;
			o._blendFn=context._targets?BlendMode.targetFns[blendType]:BlendMode.fns[blendType];
			o.offset=0;
			o.startIndex=offset / (CONST3D2D.BYTES_PE *vb.vertexStride)*1.5;
			o.startIndex *=CONST3D2D.BYTES_PIDX;
			return o;
		}

		SubmitOtherIBVB._cache=(SubmitOtherIBVB._cache=[],SubmitOtherIBVB._cache._length=0,SubmitOtherIBVB._cache);
		SubmitOtherIBVB.tempMatrix4=[
		1,0,0,0,
		0,1,0,0,
		0,0,1,0,
		0,0,0,1,];
		return SubmitOtherIBVB;
	})()


	//class laya.webgl.submit.SubmitScissor
	var SubmitScissor=(function(){
		function SubmitScissor(){
			this.submitIndex=0;
			this.submitLength=0;
			this.context=null;
			this.clipRect=new Rectangle();
			this.screenRect=new Rectangle();
		}

		__class(SubmitScissor,'laya.webgl.submit.SubmitScissor');
		var __proto=SubmitScissor.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto._scissor=function(x,y,w,h){
			var m=RenderState2D.worldMatrix4;
			var a=m[0],d=m[5],tx=m[12],ty=m[13];
			x=x *a+tx;
			y=y *d+ty;
			w *=a;
			h *=d;
			if (w < 1 || h < 1){
				return false;
			};
			var r=x+w;
			var b=y+h;
			x < 0 && (x=0,w=r-x);
			y < 0 && (y=0,h=b-y);
			var screen=RenderState2D.worldClipRect;
			x=Math.max(x,screen.x);
			y=Math.max(y,screen.y);
			w=Math.min(r,screen.right)-x;
			h=Math.min(b,screen.bottom)-y;
			if (w < 1 || h < 1){
				return false;
			};
			var worldScissorTest=RenderState2D.worldScissorTest;
			this.screenRect.copyFrom(screen);
			screen.x=x;
			screen.y=y;
			screen.width=w;
			screen.height=h;
			RenderState2D.worldScissorTest=true;
			y=RenderState2D.height-y-h;
			WebGL.mainContext.scissor(x,y,w,h);
			WebGL.mainContext.enable(0x0C11);
			this.context.submitElement(this.submitIndex,this.submitIndex+this.submitLength);
			if (worldScissorTest){
				y=RenderState2D.height-this.screenRect.y-this.screenRect.height;
				WebGL.mainContext.scissor(this.screenRect.x,y,this.screenRect.width,this.screenRect.height);
				WebGL.mainContext.enable(0x0C11);
			}
			else{
				WebGL.mainContext.disable(0x0C11);
				RenderState2D.worldScissorTest=false;
			}
			screen.copyFrom(this.screenRect);
			return true;
		}

		__proto._scissorWithTagart=function(x,y,w,h){
			if (w < 1 || h < 1){
				return false;
			};
			var r=x+w;
			var b=y+h;
			x < 0 && (x=0,w=r-x);
			y < 0 && (y=0,h=b-y);
			var screen=RenderState2D.worldClipRect;
			x=Math.max(x,screen.x);
			y=Math.max(y,screen.y);
			w=Math.min(r,screen.right)-x;
			h=Math.min(b,screen.bottom)-y;
			if (w < 1 || h < 1){
				return false;
			};
			var worldScissorTest=RenderState2D.worldScissorTest;
			this.screenRect.copyFrom(screen);
			RenderState2D.worldScissorTest=true;
			screen.x=x;
			screen.y=y;
			screen.width=w;
			screen.height=h;
			y=RenderState2D.height-y-h;
			WebGL.mainContext.scissor(x,y,w,h);
			WebGL.mainContext.enable(0x0C11);
			this.context.submitElement(this.submitIndex,this.submitIndex+this.submitLength);
			if (worldScissorTest){
				y=RenderState2D.height-this.screenRect.y-this.screenRect.height;
				WebGL.mainContext.scissor(this.screenRect.x,y,this.screenRect.width,this.screenRect.height);
				WebGL.mainContext.enable(0x0C11);
			}
			else{
				WebGL.mainContext.disable(0x0C11);
				RenderState2D.worldScissorTest=false;
			}
			screen.copyFrom(this.screenRect);
			return true;
		}

		__proto.renderSubmit=function(){
			this.submitLength=Math.min(this.context._submits._length-1,this.submitLength);
			if (this.submitLength < 1 || this.clipRect.width < 1 || this.clipRect.height < 1)
				return this.submitLength+1;
			if (this.context._targets)
				this._scissorWithTagart(this.clipRect.x,this.clipRect.y,this.clipRect.width,this.clipRect.height);
			else this._scissor(this.clipRect.x,this.clipRect.y,this.clipRect.width,this.clipRect.height);
			return this.submitLength+1;
		}

		__proto.getRenderType=function(){
			return 0;
		}

		__proto.releaseRender=function(){
			var cache=SubmitScissor._cache;
			cache[cache._length++]=this;
			this.context=null;
		}

		SubmitScissor.create=function(context){
			var o=SubmitScissor._cache._length?SubmitScissor._cache[--SubmitScissor._cache._length]:new SubmitScissor();
			o.context=context;
			return o;
		}

		SubmitScissor._cache=(SubmitScissor._cache=[],SubmitScissor._cache._length=0,SubmitScissor._cache);
		return SubmitScissor;
	})()


	//class laya.webgl.submit.SubmitStencil
	var SubmitStencil=(function(){
		function SubmitStencil(){
			this.step=0;
			this.blendMode=null;
			this.level=0;
		}

		__class(SubmitStencil,'laya.webgl.submit.SubmitStencil');
		var __proto=SubmitStencil.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.renderSubmit=function(){
			switch(this.step){
				case 1:
					this.do1();
					break ;
				case 2:
					this.do2();
					break ;
				case 3:
					this.do3();
					break ;
				case 4:
					this.do4();
					break ;
				case 5:
					this.do5();
					break ;
				case 6:
					this.do6();
					break ;
				}
			return 1;
		}

		__proto.getRenderType=function(){
			return 0;
		}

		__proto.releaseRender=function(){
			var cache=SubmitStencil._cache;
			cache[cache._length++]=this;
		}

		__proto.do1=function(){
			var gl=WebGL.mainContext;
			gl.enable(0x0B90);
			gl.clear(0x00000400);
			gl.colorMask(false,false,false,false);
			gl.stencilFunc(0x0202,this.level,0xFF);
			gl.stencilOp(0x1E00,0x1E00,0x1E02);
		}

		//gl.stencilOp(WebGLContext.KEEP,WebGLContext.KEEP,WebGLContext.INVERT);//测试通过给模版缓冲 写入值 一开始是0 现在是 0xFF (模版缓冲中不知道是多少位的数据)
		__proto.do2=function(){
			var gl=WebGL.mainContext;
			gl.stencilFunc(0x0202,this.level+1,0xFF);
			gl.colorMask(true,true,true,true);
			gl.stencilOp(0x1E00,0x1E00,0x1E00);
		}

		__proto.do3=function(){
			var gl=WebGL.mainContext;
			gl.colorMask(true,true,true,true);
			gl.stencilOp(0x1E00,0x1E00,0x1E00);
			gl.clear(0x00000400);
			gl.disable(0x0B90);
		}

		__proto.do4=function(){
			var gl=WebGL.mainContext;
			gl.enable(0x0B90);
			gl.clear(0x00000400);
			gl.colorMask(false,false,false,false);
			gl.stencilFunc(0x0207,this.level,0xFF);
			gl.stencilOp(0x1E00,0x1E00,0x150A);
		}

		__proto.do5=function(){
			var gl=WebGL.mainContext;
			gl.stencilFunc(0x0202,0xff,0xFF);
			gl.colorMask(true,true,true,true);
			gl.stencilOp(0x1E00,0x1E00,0x1E00);
		}

		__proto.do6=function(){
			var gl=WebGL.mainContext;
			BlendMode.targetFns[BlendMode.TOINT[this.blendMode]](gl);
		}

		SubmitStencil.create=function(step){
			var o=SubmitStencil._cache._length?SubmitStencil._cache[--SubmitStencil._cache._length]:new SubmitStencil();
			o.step=step;
			return o;
		}

		SubmitStencil._cache=(SubmitStencil._cache=[],SubmitStencil._cache._length=0,SubmitStencil._cache);
		return SubmitStencil;
	})()


	//class laya.webgl.submit.SubmitTarget
	var SubmitTarget=(function(){
		function SubmitTarget(){
			this._renderType=0;
			this._vb=null;
			this._ib=null;
			this._startIdx=0;
			this._numEle=0;
			this.shaderValue=null;
			this.blendType=0;
			this.proName=null;
			this.scope=null;
		}

		__class(SubmitTarget,'laya.webgl.submit.SubmitTarget');
		var __proto=SubmitTarget.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		__proto.renderSubmit=function(){
			this._vb.bind_upload(this._ib);
			var target=this.scope.getValue(this.proName);
			if (target){
				this.shaderValue.texture=target.source;
				this.shaderValue.upload();
				this.blend();
				Stat.drawCall++;
				Stat.trianglesFaces+=this._numEle/3;
				WebGL.mainContext.drawElements(0x0004,this._numEle,0x1403,this._startIdx);
			}
			return 1;
		}

		__proto.blend=function(){
			if (BlendMode.activeBlendFunction!==BlendMode.fns[this.blendType]){
				var gl=WebGL.mainContext;
				gl.enable(0x0BE2);
				BlendMode.fns[this.blendType](gl);
				BlendMode.activeBlendFunction=BlendMode.fns[this.blendType];
			}
		}

		__proto.getRenderType=function(){
			return 0;
		}

		__proto.releaseRender=function(){
			var cache=SubmitTarget._cache;
			cache[cache._length++]=this;
		}

		SubmitTarget.create=function(context,ib,vb,pos,sv,proName){
			var o=SubmitTarget._cache._length?SubmitTarget._cache[--SubmitTarget._cache._length]:new SubmitTarget();
			o._ib=ib;
			o._vb=vb;
			o.proName=proName;
			o._startIdx=pos *CONST3D2D.BYTES_PIDX;
			o._numEle=0;
			o.blendType=context._nBlendType;
			o.shaderValue=sv;
			o.shaderValue.setValue(context._shader2D);
			return o;
		}

		SubmitTarget._cache=(SubmitTarget._cache=[],SubmitTarget._cache._length=0,SubmitTarget._cache);
		return SubmitTarget;
	})()


	/**
	*...特殊的字符，如泰文，必须重新实现这个类
	*@author rivetr
	*/
	//class laya.webgl.text.CharSegment
	var CharSegment=(function(){
		function CharSegment(){
			this._sourceStr=null;
		}

		__class(CharSegment,'laya.webgl.text.CharSegment');
		var __proto=CharSegment.prototype;
		Laya.imps(__proto,{"laya.webgl.text.ICharSegment":true})
		__proto.textToSpit=function(str){
			this._sourceStr=str;
		}

		__proto.getChar=function(i){
			return this._sourceStr.charAt(i);
		}

		__proto.getCharCode=function(i){
			return this._sourceStr.charCodeAt(i);
		}

		__proto.length=function(){
			return this._sourceStr.length;
		}

		return CharSegment;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.text.DrawText
	var DrawText=(function(){
		var CharValue;
		function DrawText(){};
		__class(DrawText,'laya.webgl.text.DrawText');
		DrawText.__init__=function(){
			DrawText._charsTemp=new Array;
			DrawText._drawValue=new CharValue();
			DrawText._charSeg=new CharSegment();
		}

		DrawText.customCharSeg=function(charseg){
			DrawText._charSeg=charseg;
		}

		DrawText.getChar=function(char,id,drawValue){
			return DrawText._charsCache[id]=DrawTextChar.createOneChar(char,drawValue);
		}

		DrawText._drawSlow=function(save,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy){
			var drawValue=DrawText._drawValue.value(font,fillColor,borderColor,lineWidth,sx,sy);
			var i=0,n=0;
			var chars=DrawText._charsTemp;
			var width=0,oneChar,htmlWord,id=NaN;
			if (words){
				chars.length=words.length;
				for (i=0,n=words.length;i < n;i++){
					htmlWord=words[i];
					id=htmlWord.charNum+drawValue.txtID;
					chars[i]=oneChar=DrawText._charsCache[id] || DrawText.getChar(htmlWord.char,id,drawValue);
					oneChar.active();
				}
				}else {
				if ((txt instanceof laya.utils.WordText ))
					DrawText._charSeg.textToSpit((txt).toString());
				else
				DrawText._charSeg.textToSpit(txt);
				var len=/*if err,please use iflash.method.xmlLength()*/DrawText._charSeg.length();
				chars.length=len;
				for (i=0,n=len;i < n;i++){
					id=DrawText._charSeg.getCharCode(i)+drawValue.txtID;
					chars[i]=oneChar=DrawText._charsCache[id] || DrawText.getChar(DrawText._charSeg.getChar(i),id,drawValue);
					oneChar.active();
					width+=oneChar.width;
				}
			};
			var dx=0;
			if (textAlign!==null && textAlign!=="left")
				dx=-(textAlign=="center" ? (width / 2):width);
			var uv,bdSz=NaN,texture,value,saveLength=0;
			if (words){
				for (i=0,n=chars.length;i < n;i++){
					oneChar=chars[i];
					if (!oneChar.isSpace){
						htmlWord=words[i];
						bdSz=oneChar.borderSize;
						texture=oneChar.texture;
						ctx._drawText(texture,x+dx+htmlWord.x *sx-bdSz,y+htmlWord.y *sy-bdSz,texture.width,texture.height,curMat,0,0,0,0);
					}
				}
				}else {
				for (i=0,n=chars.length;i < n;i++){
					oneChar=chars[i];
					if (!oneChar.isSpace){
						bdSz=oneChar.borderSize;
						texture=oneChar.texture;
						ctx._drawText(texture,x+dx-bdSz,y-bdSz,texture.width,texture.height,curMat,0,0,0,0);
						save && (value=save[saveLength++],value || (value=save[saveLength-1]=[]),value[0]=texture,value[1]=dx-bdSz,value[2]=-bdSz);
					}
					dx+=oneChar.width;
				}
				save && (save.length=saveLength);
			}
		}

		DrawText._drawFast=function(save,ctx,curMat,x,y){
			var texture,value;
			for (var i=0,n=save.length;i < n;i++){
				value=save[i];
				texture=value[0];
				texture.active();
				ctx._drawText(texture,x+value[1],y+value[2],texture.width,texture.height,curMat,0,0,0,0);
			}
		}

		DrawText.drawText=function(ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y){
			if ((txt && txt.length===0)|| (words && words.length===0))
				return;
			var sx=curMat.a,sy=curMat.d;
			(curMat.b!==0 || curMat.c!==0)&& (sx=sy=1);
			var scale=sx!==1 || sy!==1;
			if (scale && Laya.stage.transform){
				var t=Laya.stage.transform;
				scale=t.a===sx && t.d===sy;
			}else scale=false;
			if (scale){
				curMat=curMat.copyTo(WebGLContext2D._tmpMatrix);
				curMat.scale(1 / sx,1 / sy);
				curMat._checkTransform();
				x *=sx;
				y *=sy;
			}else sx=sy=1;
			if (words){
				DrawText._drawSlow(null,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy);
				}else {
				if (txt.toUpperCase===null){
					var idNum=sx+sy*100000;
					var myCache=txt;
					if (!myCache.changed && myCache.id===idNum){
						DrawText._drawFast(myCache.save,ctx,curMat,x,y);
					}
					else{
						myCache.id=idNum;
						myCache.changed=false;
						DrawText._drawSlow(myCache.save,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy);
					}
					return;
				};
				var id=txt+font.toString()+fillColor+borderColor+lineWidth+sx+sy+textAlign;
				var cache=DrawText._textsCache[id];
				if (cache){
					DrawText._drawFast(cache,ctx,curMat,x,y);
					}else {
					DrawText._textsCache.__length || (DrawText._textsCache.__length=0);
					if (DrawText._textsCache.__length >Config.WebGLTextCacheCount){
						DrawText._textsCache={};
						DrawText._textsCache.__length=0;
						DrawText._curPoolIndex=0;
					}
					DrawText._textCachesPool[DrawText._curPoolIndex] ? (cache=DrawText._textsCache[id]=DrawText._textCachesPool[DrawText._curPoolIndex],cache.length=0):(DrawText._textCachesPool[DrawText._curPoolIndex]=cache=DrawText._textsCache[id]=[]);
					DrawText._textsCache.__length++
					DrawText._curPoolIndex++;
					DrawText._drawSlow(cache,ctx,txt,words,curMat,font,textAlign,fillColor,borderColor,lineWidth,x,y,sx,sy);
				}
			}
		}

		DrawText._charsTemp=null
		DrawText._textCachesPool=[];
		DrawText._curPoolIndex=0;
		DrawText._charsCache={};
		DrawText._textsCache={};
		DrawText._drawValue=null
		DrawText.d=[];
		DrawText._charSeg=null;
		DrawText.__init$=function(){
			//class CharValue
			CharValue=(function(){
				function CharValue(){
					//this.txtID=NaN;
					//this.font=null;
					//this.fillColor=null;
					//this.borderColor=null;
					//this.lineWidth=0;
					//this.scaleX=NaN;
					//this.scaleY=NaN;
				}
				__class(CharValue,'');
				var __proto=CharValue.prototype;
				__proto.value=function(font,fillColor,borderColor,lineWidth,scaleX,scaleY){
					this.font=font;
					this.fillColor=fillColor;
					this.borderColor=borderColor;
					this.lineWidth=lineWidth;
					this.scaleX=scaleX;
					this.scaleY=scaleY;
					var key=font.toString()+scaleX+scaleY+lineWidth+fillColor+borderColor;
					this.txtID=CharValue._keymap[key];
					if (!this.txtID){
						this.txtID=(++CharValue._keymapCount)*0.0000001;
						CharValue._keymap[key]=this.txtID;
					}
					return this;
				}
				CharValue.clear=function(){
					CharValue._keymap={};
					CharValue._keymapCount=1;
				}
				CharValue._keymap={};
				CharValue._keymapCount=1;
				return CharValue;
			})()
		}

		return DrawText;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.text.DrawTextChar
	var DrawTextChar=(function(){
		function DrawTextChar(content,drawValue){
			//this.xs=NaN;
			//this.ys=NaN;
			//this.width=0;
			//this.height=0;
			//this.char=null;
			//this.fillColor=null;
			//this.borderColor=null;
			//this.borderSize=0;
			//this.font=null;
			//this.fontSize=0;
			//this.texture=null;
			//this.lineWidth=0;
			//this.UV=null;
			//this.isSpace=false;
			this.char=content;
			this.isSpace=content===' ';
			this.xs=drawValue.scaleX;
			this.ys=drawValue.scaleY;
			this.font=drawValue.font.toString();
			this.fontSize=drawValue.font.size;
			this.fillColor=drawValue.fillColor;
			this.borderColor=drawValue.borderColor;
			this.lineWidth=drawValue.lineWidth;
			var bIsConchApp=Render.isConchApp;
			if (bIsConchApp){
				var pCanvas=ConchTextCanvas;
				pCanvas._source=ConchTextCanvas;
				pCanvas._source.canvas=ConchTextCanvas;
				this.texture=new Texture(new WebGLCharImage(pCanvas,this));
			}
			else{
				this.texture=new Texture(new WebGLCharImage(Browser.canvas.source,this));
			}
		}

		__class(DrawTextChar,'laya.webgl.text.DrawTextChar');
		var __proto=DrawTextChar.prototype;
		__proto.active=function(){
			this.texture.active();
		}

		DrawTextChar.createOneChar=function(content,drawValue){
			var char=new DrawTextChar(content,drawValue);
			return char;
		}

		return DrawTextChar;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.text.FontInContext
	var FontInContext=(function(){
		function FontInContext(font){
			//this._text=null;
			//this._words=null;
			this._index=0;
			this._size=14;
			this._italic=-2;
			this.setFont(font || "14px Arial");
		}

		__class(FontInContext,'laya.webgl.text.FontInContext');
		var __proto=FontInContext.prototype;
		__proto.setFont=function(value){
			this._words=value.split(' ');
			for (var i=0,n=this._words.length;i < n;i++){
				if (this._words[i].indexOf('px')> 0){
					this._index=i;
					break ;
				}
			}
			this._size=parseInt(this._words[this._index]);
			this._text=null;
			this._italic=-2;
		}

		__proto.getItalic=function(){
			this._italic===-2 && (this._italic=this.hasType("italic"));
			return this._italic;
		}

		__proto.hasType=function(name){
			for (var i=0,n=this._words.length;i < n;i++)
			if (this._words[i]===name)return i;
			return-1;
		}

		__proto.removeType=function(name){
			for (var i=0,n=this._words.length;i < n;i++)
			if (this._words[i]===name){
				this._words.splice(i,1);
				if (this._index > i)this._index--;
				break ;
			}
			this._text=null;
			this._italic=-2;
		}

		__proto.copyTo=function(dec){
			dec._text=this._text;
			dec._size=this._size;
			dec._index=this._index;
			dec._words=this._words.slice();
			dec._italic=-2;
			return dec;
		}

		__proto.toString=function(){
			return this._text?this._text:(this._text=this._words.join(' '));
		}

		__getset(0,__proto,'size',function(){
			return this._size;
			},function(value){
			this._size=value;
			this._words[this._index]=value+"px";
			this._text=null;
		});

		FontInContext.create=function(font){
			var r=FontInContext._cache[font];
			if (r)return r;
			r=FontInContext._cache[font]=new FontInContext(font);
			return r;
		}

		FontInContext.EMPTY=new FontInContext();
		FontInContext._cache={};
		return FontInContext;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.utils.CONST3D2D
	var CONST3D2D=(function(){
		function CONST3D2D(){};
		__class(CONST3D2D,'laya.webgl.utils.CONST3D2D');
		CONST3D2D.defaultMatrix4=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
		CONST3D2D.defaultMinusYMatrix4=[1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1];
		CONST3D2D.uniformMatrix3=[1,0,0,0,0,1,0,0,0,0,1,0];
		CONST3D2D._TMPARRAY=[];
		CONST3D2D._OFFSETX=0;
		CONST3D2D._OFFSETY=0;
		__static(CONST3D2D,
		['BYTES_PE',function(){return this.BYTES_PE=Float32Array.BYTES_PER_ELEMENT;},'BYTES_PIDX',function(){return this.BYTES_PIDX=Uint16Array.BYTES_PER_ELEMENT;}
		]);
		return CONST3D2D;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.utils.GlUtils
	var GlUtils=(function(){
		function GlUtils(){};
		__class(GlUtils,'laya.webgl.utils.GlUtils');
		GlUtils.make2DProjection=function(width,height,depth){
			return [2.0 / width,0,0,0,0,-2.0 / height,0,0,0,0,2.0 / depth,0,-1,1,0,1,];
		}

		GlUtils.fillIBQuadrangle=function(buffer,count){
			if (count > 65535 / 4){
				throw Error("IBQuadrangle count:"+count+" must<:"+Math.floor(65535 / 4));
				return false;
			}
			count=Math.floor(count);
			buffer._resizeBuffer((count+1)*6 *2,false);
			buffer.byteLength=buffer.bufferLength;
			var bufferData=buffer.getUint16Array();
			var idx=0;
			for (var i=0;i < count;i++){
				bufferData[idx++]=i *4;
				bufferData[idx++]=i *4+2;
				bufferData[idx++]=i *4+1;
				bufferData[idx++]=i *4;
				bufferData[idx++]=i *4+3;
				bufferData[idx++]=i *4+2;
			}
			buffer.setNeedUpload();
			return true;
		}

		GlUtils.expandIBQuadrangle=function(buffer,count){
			buffer.bufferLength >=(count *6 *2)|| GlUtils.fillIBQuadrangle(buffer,count);
		}

		GlUtils.mathCeilPowerOfTwo=function(value){
			value--;
			value |=value >> 1;
			value |=value >> 2;
			value |=value >> 4;
			value |=value >> 8;
			value |=value >> 16;
			value++;
			return value;
		}

		GlUtils.fillQuadrangleImgVb=function(vb,x,y,point4,uv,m,_x,_y){
			'use strict';
			var vpos=(vb._byteLength >> 2)+16;
			vb.byteLength=(vpos << 2);
			var vbdata=vb.getFloat32Array();
			vpos-=16;
			vbdata[vpos+2]=uv[0];
			vbdata[vpos+3]=uv[1];
			vbdata[vpos+6]=uv[2];
			vbdata[vpos+7]=uv[3];
			vbdata[vpos+10]=uv[4];
			vbdata[vpos+11]=uv[5];
			vbdata[vpos+14]=uv[6];
			vbdata[vpos+15]=uv[7];
			var a=m.a,b=m.b,c=m.c,d=m.d;
			if (a!==1 || b!==0 || c!==0 || d!==1){
				m.bTransform=true;
				var tx=m.tx+_x,ty=m.ty+_y;
				vbdata[vpos]=(point4[0]+x)*a+(point4[1]+y)*c+tx;
				vbdata[vpos+1]=(point4[0]+x)*b+(point4[1]+y)*d+ty;
				vbdata[vpos+4]=(point4[2]+x)*a+(point4[3]+y)*c+tx;
				vbdata[vpos+5]=(point4[2]+x)*b+(point4[3]+y)*d+ty;
				vbdata[vpos+8]=(point4[4]+x)*a+(point4[5]+y)*c+tx;
				vbdata[vpos+9]=(point4[4]+x)*b+(point4[5]+y)*d+ty;
				vbdata[vpos+12]=(point4[6]+x)*a+(point4[7]+y)*c+tx;
				vbdata[vpos+13]=(point4[6]+x)*b+(point4[7]+y)*d+ty;
				}else {
				m.bTransform=false;
				x+=m.tx+_x;
				y+=m.ty+_y;
				vbdata[vpos]=x+point4[0];
				vbdata[vpos+1]=y+point4[1];
				vbdata[vpos+4]=x+point4[2];
				vbdata[vpos+5]=y+point4[3];
				vbdata[vpos+8]=x+point4[4];
				vbdata[vpos+9]=y+point4[5];
				vbdata[vpos+12]=x+point4[6];
				vbdata[vpos+13]=y+point4[7];
			}
			vb._upload=true;
			return true;
		}

		GlUtils.fillTranglesVB=function(vb,x,y,points,m,_x,_y){
			'use strict';
			var vpos=(vb._byteLength >> 2)+points.length;
			vb.byteLength=(vpos << 2);
			var vbdata=vb.getFloat32Array();
			vpos-=points.length;
			var len=points.length;
			var a=m.a,b=m.b,c=m.c,d=m.d;
			for (var i=0;i < len;i+=4){
				vbdata[vpos+i+2]=points[i+2];
				vbdata[vpos+i+3]=points[i+3];
				if (a!==1 || b!==0 || c!==0 || d!==1){
					m.bTransform=true;
					var tx=m.tx+_x,ty=m.ty+_y;
					vbdata[vpos+i]=(points[i]+x)*a+(points[i+1]+y)*c+tx;
					vbdata[vpos+i+1]=(points[i]+x)*b+(points[i+1]+y)*d+ty;
					}else {
					m.bTransform=false;
					x+=m.tx+_x;
					y+=m.ty+_y;
					vbdata[vpos+i]=x+points[i];
					vbdata[vpos+i+1]=y+points[i+1];
				}
			}
			vb._upload=true;
			return true;
		}

		GlUtils.fillRectImgVb=function(vb,clip,x,y,width,height,uv,m,_x,_y,dx,dy,round){
			(round===void 0)&& (round=false);
			'use strict';
			var mType=1;
			var toBx,toBy,toEx,toEy;
			var cBx,cBy,cEx,cEy;
			var w0,h0,tx,ty;
			var finalX,finalY,offsetX,offsetY;
			var a=m.a,b=m.b,c=m.c,d=m.d;
			var useClip=false;
			if (a!==1 || b!==0 || c!==0 || d!==1){
				m.bTransform=true;
				if (b===0 && c===0){
					mType=useClip ? 30 :23;
					w0=width+x,h0=height+y;
					tx=m.tx+_x,ty=m.ty+_y;
					toBx=a *x+tx;
					toEx=a *w0+tx;
					toBy=d *y+ty;
					toEy=d *h0+ty;
				}
				}else {
				mType=useClip ? 30 :23;
				m.bTransform=false;
				toBx=x+m.tx+_x;
				toEx=toBx+width;
				toBy=y+m.ty+_y;
				toEy=toBy+height;
			}
			if (useClip){
				cBx=clip.x,cBy=clip.y,cEx=clip.width+cBx,cEy=clip.height+cBy;
			}
			if (mType!==1 && (toBx >=cEx || toBy >=cEy || toEx <=cBx || toEy <=cBy))
				return false;
			var vpos=(vb._byteLength >> 2)+16;
			vb.byteLength=(vpos << 2);
			var vbdata=vb.getFloat32Array();
			vpos-=16;
			vbdata[vpos+2]=uv[0];
			vbdata[vpos+3]=uv[1];
			vbdata[vpos+6]=uv[2];
			vbdata[vpos+7]=uv[3];
			vbdata[vpos+10]=uv[4];
			vbdata[vpos+11]=uv[5];
			vbdata[vpos+14]=uv[6];
			vbdata[vpos+15]=uv[7];
			switch (mType){
				case 1:
					tx=m.tx+_x,ty=m.ty+_y;
					w0=width+x,h0=height+y;
					var w1=x,h1=y;
					var aw1=a *w1,ch1=c *h1,dh1=d *h1,bw1=b *w1;
					var aw0=a *w0,ch0=c *h0,dh0=d *h0,bw0=b *w0;
					if (round){
						finalX=aw1+ch1+tx;
						offsetX=Math.round(finalX)-finalX;
						finalY=dh1+bw1+ty;
						offsetY=Math.round(finalY)-finalY;
						vbdata[vpos]=finalX+offsetX;
						vbdata[vpos+1]=finalY+offsetY;
						vbdata[vpos+4]=aw0+ch1+tx+offsetX;
						vbdata[vpos+5]=dh1+bw0+ty+offsetY;
						vbdata[vpos+8]=aw0+ch0+tx+offsetX;
						vbdata[vpos+9]=dh0+bw0+ty+offsetY;
						vbdata[vpos+12]=aw1+ch0+tx+offsetX;
						vbdata[vpos+13]=dh0+bw1+ty+offsetY;
						}else {
						vbdata[vpos]=aw1+ch1+tx;
						vbdata[vpos+1]=dh1+bw1+ty;
						vbdata[vpos+4]=aw0+ch1+tx;
						vbdata[vpos+5]=dh1+bw0+ty;
						vbdata[vpos+8]=aw0+ch0+tx;
						vbdata[vpos+9]=dh0+bw0+ty;
						vbdata[vpos+12]=aw1+ch0+tx;
						vbdata[vpos+13]=dh0+bw1+ty;
					}
					break ;
				case 23:
					if (round){
						finalX=toBx+dx;
						offsetX=Math.round(finalX)-finalX;
						finalY=toBy;
						offsetY=Math.round(finalY)-finalY;
						vbdata[vpos]=finalX+offsetX;
						vbdata[vpos+1]=finalY+offsetY;
						vbdata[vpos+4]=toEx+dx+offsetX;
						vbdata[vpos+5]=toBy+offsetY;
						vbdata[vpos+8]=toEx+offsetX;
						vbdata[vpos+9]=toEy+offsetY;
						vbdata[vpos+12]=toBx+offsetX;
						vbdata[vpos+13]=toEy+offsetY;
						}else {
						vbdata[vpos]=toBx+dx;
						vbdata[vpos+1]=toBy;
						vbdata[vpos+4]=toEx+dx;
						vbdata[vpos+5]=toBy;
						vbdata[vpos+8]=toEx;
						vbdata[vpos+9]=toEy;
						vbdata[vpos+12]=toBx;
						vbdata[vpos+13]=toEy;
					}
					break ;
				case 30:
					if (toBx < cBx || toBy < cBy || toEx > cEx || toEy > cEy){
						var dcx=cBx-toBx,dcty=cBy-toBy,decr=toEx-cEx,decb=toEy-cEy;
						if (dcx > 0){
							toBx=cBx;
							vbdata[vpos+14]=vbdata[vpos+2]=vbdata[vpos+2]+dcx / (width *a)*(vbdata[vpos+6]-vbdata[vpos+2])
						}
						if (dcty > 0){
							toBy=cBy;
							vbdata[vpos+7]=vbdata[vpos+3]=vbdata[vpos+3]+dcty / (height *d)*(vbdata[vpos+11]-vbdata[vpos+7])
						}
						if (decr > 0){
							toEx=cEx;
							vbdata[vpos+6]=vbdata[vpos+10]=vbdata[vpos+6]-decr / (width *a)*(vbdata[vpos+6]-vbdata[vpos+2])
						}
						if (decb > 0){
							toEy=cEy;
							vbdata[vpos+11]=vbdata[vpos+15]=vbdata[vpos+15]-decb / (height *d)*(vbdata[vpos+11]-vbdata[vpos+7])
						}
					}
					if (round){
						finalX=toBx+dx;
						offsetX=Math.round(finalX)-finalX;
						finalY=toBy;
						offsetY=Math.round(finalY)-finalY;
						vbdata[vpos]=finalX+offsetX;
						vbdata[vpos+1]=finalY+offsetY;
						vbdata[vpos+4]=toEx+dx+offsetX;
						vbdata[vpos+5]=toBy+offsetY;
						vbdata[vpos+8]=toEx+offsetX;
						vbdata[vpos+9]=toEy+offsetY;
						vbdata[vpos+12]=toBx+offsetX;
						vbdata[vpos+13]=toEy+offsetY;
						}else {
						vbdata[vpos]=toBx+dx;
						vbdata[vpos+1]=toBy;
						vbdata[vpos+4]=toEx+dx;
						vbdata[vpos+5]=toBy;
						vbdata[vpos+8]=toEx;
						vbdata[vpos+9]=toEy;
						vbdata[vpos+12]=toBx;
						vbdata[vpos+13]=toEy;
					}
				}
			vb._upload=true;
			return true;
		}

		GlUtils.fillLineVb=function(vb,clip,fx,fy,tx,ty,width,mat){
			'use strict';
			var linew=width *.5;
			var data=GlUtils._fillLineArray;
			var perpx=-(fy-ty),perpy=fx-tx;
			var dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx /=dist,perpy /=dist,perpx *=linew,perpy *=linew;
			data[0]=fx-perpx,data[1]=fy-perpy,data[4]=fx+perpx,data[5]=fy+perpy,data[8]=tx+perpx,data[9]=ty+perpy,data[12]=tx-perpx,data[13]=ty-perpy;
			mat && mat.transformPointArray(data,data);
			var vpos=(vb._byteLength >> 2)+16;
			vb.byteLength=(vpos << 2);
			vb.insertData(data,vpos-16);
			return true;
		}

		GlUtils._fillLineArray=[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
		return GlUtils;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.utils.MatirxArray
	var MatirxArray=(function(){
		function MatirxArray(){}
		__class(MatirxArray,'laya.webgl.utils.MatirxArray');
		MatirxArray.ArrayMul=function(a,b,o){
			if (!a){
				MatirxArray.copyArray(b,o);
				return;
			}
			if (!b){
				MatirxArray.copyArray(a,o);
				return;
			};
			var ai0=NaN,ai1=NaN,ai2=NaN,ai3=NaN;
			for (var i=0;i < 4;i++){
				ai0=a[i];
				ai1=a[i+4];
				ai2=a[i+8];
				ai3=a[i+12];
				o[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
				o[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
				o[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
				o[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
			}
		}

		MatirxArray.copyArray=function(f,t){
			if (!f)return;
			if (!t)return;
			for (var i=0;i < f.length;i++){
				t[i]=f[i];
			}
		}

		return MatirxArray;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.utils.RenderState2D
	var RenderState2D=(function(){
		function RenderState2D(){};
		__class(RenderState2D,'laya.webgl.utils.RenderState2D');
		RenderState2D.getMatrArray=function(){
			return [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
		}

		RenderState2D.mat2MatArray=function(mat,matArray){
			var m=mat;
			var m4=matArray;
			m4[0]=m.a;
			m4[1]=m.b;
			m4[4]=m.c;
			m4[5]=m.d;
			m4[12]=m.tx;
			m4[13]=m.ty;
			return matArray;
		}

		RenderState2D.restoreTempArray=function(){
			RenderState2D.TEMPMAT4_ARRAY[0]=1;
			RenderState2D.TEMPMAT4_ARRAY[1]=0;
			RenderState2D.TEMPMAT4_ARRAY[4]=0;
			RenderState2D.TEMPMAT4_ARRAY[5]=1;
			RenderState2D.TEMPMAT4_ARRAY[12]=0;
			RenderState2D.TEMPMAT4_ARRAY[13]=0;
		}

		RenderState2D.clear=function(){
			RenderState2D.worldScissorTest=false;
			RenderState2D.worldShaderDefines=null;
			RenderState2D.worldFilters=null;
			RenderState2D.worldAlpha=1;
			RenderState2D.worldClipRect.x=RenderState2D.worldClipRect.y=0;
			RenderState2D.worldClipRect.width=RenderState2D.width;
			RenderState2D.worldClipRect.height=RenderState2D.height;
			RenderState2D.curRenderTarget=null;
		}

		RenderState2D._MAXSIZE=99999999;
		RenderState2D.TEMPMAT4_ARRAY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
		RenderState2D.worldMatrix4=RenderState2D.TEMPMAT4_ARRAY;
		RenderState2D.worldAlpha=1.0;
		RenderState2D.worldScissorTest=false;
		RenderState2D.worldFilters=null
		RenderState2D.worldShaderDefines=null
		RenderState2D.worldClipRect=new Rectangle(0,0,99999999,99999999);
		RenderState2D.curRenderTarget=null
		RenderState2D.width=0;
		RenderState2D.height=0;
		__static(RenderState2D,
		['worldMatrix',function(){return this.worldMatrix=new Matrix();}
		]);
		return RenderState2D;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.utils.ShaderCompile
	var ShaderCompile=(function(){
		var ShaderScriptBlock;
		function ShaderCompile(name,vs,ps,nameMap,includeFiles){
			//this._VS=null;
			//this._PS=null;
			//this._VSTXT=null;
			//this._PSTXT=null;
			//this._nameMap=null;
			this._VSTXT=vs;
			this._PSTXT=ps;
			function split (str){
				var words=str.split(' ');
				var out=[];
				for (var i=0;i < words.length;i++)
				words[i].length > 0 && out.push(words[i]);
				return out;
			}
			function c (script){
				var i=0,n=0,ofs=0,words,condition;
				var top=new ShaderScriptBlock(0,null,null,null);
				var parent=top;
				var lines=script.split('\n');
				for (i=0,n=lines.length;i < n;i++){
					var line=lines[i];
					if (line.indexOf("#ifdef")>=0){
						words=split(line);
						parent=new ShaderScriptBlock(1,words[1],"",parent);
						continue ;
					}
					if (line.indexOf("#else")>=0){
						condition=parent.condition;
						parent=new ShaderScriptBlock(2,null,"",parent.parent);
						parent.condition=condition;
						continue ;
					}
					if (line.indexOf("#endif")>=0){
						parent=parent.parent;
						continue ;
					}
					if (line.indexOf("#include")>=0){
						words=split(line);
						var fname=words[1];
						var chr=fname.charAt(0);
						if (chr==='"' || chr==="'"){
							fname=fname.substr(1,fname.length-2);
							ofs=fname.lastIndexOf(chr);
							if (ofs > 0)fname=fname.substr(0,ofs);
						}
						ofs=words[0].indexOf('?');
						var str=ofs > 0?words[0].substr(ofs+1):words[0];
						new ShaderScriptBlock(1,str,includeFiles[fname],parent);
						continue ;
					}
					if (parent.childs.length > 0 && parent.childs[parent.childs.length-1].type===0){
						parent.childs[parent.childs.length-1].text+="\n"+line;
					}
					else new ShaderScriptBlock(0,null,line,parent);
				}
				return top;
			}
			this._VS=c(vs);
			this._PS=c(ps);
			this._nameMap=nameMap;
		}

		__class(ShaderCompile,'laya.webgl.utils.ShaderCompile');
		var __proto=ShaderCompile.prototype;
		__proto.createShader=function(define,shaderName,createShader){
			var defMap={};
			var defineStr="";
			if (define){
				for (var i in define){
					defineStr+="#define "+i+"\n";
					defMap[i]=true;
				}
			};
			var vs=this._VS.toscript(defMap,[]);
			var ps=this._PS.toscript(defMap,[]);
			return (createShader || Shader.create)(defineStr+vs.join('\n'),defineStr+ps.join('\n'),shaderName,this._nameMap);
		}

		ShaderCompile.IFDEF_NO=0;
		ShaderCompile.IFDEF_YES=1;
		ShaderCompile.IFDEF_ELSE=2;
		ShaderCompile.__init$=function(){
			//class ShaderScriptBlock
			ShaderScriptBlock=(function(){
				function ShaderScriptBlock(type,condition,text,parent){
					//this.type=0;
					//this.condition=null;
					//this.text=null;
					//this.parent=null;
					this.childs=new Array;
					this.type=type;
					this.text=text;
					this.parent=parent;
					parent && parent.childs.push(this);
					if (!condition)return;
					var newcondition="";
					var preIsParam=false,isParam=false;
					for (var i=0,n=condition.length;i < n;i++){
						var c=condition.charAt(i);
						isParam="!&|() \t".indexOf(c)< 0;
						if (preIsParam !=isParam){
							isParam && (newcondition+="this.");
							preIsParam=isParam;
						}
						newcondition+=c;
					}
					this.condition=RunDriver.createShaderCondition(newcondition);
				}
				__class(ShaderScriptBlock,'');
				var __proto=ShaderScriptBlock.prototype;
				__proto.toscript=function(def,out){
					if (this.type===0){
						this.text && out.push(this.text);
					}
					if (this.childs.length < 1 && !this.text)return out;
					if (this.type!==0){
						var ifdef=!!this.condition.call(def);
						this.type===2 && (ifdef=!ifdef);
						if (!ifdef)return out;
						this.text && out.push(this.text);
					}
					this.childs.length>0 && this.childs.forEach(function(o,index,arr){o.toscript(def,out)});
					return out;
				}
				return ShaderScriptBlock;
			})()
		}

		return ShaderCompile;
	})()


	/**
	*@private
	*<code>Shader3D</code> 主要用数组的方式保存shader变量定义，后期合并ShaderValue不使用for in，性能较高。
	*/
	//class laya.webgl.utils.ValusArray
	var ValusArray=(function(){
		function ValusArray(){
			this._data=[];
			this._length=0;
			this._data._length=0;
		}

		__class(ValusArray,'laya.webgl.utils.ValusArray');
		var __proto=ValusArray.prototype;
		__proto.pushValue=function(name,value,id){
			this.setValue(this._length,name,value,id);
			this._length+=2;
		}

		__proto.setValue=function(index,name,value,id){
			this._data[index++]=name;
			var d=this._data[index];
			d || (d=this._data[index]=[value,0]);
			d[0]=value;
			d[1]=id;
		}

		__proto.pushArray=function(value){
			var data=this._data;
			var len=this._length;
			var inData=value._data;
			var dec,src;
			for (var i=0,n=value.length;i < n;i++,len++){
				data[len++]=inData[i++];
				src=inData[i];
				(dec=data[len])? (dec[0]=src[0],dec[1]=src[1]):(data[len]=[src[0],src[1]]);
			}
			this._length=len;
		}

		__proto.copyTo=function(dec){
			dec || (dec=new ValusArray());
			var values=this._data;
			var decData=dec._data;
			for (var i=0;i < this._length;i++){
				if (((values[i])instanceof Array)){
					var valueArray=values[i];
					var decDataArray=decData[i]=[];
					decDataArray.length=valueArray.length;
					for (var j=0;j<valueArray.length;j++)
					decDataArray[j]=valueArray[j];
				}
				else {
					decData[i]=values[i];
				}
			}
			dec.length=this._length;
			return dec;
		}

		__getset(0,__proto,'length',function(){
			return this._length;
			},function(value){
			this._length=value;
		});

		__getset(0,__proto,'data',function(){
			return this._data;
		});

		return ValusArray;
	})()


	/**
	*@private
	*/
	//class laya.webgl.WebGL
	var WebGL=(function(){
		function WebGL(){};
		__class(WebGL,'laya.webgl.WebGL');
		WebGL.Float32ArraySlice=function(){
			var _this=this;
			var sz=_this.length;
			var dec=new Float32Array(_this.length);
			for (var i=0;i < sz;i++)dec[i]=_this[i];
			return dec;
		}

		WebGL.expandContext=function(){
			var from=Context.prototype;
			var to=CanvasRenderingContext2D.prototype;
			to.fillTrangles=from.fillTrangles;
			Buffer2D.__int__(null);
			to.setIBVB=function (x,y,ib,vb,numElement,mat,shader,shaderValues,startIndex,offset){
				(startIndex===void 0)&& (startIndex=0);
				(offset===void 0)&& (offset=0);
				if (ib===null){
					this._ib=this._ib || IndexBuffer2D.QuadrangleIB;
					ib=this._ib;
					GlUtils.expandIBQuadrangle(ib,(vb.byteLength / (4 *16)+8));
				}
				this._setIBVB(x,y,ib,vb,numElement,mat,shader,shaderValues,startIndex,offset);
			};
			to.fillTrangles=function (tex,x,y,points,m){
				this._curMat=this._curMat || Matrix.create();
				this._vb=this._vb || VertexBuffer2D.create();
				if (!this._ib){
					this._ib=IndexBuffer2D.create();
					GlUtils.fillIBQuadrangle(this._ib,length / 4);
				};
				var vb=this._vb;
				var length=points.length >> 4;
				GlUtils.fillTranglesVB(vb,x,y,points,m || this._curMat,0,0);
				GlUtils.expandIBQuadrangle(this._ib,(vb.byteLength / (4 *16)+8));
				var shaderValues=new Value2D(0x01,0);
				shaderValues.textureHost=tex;
				var sd=new Shader2X("attribute vec2 position; attribute vec2 texcoord; uniform vec2 size; uniform mat4 mmat; varying vec2 v_texcoord; void main() { vec4 p=vec4(position.xy,0.0,1.0);vec4 pos=mmat*p; gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0); v_texcoord = texcoord; }","precision mediump float; varying vec2 v_texcoord; uniform sampler2D texture; void main() {vec4 color= texture2D(texture, v_texcoord); color.a*=1.0; gl_FragColor= color;}");
				vb._vertType=3;
				this._setIBVB(x,y,this._ib,vb,length *6,m,sd,shaderValues,0,0);
			}
		}

		WebGL.enable=function(){
			if (Render.isConchApp){
				if (!Render.isConchWebGL){
					WebGL.expandContext();
					return false;
				}
			}
			if (!WebGL.isWebGLSupported())return false;
			if (Render.isWebGL)return true;
			HTMLImage.create=function (src){
				return new WebGLImage(src);
			}
			Render.WebGL=WebGL;
			Render.isWebGL=true;
			DrawText.__init__();
			RunDriver.createRenderSprite=function (type,next){
				return new RenderSprite3D(type,next);
			}
			RunDriver.createWebGLContext2D=function (c){
				return new WebGLContext2D(c);
			}
			RunDriver.changeWebGLSize=function (width,height){
				laya.webgl.WebGL.onStageResize(width,height);
			}
			RunDriver.createGraphics=function (){
				return new GraphicsGL();
			};
			var action=RunDriver.createFilterAction;
			RunDriver.createFilterAction=action ? action :function (type){
				return new ColorFilterActionGL()
			}
			RunDriver.clear=function (color){
				RenderState2D.worldScissorTest && laya.webgl.WebGL.mainContext.disable(0x0C11);
				if (color==null){
					Render.context.ctx.clearBG(0,0,0,0);
					}else {
					var c=Color.create(color)._color;
					Render.context.ctx.clearBG(c[0],c[1],c[2],c[3]);
				}
				RenderState2D.clear();
			}
			RunDriver.addToAtlas=function (texture,force){
				(force===void 0)&& (force=false);
				var bitmap=texture.bitmap;
				if (!Render.optimizeTextureMemory(texture.url,texture)){
					(bitmap).enableMerageInAtlas=false;
					return;
				}
				if ((Laya.__typeof(bitmap,'laya.webgl.resource.IMergeAtlasBitmap'))&& ((bitmap).allowMerageInAtlas)){
					bitmap.on("recovered",texture,texture.addTextureToAtlas);
				}
			}
			AtlasResourceManager._enable();
			RunDriver.beginFlush=function (){
				var atlasResourceManager=AtlasResourceManager.instance;
				var count=atlasResourceManager.getAtlaserCount();
				for (var i=0;i < count;i++){
					var atlerCanvas=atlasResourceManager.getAtlaserByIndex(i).texture;
					(atlerCanvas._flashCacheImageNeedFlush)&& (RunDriver.flashFlushImage(atlerCanvas));
				}
			}
			RunDriver.drawToCanvas=function (sprite,_renderType,canvasWidth,canvasHeight,offsetX,offsetY){
				var renderTarget=new RenderTarget2D(canvasWidth,canvasHeight,0x1908,0x1401,0,false);
				renderTarget.start();
				renderTarget.clear(1.0,0.0,0.0,1.0);
				sprite.render(Render.context,-offsetX,RenderState2D.height-canvasHeight-offsetY);
				Render.context.flush();
				renderTarget.end();
				var pixels=renderTarget.getData(0,0,renderTarget.width,renderTarget.height);
				renderTarget.dispose();
				return pixels;
			}
			RunDriver.createFilterAction=function (type){
				var action;
				switch (type){
					case 0x20:
						action=new ColorFilterActionGL();
						break ;
					}
				return action;
			}
			RunDriver.addTextureToAtlas=function (texture){
				texture._uvID++;
				AtlasResourceManager._atlasRestore++;
				((texture.bitmap).enableMerageInAtlas)&& (AtlasResourceManager.instance.addToAtlas(texture));
			}
			RunDriver.getTexturePixels=function (value,x,y,width,height){
				var tSprite=new Sprite();
				tSprite.x=-x;
				tSprite.y=-y;
				tSprite.graphics.drawTexture(value,0,0,value.sourceWidth,value.sourceHeight);
				var tRenderTarget=RenderTarget2D.create(width,height);
				tRenderTarget.start();
				tRenderTarget.clear(0,0,0,0);
				tSprite.render(Render.context,0,0);
				(Render.context.ctx).flush();
				tRenderTarget.end();
				var tUint8Array=tRenderTarget.getData(0,0,width,height);
				var tArray=[];
				var tIndex=0;
				for (var i=height-1;i >=0;i--){
					for (var j=0;j < width;j++){
						tIndex=(i *width+j)*4;
						tArray.push(tUint8Array[tIndex]);
						tArray.push(tUint8Array[tIndex+1]);
						tArray.push(tUint8Array[tIndex+2]);
						tArray.push(tUint8Array[tIndex+3]);
					}
				}
				return tArray;
			}
			RunDriver.fillTextureShader=function (value,x,y,width,height){
				var tFillTetureSprite=new FillTextureSprite();
				return tFillTetureSprite;
			}
			RunDriver.skinAniSprite=function (){
				var tSkinSprite=new SkinMesh()
				return tSkinSprite;
			}
			Filter._filterStart=function (scope,sprite,context,x,y){
				var b=scope.getValue("bounds");
				var source=RenderTarget2D.create(b.width,b.height);
				source.start();
				source.clear(0,0,0,0);
				scope.addValue("src",source);
				scope.addValue("ScissorTest",RenderState2D.worldScissorTest);
				if (RenderState2D.worldScissorTest){
					var tClilpRect=new Rectangle();
					tClilpRect.copyFrom((context.ctx)._clipRect)
					scope.addValue("clipRect",tClilpRect);
					RenderState2D.worldScissorTest=false;
					laya.webgl.WebGL.mainContext.disable(0x0C11);
				}
			}
			Filter._filterEnd=function (scope,sprite,context,x,y){
				var b=scope.getValue("bounds");
				var source=scope.getValue("src");
				source.end();
				var out=RenderTarget2D.create(b.width,b.height);
				out.start();
				out.clear(0,0,0,0);
				scope.addValue("out",out);
				sprite._set$P('_filterCache',out);
				sprite._set$P('_isHaveGlowFilter',scope.getValue("_isHaveGlowFilter"));
			}
			Filter._EndTarget=function (scope,context){
				var source=scope.getValue("src");
				source.recycle();
				var out=scope.getValue("out");
				out.end();
				var b=scope.getValue("ScissorTest");
				if (b){
					RenderState2D.worldScissorTest=true;
					laya.webgl.WebGL.mainContext.enable(0x0C11);
					context.ctx.save();
					var tClipRect=scope.getValue("clipRect");
					(context.ctx).clipRect(tClipRect.x,tClipRect.y,tClipRect.width,tClipRect.height);
				}
			}
			Filter._useSrc=function (scope){
				var source=scope.getValue("out");
				source.end();
				source=scope.getValue("src");
				source.start();
				source.clear(0,0,0,0);
			}
			Filter._endSrc=function (scope){
				var source=scope.getValue("src");
				source.end();
			}
			Filter._useOut=function (scope){
				var source=scope.getValue("src");
				source.end();
				source=scope.getValue("out");
				source.start();
				source.clear(0,0,0,0);
			}
			Filter._endOut=function (scope){
				var source=scope.getValue("out");
				source.end();
			}
			Filter._recycleScope=function (scope){
				scope.recycle();
			}
			Filter._filter=function (sprite,context,x,y){
				var next=this._next;
				if (next){
					var filters=sprite.filters,len=filters.length;
					if (len==1 && (filters[0].type==0x20)){
						context.ctx.save();
						context.ctx.setFilters([filters[0]]);
						next._fun.call(next,sprite,context,x,y);
						context.ctx.restore();
						return;
					};
					var shaderValue;
					var b;
					var scope=SubmitCMDScope.create();
					var p=Point.TEMP;
					var tMatrix=context.ctx._getTransformMatrix();
					var mat=Matrix.create();
					tMatrix.copyTo(mat);
					var tPadding=0;
					var tHalfPadding=0;
					var tIsHaveGlowFilter=false;
					var out=sprite._$P._filterCache ? sprite._$P._filterCache :null;
					if (!out || sprite._repaint){
						tIsHaveGlowFilter=sprite._isHaveGlowFilter();
						scope.addValue("_isHaveGlowFilter",tIsHaveGlowFilter);
						if (tIsHaveGlowFilter){
							tPadding=50;
							tHalfPadding=25;
						}
						b=new Rectangle();
						b.copyFrom((sprite).getBounds());
						var tSX=b.x;
						var tSY=b.y;
						b.width+=tPadding;
						b.height+=tPadding;
						p.x=b.x *mat.a+b.y *mat.c;
						p.y=b.y *mat.d+b.x *mat.b;
						b.x=p.x;
						b.y=p.y;
						p.x=b.width *mat.a+b.height *mat.c;
						p.y=b.height *mat.d+b.width *mat.b;
						b.width=p.x;
						b.height=p.y;
						if (b.width <=0 || b.height <=0){
							return;
						}
						out && out.recycle();
						scope.addValue("bounds",b);
						var submit=SubmitCMD.create([scope,sprite,context,0,0],Filter._filterStart);
						context.addRenderObject(submit);
						(context.ctx)._shader2D.glTexture=null;
						var tX=sprite.x-tSX+tHalfPadding;
						var tY=sprite.y-tSY+tHalfPadding;
						next._fun.call(next,sprite,context,tX,tY);
						submit=SubmitCMD.create([scope,sprite,context,0,0],Filter._filterEnd);
						context.addRenderObject(submit);
						for (var i=0;i < len;i++){
							if (i !=0){
								submit=SubmitCMD.create([scope],Filter._useSrc);
								context.addRenderObject(submit);
								shaderValue=Value2D.create(0x01,0);
								Matrix.TEMP.identity();
								context.ctx.drawTarget(scope,0,0,b.width,b.height,Matrix.TEMP,"out",shaderValue,null,BlendMode.TOINT.overlay);
								submit=SubmitCMD.create([scope],Filter._useOut);
								context.addRenderObject(submit);
							};
							var fil=filters[i];
							fil.action.apply3d(scope,sprite,context,0,0);
						}
						submit=SubmitCMD.create([scope,context],Filter._EndTarget);
						context.addRenderObject(submit);
						}else {
						tIsHaveGlowFilter=sprite._$P._isHaveGlowFilter ? sprite._$P._isHaveGlowFilter :false;
						if (tIsHaveGlowFilter){
							tPadding=50;
							tHalfPadding=25;
						}
						b=sprite.getBounds();
						if (b.width <=0 || b.height <=0){
							return;
						}
						b.width+=tPadding;
						b.height+=tPadding;
						p.x=b.x *mat.a+b.y *mat.c;
						p.y=b.y *mat.d+b.x *mat.b;
						b.x=p.x;
						b.y=p.y;
						p.x=b.width *mat.a+b.height *mat.c;
						p.y=b.height *mat.d+b.width *mat.b;
						b.width=p.x;
						b.height=p.y;
						scope.addValue("out",out);
					}
					x=x-tHalfPadding-sprite.x;
					y=y-tHalfPadding-sprite.y;
					p.setTo(x,y);
					mat.transformPoint(p);
					x=p.x+b.x;
					y=p.y+b.y;
					shaderValue=Value2D.create(0x01,0);
					Matrix.TEMP.identity();
					(context.ctx).drawTarget(scope,x,y,b.width,b.height,Matrix.TEMP,"out",shaderValue,null,BlendMode.TOINT.overlay);
					submit=SubmitCMD.create([scope],Filter._recycleScope);
					context.addRenderObject(submit);
					mat.destroy();
				}
			}
			Float32Array.prototype.slice || (Float32Array.prototype.slice=WebGL.Float32ArraySlice);
			return true;
		}

		WebGL.isWebGLSupported=function(){
			var canvas=Browser.createElement('canvas');
			var gl;
			var names=["webgl","experimental-webgl","webkit-3d","moz-webgl"];
			for (var i=0;i < names.length;i++){
				try {
					gl=canvas.getContext(names[i]);
				}catch (e){}
				if (gl)return names[i];
			}
			return null;
		}

		WebGL.onStageResize=function(width,height){
			WebGL.mainContext.viewport(0,0,width,height);
			RenderState2D.width=width;
			RenderState2D.height=height;
		}

		WebGL.isExperimentalWebgl=function(){
			return WebGL._isExperimentalWebgl;
		}

		WebGL.addRenderFinish=function(){
			if (WebGL._isExperimentalWebgl || Render.isFlash){
				RunDriver.endFinish=function (){
					Render.context.ctx.finish();
				}
			}
		}

		WebGL.removeRenderFinish=function(){
			if (WebGL._isExperimentalWebgl){
				RunDriver.endFinish=function (){}
			}
		}

		WebGL.onInvalidGLRes=function(){
			AtlasResourceManager.instance.freeAll();
			ResourceManager.releaseContentManagers(true);
			WebGL.doNodeRepaint(Laya.stage);
			WebGL.mainContext.viewport(0,0,RenderState2D.width,RenderState2D.height);
			Laya.stage.event("devicelost");
		}

		WebGL.doNodeRepaint=function(sprite){
			(sprite.numChildren==0)&& (sprite.repaint());
			for (var i=0;i < sprite.numChildren;i++)
			WebGL.doNodeRepaint(sprite.getChildAt(i));
		}

		WebGL.init=function(canvas,width,height){
			WebGL.mainCanvas=canvas;
			HTMLCanvas._createContext=function (canvas){
				return new WebGLContext2D(canvas);
			};
			var webGLName=WebGL.isWebGLSupported();
			var gl=WebGL.mainContext=RunDriver.newWebGLContext(canvas,webGLName);
			WebGL._isExperimentalWebgl=(webGLName !="webgl" && (Browser.onWeiXin || Browser.onMQQBrowser));
			WebGL.frameShaderHighPrecision=false;
			try {
				var precisionFormat=laya.webgl.WebGL.mainContext.getShaderPrecisionFormat(0x8B30,0x8DF2);
				precisionFormat.precision ? WebGL.frameShaderHighPrecision=true :WebGL.frameShaderHighPrecision=false;
			}catch (e){}
			Browser.window.SetupWebglContext && Browser.window.SetupWebglContext(gl);
			WebGL.onStageResize(width,height);
			if (WebGL.mainContext==null)
				throw new Error("webGL getContext err!");
			System.__init__();
			AtlasResourceManager.__init__();
			ShaderDefines2D.__init__();
			Submit.__init__();
			WebGLContext2D.__init__();
			Value2D.__init__();
			Shader2D.__init__();
			Buffer2D.__int__(gl);
			BlendMode._init_(gl);
			if (Render.isConchApp){
				conch.setOnInvalidGLRes(WebGL.onInvalidGLRes);
			}
		}

		WebGL.mainCanvas=null
		WebGL.mainContext=null
		WebGL.antialias=true;
		WebGL.frameShaderHighPrecision=false;
		WebGL._bg_null=[0,0,0,0];
		WebGL._isExperimentalWebgl=false;
		return WebGL;
	})()


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.WebGLContext
	var WebGLContext=(function(){
		function WebGLContext(){};
		__class(WebGLContext,'laya.webgl.WebGLContext');
		WebGLContext.UseProgram=function(program){
			if (WebGLContext._useProgram===program)return false;
			WebGL.mainContext.useProgram(program);
			WebGLContext._useProgram=program;
			return true;
		}

		WebGLContext.setDepthTest=function(gl,value){
			value!==WebGLContext._depthTest && (WebGLContext._depthTest=value,value?gl.enable(0x0B71):gl.disable(0x0B71));
		}

		WebGLContext.setDepthMask=function(gl,value){
			value!==WebGLContext._depthMask && (WebGLContext._depthMask=value,gl.depthMask(value));
		}

		WebGLContext.setBlend=function(gl,value){
			value!==WebGLContext._blend && (WebGLContext._blend=value,value?gl.enable(0x0BE2):gl.disable(0x0BE2));
		}

		WebGLContext.setBlendFunc=function(gl,sFactor,dFactor){
			(sFactor!==WebGLContext._sFactor||dFactor!==WebGLContext._dFactor)&& (WebGLContext._sFactor=sFactor,WebGLContext._dFactor=dFactor,gl.blendFunc(sFactor,dFactor));
		}

		WebGLContext.setCullFace=function(gl,value){
			value!==WebGLContext._cullFace && (WebGLContext._cullFace=value,value?gl.enable(0x0B44):gl.disable(0x0B44));
		}

		WebGLContext.setFrontFaceCCW=function(gl,value){
			value!==WebGLContext._frontFace && (WebGLContext._frontFace=value,gl.frontFace(value));
		}

		WebGLContext.bindTexture=function(gl,target,texture){
			gl.bindTexture(target,texture);
			WebGLContext.curBindTexTarget=target;
			WebGLContext.curBindTexValue=texture;
		}

		WebGLContext._useProgram=null;
		WebGLContext._depthTest=true;
		WebGLContext._depthMask=1;
		WebGLContext._depthFunc=0x0203;
		WebGLContext._blend=false;
		WebGLContext._sFactor=1;
		WebGLContext._dFactor=0;
		WebGLContext._cullFace=false;
		WebGLContext._frontFace=0x0901;
		WebGLContext.curBindTexTarget=null
		WebGLContext.curBindTexValue=null
		WebGLContext.__init$=function(){
			;
		}

		return WebGLContext;
	})()


	/**全局配置*/
	//class UIConfig
	var UIConfig=(function(){
		function UIConfig(){};
		__class(UIConfig,'UIConfig');
		UIConfig.touchScrollEnable=true;
		UIConfig.mouseWheelEnable=true;
		UIConfig.showButtons=true;
		UIConfig.popupBgColor="#000000";
		UIConfig.popupBgAlpha=0.5;
		return UIConfig;
	})()


	/**
	*...
	*@author wangcx
	*/
	//class specter3d.engine.errors.AbstractMethodError extends Error
	var AbstractMethodError=(function(_super){
		function AbstractMethodError(id){
			(id===void 0)&& (id=0);
			AbstractMethodError.__super.call(this,"An abstract method was called! Either an instance of an abstract class was created, or an abstract method was not overridden by the subclass.",id);
		}

		__class(AbstractMethodError,'specter3d.engine.errors.AbstractMethodError',Error);
		return AbstractMethodError;
	})(Error)


	//class specter3d.engine.bounds.BoundBox extends specter3d.engine.bounds.Bound
	var BoundBox=(function(_super){
		function BoundBox(){
			this._half=null;
			BoundBox.__super.call(this);
			this._half=new Vector3D();
		}

		__class(BoundBox,'specter3d.engine.bounds.BoundBox',_super);
		var __proto=BoundBox.prototype;
		__proto.setSize=function(minX,minY,minZ,maxX,maxY,maxZ){
			_super.prototype.setSize.call(this,minX,minY,minZ,maxX,maxY,maxZ);
			this._half.x=(this._max.x-this._min.x)*0.5;
			this._half.y=(this._max.y-this._min.y)*0.5;
			this._half.z=(this._max.z-this._min.z)*0.5;
		}

		__proto.rayIntersection=function(position,direction,targetNormal){
			if (this.containsPoint(position))
				return 0;
			var _centerX=this._center.x;
			var _centerY=this._center.y;
			var _centerZ=this._center.z;
			var _halfExtentsX=this._half.x;
			var _halfExtentsY=this._half.y;
			var _halfExtentsZ=this._half.z;
			var px=position.x-_centerX,py=position.y-_centerY,pz=position.z-_centerZ;
			var vx=direction.x,vy=direction.y,vz=direction.z;
			var ix=NaN,iy=NaN,iz=NaN;
			var rayEntryDistance=NaN;
			var intersects=false;
			if (vx < 0){
				rayEntryDistance=(_halfExtentsX-px)/vx;
				if (rayEntryDistance > 0){
					iy=py+rayEntryDistance*vy;
					iz=pz+rayEntryDistance*vz;
					if (iy >-_halfExtentsY && iy < _halfExtentsY && iz >-_halfExtentsZ && iz < _halfExtentsZ){
						targetNormal.x=1;
						targetNormal.y=0;
						targetNormal.z=0;
						intersects=true;
					}
				}
			}
			if (!intersects && vx > 0){
				rayEntryDistance=(-_halfExtentsX-px)/vx;
				if (rayEntryDistance > 0){
					iy=py+rayEntryDistance*vy;
					iz=pz+rayEntryDistance*vz;
					if (iy >-_halfExtentsY && iy < _halfExtentsY && iz >-_halfExtentsZ && iz < _halfExtentsZ){
						targetNormal.x=-1;
						targetNormal.y=0;
						targetNormal.z=0;
						intersects=true;
					}
				}
			}
			if (!intersects && vy < 0){
				rayEntryDistance=(_halfExtentsY-py)/vy;
				if (rayEntryDistance > 0){
					ix=px+rayEntryDistance*vx;
					iz=pz+rayEntryDistance*vz;
					if (ix >-_halfExtentsX && ix < _halfExtentsX && iz >-_halfExtentsZ && iz < _halfExtentsZ){
						targetNormal.x=0;
						targetNormal.y=1;
						targetNormal.z=0;
						intersects=true;
					}
				}
			}
			if (!intersects && vy > 0){
				rayEntryDistance=(-_halfExtentsY-py)/vy;
				if (rayEntryDistance > 0){
					ix=px+rayEntryDistance*vx;
					iz=pz+rayEntryDistance*vz;
					if (ix >-_halfExtentsX && ix < _halfExtentsX && iz >-_halfExtentsZ && iz < _halfExtentsZ){
						targetNormal.x=0;
						targetNormal.y=-1;
						targetNormal.z=0;
						intersects=true;
					}
				}
			}
			if (!intersects && vz < 0){
				rayEntryDistance=(_halfExtentsZ-pz)/vz;
				if (rayEntryDistance > 0){
					ix=px+rayEntryDistance*vx;
					iy=py+rayEntryDistance*vy;
					if (iy >-_halfExtentsY && iy < _halfExtentsY && ix >-_halfExtentsX && ix < _halfExtentsX){
						targetNormal.x=0;
						targetNormal.y=0;
						targetNormal.z=1;
						intersects=true;
					}
				}
			}
			if (!intersects && vz > 0){
				rayEntryDistance=(-_halfExtentsZ-pz)/vz;
				if (rayEntryDistance > 0){
					ix=px+rayEntryDistance*vx;
					iy=py+rayEntryDistance*vy;
					if (iy >-_halfExtentsY && iy < _halfExtentsY && ix >-_halfExtentsX && ix < _halfExtentsX){
						targetNormal.x=0;
						targetNormal.y=0;
						targetNormal.z=-1;
						intersects=true;
					}
				}
			}
			return intersects? rayEntryDistance :-1;
		}

		__proto.containsPoint=function(position){
			var px=position.x-this._center.x;
			var py=position.y-this._center.y;
			var pz=position.z-this._center.z;
			return px <=this._half.x && px >=-this._half.x &&
			py <=this._half.y && py >=-this._half.y &&
			pz <=this._half.z && pz >=-this._half.z;
		}

		__proto.clone=function(){
			var clone=new BoundBox();
			clone.setSize(this._min.x,this._min.y,this._min.z,this._max.x,this._max.y,this._max.z);
			return clone;
		}

		return BoundBox;
	})(Bound)


	;
	/**
	*Object3D 类是可放在显示列表中的所有对象的基类。
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.Object3D extends laya.events.EventDispatcher
	var Object3D=(function(_super){
		function Object3D(){
			this.name=null;
			this.visible=true;
			this._childrenList=null;
			this._isRoot=false;
			this._next=null;
			this._parent=null;
			this._transform=null;
			Object3D.__super.call(this);
			this._transform=new Transform3D(this);
		}

		__class(Object3D,'specter3d.engine.core.Object3D',_super);
		var __proto=Object3D.prototype;
		Laya.imps(__proto,{"specter3d.engine.interfaces.IRenderUpdate":true})
		/**
		*将一个 Object3D 子实例添加到该 Object3D 实例中。
		*@param child
		*@return
		*
		*/
		__proto.addChild=function(child){
			if (child==null)
				throw new Error("Parameter child must be non-null.");
			if (child==this)
				throw new Error("An object cannot be added as a child of itself.");
			for (var container=this._parent;container !=null;container=container._parent){
				if (container==child)
					throw new Error("An object cannot be added as a child to one of it's children (or children's children, etc.).");
			}
			if (child._parent !=this){
				if (child._parent !=null)
					child._parent.removeChild(child);
				this.addToList(child);
				child._parent=this;
				this.transform.updateTransforms(true);
				if (child.hasListener("added3D"))
					child.event("added3D",true);
			}
			else{
				child=this.removeFromList(child);
				if (child==null)
					throw new Error("Cannot add child.");
				this.addToList(child);
			}
			return child;
		}

		/**
		*将一个 Object3D 子实例添加到该 Object3D 实例中。该子项将被添加到指定的索引位置。索引为 0 表示该 Object3D 对象的显示列表的后（底）部。
		*@param child
		*@param index
		*@return
		*
		*/
		__proto.addChildAt=function(child,index){
			if (child==null)
				throw new Error("Parameter child must be non-null.");
			if (child==this)
				throw new Error("An object cannot be added as a child of itself.");
			if (index < 0)
				throw new Error("The supplied index is out of bounds.");
			for (var container=this._parent;container !=null;container=container._parent){
				if (container==child)
					throw new Error("An object cannot be added as a child to one of it's children (or children's children, etc.).");
			};
			var current=this._childrenList;
			for (var i=0;i < index;i++){
				if (current==null)
					throw new Error("The supplied index is out of bounds.");
				current=current._next;
			}
			if (child._parent !=this){
				if (child._parent !=null)
					child._parent.removeChild(child);
				this.addToList(child,current);
				child._parent=this;
				this.transform.updateTransforms(true);
				if (child.hasListener("added3D"))
					child.event("added3D",true);
			}
			else{
				child=this.removeFromList(child);
				if (child==null)
					throw new Error("Cannot add child.");
				this.addToList(child,current);
			}
			return child;
		}

		__proto.clone=function(){
			var res=new Object3D();
			res._transform=this._transform.clone(res);
			res.clonePropertiesFrom(this);
			return res;
		}

		/**
		*确定指定显示对象是 Object3D 实例的子项还是该实例本身。
		*@param child
		*@return
		*
		*/
		__proto.contains=function(child){
			if (child==null)
				throw new Error("Parameter child must be non-null.");
			if (child==this)
				return true;
			for (var object=this._childrenList;object !=null;object=object._next){
				if (object.contains(child))
					return true;
			}
			return false;
		}

		__proto.dispose=function(){
			for (var child=this._childrenList,lastChild;child !=null;child=child._next){
				child.dispose();
			}
		}

		/**
		*返回位于指定索引处的子显示对象实例。
		*@param index
		*@return
		*
		*/
		__proto.getChildAt=function(index){
			if (index < 0)
				throw new Error("The supplied index is out of bounds.");
			var current=this._childrenList;
			for (var i=0;i < index;i++){
				if (current==null)
					throw new Error("The supplied index is out of bounds.");
				current=current._next;
			}
			if (current==null)
				throw new Error("The supplied index is out of bounds.");
			return current;
		}

		/**
		*返回位于指定名称的子显示对象实例。
		*@param name
		*@return
		*
		*/
		__proto.getChildByName=function(name){
			if (name==null)
				throw new Error("Parameter name must be non-null.");
			for (var child=this._childrenList;child !=null;child=child._next){
				if (child.name==name)
					return child;
			}
			return null;
		}

		/**
		*返回 Object3D 的 child 实例的索引位置。
		*@param child
		*@return
		*
		*/
		__proto.getChildIndex=function(child){
			if (child==null)
				throw new Error("Parameter child must be non-null.");
			if (child._parent !=this)
				throw new Error("The supplied Object3D must be a child of the caller.");
			var index=0;
			for (var current=this._childrenList;current !=null;current=current._next){
				if (current==child)
					return index;
				index++;
			}
			throw new Error("Cannot get child index.");
		}

		/**
		*从 Object3D 实例的子列表中删除指定的 child Object3D 实例
		*@param child
		*@return
		*
		*/
		__proto.removeChild=function(child){
			if (child==null)
				throw new Error("Parameter child must be non-null.");
			if (child._parent !=this)
				throw new Error("The supplied Object3D must be a child of the caller.");
			child=this.removeFromList(child);
			if (child==null)
				throw new Error("Cannot remove child.");
			if (child.hasListener("removed3D"))
				child.event("removed3D",true);
			child._parent=null;
			this.transform.updateTransforms(true);
			return child;
		}

		/**
		*从 Object3D 的子列表中指定的 index 位置删除子 Object3D。
		*@param index
		*@return
		*
		*/
		__proto.removeChildAt=function(index){
			if (index < 0)
				throw new Error("The supplied index is out of bounds.");
			var child=this._childrenList;
			for (var i=0;i < index;i++){
				if (child==null)
					throw new Error("The supplied index is out of bounds.");
				child=child._next;
			}
			if (child==null)
				throw new Error("The supplied index is out of bounds.");
			this.removeFromList(child);
			if (child.hasListener("removed3D"))
				child.event("removed3D",true);
			child._parent=null;
			this.transform.updateTransforms(true);
			return child;
		}

		/**
		*从 Object3D 实例的子级列表中删除所有子 Object3D 实例。
		*@param beginIndex
		*@param endIndex
		*
		*/
		__proto.removeChildren=function(beginIndex,endIndex){
			(beginIndex===void 0)&& (beginIndex=0);
			(endIndex===void 0)&& (endIndex=2147483647);
			if (beginIndex < 0)
				throw new Error("The supplied index is out of bounds.");
			if (endIndex < beginIndex)
				throw new Error("The supplied index is out of bounds.");
			var i=0;
			var prev=null;
			var begin=this._childrenList;
			while (i < beginIndex){
				if (begin==null){
					if (endIndex < 2147483647){
						throw new Error("The supplied index is out of bounds.");
					}
					else{
						return;
					}
				}
				prev=begin;
				begin=begin._next;
				i++;
			}
			if (begin==null){
				if (endIndex < 2147483647){
					throw new Error("The supplied index is out of bounds.");
				}
				else{
					return;
				}
			};
			var end=null;
			if (endIndex < 2147483647){
				end=begin;
				while (i <=endIndex){
					if (end==null)
						throw new Error("The supplied index is out of bounds.");
					end=end._next;
					i++;
				}
			}
			if (prev !=null){
				prev._next=end;
			}
			else{
				this._childrenList=end;
			}
			while (begin !=end){
				var next=begin._next;
				begin._next=null;
				if (begin.hasListener("removed3D"))
					begin.event("removed3D",true);
				begin._parent=null;
				begin=next;
			}
			this.transform.updateTransforms(true);
		}

		__proto.update=function(time,dt){
			(dt===void 0)&& (dt=0);
			for (var current=this._childrenList;current !=null;current=current._next){
				current.update(time,dt);
			}
		}

		/**
		*克隆屬性列表
		*@param source
		*
		*/
		__proto.clonePropertiesFrom=function(source){
			var _source=source;
			if (_source !=null){
				for (var child=_source._childrenList,lastChild;child !=null;child=child._next){
					var newChild=child.clone();
					if (this._childrenList !=null){
						lastChild._next=newChild;
					}
					else{
						this._childrenList=newChild;
					}
					lastChild=newChild;
					newChild._parent=this;
				}
			}
		}

		__proto.addToList=function(child,item){
			child._next=item;
			if (item==this._childrenList){
				this._childrenList=child;
			}
			else{
				for (var current=this._childrenList;current !=null;current=current._next){
					if (current._next==item){
						current._next=child;
						break ;
					}
				}
			}
		}

		/**
		*@private
		*/
		__proto.removeFromList=function(child){
			var prev;
			for (var current=this._childrenList;current !=null;current=current._next){
				if (current==child){
					if (prev !=null){
						prev._next=current._next;
					}
					else{
						this._childrenList=current._next;
					}
					current._next=null;
					return child;
				}
				prev=current;
			}
			return null;
		}

		/**朝向一个目标 */
		__proto.lookAt=function(target,upAxis){
			var matrix=this.transform.world;
			Matrix3DUtils.lookAt(matrix,target.x,target.y,target.z,Vector3D.Y_AXIS);
			this.transform.world=matrix;
		}

		__proto.collectRender=function(camera,_context3d,_renderUnits){
			if(this.visible){
				for (var current=this._childrenList;current !=null;current=current._next){
					current.collectRender(camera,_context3d,_renderUnits);
				}
			}
		}

		/**
		*返回此对象的子项数目。
		*@return
		*
		*/
		__getset(0,__proto,'numChildren',function(){
			var num=0;
			for (var current=this._childrenList;current !=null;current=current._next)
			num++;
			return num;
		});

		__getset(0,__proto,'parent',function(){
			return this._parent;
		});

		__getset(0,__proto,'transform',function(){
			return this._transform;
		});

		Object3D.__init$=function(){
			;
			/*namespace*/;
			/*namespace*/;
			/*namespace*/;
			/*namespace*/;
		}

		return Object3D;
	})(EventDispatcher)


	/**
	*Extended camera used to automatically look at a specified target object.
	*
	*@see away3d.containers.View3D
	*/
	//class specter3d.engine.controllers.LookAtController extends specter3d.engine.controllers.ControllerBase
	var LookAtController=(function(_super){
		function LookAtController(targetObject,lookAtObject){
			this._lookAtPosition=null;
			this._lookAtObject=null;
			this._origin=new Vector3D(0.0,0.0,0.0);
			this._upAxis=Vector3D.Y_AXIS;
			this._pos=new Vector3D();
			LookAtController.__super.call(this,targetObject);
			if (lookAtObject)
				this.lookAtObject=lookAtObject;
			else
			this.lookAtPosition=new Vector3D();
		}

		__class(LookAtController,'specter3d.engine.controllers.LookAtController',_super);
		var __proto=LookAtController.prototype;
		/**
		*@inheritDoc
		*/
		__proto.update=function(interpolate){
			(interpolate===void 0)&& (interpolate=true);
			interpolate=interpolate;
			if (this._targetObject){
				if (this._lookAtPosition){
					this._targetObject.lookAt(this._lookAtPosition,this._upAxis);
					}else if (this._lookAtObject){
					this._pos=this._lookAtObject.transform.getPosition(false,this._pos);
					if (this._targetObject.parent){
						Matrix3DUtils.transformVector(this._targetObject.parent.transform.invWorld,this._pos,this._pos);
					}
					this._targetObject.lookAt(this._pos,this._upAxis);
				}
			}
		}

		__proto.onLookAtObjectChanged=function(event){
			this.notifyUpdate();
		}

		/**
		*The vector representing the up direction of the target object.
		*/
		__getset(0,__proto,'upAxis',function(){
			return this._upAxis;
			},function(upAxis){
			this._upAxis=upAxis;
			this.notifyUpdate();
		});

		/**
		*The Vector3D object that the target looks at.
		*/
		__getset(0,__proto,'lookAtPosition',function(){
			return this._lookAtPosition;
			},function(val){
			if (this._lookAtObject){
				this._lookAtObject.transform.off("positionChanged",this,this.onLookAtObjectChanged);
				this._lookAtObject=null;
			}
			this._lookAtPosition=val;
			this.notifyUpdate();
		});

		/**
		*The 3d object that the target looks at.
		*/
		__getset(0,__proto,'lookAtObject',function(){
			return this._lookAtObject;
			},function(val){
			if (this._lookAtPosition)
				this._lookAtPosition=null;
			if (this._lookAtObject==val)
				return;
			if (this._lookAtObject)
				this._lookAtObject.transform.off("positionChanged",this,this.onLookAtObjectChanged);
			this._lookAtObject=val;
			if (this._lookAtObject)
				this._lookAtObject.on("positionChanged",this,this.onLookAtObjectChanged);
			this.notifyUpdate();
		});

		return LookAtController;
	})(ControllerBase)


	;
	/**
	*应用程序上下文对象
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.context.AppGlobalContext extends laya.events.EventDispatcher
	var AppGlobalContext=(function(_super){
		var AppGlobalContextSingletonEnforcer;
		function AppGlobalContext(singleton){
			this._stage2d=null;
			this._stage3d=null;
			this._stageHeight=0;
			this._stageMaxHeight=0;
			this._stageMaxWidth=0;
			this._stageMinHeight=0;
			this._stageMinWidth=0;
			this._stageWidth=0;
			AppGlobalContext.__super.call(this);
			if (!singleton)
				throw new Error("This class is a multiton and cannot be instantiated manually.");
		}

		__class(AppGlobalContext,'specter3d.engine.core.context.AppGlobalContext',_super);
		/**
		*文件队列加载器
		*/
		__getset(1,AppGlobalContext,'fileLoader',function(){
			return AppGlobalContext._fileLoader;
		},laya.events.EventDispatcher._$SET_fileLoader);

		__getset(1,AppGlobalContext,'renderDrive',function(){
			return RenderDrive.getInstance();
		},laya.events.EventDispatcher._$SET_renderDrive);

		__getset(1,AppGlobalContext,'stage2d',function(){
			return AppGlobalContext._instance._stage2d;
		},laya.events.EventDispatcher._$SET_stage2d);

		__getset(1,AppGlobalContext,'stage3d',function(){
			return AppGlobalContext.instance._stage3d;
		},laya.events.EventDispatcher._$SET_stage3d);

		__getset(1,AppGlobalContext,'stageMaxHeight',laya.events.EventDispatcher._$GET_stageMaxHeight,function(value){
			AppGlobalContext._instance._stageMaxHeight=value;
		});

		__getset(1,AppGlobalContext,'stageMinHeight',laya.events.EventDispatcher._$GET_stageMinHeight,function(value){
			AppGlobalContext._instance._stageMinHeight=value;
		});

		__getset(1,AppGlobalContext,'stageHeight',function(){
			return AppGlobalContext._instance._stageHeight;
		},laya.events.EventDispatcher._$SET_stageHeight);

		__getset(1,AppGlobalContext,'timer',function(){
			return AppGlobalContext._timer;
		},laya.events.EventDispatcher._$SET_timer);

		__getset(1,AppGlobalContext,'instance',function(){
			!AppGlobalContext._instance && (AppGlobalContext._instance=new AppGlobalContext(new AppGlobalContextSingletonEnforcer));
			return AppGlobalContext._instance;
		},laya.events.EventDispatcher._$SET_instance);

		__getset(1,AppGlobalContext,'stageMaxWidth',laya.events.EventDispatcher._$GET_stageMaxWidth,function(value){
			AppGlobalContext._instance._stageMaxWidth=value;
		});

		__getset(1,AppGlobalContext,'stageMinWidth',laya.events.EventDispatcher._$GET_stageMinWidth,function(value){
			AppGlobalContext._instance._stageMinWidth=value;
		});

		__getset(1,AppGlobalContext,'stageWidth',function(){
			return AppGlobalContext._instance._stageWidth;
		},laya.events.EventDispatcher._$SET_stageWidth);

		__getset(1,AppGlobalContext,'mouseManager',function(){
			return AppGlobalContext.instance._stage3d.mouseManager;
		},laya.events.EventDispatcher._$SET_mouseManager);

		AppGlobalContext.initEngine=function(fps,antialias){
			(fps===void 0)&& (fps=60);
			(antialias===void 0)&& (antialias=true);
			Browser.__init__();
			AppGlobalContext._timer=new Timer();
			AppGlobalContext.instance._stage3d=new Stage3D(antialias);
			NativeEventManager.instance.__init__(AppGlobalContext.instance._stage3d.canvas);
			AppGlobalContext.renderDrive.frameRate=fps;
			specter3d.engine.core.context.AppGlobalContext.renderDrive.register(AppGlobalContext.instance._stage3d);
			this.on("resize",null,AppGlobalContext.onResize);
		}

		AppGlobalContext.off=function(type,caller,listener){
			AppGlobalContext._instance.off(type,caller,listener);
		}

		AppGlobalContext.on=function(type,caller,listener){
			AppGlobalContext._instance.on(type,caller,listener);
		}

		AppGlobalContext.onResize=function(){
			AppGlobalContext.instance._stageWidth=AppGlobalContext.instance._stage3d.stageWidth < AppGlobalContext.instance._stageMinWidth && AppGlobalContext.instance._stageMinWidth > 0 ? AppGlobalContext.instance._stageMinWidth :AppGlobalContext.instance._stage3d.stageWidth;
			AppGlobalContext.instance._stageHeight=AppGlobalContext.instance._stage3d.stageHeight < AppGlobalContext.instance._stageMinHeight && AppGlobalContext.instance._stageMinHeight > 0 ? AppGlobalContext.instance._stageMinHeight :AppGlobalContext.instance._stage3d.stageHeight;
			AppGlobalContext.instance._stageWidth=AppGlobalContext.instance._stage3d.stageWidth > AppGlobalContext.instance._stageMaxWidth && AppGlobalContext.instance._stageMaxWidth > 0 ? AppGlobalContext.instance._stageMaxWidth :AppGlobalContext.instance._stage3d.stageWidth;
			AppGlobalContext.instance._stageHeight=AppGlobalContext.instance._stage3d.stageHeight > AppGlobalContext.instance._stageMaxHeight && AppGlobalContext.instance._stageMaxHeight > 0 ? AppGlobalContext.instance._stageMaxHeight :AppGlobalContext.instance._stage3d.stageHeight;
		}

		AppGlobalContext.telnetBasePath=null;
		AppGlobalContext._instance=null
		AppGlobalContext._timer=null
		__static(AppGlobalContext,
		['_fileLoader',function(){return this._fileLoader=new MultithreadedLoader();}
		]);
		AppGlobalContext.__init$=function(){
			/*namespace*/;;
			//class AppGlobalContextSingletonEnforcer
			AppGlobalContextSingletonEnforcer=(function(){
				function AppGlobalContextSingletonEnforcer(){};
				__class(AppGlobalContextSingletonEnforcer,'');
				return AppGlobalContextSingletonEnforcer;
			})()
		}

		return AppGlobalContext;
	})(EventDispatcher)


	/**
	*渲染驱动器
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.drive.RenderDrive extends laya.events.EventDispatcher
	var RenderDrive=(function(_super){
		var RenderDriveSingletonEnforcer;
		function RenderDrive(singleton){
			this._frameRate=60;
			this._intervalTime=0;
			this.absoluteTime=0;
			this.driveList=null;
			RenderDrive.__super.call(this);
			var _$this=this;
			if (!singleton)
				throw new Error("This class is a multiton and cannot be instantiated manually. Use RenderDrive.getInstance instead.");
			this.driveList=new HashMap();
			Browser.window.requestAnimationFrame(render);
			function render (timestamp){
				var deltaTime=timestamp-_$this.absoluteTime;
				if (deltaTime >=_$this._intervalTime){
					_$this.absoluteTime=timestamp;
					NativeEventManager.instance.runEvent();
					AppGlobalContext.timer._update();
					_$this.driveList.forEach(_$this.updateRender,_$this.absoluteTime,deltaTime);
				}
				Browser.window.requestAnimationFrame(render);
			}
		}

		__class(RenderDrive,'specter3d.engine.core.drive.RenderDrive',_super);
		var __proto=RenderDrive.prototype;
		/**
		*注册到渲染列表
		*@param anim
		*
		*/
		__proto.register=function(anim){
			anim && this.driveList.put(anim,anim);
		}

		/**
		*从渲染列表中移除
		*@param anim
		*
		*/
		__proto.unregister=function(anim){
			this.driveList.remove(anim);
		}

		__proto.updateRender=function(key,value,time,dt){
			if (Laya.__typeof(value,'specter3d.engine.interfaces.IRenderUpdate')){
				value.update(time,dt);
			}
		}

		__getset(0,__proto,'frameRate',function(){
			return this._frameRate;
			},function(value){
			this._frameRate=value;
			this._intervalTime=1000 / this._frameRate;
		});

		__getset(0,__proto,'time',function(){
			return Math.floor(this.absoluteTime);
		});

		RenderDrive.getInstance=function(){RenderDrive._instances=RenderDrive._instances||new RenderDrive(new RenderDriveSingletonEnforcer);
			return RenderDrive._instances;
		}

		RenderDrive._instances=null
		RenderDrive.__init$=function(){
			//class RenderDriveSingletonEnforcer
			RenderDriveSingletonEnforcer=(function(){
				function RenderDriveSingletonEnforcer(){};
				__class(RenderDriveSingletonEnforcer,'');
				return RenderDriveSingletonEnforcer;
			})()
		}

		return RenderDrive;
	})(EventDispatcher)


	;
	/**
	*3D层
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.Layer3D extends laya.events.EventDispatcher
	var Layer3D=(function(_super){
		function Layer3D(name,camera,scene){
			this._camera3d=null;
			this._globalPosDirty=false;
			this._height=NaN;
			this._name=null;
			this._renderer=null;
			this._scene3d=null;
			this._viewPort=null;
			this._viewportDirty=true;
			this._width=NaN;
			this._x=0;
			this._y=0;
			Layer3D.__super.call(this);
			this._name=name;
			this._scene3d=scene;
			this._camera3d=camera;
			this._viewPort=new Rectangle();
			this._renderer=new Renderer(this);
		}

		__class(Layer3D,'specter3d.engine.core.Layer3D',_super);
		var __proto=Layer3D.prototype;
		Laya.imps(__proto,{"specter3d.engine.interfaces.IRenderUpdate":true})
		__proto.updateRender=function(_gl,time,dt){
			(dt===void 0)&& (dt=0);
			this._renderer.clear();
			this.updateGlobalPos();
			this.updateViewSizeData();
			this.collectingObject();
			this._renderer.render(_gl);
		}

		__proto.update=function(time,dt){
			(dt===void 0)&& (dt=0);
			this._scene3d._rootContainer3D.update(time,dt);
		}

		__proto.updateGlobalPos=function(){
			if (this._globalPosDirty){
				this._globalPosDirty=false;
				this._viewPort.x=this._x;
				this._viewPort.y=this._y;
				this._viewportDirty=true;
			}
		}

		__proto.updateViewSizeData=function(){
			if (this._viewportDirty){
				this._viewportDirty=false;
				this._camera3d.setViewPort(this._viewPort.x,this._viewPort.y,this._viewPort.width,this._viewPort.height);
			}
		}

		/**
		*对象收集
		*
		*/
		__proto.collectingObject=function(){
			if (this._scene3d && this._scene3d._rootContainer3D.visible){
				this._scene3d._rootContainer3D.collectRender(this._camera3d,AppGlobalContext.stage3d.webglContext,this._renderer._renderUnits);
			}
		}

		__getset(0,__proto,'camera3d',function(){
			return this._camera3d;
		});

		__getset(0,__proto,'height',function(){
			return this._height;
			},function(value){
			if (value > 2048)
				value=2048;
			if (this._height==value)
				return;
			this._height=value;
			this._viewPort.height=value;
			this._viewportDirty=true;
		});

		__getset(0,__proto,'scene3d',function(){
			return this._scene3d;
		});

		__getset(0,__proto,'width',function(){
			return this._width;
			},function(value){
			if (value > 2048)
				value=2048;
			if (this._width==value)
				return;
			this._width=value;
			this._viewPort.width=value;
			this._viewportDirty=true;
		});

		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			if (this.x==value)
				return;
			this._x=value;
			this._globalPosDirty=true;
		});

		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			if (this.y==value)
				return;
			this._y=value;
			this._globalPosDirty=true;
		});

		return Layer3D;
	})(EventDispatcher)


	;
	/**
	*3D 场景
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.Scene3D extends laya.events.EventDispatcher
	var Scene3D=(function(_super){
		function Scene3D(name){
			this._name=null;
			this._rootContainer3D=null;
			Scene3D.__super.call(this);
			this._rootContainer3D=new Object3D;
			this._rootContainer3D._isRoot=true;
			this._name=name=name||"default_scene3d";
		}

		__class(Scene3D,'specter3d.engine.core.Scene3D',_super);
		var __proto=Scene3D.prototype;
		Laya.imps(__proto,{"specter3d.engine.interfaces.IRenderUpdate":true})
		/**
		*将一个 Object3D 子实例添加到该 Object3D 实例中。
		*@param child
		*@return
		*
		*/
		__proto.addChild=function(child){
			return this._rootContainer3D.addChild(child);
		}

		/**
		*将一个 Object3D 子实例添加到该 Object3D 实例中。该子项将被添加到指定的索引位置。索引为 0 表示该 Object3D 对象的显示列表的后（底）部。
		*@param child
		*@param index
		*@return
		*
		*/
		__proto.addChildAt=function(child,index){
			return this._rootContainer3D.addChildAt(child,index);
		}

		/**
		*确定指定显示对象是 Object3D 实例的子项还是该实例本身。
		*@param child
		*@return
		*
		*/
		__proto.contains=function(child){
			return this._rootContainer3D.contains(child);
		}

		/**
		*返回位于指定索引处的子显示对象实例。
		*@param index
		*@return
		*
		*/
		__proto.getChildAt=function(index){
			return this._rootContainer3D.getChildAt(index);
		}

		/**
		*返回位于指定名称的子显示对象实例。
		*@param name
		*@return
		*
		*/
		__proto.getChildByName=function(name){
			return this._rootContainer3D.getChildByName(name);
		}

		/**
		*返回 Object3D 的 child 实例的索引位置。
		*@param child
		*@return
		*
		*/
		__proto.getChildIndex=function(child){
			return this._rootContainer3D.getChildIndex(child);
		}

		/**
		*从 Object3D 实例的子列表中删除指定的 child Object3D 实例
		*@param child
		*@return
		*
		*/
		__proto.removeChild=function(child){
			return this._rootContainer3D.removeChild(child);
		}

		/**
		*从 Object3D 的子列表中指定的 index 位置删除子 Object3D。
		*@param index
		*@return
		*
		*/
		__proto.removeChildAt=function(index){
			return this._rootContainer3D.removeChildAt(index);
		}

		/**
		*从 Object3D 实例的子级列表中删除所有子 Object3D 实例。
		*@param beginIndex
		*@param endIndex
		*
		*/
		__proto.removeChildren=function(beginIndex,endIndex){
			(beginIndex===void 0)&& (beginIndex=0);
			(endIndex===void 0)&& (endIndex=2147483647);
			this._rootContainer3D.removeChildren(beginIndex,endIndex);
		}

		/**
		*销毁对象
		*
		*/
		__proto.dispose=function(){
			this._rootContainer3D.dispose();
		}

		__proto.update=function(time,dt){
			(dt===void 0)&& (dt=0);
			this._rootContainer3D.update(time,dt);
		}

		__getset(0,__proto,'name',function(){
			return this._name;
		});

		/**
		*返回此对象的子项数目。
		*@return
		*
		*/
		__getset(0,__proto,'numChildren',function(){
			return this._rootContainer3D.numChildren;
		});

		Scene3D.SCENE_DEFAULT_NAME="default_scene3d";
		Scene3D.__init$=function(){
			;
			/*namespace*/;
		}

		return Scene3D;
	})(EventDispatcher)


	;
	/**
	*Stage3D 类是specter3d显示对象的根节点。
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.Stage3D extends laya.events.EventDispatcher
	var Stage3D=(function(_super){
		function Stage3D(antialias){
			this._canvas=null;
			this.webglContext=null;
			this._antialias=true;
			this._backBufferHeight=0;
			this._backBufferWidth=0;
			this._color=0;
			this._defaultCamera=null;
			this._defaultScene=null;
			this._isEngineInit=false;
			this._mainLayer=null;
			this._mouseManager=null;
			this._cullFaceEnabled=false;
			this._cullFace=-1;
			Stage3D.__super.call(this);
			(antialias===void 0)&& (antialias=true);
			this._antialias=antialias;
			if (!this.initWebglContext3D()){
				alert("S3DEngine Stage3D init err,must support webGL!");
				return;
			}
			if (!Stage3D._layer3dHash){
				Stage3D._layer3dHash=new HashMap();
				this._defaultCamera=new PerspectiveCamera3D();
				this._defaultScene=new Scene3D();
				this._mainLayer=this.createLayer3d("defaultLayer3D");
			}
			else{
				throw new Error("This class is a multiton and cannot be instantiated manually.");
			}
		}

		__class(Stage3D,'specter3d.engine.core.Stage3D',_super);
		var __proto=Stage3D.prototype;
		Laya.imps(__proto,{"specter3d.engine.interfaces.IRenderUpdate":true})
		__proto.addChild=function(child,layerName){
			(layerName===void 0)&& (layerName="defaultLayer3D");
			var _layer3d=this.getLayer3D(layerName);
			if (_layer3d && _layer3d.scene3d)
				_layer3d.scene3d.addChild(child);
			return child;
		}

		__proto.addChildAt=function(child,index,layerName){
			(layerName===void 0)&& (layerName="defaultLayer3D");
			var _layer3d=this.getLayer3D(layerName);
			if (_layer3d && _layer3d.scene3d)
				_layer3d.scene3d.addChildAt(child,index);
			return child;
		}

		__proto.clear=function(){
			if (this.webglContext){
				this.webglContext.enable(0x0B71);
				this.webglContext.enable(0x0B44);
				this._cullFaceEnabled=true;
				this.webglContext.frontFace(0x0900);
				this.webglContext.clearColor(((this._color >> 16)& 0xff)/ 255.0,((this._color >> 8)& 0xff)/ 255.0,(this._color & 0xff)/ 255.0,((this._color >> 24)& 0xff)/ 255.0);
				this.webglContext.clear(0x00004000 | 0x00000100);
			}
		}

		__proto.clearDepthBuffer=function(){
			this.webglContext && this.webglContext.clearDepth(0x00000100);
		}

		/**
		*创建一个 Layer3d 默认情况下都是共用 一个 Camera 与 Scene 对象进行渲染，如果有多个Layer3d共用Camera 与 Scene时当前的Scene中所以对象将会被渲染多次
		*@param name 全局唯一名称
		*@param camera 默认为 defaultCamera
		*@param scene 默认为 _defaultScene
		*@return
		*
		*/
		__proto.createLayer3d=function(name,camera,scene){
			var _layer=new Layer3D(name,camera ? camera :this._defaultCamera,scene ? scene :this._defaultScene);
			Stage3D._layer3dHash.put(name,_layer);
			Stage3D._layer3ds.push(_layer);
			_layer.x=0;
			_layer.y=0;
			return _layer;
		}

		__proto.getChildAt=function(index,layerName){
			(layerName===void 0)&& (layerName="defaultLayer3D");
			var child;
			var _layer3d=this.getLayer3D(layerName);
			if (_layer3d && _layer3d.scene3d)
				child=_layer3d.scene3d.getChildAt(index);
			return child;
		}

		__proto.getChildByName=function(name,layerName){
			(layerName===void 0)&& (layerName="defaultLayer3D");
			var child;
			var _layer3d=this.getLayer3D(layerName);
			if (_layer3d && _layer3d.scene3d)
				child=_layer3d.scene3d.getChildByName(name);
			return child;
		}

		__proto.getChildIndex=function(child,layerName){
			(layerName===void 0)&& (layerName="defaultLayer3D");
			var index=-1;
			var _layer3d=this.getLayer3D(layerName);
			if (_layer3d && _layer3d.scene3d)
				index=_layer3d.scene3d.getChildIndex(child);
			return index;
		}

		__proto.getLayer3D=function(layerName){
			return Stage3D._layer3dHash.getValue(layerName);
		}

		__proto.removeChild=function(child,layerName){
			(layerName===void 0)&& (layerName="defaultLayer3D");
			var _layer3d=this.getLayer3D(layerName);
			if (_layer3d && _layer3d.scene3d)
				_layer3d.scene3d.removeChild(child);
			return child;
		}

		__proto.removeChildAt=function(index,layerName){
			(layerName===void 0)&& (layerName="defaultLayer3D");
			var child;
			var _layer3d=this.getLayer3D(layerName);
			if (_layer3d && _layer3d.scene3d)
				child=_layer3d.scene3d.removeChildAt(index);
			return child;
		}

		__proto.update=function(time,dt){
			(dt===void 0)&& (dt=0);
			var isResize=false;
			if (this._mainLayer.width !=Browser.clientWidth){
				this._mainLayer.width=Browser.clientWidth;
				isResize=true;
			}
			if (this._mainLayer.height !=Browser.clientHeight){
				this._mainLayer.height=Browser.clientHeight;
				isResize=true;
			}
			this.clear();
			for (var i=0;i < Stage3D._layer3ds.length;i++){
				this.clearDepthBuffer();
				Stage3D._layer3ds[i].update(time,dt);
				Stage3D._layer3ds[i].updateRender(this.webglContext,time,dt);
			}
			if (isResize && AppGlobalContext._instance.hasListener("resize")){
				AppGlobalContext._instance.event("resize");
			}
			if (!this._isEngineInit && AppGlobalContext._instance.hasListener("EngineInitComplete")){
				this._isEngineInit=true;
				AppGlobalContext._instance.event("EngineInitComplete");
			}
		}

		/**
		*初始化WebglContext3D
		*@return
		*
		*/
		__proto.initWebglContext3D=function(){
			this._canvas=Browser.document.getElementById('webglx');
			this._canvas.width=Browser.width;
			this._canvas.height=Browser.height;
			WebGL.mainContext=this.webglContext=this._canvas.getContext('webgl',{stencil:true,alpah:false,antialias:this._antialias,premultipliedAlpha:false});
			return this.webglContext !=null;
		}

		__getset(0,__proto,'mouseManager',function(){
			return this._mouseManager;
		});

		__getset(0,__proto,'backgroundColor',function(){
			return this._color;
			},function(value){
			this._color=value;
		});

		__getset(0,__proto,'cullFace',function(){
			return this._cullFace;
			},function(value){
			if (this._cullFace==value)
				return;
			this._cullFace=value;
			this.webglContext.cullFace(this._cullFace);
		});

		/**
		*舞台高
		*@return
		*
		*/
		__getset(0,__proto,'stageHeight',function(){
			return this._mainLayer.height;
		});

		__getset(0,__proto,'cullFaceEnabled',function(){
			return this._cullFaceEnabled;
			},function(value){
			if (this._cullFaceEnabled==value)
				return;
			this._cullFaceEnabled=value;
			if (this._cullFaceEnabled)
				this.webglContext.enable(0x0B44);
			else
			this.webglContext.disable(0x0B44);
		});

		/**
		*舞台宽
		*@return
		*
		*/
		__getset(0,__proto,'stageWidth',function(){
			return this._mainLayer.width;
		});

		__getset(0,__proto,'canvas',function(){
			return this._canvas;
		});

		Stage3D.DEFAULT_LAYER3D="defaultLayer3D";
		Stage3D._layer3dHash=null
		Stage3D._layer3ds=[];
		Stage3D.__init$=function(){
			/*namespace*/;;
		}

		return Stage3D;
	})(EventDispatcher)


	;
	/**
	*Transform3D
	*@author wangcx
	*
	*/
	//class specter3d.engine.core.Transform3D extends laya.events.EventDispatcher
	var Transform3D=(function(_super){
		function Transform3D(owner){
			this._dirty=false;
			this._dirtyInv=false;
			this._invWorld=null;
			this._local=null;
			this._modelView=null;
			this._mvp=null;
			this._owner=null;
			this._world=null;
			Transform3D.__super.call(this);
			this._owner=owner;
			this._local=new Matrix3D();
			this._world=new Matrix3D();
			this._invWorld=new Matrix3D();
			this._modelView=new Matrix3D();
		}

		__class(Transform3D,'specter3d.engine.core.Transform3D',_super);
		var __proto=Transform3D.prototype;
		// 全局transform
		__proto.clone=function(owner){
			owner.transform.local.copyFrom(this._local);
			owner.transform.world.copyFrom(this._world);
			owner.transform.invWorld.copyFrom(this._invWorld);
			owner.transform._dirty=this._dirty;
			owner.transform._dirtyInv=this._dirtyInv;
			return owner.transform;
		}

		/**
		*后方方向
		*@param local
		*@param out
		*@return
		*
		*/
		__proto.getBackward=function(local,out){
			(local===void 0)&& (local=true);
			return Matrix3DUtils.getBackward(local ? this.local :this.world,out);
		}

		/**
		*前方方向
		*@param local
		*@param out
		*@return
		*
		*/
		__proto.getDir=function(local,out){
			(local===void 0)&& (local=true);
			return Matrix3DUtils.getDir(local ? this.local :this.world,out);
		}

		/**
		*下方方向
		*@param local
		*@param out
		*@return
		*
		*/
		__proto.getDown=function(local,out){
			(local===void 0)&& (local=true);
			return Matrix3DUtils.getDown(local ? this.local :this.world,out);
		}

		/**
		*左方方向
		*@param local
		*@param out
		*@return
		*
		*/
		__proto.getLeft=function(local,out){
			(local===void 0)&& (local=true);
			return Matrix3DUtils.getLeft(local ? this.local :this.world,out);
		}

		/**
		*获取位移
		*@param local local?
		*@param out position
		*@return position
		*/
		__proto.getPosition=function(local,out){
			(local===void 0)&& (local=true);
			return Matrix3DUtils.getPosition(local ? this.local :this.world,out);
		}

		/**
		*右方方向
		*@param local
		*@param out
		*@return
		*
		*/
		__proto.getRight=function(local,out){
			(local===void 0)&& (local=true);
			return Matrix3DUtils.getRight(local ? this.local :this.world,out);
		}

		/**
		*该方式是以欧拉角得方式获取，因此获取的角度值为-90到90范围。
		*如果想要以360度方式获取，或者其他方式。自己在外面缓存当前设置的角度值，
		*或者使用 getRotationX/Y/Z方式获取。该方式是通过计算dir向量来计算
		*@param local
		*@param out
		*@return
		*
		*/
		__proto.getRotation=function(local,out){
			(local===void 0)&& (local=true);
			return Matrix3DUtils.getRotation(local ? this.local :this.world,out);
		}

		/**
		*获取rotationX值，该值范围为-180到180。使用欧拉角获取的数据只能为-90到90。因此需要根据方位计算出更大范围的值。
		*@param local
		*@return
		*
		*/
		__proto.getRotationX=function(local){
			var dir=this.getDir(local);
			var ang=Math.atan2(dir.y,dir.z)*180 / Math.PI;
			return ang;
		}

		/**
		*获取rotationY值，该值范围为-180到180。使用欧拉角获取的数据只能为-90到90。因此需要根据方位计算出更大范围的值。
		*@param local
		*@return
		*/
		__proto.getRotationY=function(local){
			var dir=this.getDir(local);
			var ang=Math.atan2(dir.x,dir.z)*180 / Math.PI;
			return ang;
		}

		/**
		*获取rotationZ值，该值范围为-180到180。使用欧拉角获取的数据只能为-90到90。因此需要根据方位计算出更大范围的值。
		*@param local
		*@return
		*
		*/
		__proto.getRotationZ=function(local){
			var dir=this.getDir(local);
			var ang=Math.atan2(dir.x,dir.y)*180 / Math.PI;
			return ang;
		}

		/**
		*获取缩放值
		*@param local local
		*@param out 缩放值
		*@return 缩放值
		*
		*/
		__proto.getScale=function(local,out){
			(local===void 0)&& (local=true);
			return Matrix3DUtils.getScale(local ? this.local :this.world,out);
		}

		/**
		*上方方向
		*@param local
		*@param out
		*@return
		*
		*/
		__proto.getUp=function(local,out){
			(local===void 0)&& (local=true);
			return Matrix3DUtils.getUp(local ? this.local :this.world,out);
		}

		/**
		*全局转本地
		*@param point
		*@param out
		*@return
		*
		*/
		__proto.globalToLocal=function(point,out){
			return Matrix3DUtils.transformVector(this.invWorld,point,out);
		}

		/**
		*全局转本地
		*@param vector
		*@param out
		*@return
		*
		*/
		__proto.globalToLocalVector=function(vector,out){
			return out=Matrix3DUtils.deltaTransformVector(this.invWorld,vector,out);
		}

		/**
		*本地转全局
		*@param point
		*@param out
		*@return
		*
		*/
		__proto.localToGlobal=function(point,out){
			return Matrix3DUtils.transformVector(this.world,point,out);
		}

		/**
		*本地转全局
		*@param vector
		*@param out
		*@return
		*
		*/
		__proto.localToGlobalVector=function(vector,out){
			return Matrix3DUtils.deltaTransformVector(this.world,vector,out);
		}

		/**
		*设置pivot朝向。pivot会朝着目的点
		*@param x target x
		*@param y target y
		*@param z target z
		*@param up 可以指定pivot的up方向，指定时候pivot会根据该up方向来确定朝向方位。
		*@param smooth 插值
		*
		*/
		__proto.lookAt=function(x,y,z,up,smooth){
			(smooth===void 0)&& (smooth=1);
			Matrix3DUtils.lookAt(this.local,x,y,z,up,smooth);
			this.updateTransforms(true);
		}

		/**
		*绕着指定轴线进行旋转
		*@param angle 角度
		*@param axis 轴
		*@param pivotPoint 参照点，默认为自身。
		*
		*/
		__proto.rotateAxis=function(angle,axis,pivotPoint){
			Matrix3DUtils.rotateAxis(this.local,angle,axis,pivotPoint);
			this.updateTransforms(true);
			this.hasListener("rotationChanged")&& this.event("rotationChanged");
		}

		/**
		*会在上一次的基础上进行旋转。例:当前角度为30,旋转角度为15，那么结果角度就为45而不是15。setRotation(x,y,z)属于直接设置值
		*@param angle 角度
		*@param local
		*@param pivotPoint 旋转参照点。例如pivotPoint->(0,0,0)，那么pivot会绕着0,0,0进行旋转，默认为自身。
		*
		*/
		__proto.rotateX=function(angle,local,pivotPoint){
			(local===void 0)&& (local=true);
			Matrix3DUtils.rotateX(this.local,angle,local,pivotPoint);
			this.updateTransforms(true);
			this.hasListener("rotationChanged")&& this.event("rotationChanged");
		}

		/**
		*会在上一次的基础上进行旋转。例:当前角度为30,旋转角度为15，那么结果角度就为45而不是15。setRotation(x,y,z)属于直接设置值
		*@param angle 角度
		*@param local
		*@param pivotPoint 旋转参照点。例如pivotPoint->(0,0,0)，那么pivot会绕着0,0,0进行旋转，默认为自身。
		*
		*/
		__proto.rotateY=function(angle,local,pivotPoint){
			(local===void 0)&& (local=true);
			Matrix3DUtils.rotateY(this.local,angle,local,pivotPoint);
			this.updateTransforms(true);
			this.hasListener("rotationChanged")&& this.event("rotationChanged");
		}

		/**
		*会在上一次的基础上进行旋转。例:当前角度为30,旋转角度为15，那么结果角度就为45而不是15。setRotation(x,y,z)属于直接设置值
		*@param angle 角度
		*@param local
		*@param pivotPoint 旋转参照点。例如pivotPoint->(0,0,0)，那么pivot会绕着0,0,0进行旋转，默认为自身。
		*
		*/
		__proto.rotateZ=function(angle,local,pivotPoint){
			(local===void 0)&& (local=true);
			Matrix3DUtils.rotateZ(this.local,angle,local,pivotPoint);
			this.updateTransforms(true);
			this.hasListener("rotationChanged")&& this.event("rotationChanged");
		}

		/**
		*设置朝向，例如面向摄像机
		*@param dir 朝向
		*@param up up vector
		*@param smooth 插值
		*/
		__proto.setOrientation=function(dir,up,smooth){
			(smooth===void 0)&& (smooth=1);
			Matrix3DUtils.setOrientation(this.local,dir,up,smooth);
			this.updateTransforms(true);
		}

		/**
		*设置坐标
		*@param x x
		*@param y y
		*@param z z
		*@param smooth
		*@param local
		*
		*/
		__proto.setPosition=function(x,y,z,smooth){
			(smooth===void 0)&& (smooth=1);
			Matrix3DUtils.setPosition(this.local,x,y,z,smooth);
			this.updateTransforms(true);
			this.hasListener("positionChanged")&& this.event("positionChanged");
		}

		/**
		*设置Rotation
		*@param x
		*@param y
		*@param z
		*
		*/
		__proto.setRotation=function(x,y,z){
			Matrix3DUtils.setRotation(this.local,x,y,z);
			this.updateTransforms(true);
			this.hasListener("rotationChanged")&& this.event("rotationChanged");
		}

		/**
		*设置缩放
		*@param value 缩放值
		*@param smooth 插值
		*
		*/
		__proto.setScale=function(value,smooth){
			(smooth===void 0)&& (smooth=1);
			Matrix3DUtils.setScale(this.local,value,value,value,smooth);
			this.updateTransforms(true);
			this.hasListener("scaleChanged")&& this.event("scaleChanged");
		}

		/**
		*设置pivot位移。该位移以世界坐标轴为参照物。
		*@param x
		*@param y
		*@param z
		*@param local
		*
		*/
		__proto.setTranslation=function(x,y,z,local){
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(local===void 0)&& (local=true);
			Matrix3DUtils.setTranslation(this.local,x,y,z,local);
			this.updateTransforms(true);
			this.hasListener("positionChanged")&& this.event("positionChanged");
		}

		__proto.translateAxis=function(distance,axis){
			Matrix3DUtils.translateAxis(this.local,distance,axis);
			this.updateTransforms(true);
			this.hasListener("positionChanged")&& this.event("positionChanged");
		}

		__proto.translateX=function(distance,local){
			(local===void 0)&& (local=true);
			Matrix3DUtils.translateX(this.local,distance);
			this.updateTransforms(true);
			this.hasListener("positionChanged")&& this.event("positionChanged");
		}

		__proto.translateY=function(distance,local){
			(local===void 0)&& (local=true);
			Matrix3DUtils.translateY(this.local,distance,local);
			this.updateTransforms(true);
			this.hasListener("positionChanged")&& this.event("positionChanged");
		}

		__proto.translateZ=function(distance,local){
			(local===void 0)&& (local=true);
			Matrix3DUtils.translateZ(this.local,distance,local);
			this.updateTransforms(true);
			this.hasListener("positionChanged")&& this.event("positionChanged");
		}

		/**
		*update model-->view-->projection (MVP)
		*@param _camera
		*
		*/
		__proto.updateModelViewProjection=function(_camera){
			if (!this._mvp)
				this._mvp=new Matrix3D();
			this._mvp.identity();
			this._mvp.copyFrom(this.world);
			this._mvp.append(_camera.modelViewMatrix);
		}

		/**
		*update transform
		*@param includeChildren
		*
		*/
		__proto.updateTransforms=function(includeChildren){
			this._dirty=true;
			this._dirtyInv=true;
			if (includeChildren){
				for (var object=this._owner._childrenList;object !=null;object=object._next){
					object.transform.updateTransforms(includeChildren);
				}
			}
			this.hasListener("update_transform")&& this.event("update_transform");
		}

		/**
		*世界逆矩阵
		*@return
		*
		*/
		__getset(0,__proto,'invWorld',function(){
			if (this._dirty || this._dirtyInv){
				this._invWorld.copyFrom(this.world);
				this._invWorld.invert();
				this._dirtyInv=false;
			}
			return this._invWorld
		});

		/**
		*模型世界矩阵
		*@return
		*
		*/
		__getset(0,__proto,'world',function(){
			if (this._dirty){
				this._world.copyFrom(this.local);
				if (this._owner.parent){
					this._world.append(this._owner.parent.transform.world);
				}
				this._dirty=false;
				this._dirtyInv=true;
			}
			return this._world;
			},function(value){
			this.local.copyFrom(value);
			if (this._owner.parent){
				this.local.append(this._owner.parent.transform.invWorld);
			}
			this.updateTransforms(true);
		});

		/**
		*设置x轴缩放值
		*@param val
		*
		*/
		/**
		*获取x轴缩放值
		*@return
		*
		*/
		__getset(0,__proto,'scaleX',function(){
			return Matrix3DUtils.getRight(this.local,Vector3DUtils.vec0).length;
			},function(val){
			Matrix3DUtils.scaleX(this.local,val);
			this.updateTransforms(true);
			this.hasListener("scaleChanged")&& this.event("scaleChanged");
		});

		/**
		*设置y轴缩放值
		*@param val
		*
		*/
		/**
		*获取y轴缩放值
		*@return
		*
		*/
		__getset(0,__proto,'scaleY',function(){
			return Matrix3DUtils.getUp(this.local,Vector3DUtils.vec0).length;
			},function(val){
			Matrix3DUtils.scaleY(this.local,val);
			this.updateTransforms(true);
			this.hasListener("scaleChanged")&& this.event("scaleChanged");
		});

		/**
		*local
		*@return
		*
		*/
		__getset(0,__proto,'local',function(){
			return this._local;
		});

		/**
		*设置z轴缩放值
		*@param val
		*
		*/
		/**
		*获取z轴缩放值
		*@return
		*
		*/
		__getset(0,__proto,'scaleZ',function(){
			return Matrix3DUtils.getDir(this.local,Vector3DUtils.vec0).length;
			},function(val){
			Matrix3DUtils.scaleZ(this.local,val);
			this.updateTransforms(true);
			this.hasListener("scaleChanged")&& this.event("scaleChanged");
		});

		/**
		*模型-视图 矩阵
		*@return
		*
		*/
		__getset(0,__proto,'modelView',function(){
			this._modelView.identity();
			this._modelView.copyFrom(this.world);
			return this._modelView;
		});

		/**
		*model-->view-->projection (MVP)
		*@return
		*
		*/
		__getset(0,__proto,'modelViewProjection',function(){
			return this._mvp;
		});

		/**
		*设置x坐标
		*@param val
		*
		*/
		/**
		*获取x坐标
		*@return
		*
		*/
		__getset(0,__proto,'x',function(){
			this.local.copyColumnTo(3,Vector3DUtils.vec0);
			return Vector3DUtils.vec0.x;
			},function(val){
			this.local.copyColumnTo(3,Vector3DUtils.vec0);
			Vector3DUtils.vec0.x=val;
			this.local.copyColumnFrom(3,Vector3DUtils.vec0);
			this.updateTransforms(true);
			this.hasListener("positionChanged")&& this.event("positionChanged");
		});

		/**
		*设置y坐标
		*@param val
		*
		*/
		/**
		*获取y坐标
		*@return
		*
		*/
		__getset(0,__proto,'y',function(){
			this.local.copyColumnTo(3,Vector3DUtils.vec0);
			return Vector3DUtils.vec0.y;
			},function(val){
			this.local.copyColumnTo(3,Vector3DUtils.vec0);
			Vector3DUtils.vec0.y=val;
			this.local.copyColumnFrom(3,Vector3DUtils.vec0);
			this.updateTransforms(true);
			this.hasListener("positionChanged")&& this.event("positionChanged");
		});

		/**
		*设置z坐标
		*@param val
		*
		*/
		/**
		*获取z坐标
		*@return
		*
		*/
		__getset(0,__proto,'z',function(){
			this.local.copyColumnTo(3,Vector3DUtils.vec0);
			return Vector3DUtils.vec0.z;
			},function(val){
			this.local.copyColumnTo(3,Vector3DUtils.vec0);
			Vector3DUtils.vec0.z=val;
			this.local.copyColumnFrom(3,Vector3DUtils.vec0);
			this.updateTransforms(true);
			this.hasListener("positionChanged")&& this.event("positionChanged");
		});

		Transform3D.__init$=function(){
			/*namespace*/;
			/*namespace*/;
		}

		return Transform3D;
	})(EventDispatcher)


	//class specter3d.engine.loaders.FileLoader extends laya.events.EventDispatcher
	var FileLoader=(function(_super){
		function FileLoader(target){
			this._urlLoader=null;
			this._url=null;
			this._group=null;
			FileLoader.__super.call(this);
		}

		__class(FileLoader,'specter3d.engine.loaders.FileLoader',_super);
		var __proto=FileLoader.prototype;
		/**
		*分解文件后缀
		*@param url
		*@return
		*
		*/
		__proto.decomposeFileSuffix=function(url){
			if (!url){
				return "";
			};
			var lastIndex=url.lastIndexOf(".");
			var type=url.substr(lastIndex);
			return type.toLocaleLowerCase();
		}

		/**
		*加载
		*@param url
		*
		*/
		__proto.load=function(url,group){
			this._url=url;
			this._group=group;
			this.removeAllLoadEvent();
			this._urlLoader==null && (this._urlLoader=new URLLoader());
			this._urlLoader.on("onLoadProgress",this,this.progressing);
			this._urlLoader.on("onLoadError",this,this.onFileLoaderError);
			this._urlLoader.on("onLoadComplete",this,this.onFileLoaderOver);
			var responseType="";
			var fileType=this.decomposeFileSuffix(this._url);
			if (fileType==".jpg" || fileType==".png"){
				responseType="image";
			}
			else if (fileType==".mp3"){
				responseType="sound";
			}
			else{
				responseType="arraybuffer";
			}
			if(AssetLib.requestErrorDic.indexOf(url)!=-1){
				this._urlLoader.send(this.urlRequest(this._url+"?error="+AppGlobalContext.timer.currTimer),null,null,responseType);
			}
			else{
				this._urlLoader.send(this.urlRequest(this._url),null,null,responseType);
			}
			return this._urlLoader;
		}

		__proto.removeAllLoadEvent=function(){
			if(this._urlLoader !=null){
				this._urlLoader.offAll("onLoadProgress");
				this._urlLoader.offAll("onLoadComplete");
				this._urlLoader.offAll("onLoadError");
			}
		}

		__proto.urlRequest=function($url){
			$url=FileLoader.formatPath($url);
			var __realUrl=AssetLib.getRealUrl ? AssetLib.getRealUrl($url):null;
			if (__realUrl==null){
				if (AppGlobalContext.telnetBasePath !=null){
					$url=AppGlobalContext.telnetBasePath+"/"+$url;
				}
				return $url;
			}
			return __realUrl;
		}

		/**
		*开始下一次加载
		*
		*/
		__proto.nextLoad=function(failure){
			(failure===void 0)&& (failure=false);
		}

		__proto.onAssetComplete=function(event){
			AssetLib.putAsset(this._url,event.asset,this._group ? this._group :"default_group");
		}

		__proto.onCurrentParseComplete=function(_parser){
			_parser.offAll('parseError');
			_parser.offAll("assetComplete");
			_parser.offAll('parseComplete');
			this.nextLoad();
		}

		/**
		*加载失败
		*@param event
		*
		*/
		__proto.onFileLoaderError=function(event){
			this.removeAllLoadEvent();
			Debug.error("engine","载入失败:"+this._url+"\n 【"+event.text+"】");
		}

		/**
		*加载完成
		*@param event
		*
		*/
		__proto.onFileLoaderOver=function(event){
			this.removeAllLoadEvent();
		}

		/**
		*解析加载的数据
		*@param data 类型
		*
		*/
		__proto.parseData=function(data){
			var _parser=this.getParserFromSuffix();
			if (_parser !=null){
				_parser.name=this._url;
				_parser.on("assetComplete",this,this.onAssetComplete);
				_parser.on('parseComplete',this,this.onCurrentParseComplete,[_parser]);
				_parser.on('parseError',this,this.parserFileError,[_parser]);
				_parser.parseAsync(data);
			}
			else{
				AssetLib.putAsset(this._url,data,this._group);
				this.nextLoad();
			}
		}

		__proto.parserFileError=function(_parser){
			_parser.offAll('parseError');
			_parser.offAll("assetComplete");
			_parser.offAll('parseComplete');
			Debug.error("engine","解析失败:"+this._url);
			this.nextLoad(true);
		}

		/**
		*根据后缀获得对应的解析器
		*@return
		*
		*/
		__proto.getParserFromSuffix=function(){
			var _suffix=this.decomposeFileSuffix(this._url);
			var _parser=FileLoader._parserSet.getValue(_suffix);
			if (Laya.__isClass(_parser)){
				var _parserObj=new _parser();
				return _parserObj;
			}
			return null;
		}

		/**
		*进度条控制
		*@param event
		*
		*/
		__proto.progressing=function(event){
			this.dispatchEvent(event);
		}

		/**
		*资源url
		*/
		__getset(0,__proto,'url',function(){
			return this._url;
		});

		FileLoader.registerParser=function(_suffix,_parserClass){
			var _parser=FileLoader._parserSet.getValue(_suffix);
			!_parser && FileLoader._parserSet.put(_suffix,_parserClass);
		}

		FileLoader.registerParserAll=function(){
			FileLoader.registerParser(".3ds",C3DSParser);
			FileLoader.registerParser(".zmd5mesh",MD5MeshParser);
		}

		FileLoader.formatPath=function(path){
			if (path==null){
				return "";
			}
			path=path.replace(/\\\\/g,"\\");
			path=path.replace(/\\/g,"/");
			return path;
		}

		__static(FileLoader,
		['_parserSet',function(){return this._parserSet=new HashMap;}
		]);
		return FileLoader;
	})(EventDispatcher)


	/**
	*解析器基类
	*/
	//class specter3d.engine.loaders.parsers.ParserBase extends laya.events.EventDispatcher
	var ParserBase=(function(_super){
		function ParserBase(format){
			this.isParsering=false;
			this.url=null;
			this._data=null;
			this._dataFormat=null;
			this._frameLimit=NaN;
			this._name=null;
			this._parsingComplete=false;
			this._parsingFailure=false;
			this._parsingPaused=false;
			this._timer=null;
			ParserBase.__super.call(this);
			this._dataFormat=format;
		}

		__class(ParserBase,'specter3d.engine.loaders.parsers.ParserBase',_super);
		var __proto=ParserBase.prototype;
		/**
		*分析数据（可能含有bytearry，纯文本或bitmapasset）是异步的，即解析器将定期停止解析，AVM可能前进到下一帧。
		*@param data
		*@param frameLimit
		*
		*/
		__proto.parseAsync=function(data,frameLimit){
			(frameLimit===void 0)&& (frameLimit=30);
			this._data=data;
			this.startParsing(frameLimit);
		}

		__proto.finalizeAsset=function(asset){
			this.dispatchEvent(new AssetEvent("assetComplete",asset));
		}

		/**
		*完成对数据的解析。
		*/
		__proto.finishParsing=function(isError){
			(isError===void 0)&& (isError=false);
			AppGlobalContext.timer.clear(this,this.onInterval);
			this._parsingComplete=true;
			if (isError){
				this.dispatchEvent(new ParserEvent('parseError'));
			}
			else{
				if (this.hasListener('parseComplete')){
					this.dispatchEvent(new ParserEvent('parseComplete'));
				}
			}
		}

		__proto.getByteData=function(){
			return ParserUtil.toByte(this._data);
		}

		__proto.getTextData=function(){
			return ParserUtil.toString(this._data);
		}

		__proto.onInterval=function(){
			(this.proceedParsing()&& !this._parsingFailure)&& this.finishParsing();
		}

		/**
		*解析下一个数据块。
		*@return
		*
		*/
		__proto.proceedParsing=function(){
			throw new AbstractMethodError();
			return true;
		}

		/**
		*初始化数据解析。
		*@param frameLimit
		*/
		__proto.startParsing=function(frameLimit){
			this._frameLimit=frameLimit;
			AppGlobalContext.timer.loop(this._frameLimit,this,this.onInterval);
		}

		/**
		*要解析的文件数据的数据格式。可以是Parserdataformat.binary或Parserdataformat.plain_text。
		*/
		__getset(0,__proto,'dataFormat',function(){
			return this._dataFormat;
		});

		__getset(0,__proto,'name',function(){
			return this._name;
			},function(value){
			this._name=value;
		});

		__getset(0,__proto,'parsingComplete',function(){
			return this._parsingComplete;
		});

		__getset(0,__proto,'parsingFailure',function(){
			return this._parsingFailure;
			},function(b){
			this._parsingFailure=b;
		});

		__getset(0,__proto,'parsingPaused',function(){
			return this._parsingPaused;
		});

		ParserBase.MORE_TO_PARSE=false;
		ParserBase.PARSING_DONE=true;
		return ParserBase;
	})(EventDispatcher)


	//class specter3d.engine.loaders.ResourceVo extends laya.events.EventDispatcher
	var ResourceVo=(function(_super){
		function ResourceVo(url,_level,_callBackHandler,_errorCallBackHandler){
			this.group=null;
			this.token=null;
			this.loadTime=0;
			this._url=null;
			this.level=1;
			this.reqeuestTime=0;
			this.callBackHandler=null;
			this.errorCallBackHandler=null;
			this.progressCallBackHandler=null;
			ResourceVo.__super.call(this);
			(_level===void 0)&& (_level=1);
			this._url=AssetLib.operationUrlByVersion(url);
			this.level=_level;
			this.errorCallBackHandler=_errorCallBackHandler;
			this.callBackHandler=_callBackHandler;
		}

		__class(ResourceVo,'specter3d.engine.loaders.ResourceVo',_super);
		var __proto=ResourceVo.prototype;
		__proto.progressing=function(e){
			if (this.progressCallBackHandler !=null){
				this.progressCallBackHandler.runWith(e);
			}
			this.dispatchEvent(e);
		}

		/**
		*资源url
		*/
		__getset(0,__proto,'url',function(){
			return this._url;
			},function(value){
			this._url=value;
		});

		ResourceVo.START="start";
		ResourceVo.FINISH="finish";
		ResourceVo.ERROR="error";
		return ResourceVo;
	})(EventDispatcher)


	/**
	*<code>HttpRequest</code> 通过 HTTP 协议传送或接收 XML 及其他数据。
	*/
	//class specter3d.engine.loaders.URLLoader extends laya.events.EventDispatcher
	var URLLoader=(function(_super){
		function URLLoader(){
			this._responseType=null;
			this._data=null;
			this._progressEvent=null;
			this._bytesLoaded=0;
			this._bytesTotal=0;
			URLLoader.__super.call(this);
			this._http=new Browser.window.XMLHttpRequest();
			this._event=new LoaderEvent();
		}

		__class(URLLoader,'specter3d.engine.loaders.URLLoader',_super);
		var __proto=URLLoader.prototype;
		/**
		*发送请求。
		*@param url 请求的地址。
		*@param data 发送的数据，可选。
		*@param method 发送数据方式，值为“get”或“post”，默认为 “get”方式。
		*@param responseType 返回消息类型，可设置为"text"，"json"，"xml","arraybuffer"。
		*@param headers 头信息，key value数组，比如["Content-Type","application/json"]。
		*/
		__proto.send=function(url,data,method,responseType,headers){
			(method===void 0)&& (method="get");
			(responseType===void 0)&& (responseType="text");
			this._responseType=responseType;
			this._data=null;
			if (responseType==="image" || responseType==="htmlimage" || responseType==="nativeimage")return this._loadImage(url);
			if (responseType==="sound")return this._loadSound(url);
			var _this=this;
			var http=this._http;
			method="get";
			http.open(method,url,true);
			if (headers){
				for (var i=0;i < headers.length;i++){
					http.setRequestHeader(headers[i++],headers[i]);
				}
				}else {
				if (!data || (typeof data=='string'))http.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
				else http.setRequestHeader("Content-Type","application/json");
			}
			http.responseType=responseType!=="arraybuffer" ? "text" :"arraybuffer";
			http.onerror=function (e){
				_this._onError(e);
			}
			http.onabort=function (e){
				_this._onAbort(e);
			}
			http.onprogress=function (e){
				_this._onProgress(e);
			}
			http.onload=function (e){
				_this._onLoad(e);
			}
			http.send(data);
		}

		/**
		*@private
		*加载图片资源。
		*@param url 资源地址。
		*/
		__proto._loadImage=function(url){
			if (this._responseType==="nativeimage"){
				var image=new Browser.window.Image();
				image.crossOrigin="";
				image.src=url;
				}else {
				image=new HTMLImage.create(url);
			};
			var _this=this;
			image.onload=function (){
				_clear();
				_this.onLoaded(image);
			};
			image.onerror=function (){
				_clear();
				_this.event("error","Load image filed");
			}
			function _clear (){
				image.onload=null;
				image.onerror=null;
			}
		}

		/**
		*@private
		*加载声音资源。
		*@param url 资源地址。
		*/
		__proto._loadSound=function(url){
			var sound=new Sound();
			var _this=this;
			sound.on("complete",this,_soundOnload);
			sound.on("error",this,_soundOnErr);
			sound.load(url);
			function _soundOnload (){
				_clear();
				_this.onLoaded(sound);
			}
			function _soundOnErr (){
				_clear();
				_this.event("error","Load sound filed");
			}
			function _clear (){
				sound.offAll();
			}
		}

		/**
		*资源加载完成的处理函数。
		*@param data 数据。
		*/
		__proto.onLoaded=function(data){
			this.clear();
			this._data=data;
			this._event.target=this;
			this._event.currentTarget=this;
			this._event.type="onLoadComplete";
			this.dispatchEvent(this._event);
		}

		/**
		*@private
		*请求进度的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onProgress=function(e){
			this._bytesLoaded=e.loaded;
			this._bytesTotal=e.total;
			if (e && e.lengthComputable){
				this._progressEvent=e;
				this._event.target=this;
				this._event.currentTarget=this;
				this._event.type="onLoadProgress";
				this.dispatchEvent(this._event);
			}
		}

		/**
		*@private
		*请求中断的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onAbort=function(e){
			this.error("Request was aborted by user");
		}

		/**
		*@private
		*请求出错侦的听处理函数。
		*@param e 事件对象。
		*/
		__proto._onError=function(e){
			this.error("Request failed Status:"+this._http.status+" text:"+this._http.statusText);
		}

		/**
		*@private
		*请求消息返回的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onLoad=function(e){
			var http=this._http;
			var status=http.status!==undefined ? http.status :200;
			if (status===200 || status===204 || status===0){
				this.complete();
				}else {
				this.error("["+http.status+"]"+http.statusText+":"+http.responseURL);
			}
		}

		/**
		*@private
		*请求错误的处理函数。
		*@param message 错误信息。
		*/
		__proto.error=function(message){
			this.clear();
			this._event.type="onLoadError";
			this._event.text=message;
			this.dispatchEvent(this._event);
		}

		/**
		*@private
		*请求成功完成的处理函数。
		*/
		__proto.complete=function(){
			this.clear();
			if (this._responseType==="json"){
				this._data=JSON.parse(this._http.responseText);
				}else if (this._responseType==="xml"){
				this._data=Utils.parseXMLFromString(this._http.responseText);
				}else {
				this._data=this._http.response || this._http.responseText;
			}
			this._event.target=this;
			this._event.currentTarget=this;
			this._event.type="onLoadComplete";
			this.dispatchEvent(this._event);
		}

		/**
		*@private
		*清除当前请求。
		*/
		__proto.clear=function(){
			var http=this._http;
			http.onerror=http.onabort=http.onprogress=http.onload=null;
		}

		/**返回的数据。*/
		__getset(0,__proto,'data',function(){
			return this._data;
		});

		/**请求的地址。*/
		__getset(0,__proto,'url',function(){
			return this._http.responseURL;
		});

		/**已加载数据大小。*/
		__getset(0,__proto,'bytesLoaded',function(){
			return this._progressEvent ? this._progressEvent.loaded :0;;
		});

		/**总数据大小。*/
		__getset(0,__proto,'bytesTotal',function(){
			return this._progressEvent ? this._progressEvent.total :0;
		});

		URLLoader.TEXT="text";
		URLLoader.BUFFER="arraybuffer";
		URLLoader.IMAGE="image";
		URLLoader.SOUND="sound";
		return URLLoader;
	})(EventDispatcher)


	//class specter3d.engine.events.AssetEvent extends laya.events.Event
	var AssetEvent=(function(_super){
		function AssetEvent(_type,asset){
			this._asset=null;
			AssetEvent.__super.call(this);
			this.type=_type;
			this._asset=asset;
		}

		__class(AssetEvent,'specter3d.engine.events.AssetEvent',_super);
		var __proto=AssetEvent.prototype;
		__proto.clone=function(){
			return new AssetEvent(this.type,this.asset);
		}

		__getset(0,__proto,'asset',function(){
			return this._asset;
		});

		AssetEvent.ASSET_COMPLETE="assetComplete";
		AssetEvent.ASSET_RENAME='assetRename';
		AssetEvent.ASSET_CONFLICT_RESOLVED='assetConflictResolved';
		return AssetEvent;
	})(Event)


	/**
	*<code>MouseManager</code> 是鼠标、触摸交互管理器。
	*/
	//class specter3d.engine.managers.NativeEventManager extends laya.events.EventDispatcher
	var NativeEventManager=(function(_super){
		function NativeEventManager(){
			this.mouseX=0;
			this.mouseY=0;
			this.disableMouseEvent=false;
			this.mouseDownTime=0;
			this._target=null;
			this._lastOvers=[];
			this._currOvers=[];
			this._lastClickTimer=0;
			this._lastMoveTimer=0;
			this._isDoubleClick=false;
			this._isLeftMouse=false;
			this._eventList=[];
			NativeEventManager.__super.call(this);
			this._event=new Event();
			this._matrix=new Matrix();
			this._point=new Point();
			this._rect=new Rectangle();
		}

		__class(NativeEventManager,'specter3d.engine.managers.NativeEventManager',_super);
		var __proto=NativeEventManager.prototype;
		/**
		*@private
		*初始化。
		*/
		__proto.__init__=function(canvas){
			var _this=this;
			var list=this._eventList;
			canvas.oncontextmenu=function (e){
				if (NativeEventManager.enabled)return false;
			}
			canvas.addEventListener('mousedown',function(e){
				if (NativeEventManager.enabled){
					e.preventDefault();
					list.push(e);
					_this.mouseDownTime=Browser.now();
				}
			});
			canvas.addEventListener('mouseup',function(e){
				if (NativeEventManager.enabled){
					e.preventDefault();
					list.push(e);
					_this.mouseDownTime=-Browser.now();
				}
			},true);
			canvas.addEventListener('mousemove',function(e){
				if (NativeEventManager.enabled){
					e.preventDefault();
					var now=Browser.now();
					if (now-_this._lastMoveTimer < 10)return;
					_this._lastMoveTimer=now;
					list.push(e);
				}
			},true);
			canvas.addEventListener("mouseout",function(e){
				if (NativeEventManager.enabled)list.push(e);
			})
			canvas.addEventListener("mouseover",function(e){
				if (NativeEventManager.enabled)list.push(e);
			})
			canvas.addEventListener("touchstart",function(e){
				if (NativeEventManager.enabled){
					if(!Input.IOS_IFRAME)e.preventDefault();
					list.push(e);
					_this.mouseDownTime=Browser.now();
				}
			});
			canvas.addEventListener("touchend",function(e){
				if (NativeEventManager.enabled){
					if(!Input.IOS_IFRAME)e.preventDefault();
					list.push(e);
					_this.mouseDownTime=-Browser.now();
				}
			},true);
			canvas.addEventListener("touchmove",function(e){
				if (NativeEventManager.enabled){
					e.preventDefault();
					list.push(e);
				}
			},true);
			canvas.addEventListener('mousewheel',function(e){
				if (NativeEventManager.enabled)list.push(e);
			});
			canvas.addEventListener('DOMMouseScroll',function(e){
				if (NativeEventManager.enabled)list.push(e);
			});
		}

		__proto.initEvent=function(e,nativeEvent){
			var _this=this;
			_this._event._stoped=false;
			_this._event.nativeEvent=nativeEvent || e;
			_this._target=null;
			this._point.setTo(e.clientX,e.clientY);
			_this.mouseX=this._point.x;
			_this.mouseY=this._point.y;
			_this._event.touchId=e.identifier;
			_this._event.mouseX=this._point.x;
			_this._event.mouseY=this._point.y;
		}

		__proto.checkMouseWheel=function(e){
			this._event.delta=e.wheelDelta ? e.wheelDelta *0.025 :-e.detail;
			for (var i=0,n=this._lastOvers.length;i < n;i++){
				var ele=this._lastOvers[i];
				ele.event("mousewheel",this._event.setTo("mousewheel",ele,this._target));
			}
		}

		__proto.checkMouseOut=function(){
			if (this.disableMouseEvent)return;
			for (var i=0,n=this._lastOvers.length;i < n;i++){
				var ele=this._lastOvers[i];
				if (!ele.destroyed && this._currOvers.indexOf(ele)< 0){
					ele.event("mouseout",this._event.setTo("mouseout",ele,this._target));
				}
			};
			var temp=this._lastOvers;
			this._lastOvers=this._currOvers;
			this._currOvers=temp;
			this._currOvers.length=0;
		}

		__proto.onMouseMove=function(ele){
			this.sendMouseMove(ele);
			this._event._stoped=false;
			this.sendMouseOver(this._target);
		}

		__proto.sendMouseMove=function(ele){
			ele.event("mousemove",this._event.setTo("mousemove",ele,this._target));
			!this._event._stoped && ele.parent && this.sendMouseMove(ele.parent);
		}

		__proto.sendMouseOver=function(ele){
			if (ele.parent){
				ele.event("mouseover",this._event.setTo("mouseover",ele,this._target));
				this._currOvers.push(ele);
			}
			!this._event._stoped && ele.parent && this.sendMouseOver(ele.parent);
		}

		__proto.onMouseDown=function(ele){
			if (this._isLeftMouse){
				ele.event("mousedown",this._event.setTo("mousedown",ele,this._target));
				}else {
				ele.event("rightmousedown",this._event.setTo("rightmousedown",ele,this._target));
			}
			!this._event._stoped && ele.parent && this.onMouseDown(ele.parent);
		}

		__proto.onMouseUp=function(ele){
			var type=this._isLeftMouse ? "mouseup" :"rightmouseup";
			this.sendMouseUp(ele,type);
			this._event._stoped=false;
			this.sendClick(this._target,type);
		}

		__proto.sendMouseUp=function(ele,type){
			ele.event(type,this._event.setTo(type,ele,this._target));
			!this._event._stoped && ele.parent && this.sendMouseUp(ele.parent,type);
		}

		__proto.sendClick=function(ele,type){
			if (ele.destroyed)return;
			if (type==="mouseup"){
				ele.event("click",this._event.setTo("click",ele,this._target));
				this._isDoubleClick && ele.event("doubleclick",this._event.setTo("doubleclick",ele,this._target));
				}else if (type==="rightmouseup"){
				ele.event("rightclick",this._event.setTo("rightclick",ele,this._target));
			}
			!this._event._stoped && ele.parent && this.sendClick(ele.parent,type);
		}

		__proto.check=function(sp,mouseX,mouseY,callBack){
			this._target=this;
			callBack.call(this,this._target);
			return true;
		}

		/**
		*执行事件处理。
		*/
		__proto.runEvent=function(){
			var len=this._eventList.length;
			if (!len)return;
			var _this=this;
			var i=0;
			while (i < len){
				var evt=this._eventList[i];
				switch (evt.type){
					case 'mousedown':
						if (!NativeEventManager._isTouchRespond){
							_this._isLeftMouse=evt.button===0;
							_this.initEvent(evt);
							_this.check(_this,_this.mouseX,_this.mouseY,_this.onMouseDown);
						}
						else
						NativeEventManager._isTouchRespond=false;
						break ;
					case 'mouseup':
						_this._isLeftMouse=evt.button===0;
						var now=Browser.now();
						_this._isDoubleClick=(now-_this._lastClickTimer)< 300;
						_this._lastClickTimer=now;
						_this.initEvent(evt);
						_this.check(_this,_this.mouseX,_this.mouseY,_this.onMouseUp);
						break ;
					case 'mousemove':
						_this.initEvent(evt);
						_this.check(_this,_this.mouseX,_this.mouseY,_this.onMouseMove);
						_this.checkMouseOut();
						break ;
					case "touchstart":
						NativeEventManager._isTouchRespond=true;
						_this._isLeftMouse=true;
						var touches=evt.changedTouches;
						for (var j=0,n=touches.length;j < n;j++){
							_this.initEvent(touches[j],evt);
							_this.check(_this,_this.mouseX,_this.mouseY,_this.onMouseDown);
						}
						break ;
					case "touchend":
						NativeEventManager._isTouchRespond=true;
						_this._isLeftMouse=true;
						now=Browser.now();
						_this._isDoubleClick=(now-_this._lastClickTimer)< 300;
						_this._lastClickTimer=now;
						var touchends=evt.changedTouches;
						for (j=0,n=touchends.length;j < n;j++){
							_this.initEvent(touchends[j],evt);
							_this.check(_this,_this.mouseX,_this.mouseY,_this.onMouseUp);
						}
						break ;
					case "touchmove":;
						var touchemoves=evt.changedTouches;
						for (j=0,n=touchemoves.length;j < n;j++){
							_this.initEvent(touchemoves[j],evt);
							_this.check(_this,_this.mouseX,_this.mouseY,_this.onMouseMove);
						}
						_this.checkMouseOut();
						break ;
					case "wheel":
					case "mousewheel":
					case "DOMMouseScroll":
						_this.checkMouseWheel(evt);
						break ;
					case "mouseout":
						_this.event("mouseout",_this._event.setTo("mouseout",_this,_this));
						break ;
					case "mouseover":
						_this.event("mouseover",_this._event.setTo("mouseover",_this,_this));
						break ;
					}
				i++;
			}
			this._eventList.length=0;
		}

		NativeEventManager.enabled=true;
		NativeEventManager._isTouchRespond=false;
		__static(NativeEventManager,
		['instance',function(){return this.instance=new NativeEventManager();}
		]);
		return NativeEventManager;
	})(EventDispatcher)


	/**
	*引擎上下文对象事件定义
	*@author wangcx
	*
	*/
	//class specter3d.engine.events.EngineContextEvent extends laya.events.Event
	var EngineContextEvent=(function(_super){
		function EngineContextEvent(){EngineContextEvent.__super.call(this);;
		};

		__class(EngineContextEvent,'specter3d.engine.events.EngineContextEvent',_super);
		EngineContextEvent.RESIZE="resize";
		EngineContextEvent.ENGINE_INIT_COMPLETE="EngineInitComplete";
		return EngineContextEvent;
	})(Event)


	/**
	*...
	*@author wangcx
	*/
	//class specter3d.engine.events.Event3D extends laya.events.Event
	var Event3D=(function(_super){
		function Event3D(){Event3D.__super.call(this);;
		};

		__class(Event3D,'specter3d.engine.events.Event3D',_super);
		Event3D.ADDED="added3D";
		Event3D.REMOVED="removed3D";
		Event3D.POSITION_CHANGED="positionChanged";
		Event3D.ROTATION_CHANGED="rotationChanged";
		Event3D.SCALE_CHANGED="scaleChanged";
		Event3D.UPDATE_TRANSFORM="update_transform";
		return Event3D;
	})(Event)


	//class specter3d.engine.events.LoaderEvent extends laya.events.Event
	var LoaderEvent=(function(_super){
		function LoaderEvent(){
			this.loader=null;
			this.text=null;
			LoaderEvent.__super.call(this);
		}

		__class(LoaderEvent,'specter3d.engine.events.LoaderEvent',_super);
		LoaderEvent.LOADER_COMPLETE="onLoadComplete";
		LoaderEvent.LOADER_PROGRESS="onLoadProgress";
		LoaderEvent.LOADER_ERROR="onLoadError";
		return LoaderEvent;
	})(Event)


	;
	/**
	*A MouseEvent3D is dispatched when a mouse event occurs over a mouseEnabled object in View3D.
	*todo:we don't have screenZ data, tho this should be easy to implement
	*/
	//class specter3d.engine.events.MouseEvent3D extends laya.events.Event
	var MouseEvent3D=(function(_super){
		function MouseEvent3D(type){
			this._allowedToPropagate=true;
			this._parentEvent=null;
			this.screenX=NaN;
			this.screenY=NaN;
			this.view=null;
			this.object=null;
			this.renderable=null;
			this.material=null;
			this.uv=null;
			this.index=0;
			this.surfaceIndex=0;
			this.localPosition=null;
			this.localNormal=null;
			this._ctrlKey=false;
			this._altKey=false;
			this._shiftKey=false;
			this.delta=0;
			MouseEvent3D.__super.call(this);
			this.setTo(type,this,this);
		}

		__class(MouseEvent3D,'specter3d.engine.events.MouseEvent3D',_super);
		var __proto=MouseEvent3D.prototype;
		/**
		*@inheritDoc
		*/
		__proto.stopPropagation=function(){
			_super.prototype.stopPropagation.call(this);
			this._allowedToPropagate=false;
			if (this._parentEvent)
				this._parentEvent.stopPropagation();
		}

		/**
		*@inheritDoc
		*/
		__proto.stopImmediatePropagation=function(){
			_super.prototype.stopImmediatePropagation();
			this._allowedToPropagate=false;
			if (this._parentEvent)
				this._parentEvent.stopImmediatePropagation();
		}

		/**
		*Creates a copy of the MouseEvent3D object and sets the value of each property to match that of the original.
		*/
		__proto.clone=function(){
			var result=new MouseEvent3D(this.type);
			result.screenX=this.screenX;
			result.screenY=this.screenY;
			result.view=this.view;
			result.object=this.object;
			result.renderable=this.renderable;
			result.material=this.material;
			result.uv=this.uv;
			result.localPosition=this.localPosition;
			result.localNormal=this.localNormal;
			result.index=this.index;
			result.surfaceIndex=this.surfaceIndex;
			result.delta=this.delta;
			result.ctrlKey=this.ctrlKey;
			result.shiftKey=this.shiftKey;
			result._parentEvent=this;
			result._allowedToPropagate=this._allowedToPropagate;
			return result;
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'bubbles',function(){
			var doesBubble=this._allowedToPropagate;
			this._allowedToPropagate=true;
			return doesBubble;
		});

		/**
		*@private
		*/
		/**
		*Indicates whether the Shift key is active (true)or inactive (false).
		*/
		__getset(0,__proto,'shiftKey',function(){
			return this._shiftKey;
			},function(value){
			this._shiftKey=value;
		});

		/**
		*@private
		*/
		/**
		*Indicates whether the Alt key is active (true)or inactive (false).
		*/
		__getset(0,__proto,'altKey',function(){
			return this._altKey;
			},function(value){
			this._altKey=value;
		});

		/**
		*@private
		*/
		/**
		*Indicates whether the Control key is active (true)or inactive (false).
		*/
		__getset(0,__proto,'ctrlKey',function(){
			return this._ctrlKey;
			},function(value){
			this._ctrlKey=value;
		});

		MouseEvent3D.MOUSE_OVER="mouseOver3d";
		MouseEvent3D.MOUSE_OUT="mouseOut3d";
		MouseEvent3D.MOUSE_UP="mouseUp3d";
		MouseEvent3D.MOUSE_DOWN="mouseDown3d";
		MouseEvent3D.MOUSE_MOVE="mouseMove3d";
		MouseEvent3D.CLICK="click3d";
		MouseEvent3D.DOUBLE_CLICK="doubleClick3d";
		MouseEvent3D.MOUSE_WHEEL="mouseWheel3d";
		MouseEvent3D.__init$=function(){
			/*namespace*/;
			/*namespace*/;
		}

		return MouseEvent3D;
	})(Event)


	/**
	*LightPicker
	*@author wangcx
	*
	*/
	//class specter3d.engine.materials.lightpickers.LightPicker extends laya.events.EventDispatcher
	var LightPicker=(function(_super){
		function LightPicker(_lights){
			this._allPickedLights=null;
			this._directionalLights=null;
			this._numDirectionalLights=0;
			this._numLight=0;
			this._numPointLights=0;
			this._pointLights=null;
			LightPicker.__super.call(this);
			this._directionalLights=[];
			this._pointLights=[];
			this._allPickedLights=[];
			this.lights=_lights;
		}

		__class(LightPicker,'specter3d.engine.materials.lightpickers.LightPicker',_super);
		var __proto=LightPicker.prototype;
		__getset(0,__proto,'pointLights',function(){
			return this._pointLights;
		});

		__getset(0,__proto,'directionalLights',function(){
			return this._directionalLights;
		});

		__getset(0,__proto,'numDirectionalLights',function(){
			return this._numDirectionalLights;
		});

		__getset(0,__proto,'lights',function(){
			return this._allPickedLights;
			},function(value){
			var _light;
			var len=value.length;
			for (var i=0;i < value.length;i++){
				_light=value[i];
				switch (_light.lightType){
					case 0x00:
						this._directionalLights[this._numDirectionalLights++]=_light;
						this._allPickedLights[this._numLight++]=_light;
						break ;
					case 0x01:
						this._pointLights[this._numPointLights++]=_light;
						this._allPickedLights[this._numLight++]=_light;
						break ;
					}
			}
			this.event("change");
		});

		__getset(0,__proto,'numLight',function(){
			return this._numLight;
		});

		__getset(0,__proto,'numPointLights',function(){
			return this._numPointLights;
		});

		return LightPicker;
	})(EventDispatcher)


	//class specter3d.engine.events.ParserEvent extends laya.events.Event
	var ParserEvent=(function(_super){
		function ParserEvent(_type,message){
			this._message=null;
			ParserEvent.__super.call(this);
			(message===void 0)&& (message='');
			this.type=_type
			this._message=message;
		}

		__class(ParserEvent,'specter3d.engine.events.ParserEvent',_super);
		var __proto=ParserEvent.prototype;
		__proto.clone=function(){
			return new ParserEvent(this.type,this.message);
		}

		/**
		*Additional human-readable message. Usually supplied for PARSE_ERROR events.
		*/
		__getset(0,__proto,'message',function(){
			return this._message;
		});

		ParserEvent.PARSE_COMPLETE='parseComplete';
		ParserEvent.PARSE_ERROR='parseError';
		ParserEvent.READY_FOR_DEPENDENCIES='readyForDependencies';
		return ParserEvent;
	})(Event)


	;
	/**
	*Material3DPass
	*@author wangcx
	*
	*/
	//class specter3d.engine.materials.passes.Material3DPass extends laya.events.EventDispatcher
	var Material3DPass=(function(_super){
		function Material3DPass(material){
			this._alpha=1;
			this._color=null;
			this._diffuseTexture=null;
			this._normalMapTexture=null;
			this._material=null;
			this._mipmap=true;
			this._program=null;
			this._repeat=false;
			this._smooth=true;
			this._useNormal=true;
			this._useTangent=false;
			this._useUV=false;
			this._alphaBlend=false;
			this._bothSides=false;
			this._fragmentCode=null;
			this._vertexCode=null;
			this._defaultCulling=0x0405;
			Material3DPass.__super.call(this);
			this._material=material;
			this._vertexCode=new ShaderElementArray(ShaderCompiler.shaderVersion);
			this._fragmentCode=new ShaderElementArray(ShaderCompiler.shaderVersion);
			ShaderCompiler.__initDefinition__();
		}

		__class(Material3DPass,'specter3d.engine.materials.passes.Material3DPass',_super);
		var __proto=Material3DPass.prototype;
		__proto.getFragmentCode=function(code){
			throw new AbstractMethodError();
		}

		__proto.getVertexCode=function(code){
			throw new AbstractMethodError();
		}

		__proto.render=function(_context3d,renderable,camera){
			this.updateProgram(_context3d);
			if (renderable){
				if(renderable.transform){
					renderable.transform.updateModelViewProjection(camera);
					var u_projectionMatrix=_context3d.getUniformLocation(this._program,"u_projectionMatrix");
					_context3d.uniformMatrix4fv(u_projectionMatrix,false,camera.projectMatrix.rawData);
					var u_viewMatrix=_context3d.getUniformLocation(this._program,"u_viewMatrix");
					_context3d.uniformMatrix4fv(u_viewMatrix,false,camera.viewMatrix.rawData);
					var u_modelMatrix=_context3d.getUniformLocation(this._program,"u_modelMatrix");
					_context3d.uniformMatrix4fv(u_modelMatrix,false,renderable.transform.world.rawData);
				}
				if(renderable.subGeometry){
					renderable.subGeometry.activate(_context3d,camera,this._program);
				}
			}
			if (this._diffuseTexture){
				!this._diffuseTexture.isUploaded && this._diffuseTexture.upload(_context3d);
				this._diffuseTexture.activeTexture(_context3d,0x84C0);
				var diffuseTextureSampler=_context3d.getUniformLocation(this._program,"u_DiffuseSampler");
				_context3d.uniform1i(diffuseTextureSampler,0);
				if(this._normalMapTexture){
					!this._normalMapTexture.isUploaded && this._normalMapTexture.upload(_context3d);
					this._normalMapTexture.activeTexture(_context3d,0x84C1);
					var normalMapSampler=_context3d.getUniformLocation(this._program,"u_NormalMapSampler");
					_context3d.uniform1i(normalMapSampler,0);
				}
			}
			else
			{this._color=this._color|| new Vector3D();
				var diffuseColorSampler=_context3d.getUniformLocation(this._program,"u_DiffuseColor");
				_context3d.uniform3fv(diffuseColorSampler,this._color.elementsForVec3);
				_context3d.enable(0x0BE2);
				_context3d.blendFunc(0x0302,0x0303);
			};
			var u_alpha=_context3d.getUniformLocation(this._program,"u_DiffuseAlpha");
			_context3d.uniform1f(u_alpha,this._alpha);
			if (this._bothSides){
				AppGlobalContext.stage3d.cullFaceEnabled=false;
			}
			else{
				AppGlobalContext.stage3d.cullFaceEnabled=true;
				AppGlobalContext.stage3d.cullFace=this._defaultCulling;
			}
		}

		__proto.updateProgram=function(_context3d){
			this._vertexCode=this.getVertexCode(this._vertexCode);
			this._fragmentCode=this.getFragmentCode(this._fragmentCode);
			this._program=ShaderCompiler.compile(_context3d,this,this._vertexCode.toString(),this._fragmentCode.toString());
			this._vertexCode.clear();
			this._fragmentCode.clear();
		}

		__getset(0,__proto,'normalMapTexture',function(){
			return this._normalMapTexture;
			},function(value){
			this._normalMapTexture=value;
			this._useTangent=true;
		});

		__getset(0,__proto,'smooth',function(){
			return this._smooth;
			},function(value){
			this._smooth=value;
		});

		__getset(0,__proto,'bothSides',function(){
			return this._bothSides;
			},function(value){
			this._bothSides=value;
		});

		__getset(0,__proto,'material',function(){
			return this._material;
		});

		__getset(0,__proto,'alphaBlend',function(){
			return this._alphaBlend;
			},function(value){
			this._alphaBlend=value;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
			},function(value){
			this._color=value;
		});

		__getset(0,__proto,'alpha',function(){
			return this._alpha;
			},function(value){
			if(value >=0){
				this._alpha=value;
			}
		});

		__getset(0,__proto,'diffuseTexture',function(){
			return this._diffuseTexture;
			},function(value){
			this._diffuseTexture=value;
			this._useUV=this._diffuseTexture !=null;
		});

		__getset(0,__proto,'mipmap',function(){
			return this._mipmap;
			},function(value){
			this._mipmap=value;
		});

		__getset(0,__proto,'repeat',function(){
			return this._repeat;
			},function(value){
			this._repeat=value;
		});

		return Material3DPass;
	})(EventDispatcher)


	//class specter3d.engine.resources.ResourceBase extends laya.events.EventDispatcher
	var ResourceBase=(function(_super){
		function ResourceBase(name){
			this._id=null;
			this._name=null;
			this._isDispose=false;
			ResourceBase.__super.call(this);
			this._name=name;
		}

		__class(ResourceBase,'specter3d.engine.resources.ResourceBase',_super);
		var __proto=ResourceBase.prototype;
		/**
		*上传资源到Context3D。
		*
		*/
		__proto.upload=function(_context3d){
			throw new Error("Cannot upload without data");
		}

		/**
		*释放资源
		*
		*/
		__proto.dispose=function(){
			this._isDispose=true;
		}

		__getset(0,__proto,'isDispose',function(){
			return this._isDispose;
		});

		__getset(0,__proto,'id',function(){
			return this._id;
			},function(newID){
			this._id=newID;
		});

		/**
		*该资源是否被上传到Context3D。
		*@return
		*
		*/
		__getset(0,__proto,'isUploaded',function(){
			return false;
		});

		return ResourceBase;
	})(EventDispatcher)


	;
	//class specter3d.engine.objects.Surface3D extends specter3d.engine.core.render.data.DrawUnit
	var Surface3D=(function(_super){
		function Surface3D(index,subGeometry,parentMesh,material){
			this._parentMesh=null;
			this._index=-1;
			this._subGeometry=null;
			this._material=null;
			Surface3D.__super.call(this,1);
			this._index=index;
			this.material=material;
			this._subGeometry=subGeometry;
			this._parentMesh=parentMesh;
		}

		__class(Surface3D,'specter3d.engine.objects.Surface3D',_super);
		var __proto=Surface3D.prototype;
		__getset(0,__proto,'parentMesh',function(){
			return this._parentMesh;
			},function(value){
			this._parentMesh=value;
		});

		__getset(0,__proto,'vertexData',function(){
			return this._subGeometry.vertexData;
		});

		__getset(0,__proto,'indexData',function(){
			return this._subGeometry.indices;
		});

		__getset(0,__proto,'material',function(){
			return this._material;
			},function(value){
			if(this._material !=value){
				this._material=value;
			}
		});

		__getset(0,__proto,'UVData',function(){
			return this._subGeometry.UVData;
		});

		__getset(0,__proto,'subGeometry',function(){
			return this._subGeometry;
		});

		__getset(0,__proto,'UVStride',function(){
			return this._subGeometry.UVStride;
		});

		__getset(0,__proto,'transform',function(){
			return this._parentMesh.transform;
		});

		__getset(0,__proto,'vertexStride',function(){
			return this._subGeometry.vertexStride;
		});

		__getset(0,__proto,'vertexOffset',function(){
			return this._subGeometry.vertexOffset;
		});

		__getset(0,__proto,'UVOffset',function(){
			return this._subGeometry.UVOffset;
		});

		return Surface3D;
	})(DrawUnit)


	/**
	*<code>Resource</code> 是一个资源存取类。
	*/
	//class laya.resource.Resource extends laya.events.EventDispatcher
	var Resource=(function(_super){
		function Resource(){
			this._id=0;
			this._lastUseFrameCount=0;
			this._memorySize=0;
			this._name=null;
			this._released=false;
			this._resourceManager=null;
			this.lock=false;
			Resource.__super.call(this);
			this._$1__id=++Resource._uniqueIDCounter;
			Resource._loadedResources.push(this);
			Resource._isLoadedResourcesSorted=false;
			this._released=true;
			this.lock=false;
			this._memorySize=0;
			this._lastUseFrameCount=-1;
			(ResourceManager.currentResourceManager)&& (ResourceManager.currentResourceManager.addResource(this));
		}

		__class(Resource,'laya.resource.Resource',_super);
		var __proto=Resource.prototype;
		Laya.imps(__proto,{"laya.resource.IDispose":true})
		/**重新创建资源。override it，同时修改memorySize属性、处理startCreate()和compoleteCreate()方法。*/
		__proto.recreateResource=function(){
			this.startCreate();
			this.compoleteCreate();
		}

		/**销毁资源，override it,同时修改memorySize属性。*/
		__proto.detoryResource=function(){}
		/**
		*激活资源，使用资源前应先调用此函数激活。
		*@param force 是否强制创建。
		*/
		__proto.activeResource=function(force){
			(force===void 0)&& (force=false);
			this._lastUseFrameCount=Stat.loopCount;
			if (this._released || force){
				this.recreateResource();
			}
		}

		/**
		*释放资源。
		*@param force 是否强制释放。
		*@return 是否成功释放。
		*/
		__proto.releaseResource=function(force){
			(force===void 0)&& (force=false);
			if (!force && this.lock)
				return false;
			if (!this._released || force){
				this.detoryResource();
				this._released=true;
				this._lastUseFrameCount=-1;
				this.event("released",this);
				return true;
				}else {
				return false;
			}
		}

		/**
		*设置唯一名字,如果名字重复则自动加上“-copy”。
		*@param newName 名字。
		*/
		__proto.setUniqueName=function(newName){
			var isUnique=true;
			for (var i=0;i < Resource._loadedResources.length;i++){
				if (Resource._loadedResources[i]._name!==newName || Resource._loadedResources[i]===this)
					continue ;
				isUnique=false;
				return;
			}
			if (isUnique){
				if (this.name !=newName){
					this.name=newName;
					Resource._isLoadedResourcesSorted=false;
				}
				}else{
				this.setUniqueName(newName.concat("-copy"));
			}
		}

		/**
		*<p>彻底清理资源。</p>
		*<p><b>注意：</b>会强制解锁清理。</p>
		*/
		__proto.dispose=function(){
			if (this._resourceManager!==null)
				throw new Error("附属于resourceManager的资源不能独立释放！");
			this.lock=false;
			this.releaseResource();
			var index=Resource._loadedResources.indexOf(this);
			if (index!==-1){
				Resource._loadedResources.splice(index,1);
				Resource._isLoadedResourcesSorted=false;
			}
		}

		/**开始资源激活。*/
		__proto.startCreate=function(){
			this.event("recovering",this);
		}

		/**完成资源激活。*/
		__proto.compoleteCreate=function(){
			this._released=false;
			this.event("recovered",this);
		}

		/**
		*获取唯一标识ID(通常用于优化或识别)。
		*/
		__getset(0,__proto,'id',function(){
			return this._$1__id;
		});

		/**
		*距离上次使用帧率。
		*/
		__getset(0,__proto,'lastUseFrameCount',function(){
			return this._lastUseFrameCount;
		});

		/**
		*设置名字
		*/
		/**
		*获取名字。
		*/
		__getset(0,__proto,'name',function(){
			return this._name;
			},function(value){
			if ((value || value!=="")&& this.name!==value){
				this._name=value;
				Resource._isLoadedResourcesSorted=false;
			}
		});

		/**
		*资源管理员。
		*/
		__getset(0,__proto,'resourceManager',function(){
			return this._resourceManager;
		});

		/**
		*占用内存尺寸。
		*/
		__getset(0,__proto,'memorySize',function(){
			return this._memorySize;
			},function(value){
			var offsetValue=value-this._memorySize;
			this._memorySize=value;
			this.resourceManager && this.resourceManager.addSize(offsetValue);
		});

		/**
		*是否已释放。
		*/
		__getset(0,__proto,'released',function(){
			return this._released;
		});

		/**
		*本类型排序后的已载入资源。
		*/
		__getset(1,Resource,'sortedLoadedResourcesByName',function(){
			if (!Resource._isLoadedResourcesSorted){
				Resource._isLoadedResourcesSorted=true;
				Resource._loadedResources.sort(Resource.compareResourcesByName);
			}
			return Resource._loadedResources;
		},laya.events.EventDispatcher._$SET_sortedLoadedResourcesByName);

		Resource.getLoadedResourceByIndex=function(index){
			return Resource._loadedResources[index];
		}

		Resource.getLoadedResourcesCount=function(){
			return Resource._loadedResources.length;
		}

		Resource.compareResourcesByName=function(left,right){
			if (left===right)
				return 0;
			var x=left.name;
			var y=right.name;
			if (x===null){
				if (y===null)
					return 0;
				else
				return-1;
				}else {
				if (y==null)
					return 1;
				else {
					var retval=x.localeCompare(y);
					if (retval !=0)
						return retval;
					else {
						right.setUniqueName(y);
						y=right.name;
						return x.localeCompare(y);
					}
				}
			}
		}

		Resource.animationCache={};
		Resource.meshCache={};
		Resource.materialCache={};
		Resource._uniqueIDCounter=0;
		Resource._loadedResources=[];
		Resource._isLoadedResourcesSorted=false;
		return Resource;
	})(EventDispatcher)


	/**
	*<code>Node</code> 类用于创建节点对象，节点是最基本的元素。
	*/
	//class laya.display.Node extends laya.events.EventDispatcher
	var Node=(function(_super){
		function Node(){
			this.name="";
			this.destroyed=false;
			this._displayedInStage=false;
			this._parent=null;
			this.model=null;
			Node.__super.call(this);
			this._childs=Node.ARRAY_EMPTY;
			this.timer=Laya.timer;
			this._$P=Node.PROP_EMPTY;
			this.model=Render.isConchNode ? new ConchNode():null;
		}

		__class(Node,'laya.display.Node',_super);
		var __proto=Node.prototype;
		/**
		*<p>销毁此对象。</p>
		*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			this.destroyed=true;
			this._parent && this._parent.removeChild(this);
			if (this._childs){
				if (destroyChild)this.destroyChildren();
				else this.removeChildren();
			}
			this._childs=null;
			this._$P=null;
			this.offAll();
		}

		/**
		*销毁所有子对象，不销毁自己本身。
		*/
		__proto.destroyChildren=function(){
			if (this._childs){
				for (var i=this._childs.length-1;i >-1;i--){
					this._childs[i].destroy(true);
				}
			}
		}

		/**
		*添加子节点。
		*@param node 节点对象
		*@return 返回添加的节点
		*/
		__proto.addChild=function(node){
			if (node===this)return node;
			if (node._parent===this){
				this._childs.splice(this.getChildIndex(node),1);
				this._childs.push(node);
				if (this.model){
					this.model.removeChild(node.model);
					this.model.addChildAt(node.model,this._childs.length-1);
				}
				this._childChanged();
				}else {
				node.parent && node.parent.removeChild(node);
				this._childs===Node.ARRAY_EMPTY && (this._childs=[]);
				this._childs.push(node);
				this.model && this.model.addChildAt(node.model,this._childs.length-1);
				node.parent=this;
			}
			return node;
		}

		/**
		*批量增加子节点
		*@param ...args 无数子节点。
		*/
		__proto.addChildren=function(__args){
			var args=arguments;
			var i=0,n=args.length;
			while (i < n){
				this.addChild(args[i++]);
			}
		}

		/**
		*添加子节点到指定的索引位置。
		*@param node 节点对象。
		*@param index 索引位置。
		*@return 返回添加的节点。
		*/
		__proto.addChildAt=function(node,index){
			if (node===this)return node;
			if (index >=0 && index <=this._childs.length){
				if (node._parent===this){
					var oldIndex=this.getChildIndex(node);
					this._childs.splice(oldIndex,1);
					this._childs.splice(index,0,node);
					if (this.model){
						this.model.removeChild(node.model);
						this.model.addChildAt(node.model,index);
					}
					this._childChanged();
					}else {
					node.parent && node.parent.removeChild(node);
					this._childs===Node.ARRAY_EMPTY && (this._childs=[]);
					this._childs.splice(index,0,node);
					this.model && this.model.addChildAt(node.model,index);
					node.parent=this;
				}
				return node;
				}else {
				throw new Error("appendChildAt:The index is out of bounds");
			}
		}

		/**
		*根据子节点对象，获取子节点的索引位置。
		*@param node 子节点。
		*@return 子节点所在的索引位置。
		*/
		__proto.getChildIndex=function(node){
			return this._childs.indexOf(node);
		}

		/**
		*根据子节点的名字，获取子节点对象。
		*@param name 子节点的名字。
		*@return 节点对象。
		*/
		__proto.getChildByName=function(name){
			var nodes=this._childs;
			for (var i=0,n=nodes.length;i < n;i++){
				var node=nodes[i];
				if (node.name===name)return node;
			}
			return null;
		}

		/**@private */
		__proto._get$P=function(key){
			return this._$P[key];
		}

		/**@private */
		__proto._set$P=function(key,value){
			this._$P===Node.PROP_EMPTY && (this._$P={});
			this._$P[key]=value;
			return value;
		}

		/**
		*根据子节点的索引位置，获取子节点对象。
		*@param index 索引位置
		*@return 子节点
		*/
		__proto.getChildAt=function(index){
			return this._childs[index];
		}

		/**
		*设置子节点的索引位置。
		*@param node 子节点。
		*@param index 新的索引。
		*@return 返回子节点本身。
		*/
		__proto.setChildIndex=function(node,index){
			var childs=this._childs;
			if (index < 0 || index >=childs.length){
				throw new Error("setChildIndex:The index is out of bounds.");
			};
			var oldIndex=this.getChildIndex(node);
			if (oldIndex < 0)throw new Error("setChildIndex:node is must child of this object.");
			childs.splice(oldIndex,1);
			childs.splice(index,0,node);
			if (this.model){
				this.model.removeChild(node.model);
				this.model.addChildAt(node.model,index);
			}
			this._childChanged();
			return node;
		}

		/**
		*@private
		*子节点发生改变。
		*@param child 子节点。
		*/
		__proto._childChanged=function(child){}
		/**
		*删除子节点。
		*@param node 子节点
		*@return 被删除的节点
		*/
		__proto.removeChild=function(node){
			if (!this._childs)return node;
			var index=this._childs.indexOf(node);
			return this.removeChildAt(index);
		}

		/**
		*从父容器删除自己，如已经被删除不会抛出异常。
		*@return 当前节点（ Node ）对象。
		*/
		__proto.removeSelf=function(){
			this._parent && this._parent.removeChild(this);
			return this;
		}

		/**
		*根据子节点名字删除对应的子节点对象，如果找不到不会抛出异常。
		*@param name 对象名字。
		*@return 查找到的节点（ Node ）对象。
		*/
		__proto.removeChildByName=function(name){
			var node=this.getChildByName(name);
			node && this.removeChild(node);
			return node;
		}

		/**
		*根据子节点索引位置，删除对应的子节点对象。
		*@param index 节点索引位置。
		*@return 被删除的节点。
		*/
		__proto.removeChildAt=function(index){
			var node=this.getChildAt(index);
			if (node){
				this._childs.splice(index,1);
				this.model && this.model.removeChild(node.model);
				node.parent=null;
			}
			return node;
		}

		/**
		*删除指定索引区间的所有子对象。
		*@param beginIndex 开始索引。
		*@param endIndex 结束索引。
		*@return 当前节点对象。
		*/
		__proto.removeChildren=function(beginIndex,endIndex){
			(beginIndex===void 0)&& (beginIndex=0);
			(endIndex===void 0)&& (endIndex=0x7fffffff);
			if (this._childs.length > 0){
				var childs=this._childs;
				if (beginIndex===0 && endIndex >=n){
					var arr=childs;
					this._childs=Node.ARRAY_EMPTY;
					}else {
					arr=childs.splice(beginIndex,endIndex-beginIndex);
				}
				for (var i=0,n=arr.length;i < n;i++){
					arr[i].parent=null;
					this.model && this.model.removeChild(arr[i].model);
				}
			}
			return this;
		}

		/**
		*替换子节点。
		*@internal 将传入的新节点对象替换到已有子节点索引位置处。
		*@param newNode 新节点。
		*@param oldNode 老节点。
		*@return 返回新节点。
		*/
		__proto.replaceChild=function(newNode,oldNode){
			var index=this._childs.indexOf(oldNode);
			if (index >-1){
				this._childs.splice(index,1,newNode);
				if (this.model){
					this.model.removeChild(oldNode.model);
					this.model.addChildAt(newNode.model,index);
				}
				oldNode.parent=null;
				newNode.parent=this;
				return newNode;
			}
			return null;
		}

		/**@private */
		__proto._setDisplay=function(value){
			if (this._displayedInStage!==value){
				this._displayedInStage=value;
				if (value)this.event("display");
				else this.event("undisplay");
			}
		}

		/**
		*@private
		*设置指定节点对象是否可见(是否在渲染列表中)。
		*@param node 节点。
		*@param display 是否可见。
		*/
		__proto._displayChild=function(node,display){
			var childs=node._childs;
			if (childs){
				for (var i=childs.length-1;i >-1;i--){
					var child=childs[i];
					child._setDisplay(display);
					child._childs.length && this._displayChild(child,display);
				}
			}
			node._setDisplay(display);
		}

		/**
		*当前容器是否包含 <code>node</code> 节点。
		*@param node 某一个节点 <code>Node</code>。
		*@return 一个布尔值表示是否包含<code>node</code>节点。
		*/
		__proto.contains=function(node){
			if (node===this)return true;
			while (node){
				if (node.parent===this.parent)return true;
				node=node.parent;
			}
			return false;
		}

		/**
		*定时重复执行某函数。
		*@param delay 间隔时间(单位毫秒)。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为true。
		*/
		__proto.timerLoop=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this.timer._create(false,true,delay,caller,method,args,coverBefore);
		}

		/**
		*定时执行某函数一次。
		*@param delay 延迟时间(单位毫秒)。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为true。
		*/
		__proto.timerOnce=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this.timer._create(false,false,delay,caller,method,args,coverBefore);
		}

		/**
		*定时重复执行某函数(基于帧率)。
		*@param delay 间隔几帧(单位为帧)。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为true。
		*/
		__proto.frameLoop=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this.timer._create(true,true,delay,caller,method,args,coverBefore);
		}

		/**
		*定时执行一次某函数(基于帧率)。
		*@param delay 延迟几帧(单位为帧)。
		*@param caller 执行域(this)
		*@param method 结束时的回调方法
		*@param args 回调参数
		*@param coverBefore 是否覆盖之前的延迟执行，默认为true
		*/
		__proto.frameOnce=function(delay,caller,method,args,coverBefore){
			(coverBefore===void 0)&& (coverBefore=true);
			this.timer._create(true,false,delay,caller,method,args,coverBefore);
		}

		/**
		*清理定时器。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*/
		__proto.clearTimer=function(caller,method){
			this.timer.clear(caller,method);
		}

		/**表示是否在显示列表中显示。是否在显示渲染列表中。*/
		__getset(0,__proto,'displayedInStage',function(){
			return this._displayedInStage;
		});

		/**
		*子对象数量。
		*/
		__getset(0,__proto,'numChildren',function(){
			return this._childs.length;
		});

		/**父节点。*/
		__getset(0,__proto,'parent',function(){
			return this._parent;
			},function(value){
			if (this._parent!==value){
				if (value){
					this._parent=value;
					this.event("added");
					value.displayedInStage && this._displayChild(this,true);
					value._childChanged(this);
					}else {
					this.event("removed");
					this._parent._childChanged();
					this._displayChild(this,false);
					this._parent=value;
				}
			}
		});

		Node.ARRAY_EMPTY=[];
		Node.PROP_EMPTY={};
		return Node;
	})(EventDispatcher)


	/**
	*<code>Component3D</code> 类用于创建组件的父类。
	*/
	//class laya.d3.component.Component3D extends laya.events.EventDispatcher
	var Component3D=(function(_super){
		function Component3D(){
			this._id=0;
			this._cachedOwnerLayerMask=0;
			this._cachedOwnerEnable=false;
			this._enable=false;
			this._owner=null;
			this.started=false;
			Component3D.__super.call(this);
			this._id=Component3D._uniqueIDCounter;
			Component3D._uniqueIDCounter++;
		}

		__class(Component3D,'laya.d3.component.Component3D',_super);
		var __proto=Component3D.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IUpdate":true})
		/**
		*@private
		*owner蒙版变化事件处理。
		*@param mask 蒙版值。
		*/
		__proto._onLayerChanged=function(layer){
			this._cachedOwnerLayerMask=layer.mask;
		}

		/**
		*@private
		*owner启用变化事件处理。
		*@param enable 是否启用。
		*/
		__proto._onEnableChanged=function(enable){
			this._cachedOwnerEnable=enable;
		}

		/**
		*@private
		*初始化组件。
		*@param owner 所属Sprite3D节点。
		*/
		__proto._initialize=function(owner){
			this._owner=owner;
			this.enable=true;
			this.started=false;
			this._cachedOwnerLayerMask=owner.layer.mask;
			this._owner.on("layerchanged",this,this._onLayerChanged);
			this._cachedOwnerEnable=owner.enable;
			this._owner.on("enabledchanged",this,this._onEnableChanged);
			this._load(owner);
		}

		/**
		*@private
		*卸载组件。
		*/
		__proto._uninitialize=function(){
			this._unload(this.owner);
			this._owner.off("layerchanged",this,this._onLayerChanged);
			this._owner.off("enabledchanged",this,this._onEnableChanged);
			this._owner=null;
		}

		/**
		*@private
		*载入组件时执行,可重写此函数。
		*/
		__proto._load=function(owner){}
		/**
		*@private
		*在任意第一次更新时执行,可重写此函数。
		*/
		__proto._start=function(state){}
		/**
		*@private
		*更新组件,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._update=function(state){}
		/**
		*@private
		*更新的最后阶段执行,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._lateUpdate=function(state){}
		/**
		*@private
		*渲染前设置组件相关参数,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._preRenderUpdate=function(state){}
		/**
		*@private
		*渲染的最后阶段执行,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._postRenderUpdate=function(state){}
		/**
		*@private
		*卸载组件时执行,可重写此函数。
		*/
		__proto._unload=function(owner){}
		/**
		*获取唯一标识ID。
		*@return 唯一标识ID。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*获取所属Sprite3D节点。
		*@return 所属Sprite3D节点。
		*/
		__getset(0,__proto,'owner',function(){
			return this._owner;
		});

		/**
		*设置是否启用。
		*@param value 是否启动
		*/
		/**
		*获取是否启用。
		*@return 是否启动。
		*/
		__getset(0,__proto,'enable',function(){
			return this._enable;
			},function(value){
			if (this._enable!==value){
				this._enable=value;
				this.event("enabledchanged",this._enable);
			}
		});

		/**
		*获取是否激活。
		*@return 是否激活。
		*/
		__getset(0,__proto,'isActive',function(){
			return Layer.isActive(this._cachedOwnerLayerMask)&& this._cachedOwnerEnable && this._enable;
		});

		/**
		*获取是否可见。
		*@return 是否可见。
		*/
		__getset(0,__proto,'isVisible',function(){
			return Layer.isVisible(this._cachedOwnerLayerMask)&& this._cachedOwnerEnable && this._enable;
		});

		Component3D.__init__=function(){}
		Component3D._uniqueIDCounter=1;
		return Component3D;
	})(EventDispatcher)


	//class specter3d.engine.materials.ColorMaterial3D extends specter3d.engine.materials.Material3D
	var ColorMaterial3D=(function(_super){
		function ColorMaterial3D(color,alpha){
			this._color=0xffffff;
			(color===void 0)&& (color=0xcccccc);
			(alpha===void 0)&& (alpha=1);
			ColorMaterial3D.__super.call(this);
			this.color=color;
			this.alpha=alpha;
		}

		__class(ColorMaterial3D,'specter3d.engine.materials.ColorMaterial3D',_super);
		var __proto=ColorMaterial3D.prototype;
		__getset(0,__proto,'color',function(){
			return this._color;
			},function(value){
			this._color=value;
			var _colorR=((this._color >> 16)& 0xff)/ 255;
			var _colorG=((this._color >> 8)& 0xff)/ 255;
			var _colorB=(this._color & 0xff)/ 255;
			this._compiledPass.color=new Vector3D(_colorR,_colorG,_colorB)
		});

		return ColorMaterial3D;
	})(Material3D)


	/**
	*<code>Material</code> 类用于创建材质。
	*/
	//class laya.d3.core.material.Material extends laya.events.EventDispatcher
	var Material=(function(_super){
		function Material(){
			this._id=0;
			this._loaded=true;
			this._renderQueue=0;
			this._renderMode=0;
			this._texturesloaded=false;
			this._shader=null;
			this._sharderNameID=0;
			this._disableDefine=0;
			this._color=[];
			this._alphaTestValue=NaN;
			this._transformUV=null;
			this._shaderDef=0;
			this._isInstance=false;
			this.name=null;
			Material.__super.call(this);
			this._textures=[];
			this._texturesSharderIndex=[];
			this._otherSharderIndex=[];
			this._shaderValues=new ValusArray();
			this._albedo=new Vector4(1.0,1.0,1.0,1.0);
			this._id=++Material._uniqueIDCounter;
			if (this._id > Material.maxMaterialCount)
				throw new Error("Material: Material count should not large than ",Material.maxMaterialCount);
			this._color[0]=Material.AMBIENTCOLORVALUE;
			this._color[1]=Material.DIFFUSECOLORVALUE;
			this._color[2]=Material.SPECULARCOLORVALUE;
			this._color[3]=Material.REFLECTCOLORVALUE;
			this._pushShaderValue(0,"MATERIALAMBIENT",this._color[0].elements,this._id);
			this._pushShaderValue(1,"MATERIALDIFFUSE",this._color[1].elements,this._id);
			this._pushShaderValue(2,"MATERIALSPECULAR",this._color[2].elements,this._id);
			this._pushShaderValue(3,"MATERIALREFLECT",this._color[3].elements,this._id);
			this._pushShaderValue(5,"ALBEDO",this._albedo.elements,this._id);
			this.renderMode=1;
			this.alphaTestValue=0.5;
		}

		__class(Material,'laya.d3.core.material.Material',_super);
		var __proto=Material.prototype;
		/**
		*@private
		*/
		__proto._eventLoaded=function(){
			this._loaded=true;
			this.event("loaded",this);
		}

		/**
		*@private
		*/
		__proto._loadeCompleted=function(){
			if (this._texturesloaded)
				return true;
			if (this.diffuseTexture && !this.diffuseTexture.loaded)
				return false;
			if (this.normalTexture && !this.normalTexture.loaded)
				return false;
			if (this.specularTexture && !this.specularTexture.loaded)
				return false;
			if (this.emissiveTexture && !this.emissiveTexture.loaded)
				return false;
			if (this.ambientTexture && !this.ambientTexture.loaded)
				return false;
			if (this.reflectTexture && !this.reflectTexture.loaded)
				return false;
			(this.diffuseTexture)&& this._uploadTexture(0,this.diffuseTexture);
			(this.normalTexture)&& (this._uploadTexture(1,this.normalTexture));
			(this.specularTexture)&& this._uploadTexture(2,this.specularTexture);
			(this.emissiveTexture)&& (this._uploadTexture(3,this.emissiveTexture));
			(this.ambientTexture)&& (this._uploadTexture(4,this.ambientTexture));
			(this.reflectTexture)&& (this._uploadTexture(5,this.reflectTexture));
			return this._texturesloaded=true;
		}

		/**
		*@private
		*获取材质的ShaderDefine。
		*@param shaderIndex 在ShaderValue队列中的索引。
		*@param name 名称。
		*@param value 值。
		*@param id 优化id。
		*@return 当前ShaderValue队列的索引。
		*/
		__proto._pushShaderValue=function(shaderIndex,name,value,id){
			var shaderValue=this._shaderValues;
			var index=this._otherSharderIndex[shaderIndex];
			if (!index){
				index=shaderValue.length+1;
				shaderValue.pushValue(name,null,-1);
				this._otherSharderIndex[shaderIndex]=index;
			}
			shaderValue.data[index][0]=value;
			shaderValue.data[index][1]=id;
			return index;
		}

		/**
		*@private
		*获取材质的ShaderDefine。
		*@return 材质的ShaderDefine。
		*/
		__proto._getShaderDefineValue=function(){
			this._shaderDef=0;
			this.diffuseTexture && (this._shaderDef |=0x1);
			this.normalTexture && (this._shaderDef |=0x2);
			this.specularTexture && (this._shaderDef |=0x4);
			this.emissiveTexture && (this._shaderDef |=0x8);
			this.ambientTexture && (this._shaderDef |=0x10);
			this.reflectTexture && (this._shaderDef |=0x40000);
			this._transformUV && (this._shaderDef |=0x4000);
			(this._renderMode===3 || this._renderMode===4)&& (this._shaderDef |=0x800);
			return this._shaderDef;
		}

		/**
		*@private
		*/
		__proto._setTexture=function(value,shaderIndex,shaderValue){
			var index=this._texturesSharderIndex[shaderIndex];
			if (!index && value){
				index=this._shaderValues.length+1;
				this._shaderValues.pushValue(shaderValue,null,-1);
				this._texturesSharderIndex[shaderIndex]=index;
			}
			(value)&& (this._texturesloaded=false);
			this._textures[shaderIndex]=value;
			return index;
		}

		/**
		*@private
		*/
		__proto._uploadTexture=function(shaderIndex,texture){
			var shaderValue=this._shaderValues;
			var data=shaderValue.data[this._texturesSharderIndex[shaderIndex]];
			data[0]=texture.source;
			data[1]=texture.bitmap.id;
		}

		/**
		*通过索引获取纹理。
		*@param index 索引。
		*@return 纹理。
		*/
		__proto.getTextureByIndex=function(index){
			return this._textures[index];
		}

		/**
		*获取Shader。
		*@param state 相关渲染状态。
		*@return Shader。
		*/
		__proto.getShader=function(state){
			var shaderDefs=state.shaderDefs;
			var preDef=shaderDefs._value;
			this._disableDefine && (shaderDefs._value=preDef & (~this._disableDefine));
			var nameID=(shaderDefs._value | state.shadingMode)+this._sharderNameID *0.0002;
			this._shader=Shader.withCompile(this._sharderNameID,state.shadingMode,shaderDefs.toNameDic(),nameID,null);
			shaderDefs._value=preDef;
			return this._shader;
		}

		/**
		*上传材质。
		*@param state 相关渲染状态。
		*@param bufferUsageShader Buffer相关绑定。
		*@param shader 着色器。
		*@return 是否成功。
		*/
		__proto.upload=function(state,bufferUsageShader,shader){
			if (!this._loadeCompleted())return false;
			shader || (shader=this.getShader(state));
			var shaderValue=this._shaderValues;
			var _presize=shaderValue.length;
			shaderValue.pushArray(state.shaderValue);
			if (shader.tag._uploadMaterialID !=Stat.loopCount){
				shader.tag._uploadMaterialID=Stat.loopCount;
				shaderValue.pushArray(state.worldShaderValue);
			}
			shader.uploadArray(shaderValue.data,shaderValue.length,bufferUsageShader);
			shaderValue.length=_presize;
			return true;
		}

		/**
		*禁用灯光。
		*/
		__proto.disableLight=function(){
			this._disableDefine |=0x80 | 0x100 | 0x40;
		}

		/**
		*禁用相关Define。
		*@param value 禁用值。
		*/
		__proto.disableDefine=function(value){
			this._disableDefine=value;
		}

		/**
		*设置使用Shader名字。
		*@param name 名称。
		*/
		__proto.setShaderName=function(name){
			this._sharderNameID=Shader.nameKey.get(name);
		}

		/**
		*复制材质
		*@param dec 目标材质
		*/
		__proto.copy=function(dec){
			dec._loaded=this._loaded;
			dec._renderQueue=this._renderQueue;
			dec._renderMode=this._renderMode;
			dec._textures=this._textures;
			dec._texturesSharderIndex=this._texturesSharderIndex;
			dec._otherSharderIndex=this._otherSharderIndex;
			dec._texturesloaded=this._texturesloaded;
			dec._shader=this._shader;
			dec._sharderNameID=this._sharderNameID;
			dec._disableDefine=this._disableDefine;
			dec._color=this._color;
			dec._alphaTestValue=this._alphaTestValue;
			dec._transformUV=this._transformUV;
			dec._albedo=this._albedo;
			dec._shaderDef=this._shaderDef;
			dec.name=this.name;
			this._shaderValues.copyTo(dec._shaderValues);
			return dec;;
		}

		/**
		*获取唯一标识ID(通常用于优化或识别)。
		*@return 唯一标识ID
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*设置反射贴图。
		*@param value 反射贴图。
		*/
		/**
		*获取反射贴图。
		*@return 反射贴图。
		*/
		__getset(0,__proto,'reflectTexture',function(){
			return this._textures[5];
			},function(value){
			this._setTexture(value,5,"REFLECTTEXTURE");
			this._getShaderDefineValue();
		});

		/**
		*设置高光贴图。
		*@param value 高光贴图。
		*/
		/**
		*获取高光贴图。
		*@return 高光贴图。
		*/
		__getset(0,__proto,'specularTexture',function(){
			return this._textures[2];
			},function(value){
			this._setTexture(value,2,"SPECULARTEXTURE");
			this._getShaderDefineValue();
		});

		/**
		*获取是否已加载完成。
		*@return 是否已加载完成
		*/
		__getset(0,__proto,'loaded',function(){
			return this._loaded;
		});

		/**
		*获取所属渲染队列。
		*@return 渲染队列。
		*/
		__getset(0,__proto,'renderQueue',function(){
			return this._renderQueue;
		});

		/**
		*设置透明测试模式裁剪值。
		*@param value 透明测试模式裁剪值。
		*/
		/**
		*获取透明测试模式裁剪值。
		*@return 透明测试模式裁剪值。
		*/
		__getset(0,__proto,'alphaTestValue',function(){
			return this._alphaTestValue;
			},function(value){
			this._alphaTestValue=value;
			this._pushShaderValue(7,"ALPHATESTVALUE",value,this._id);
		});

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		/**
		*获取渲染状态。
		*@return 渲染状态。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			this._renderMode=value;
			switch (value){
				case 0:
					this._renderQueue=0;
					this.event("renderqueuechanged",this);
					break ;
				case 1:
					this._renderQueue=1;
					this.event("renderqueuechanged",this);
					break ;
				case 2:
					this._renderQueue=2;
					this.event("renderqueuechanged",this);
					break ;
				case 3:
					this._renderQueue=1;
					this.event("renderqueuechanged",this);
					break ;
				case 4:
					this._renderQueue=2;
					this.event("renderqueuechanged",this);
					break ;
				case 5:
					this._renderQueue=7;
					this.event("renderqueuechanged",this);
					break ;
				case 6:
					this._renderQueue=8;
					this.event("renderqueuechanged",this);
					break ;
				case 7:
					this._renderQueue=9;
					this.event("renderqueuechanged",this);
					break ;
				case 8:
					this._renderQueue=10;
					this.event("renderqueuechanged",this);
					break ;
				default :
					throw new Error("Material:renderMode value error.");
					break ;
				}
			this._getShaderDefineValue();
		});

		/**
		*获取材质的ShaderDef。
		*@return 材质的ShaderDef。
		*/
		__getset(0,__proto,'shaderDef',function(){
			return this._shaderDef;
		});

		/**
		*设置反射率。
		*@param value 反射率。
		*/
		__getset(0,__proto,'albedo',null,function(value){
			this._albedo=value;
			this._pushShaderValue(5,"ALBEDO",this._albedo.elements,this._id);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._textures[0];
			},function(value){
			this._setTexture(value,0,"DIFFUSETEXTURE");
			this._getShaderDefineValue();
		});

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._textures[1];
			},function(value){
			this._setTexture(value,1,"NORMALTEXTURE");
			this._getShaderDefineValue();
		});

		/**
		*设置放射贴图。
		*@param value 放射贴图。
		*/
		/**
		*获取放射贴图。
		*@return 放射贴图。
		*/
		__getset(0,__proto,'emissiveTexture',function(){
			return this._textures[3];
			},function(value){
			this._setTexture(value,3,"EMISSIVETEXTURE");
			this._getShaderDefineValue();
		});

		/**
		*设置环境贴图。
		*@param value 环境贴图。
		*/
		/**
		*获取环境贴图。
		*@return 环境贴图。
		*/
		__getset(0,__proto,'ambientTexture',function(){
			return this._textures[4];
			},function(value){
			this._setTexture(value,4,"AMBIENTTEXTURE");
			this._getShaderDefineValue();
		});

		/**
		*获取贴图数量。
		*@return 贴图数量。
		*/
		__getset(0,__proto,'texturesCount',function(){
			return this._textures.length;
		});

		/**
		*设置环境光颜色。
		*@param value 环境光颜色。
		*/
		__getset(0,__proto,'ambientColor',null,function(value){
			this._color[0]=value;
			this._pushShaderValue(0,"MATERIALAMBIENT",value.elements,this._id);
		});

		/**
		*设置漫反射光颜色。
		*@param value 漫反射光颜色。
		*/
		__getset(0,__proto,'diffuseColor',null,function(value){
			this._color[1]=value;
			this._pushShaderValue(1,"MATERIALDIFFUSE",value.elements,this._id);
		});

		/**
		*设置高光颜色。
		*@param value 高光颜色。
		*/
		__getset(0,__proto,'specularColor',null,function(value){
			this._color[2]=value;
			this._pushShaderValue(2,"MATERIALSPECULAR",value.elements,this._id);
		});

		/**
		*设置反射颜色。
		*@param value 反射颜色。
		*/
		__getset(0,__proto,'reflectColor',null,function(value){
			this._color[3]=value;
			this._pushShaderValue(3,"MATERIALREFLECT",value.elements,this._id);
		});

		/**
		*设置UV变换。
		*@param value UV变换。
		*/
		/**
		*获取UV变换。
		*@return UV变换。
		*/
		__getset(0,__proto,'transformUV',function(){
			return this._transformUV;
			},function(value){
			this._transformUV=value;
			var uvMat=this._transformUV.matrix;
			this._pushShaderValue(6,"MATRIX2",uvMat.elements,this._id);
			this._getShaderDefineValue();
		});

		Material.createFromFile=function(url,out){
			out._loaded=false;
			var loader=new Loader();
			var onComp=function (data){
				var preBasePath=URL.basePath;
				URL.basePath=URL.getPath(URL.formatURL(url));
				ClassUtils.createByJson(data,out,null,Handler.create(null,Utils3D._parseMaterial,null,false));
				URL.basePath=preBasePath;
				out._eventLoaded();
			}
			loader.once("complete",null,onComp);
			loader.load(url,"json");
		}

		Material._uniqueIDCounter=1;
		Material.DIFFUSETEXTURE=0;
		Material.NORMALTEXTURE=1;
		Material.SPECULARTEXTURE=2;
		Material.EMISSIVETEXTURE=3;
		Material.AMBIENTTEXTURE=4;
		Material.REFLECTTEXTURE=5;
		Material.AMBIENTCOLOR=0;
		Material.DIFFUSECOLOR=1;
		Material.SPECULARCOLOR=2;
		Material.REFLECTCOLOR=3;
		Material.TRANSPARENT=4;
		Material.ALBEDO=5;
		Material.TRANSFORMUV=6;
		Material.ALPHATESTVALUE=7;
		Material.RENDERMODE_SKY=0;
		Material.RENDERMODE_OPAQUE=1;
		Material.RENDERMODE_OPAQUEDOUBLEFACE=2;
		Material.RENDERMODE_CUTOUT=3;
		Material.RENDERMODE_CUTOUTDOUBLEFACE=4;
		Material.RENDERMODE_TRANSPARENT=5;
		Material.RENDERMODE_TRANSPARENTDOUBLEFACE=6;
		Material.RENDERMODE_ADDTIVE=7;
		Material.RENDERMODE_ADDTIVEDOUBLEFACE=8;
		__static(Material,
		['maxMaterialCount',function(){return this.maxMaterialCount=Math.floor(2147483647 / 1000);},'AMBIENTCOLORVALUE',function(){return this.AMBIENTCOLORVALUE=new Vector3(0.6,0.6,0.6);},'DIFFUSECOLORVALUE',function(){return this.DIFFUSECOLORVALUE=new Vector3(1.0,1.0,1.0);},'SPECULARCOLORVALUE',function(){return this.SPECULARCOLORVALUE=new Vector4(1.0,1.0,1.0,8.0);},'REFLECTCOLORVALUE',function(){return this.REFLECTCOLORVALUE=new Vector3(1.0,1.0,1.0);}
		]);
		return Material;
	})(EventDispatcher)


	/**
	*<code>MeshFilter</code> 类用于创建网格过滤器。
	*/
	//class laya.d3.core.MeshFilter extends laya.events.EventDispatcher
	var MeshFilter=(function(_super){
		function MeshFilter(owner){
			this._owner=null;
			this._sharedMesh=null;
			MeshFilter.__super.call(this);
			this._owner=owner;
		}

		__class(MeshFilter,'laya.d3.core.MeshFilter',_super);
		var __proto=MeshFilter.prototype;
		/**
		*设置共享网格。
		*@return value 共享网格。
		*/
		/**
		*获取共享网格。
		*@return 共享网格。
		*/
		__getset(0,__proto,'sharedMesh',function(){
			return this._sharedMesh;
			},function(value){
			this._sharedMesh=value;
			this.event("meshchanged",this);
		});

		return MeshFilter;
	})(EventDispatcher)


	/**
	*<code>MeshRender</code> 类用于网格渲染器。
	*/
	//class laya.d3.core.MeshRender extends laya.events.EventDispatcher
	var MeshRender=(function(_super){
		function MeshRender(owner){
			this._boundingObjectNeedChange=false;
			this._owner=null;
			this._materials=null;
			this._frustumCulling=null;
			this._boundingSphere=null;
			this._boundingBox=null;
			this.castShadow=false;
			this.receiveShadow=false;
			MeshRender.__super.call(this);
			this._materials=[];
			this._boundingBox=new BoundBox1(new Vector3(),new Vector3());
			this._boundingSphere=new BoundSphere1(new Vector3(),0);
			this._boundingObjectNeedChange=true;
			this._owner=owner;
			this.castShadow=true;
			this.receiveShadow=true;
			this._frustumCulling=new FrustumCullingObject();
			this._frustumCulling._component=this;
			this._frustumCulling._layerMask=this._owner.layer.mask;
			this._frustumCulling._ownerEnable=this._owner.enable;
			this._owner.transform.on("worldmatrixneedchanged",this,this._onWorldMatNeedChange);
			this._owner.on("layerchanged",this,this._onOwnerLayerChanged);
			this._owner.on("enabledchanged",this,this._onOwnerEnableChanged);
		}

		__class(MeshRender,'laya.d3.core.MeshRender',_super);
		var __proto=MeshRender.prototype;
		Laya.imps(__proto,{"laya.resource.IDispose":true})
		/**
		*@private
		*/
		__proto._onWorldMatNeedChange=function(){
			this._boundingObjectNeedChange=true;
		}

		/**
		*@private
		*/
		__proto._onOwnerLayerChanged=function(layer){
			this._frustumCulling._layerMask=layer.mask;
		}

		/**
		*@private
		*/
		__proto._onOwnerEnableChanged=function(enable){
			this._frustumCulling._ownerEnable=enable;
		}

		/**
		*@private
		*/
		__proto._calculateBoundingObject=function(){
			if (this._boundingObjectNeedChange){
				if (this._owner.meshFilter.sharedMesh==null){
					this._boundingBox.toDefault();
					this._boundingSphere.toDefault();
					}else {
					var meshBoundingSphere=this._owner.meshFilter.sharedMesh._boundingSphere;
					var maxScale=NaN;
					var transform=this._owner.transform;
					var scale=transform.scale;
					if (scale.x >=scale.y && scale.x >=scale.z)
						maxScale=scale.x;
					else
					maxScale=scale.y >=scale.z ? scale.y :scale.z;
					var worldMat=transform.worldMatrix;
					Vector3.transformCoordinate(meshBoundingSphere.center,worldMat,this._boundingSphere.center);
					this._boundingSphere.radius=meshBoundingSphere.radius *maxScale;
					var meshBoudingBox=this._owner.meshFilter.sharedMesh._boundingBox;
					Vector3.transformCoordinate(meshBoudingBox.min,worldMat,this._boundingBox.min);
					Vector3.transformCoordinate(meshBoudingBox.max,worldMat,this._boundingBox.max)
				}
				this._boundingObjectNeedChange=false;
			}
		}

		/**
		*@private
		*<p>彻底清理资源。</p>
		*<p><b>注意：</b>会强制解锁清理。</p>
		*/
		__proto.dispose=function(){
			this._owner.transform.off("worldmatrixneedchanged",this,this._onWorldMatNeedChange);
			this._owner.off("layerchanged",this,this._onOwnerLayerChanged);
			this._owner.off("enabledchanged",this,this._onOwnerEnableChanged);
		}

		/**
		*设置第一个实例材质。
		*@param value 第一个实例材质。
		*/
		/**
		*返回第一个实例材质,第一次使用会拷贝实例对象。
		*@return 第一个实例材质。
		*/
		__getset(0,__proto,'material',function(){
			var material=this._materials[0];
			if (material && !material._isInstance){
				var instanceMaterial=new Material();
				material.copy(instanceMaterial);
				instanceMaterial.name=instanceMaterial.name+"(Instance)";
				instanceMaterial._isInstance=true;
				this._materials[0]=instanceMaterial;
			}
			return this._materials[0];
			},function(value){
			var oldMaterial=this._materials[0];
			this._materials[0]=value;
			this.event("materialchanged",[this,[oldMaterial],[value]]);
		});

		/**
		*获取包围盒。
		*@return 包围盒。
		*/
		__getset(0,__proto,'boundingBox',function(){
			this._calculateBoundingObject();
			return this._boundingBox;
		});

		/**
		*设置实例材质列表。
		*@param value 实例材质列表。
		*/
		/**
		*获取潜拷贝实例材质列表,第一次使用会拷贝实例对象。
		*@return 浅拷贝实例材质列表。
		*/
		__getset(0,__proto,'materials',function(){
			for (var i=0,n=this._materials.length;i < n;i++){
				var material=this._materials[i];
				if (!material._isInstance){
					var instanceMaterial=new Material();
					material.copy(instanceMaterial);
					instanceMaterial.name=instanceMaterial.name+"(Instance)";
					instanceMaterial._isInstance=true;
					this._materials[i]=instanceMaterial;
				}
			}
			return this._materials.slice();
			},function(value){
			if (!value)
				throw new Error("MeshRender: materials value can't be null.");
			var oldMaterials=this._materials;
			this._materials=value;
			this._owner._iAsyncLodingMeshMaterial=false;
			this.event("materialchanged",[this,oldMaterials.slice(),value.slice()]);
		});

		/**
		*设置第一个材质。
		*@param value 第一个材质。
		*/
		/**
		*返回第一个材质。
		*@return 第一个材质。
		*/
		__getset(0,__proto,'shadredMaterial',function(){
			return this._materials[0];
			},function(value){
			var oldMaterial=this._materials[0];
			this._materials[0]=value;
			this.event("materialchanged",[this,[oldMaterial],[value]]);
		});

		/**
		*设置材质列表。
		*@param value 材质列表。
		*/
		/**
		*获取浅拷贝材质列表。
		*@return 浅拷贝材质列表。
		*/
		__getset(0,__proto,'shadredMaterials',function(){
			var materials=this._materials.slice();
			return materials;
			},function(value){
			if (!value)
				throw new Error("MeshRender: shadredMaterials value can't be null.");
			var oldMaterials=this._materials;
			this._materials=value;
			this._owner._iAsyncLodingMeshMaterial=false;
			this.event("materialchanged",[this,oldMaterials.slice(),value.slice()]);
		});

		/**
		*获取包围球。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundingSphere',function(){
			this._calculateBoundingObject();
			return this._boundingSphere;
		});

		return MeshRender;
	})(EventDispatcher)


	;
	//class specter3d.engine.materials.TextureMaterial3D extends specter3d.engine.materials.Material3D
	var TextureMaterial3D=(function(_super){
		function TextureMaterial3D(diffuseTexture,smooth,repeat,mipmap){
			(smooth===void 0)&& (smooth=true);
			(repeat===void 0)&& (repeat=false);
			(mipmap===void 0)&& (mipmap=true);
			TextureMaterial3D.__super.call(this);
			this.smooth=smooth;
			this.repeat=repeat;
			this.mipmap=mipmap;
			this.diffuseTexture=diffuseTexture;
		}

		__class(TextureMaterial3D,'specter3d.engine.materials.TextureMaterial3D',_super);
		var __proto=TextureMaterial3D.prototype;
		__getset(0,__proto,'normalMap',function(){
			return this._compiledPass.normalMapTexture;
			},function(value){
			this._compiledPass.normalMapTexture=value;
		});

		__getset(0,__proto,'diffuseTexture',function(){
			return this._compiledPass.diffuseTexture;
			},function(value){
			this._compiledPass.diffuseTexture=value;
		});

		__getset(0,__proto,'smooth',null,function(value){
			this._compiledPass.smooth=value;
		});

		__getset(0,__proto,'repeat',null,function(value){
			this._compiledPass.repeat=value;
		});

		__getset(0,__proto,'mipmap',null,function(value){
			this._compiledPass.mipmap=value;
		});

		return TextureMaterial3D;
	})(Material3D)


	/**
	*<code>Transform3D</code> 类用于实现3D变换。
	*/
	//class laya.d3.core.Transform3D extends laya.events.EventDispatcher
	var Transform3D1=(function(_super){
		function Transform3D(owner){
			this._owner=null;
			this._preWorldTransformModifyID=-1;
			this._localUpdate=false;
			this._worldUpdate=true;
			this._parent=null;
			Transform3D.__super.call(this);
			this._tempMatrix0=new Matrix4x4();
			this._tempQuaternion0=new Quaternion1();
			this._tempVector30=new Vector3();
			this._localPosition=new Vector3();
			this._localRotation=new Quaternion1(0,0,0,1);
			this._localScale=new Vector3(1,1,1);
			this._localMatrix=new Matrix4x4();
			this._position=new Vector3();
			this._rotation=new Quaternion1(0,0,0,1);
			this._scale=new Vector3(1,1,1);
			this._worldMatrix=new Matrix4x4();
			this._forward=new Vector3();
			this._up=new Vector3();
			this._right=new Vector3();
			this._owner=owner;
		}

		__class(Transform3D,'laya.d3.core.Transform3D',_super,'Transform3D1');
		var __proto=Transform3D.prototype;
		/**
		*@private
		*/
		__proto._updateLocalMatrix=function(){
			Matrix4x4.createAffineTransformation(this._localPosition,this._localRotation,this._localScale,this._localMatrix);
		}

		/**
		*@private
		*/
		__proto._onLocalTransform=function(){
			this._localUpdate=true;
		}

		/**
		*@private
		*/
		__proto._onWorldTransform=function(){
			if (!this._worldUpdate){
				this._worldUpdate=true;
				this.event("worldmatrixneedchanged");
				for (var i=0,n=this._owner._childs.length;i < n;i++)
				(this._owner._childs [i]).transform._onWorldTransform();
			}
		}

		/**
		*平移变换。
		*@param translation 移动距离。
		*@param isLocal 是否局部空间。
		*/
		__proto.translate=function(translation,isLocal){
			(isLocal===void 0)&& (isLocal=true);
			if (isLocal){
				Matrix4x4.createFromQuaternion(this.localRotation,this._tempMatrix0);
				Vector3.transformCoordinate(translation,this._tempMatrix0,this._tempVector30);
				Vector3.add(this.localPosition,this._tempVector30,this._localPosition);
				this.localPosition=this._localPosition;
				}else {
				Vector3.add(this.position,translation,this._position);
				this.position=this._position;
			}
		}

		/**
		*旋转变换。
		*@param rotations 旋转幅度。
		*@param isLocal 是否局部空间。
		*@param isRadian 是否弧度制。
		*/
		__proto.rotate=function(rotation,isLocal,isRadian){
			(isLocal===void 0)&& (isLocal=true);
			(isRadian===void 0)&& (isRadian=true);
			var rot;
			if (!isRadian){
				Vector3.scale(rotation,Math.PI / 180,this._tempVector30);
				rot=this._tempVector30;
				}else {
				rot=rotation;
			}
			Quaternion1.createFromYawPitchRoll(rot.y,rot.x,rot.z,this._tempQuaternion0);
			if (isLocal){
				Quaternion1.multiply(this._localRotation,this._tempQuaternion0,this._localRotation);
				this.localRotation=this._localRotation;
				}else {
				Quaternion1.multiply(this._tempQuaternion0,this.rotation,this._rotation);
				this.rotation=this._rotation;
			}
		}

		/**
		*设置局部位置。
		*@param value 局部位置。
		*/
		/**
		*获取局部位置。
		*@return 局部位置。
		*/
		__getset(0,__proto,'localPosition',function(){
			return this._localPosition;
			},function(value){
			this._localPosition=value;
			this._onLocalTransform();
			this._onWorldTransform();
		});

		/**
		*获取世界矩阵是否需要更新。
		*@return 世界矩阵是否需要更新。
		*/
		__getset(0,__proto,'worldNeedUpdate',function(){
			return this._worldUpdate;
		});

		/**
		*设置世界位置。
		*@param value 世界位置。
		*/
		/**
		*获取世界位置。
		*@return 世界位置。
		*/
		__getset(0,__proto,'position',function(){
			if (this._parent!==null){
				var worldMatElem=this.worldMatrix.elements;
				this._position.elements[0]=worldMatElem[12];
				this._position.elements[1]=worldMatElem[13];
				this._position.elements[2]=worldMatElem[14];
				}else {
				this._localPosition.cloneTo(this._position);
			}
			return this._position;
			},function(value){
			if (this._parent!==null){
				this._parent.worldMatrix.invert(this._tempMatrix0);
				Vector3.transformCoordinate(value,this._tempMatrix0,this._localPosition);
				this.localPosition=this._localPosition;
				}else {
				value.cloneTo(this._localPosition);
				this.localPosition=this._localPosition;
			}
		});

		/**
		*设置世界矩阵。
		*@param value 世界矩阵。
		*/
		/**
		*获取世界矩阵。
		*@return 世界矩阵。
		*/
		__getset(0,__proto,'worldMatrix',function(){
			if (!this._worldUpdate)
				return this._worldMatrix;
			if (this._parent !=null)
				Matrix4x4.multiply(this._parent.worldMatrix,this.localMatrix,this._worldMatrix);
			else
			this.localMatrix.cloneTo(this._worldMatrix);
			this._worldUpdate=false;
			return this._worldMatrix;
			},function(value){
			if (this._parent===null)
				this.localMatrix=value;
			else {
				this._parent.worldMatrix.invert(this._localMatrix);
				Matrix4x4.multiply(this._localMatrix,value,this._localMatrix);
				this.localMatrix=this._localMatrix;
			}
		});

		/**
		*设置局部矩阵。
		*@param value 局部矩阵。
		*/
		/**
		*获取局部矩阵。
		*@return 局部矩阵。
		*/
		__getset(0,__proto,'localMatrix',function(){
			if (this._localUpdate){
				this._updateLocalMatrix();
				this._localUpdate=false;
			}
			return this._localMatrix;
			},function(value){
			this._localMatrix=value;
			this._localMatrix.decompose(this._localPosition,this._localRotation,this._localScale);
			this._onWorldTransform();
		});

		/**
		*设置局部旋转。
		*@param value 局部旋转。
		*/
		/**
		*获取局部旋转。
		*@return 局部旋转。
		*/
		__getset(0,__proto,'localRotation',function(){
			return this._localRotation;
			},function(value){
			this._localRotation=value;
			this._localRotation.normalize(this._localRotation);
			this._onLocalTransform();
			this._onWorldTransform();
		});

		/**
		*设置世界旋转。
		*@param value 世界旋转。
		*/
		/**
		*获取世界旋转。
		*@return 世界旋转。
		*/
		__getset(0,__proto,'rotation',function(){
			if (this._parent!==null){
				this.worldMatrix.decompose(this._position,this._rotation,this._scale);
				}else {
				this._localRotation.cloneTo(this._rotation);
			}
			return this._rotation;
			},function(value){
			if (this._parent!==null){
				this._parent.rotation.invert(this._tempQuaternion0);
				Quaternion1.multiply(value,this._tempQuaternion0,this._localRotation);
				this.localRotation=this._localRotation;
				}else {
				value.cloneTo(this._localRotation);
				this.localRotation=this._localRotation;
			}
		});

		/**
		*设置局部缩放。
		*@param value 局部缩放。
		*/
		/**
		*获取局部缩放。
		*@return 局部缩放。
		*/
		__getset(0,__proto,'localScale',function(){
			return this._localScale;
			},function(value){
			this._localScale=value;
			this._onLocalTransform();
			this._onWorldTransform();
		});

		/**
		*设置局部空间的旋转角度。
		*@param value 欧拉角的旋转值，顺序为x、y、z。
		*/
		__getset(0,__proto,'localRotationEuler',null,function(value){
			Quaternion1.createFromYawPitchRoll(value.y,value.x,value.z,this._localRotation);
			this._onLocalTransform();
			this._onWorldTransform();
		});

		/**
		*获取世界缩放。
		*@return 世界缩放。
		*/
		__getset(0,__proto,'scale',function(){
			if (this._parent!==null){
				Vector3.multiply(this._parent.scale,this._localScale,this._scale);
				}else {
				this._localScale.cloneTo(this._scale);
			}
			return this._scale;
		});

		/**
		*设置局部空间的旋转角度。
		*@param 欧拉角的旋转值，顺序为x、y、z。
		*/
		__getset(0,__proto,'rotationEuler',null,function(value){
			Quaternion1.createFromYawPitchRoll(value.y,value.x,value.z,this._rotation);
			this.rotation=this._rotation;
		});

		/**
		*获取向前方向。
		*@return 向前方向。
		*/
		__getset(0,__proto,'forward',function(){
			var worldMatElem=this.worldMatrix.elements;
			this._forward.elements[0]=-worldMatElem[8];
			this._forward.elements[1]=-worldMatElem[9];
			this._forward.elements[2]=-worldMatElem[10];
			return this._forward;
		});

		/**
		*获取向上方向。
		*@return 向上方向。
		*/
		__getset(0,__proto,'up',function(){
			var worldMatElem=this.worldMatrix.elements;
			this._up.elements[0]=worldMatElem[4];
			this._up.elements[1]=worldMatElem[5];
			this._up.elements[2]=worldMatElem[6];
			return this._up;
		});

		/**
		*获取向右方向。
		*@return 向右方向。
		*/
		__getset(0,__proto,'right',function(){
			var worldMatElem=this.worldMatrix.elements;
			this._right.elements[0]=worldMatElem[0];
			this._right.elements[1]=worldMatElem[1];
			this._right.elements[2]=worldMatElem[2];
			return this._right;
		});

		return Transform3D;
	})(EventDispatcher)


	/**
	*<code>TransformUV</code> 类用于实现UV变换。
	*/
	//class laya.d3.core.TransformUV extends laya.events.EventDispatcher
	var TransformUV=(function(_super){
		function TransformUV(){
			this._rotation=0;
			this._matNeedUpdte=false;
			TransformUV.__super.call(this);
			this._tempTitlingV3=new Vector3();
			this._tempRotationMatrix=new Matrix4x4();
			this._tempTitlingMatrix=new Matrix4x4();
			this._matrix=new Matrix4x4();
			this._offset=new Vector2();
			this._tiling=new Vector2();
		}

		__class(TransformUV,'laya.d3.core.TransformUV',_super);
		var __proto=TransformUV.prototype;
		/**
		*@private
		*/
		__proto._updateMatrix=function(){
			this._tempTitlingV3.elements[0]=this._tiling.x;
			this._tempTitlingV3.elements[1]=this._tiling.y;
			this._tempTitlingV3.elements[2]=1;
			Matrix4x4.createScaling(this._tempTitlingV3,this._tempTitlingMatrix);
			Matrix4x4.createRotationZ(this._rotation,this._tempRotationMatrix);
			Matrix4x4.multiply(this._tempRotationMatrix,this._tempTitlingMatrix,this._matrix);
			var mate=this._matrix.elements;
			mate[12]=this._offset.x;
			mate[13]=this._offset.y;
			mate[14]=0;
		}

		/**
		*获取变换矩阵。
		*@return 变换矩阵。
		*/
		__getset(0,__proto,'matrix',function(){
			if (this._matNeedUpdte){
				this._updateMatrix();
				this._matNeedUpdte=false;
			}
			return this._matrix;
		});

		/**
		*设置偏移。
		*@param value 偏移。
		*/
		/**
		*获取偏移。
		*@return 偏移。
		*/
		__getset(0,__proto,'offset',function(){
			return this._offset;
			},function(value){
			this._offset=value;
			this._matNeedUpdte=true;
		});

		/**
		*设置旋转。
		*@param value 旋转。
		*/
		/**
		*获取旋转。
		*@return 旋转。
		*/
		__getset(0,__proto,'rotation',function(){
			return this._rotation;
			},function(value){
			this._rotation=value;
			this._matNeedUpdte=true;
		});

		/**
		*设置平铺次数。
		*@param value 平铺次数。
		*/
		/**
		*获取平铺次数。
		*@return 平铺次数。
		*/
		__getset(0,__proto,'tiling',function(){
			return this._tiling;
			},function(value){
			this._tiling=value;
			this._matNeedUpdte=true;
		});

		return TransformUV;
	})(EventDispatcher)


	//class specter3d.engine.primitives.CubeGeometry extends specter3d.engine.resources.Geometry3D
	var CubeGeometry=(function(_super){
		function CubeGeometry(width,height,depth,segmentsW,segmentsH,segmentsD,tile6){
			this._width=NaN;
			this._height=NaN;
			this._depth=NaN;
			this._tile6=false;
			this._segmentsW=NaN;
			this._segmentsH=NaN;
			this._segmentsD=NaN;
			(width===void 0)&& (width=100);
			(height===void 0)&& (height=100);
			(depth===void 0)&& (depth=100);
			(segmentsW===void 0)&& (segmentsW=1);
			(segmentsH===void 0)&& (segmentsH=1);
			(segmentsD===void 0)&& (segmentsD=1);
			(tile6===void 0)&& (tile6=true);
			CubeGeometry.__super.call(this);
			this._width=width;
			this._height=height;
			this._depth=depth;
			this._segmentsW=segmentsW;
			this._segmentsH=segmentsH;
			this._segmentsD=segmentsD;
			this._tile6=tile6;
			this.buildGeometry();
		}

		__class(CubeGeometry,'specter3d.engine.primitives.CubeGeometry',_super);
		var __proto=CubeGeometry.prototype;
		__proto.buildGeometry=function(){
			var target=new SubGeometry3D();
			var data;
			var indices;
			var tl=0,tr=0,bl=0,br=0;
			var i=0,j=0,inc=0;
			var vidx=0,fidx=0;
			var hw=NaN,hh=NaN,hd=NaN;
			var dw=NaN,dh=NaN,dd=NaN;
			var outer_pos=NaN;
			var numVerts=((this._segmentsW+1)*(this._segmentsH+1)+
			(this._segmentsW+1)*(this._segmentsD+1)+
			(this._segmentsH+1)*(this._segmentsD+1))*2;
			var stride=13;
			var skip=stride-9;
			data=new Float32Array(numVerts *stride,true);
			indices=new Uint16Array((this._segmentsW*this._segmentsH+this._segmentsW*this._segmentsD+this._segmentsH*this._segmentsD)*12,true);
			vidx=0;
			fidx=0;
			hw=this._width/2;
			hh=this._height/2;
			hd=this._depth/2;
			dw=this._width/this._segmentsW;
			dh=this._height/this._segmentsH;
			dd=this._depth/this._segmentsD;
			for (i=0;i <=this._segmentsW;i++){
				outer_pos=-hw+i*dw;
				for (j=0;j <=this._segmentsH;j++){
					data[vidx++]=outer_pos;
					data[vidx++]=-hh+j*dh;
					data[vidx++]=-hd;
					data[vidx++]=0;
					data[vidx++]=0;
					data[vidx++]=-1;
					data[vidx++]=1;
					data[vidx++]=0;
					data[vidx++]=0;
					vidx+=skip;
					data[vidx++]=outer_pos;
					data[vidx++]=-hh+j*dh;
					data[vidx++]=hd;
					data[vidx++]=0;
					data[vidx++]=0;
					data[vidx++]=1;
					data[vidx++]=-1;
					data[vidx++]=0;
					data[vidx++]=0;
					vidx+=skip;
					if (i && j){
						tl=2 *((i-1)*(this._segmentsH+1)+(j-1));
						tr=2 *(i *(this._segmentsH+1)+(j-1));
						bl=tl+2;
						br=tr+2;
						indices[fidx++]=tl;
						indices[fidx++]=bl;
						indices[fidx++]=br;
						indices[fidx++]=tl;
						indices[fidx++]=br;
						indices[fidx++]=tr;
						indices[fidx++]=tr+1;
						indices[fidx++]=br+1;
						indices[fidx++]=bl+1;
						indices[fidx++]=tr+1;
						indices[fidx++]=bl+1;
						indices[fidx++]=tl+1;
					}
				}
			}
			inc+=2*(this._segmentsW+1)*(this._segmentsH+1);
			for (i=0;i <=this._segmentsW;i++){
				outer_pos=-hw+i*dw;
				for (j=0;j <=this._segmentsD;j++){
					data[vidx++]=outer_pos;
					data[vidx++]=hh;
					data[vidx++]=-hd+j*dd;
					data[vidx++]=0;
					data[vidx++]=1;
					data[vidx++]=0;
					data[vidx++]=1;
					data[vidx++]=0;
					data[vidx++]=0;
					vidx+=skip;
					data[vidx++]=outer_pos;
					data[vidx++]=-hh;
					data[vidx++]=-hd+j*dd;
					data[vidx++]=0;
					data[vidx++]=-1;
					data[vidx++]=0;
					data[vidx++]=1;
					data[vidx++]=0;
					data[vidx++]=0;
					vidx+=skip;
					if (i && j){
						tl=inc+2 *((i-1)*(this._segmentsD+1)+(j-1));
						tr=inc+2 *(i *(this._segmentsD+1)+(j-1));
						bl=tl+2;
						br=tr+2;
						indices[fidx++]=tl;
						indices[fidx++]=bl;
						indices[fidx++]=br;
						indices[fidx++]=tl;
						indices[fidx++]=br;
						indices[fidx++]=tr;
						indices[fidx++]=tr+1;
						indices[fidx++]=br+1;
						indices[fidx++]=bl+1;
						indices[fidx++]=tr+1;
						indices[fidx++]=bl+1;
						indices[fidx++]=tl+1;
					}
				}
			}
			inc+=2*(this._segmentsW+1)*(this._segmentsD+1);
			for (i=0;i <=this._segmentsD;i++){
				outer_pos=hd-i*dd;
				for (j=0;j <=this._segmentsH;j++){
					data[vidx++]=-hw;
					data[vidx++]=-hh+j*dh;
					data[vidx++]=outer_pos;
					data[vidx++]=-1;
					data[vidx++]=0;
					data[vidx++]=0;
					data[vidx++]=0;
					data[vidx++]=0;
					data[vidx++]=-1;
					vidx+=skip;
					data[vidx++]=hw;
					data[vidx++]=-hh+j*dh;
					data[vidx++]=outer_pos;
					data[vidx++]=1;
					data[vidx++]=0;
					data[vidx++]=0;
					data[vidx++]=0;
					data[vidx++]=0;
					data[vidx++]=1;
					vidx+=skip;
					if (i && j){
						tl=inc+2 *((i-1)*(this._segmentsH+1)+(j-1));
						tr=inc+2 *(i *(this._segmentsH+1)+(j-1));
						bl=tl+2;
						br=tr+2;
						indices[fidx++]=tl;
						indices[fidx++]=bl;
						indices[fidx++]=br;
						indices[fidx++]=tl;
						indices[fidx++]=br;
						indices[fidx++]=tr;
						indices[fidx++]=tr+1;
						indices[fidx++]=br+1;
						indices[fidx++]=bl+1;
						indices[fidx++]=tr+1;
						indices[fidx++]=bl+1;
						indices[fidx++]=tl+1;
					}
				}
			}
			target.indices=indices;
			this.buildUVs(target,data);
			this.addSubGeometry(target);
		}

		__proto.buildUVs=function(target,data){
			var i=0,j=0,uidx=0;
			var u_tile_dim=NaN,v_tile_dim=NaN;
			var u_tile_step=NaN,v_tile_step=NaN;
			var tl0u=NaN,tl0v=NaN;
			var tl1u=NaN,tl1v=NaN;
			var du=NaN,dv=NaN;
			var stride=13;
			var numUvs=((this._segmentsW+1)*(this._segmentsH+1)+
			(this._segmentsW+1)*(this._segmentsD+1)+
			(this._segmentsH+1)*(this._segmentsD+1))*2 *stride;
			var skip=stride-2;
			if (this._tile6){
				u_tile_dim=u_tile_step=1/3;
				v_tile_dim=v_tile_step=1/2;
			}
			else {
				u_tile_dim=v_tile_dim=1;
				u_tile_step=v_tile_step=0;
			}
			uidx=9;
			tl0u=1 *u_tile_step;
			tl0v=1 *v_tile_step;
			tl1u=2 *u_tile_step;
			tl1v=0 *v_tile_step;
			du=u_tile_dim / this._segmentsW;
			dv=v_tile_dim / this._segmentsH;
			for (i=0;i<=this._segmentsW;i++){
				for (j=0;j<=this._segmentsH;j++){
					data[uidx++]=tl0u+i *du;
					data[uidx++]=tl0v+(v_tile_dim-j *dv);
					uidx+=skip;
					data[uidx++]=tl1u+(u_tile_dim-i *du);
					data[uidx++]=tl1v+(v_tile_dim-j *dv);
					uidx+=skip;
				}
			}
			tl0u=1 *u_tile_step;
			tl0v=0 *v_tile_step;
			tl1u=0 *u_tile_step;
			tl1v=0 *v_tile_step;
			du=u_tile_dim / this._segmentsW;
			dv=v_tile_dim / this._segmentsD;
			for (i=0;i<=this._segmentsW;i++){
				for (j=0;j<=this._segmentsD;j++){
					data[uidx++]=tl0u+i *du;
					data[uidx++]=tl0v+(v_tile_dim-j *dv);
					uidx+=skip;
					data[uidx++]=tl1u+i *du;
					data[uidx++]=tl1v+j *dv;
					uidx+=skip;
				}
			}
			tl0u=0 *u_tile_step;
			tl0v=1 *v_tile_step;
			tl1u=2 *u_tile_step;
			tl1v=1 *v_tile_step;
			du=u_tile_dim / this._segmentsD;
			dv=v_tile_dim / this._segmentsH;
			for (i=0;i<=this._segmentsD;i++){
				for (j=0;j<=this._segmentsH;j++){
					data[uidx++]=tl0u+i *du;
					data[uidx++]=tl0v+(v_tile_dim-j *dv);
					uidx+=skip;
					data[uidx++]=tl1u+(u_tile_dim-i *du);
					data[uidx++]=tl1v+(v_tile_dim-j *dv);
					uidx+=skip;
				}
			}
			target.updateVertexAttribute(data,GeomUtil.SUB_GEOMETRY_ATTRIBUTES);
		}

		return CubeGeometry;
	})(Geometry3D)


	/**
	*面片几何体
	*@author wangcx
	*
	*/
	//class specter3d.engine.primitives.PlaneGeometry extends specter3d.engine.resources.Geometry3D
	var PlaneGeometry=(function(_super){
		function PlaneGeometry(width,height,segments,yUp,doubleSided){
			this._doubleSided=false;
			this._height=NaN;
			this._segments=0;
			this._width=NaN;
			this._yUp=false;
			(width===void 0)&& (width=100);
			(height===void 0)&& (height=100);
			(segments===void 0)&& (segments=1);
			(yUp===void 0)&& (yUp=false);
			(doubleSided===void 0)&& (doubleSided=false);
			PlaneGeometry.__super.call(this);
			this._segments=segments;
			this._yUp=yUp;
			this._width=width;
			this._height=height;
			this._doubleSided=doubleSided;
			this.buildGeometry();
		}

		__class(PlaneGeometry,'specter3d.engine.primitives.PlaneGeometry',_super);
		var __proto=PlaneGeometry.prototype;
		/**
		*构建几何体
		*
		*/
		__proto.buildGeometry=function(){
			var _subGeometry=new SubGeometry3D();
			var x=NaN,y=NaN;
			var numIndices=0;
			var base=0;
			var tw=this._segments+1;
			var numVertices=(this._segments+1)*tw;
			var stride=13;
			var skip=stride-9;
			if (this._doubleSided)
				numVertices*=2;
			numIndices=this._segments *this._segments *6;
			if (this._doubleSided)
				numIndices<<=1;
			var _vertexData=new Float32Array(numVertices *stride);
			var _indices=new Uint16Array(numIndices);
			numIndices=0;
			var index=0;
			for (var yi=0;yi <=this._segments;++yi){
				for (var xi=0;xi <=this._segments;++xi){
					x=(xi / this._segments-.5)*this._width;
					y=(yi / this._segments-.5)*this._height;
					_vertexData[index++]=x;
					if (this._yUp){
						_vertexData[index++]=0;
						_vertexData[index++]=y;
					}
					else{
						_vertexData[index++]=y;
						_vertexData[index++]=0;
					}
					_vertexData[index++]=0;
					if (this._yUp){
						_vertexData[index++]=1;
						_vertexData[index++]=0;
					}
					else{
						_vertexData[index++]=0;
						_vertexData[index++]=-1;
					}
					_vertexData[index++]=1;
					_vertexData[index++]=0;
					_vertexData[index++]=0;
					index+=skip;
					if (this._doubleSided){
						for (var i=0;i < 3;++i){
							_vertexData[index]=_vertexData[index-stride];
							++index;
						}
						for (i=0;i < 3;++i){
							_vertexData[index]=-_vertexData[index-stride];
							++index;
						}
						for (i=0;i < 3;++i){
							_vertexData[index]=-_vertexData[index-stride];
							++index
						}
						index+=skip;
					}
					if (xi !=this._segments && yi !=this._segments){
						base=xi+yi *tw;
						var mult=this._doubleSided ? 2 :1;
						_indices[numIndices++]=base *mult;
						_indices[numIndices++]=(base+tw)*mult;
						_indices[numIndices++]=(base+tw+1)*mult;
						_indices[numIndices++]=base *mult;
						_indices[numIndices++]=(base+tw+1)*mult;
						_indices[numIndices++]=(base+1)*mult;
						if (this._doubleSided){
							_indices[numIndices++]=(base+tw+1)*mult+1;
							_indices[numIndices++]=(base+tw)*mult+1;
							_indices[numIndices++]=base *mult+1;
							_indices[numIndices++]=(base+1)*mult+1;
							_indices[numIndices++]=(base+tw+1)*mult+1;
							_indices[numIndices++]=base *mult+1;
						}
					}
				}
			}
			_subGeometry.indices=_indices;
			_subGeometry.updateVertexAttribute(_vertexData,GeomUtil.SUB_GEOMETRY_ATTRIBUTES);
			this.buildUVs(_subGeometry,_vertexData);
			this.addSubGeometry(_subGeometry);
			_subGeometry.vertexData;
		}

		__proto.buildUVs=function(target,_vertexData){
			var data;
			var stride=13;
			var numUvs=(this._segments+1)*(this._segments+1)*stride;
			var skip=stride-2;
			if (this._doubleSided)
				numUvs*=2;
			if (_vertexData && numUvs==_vertexData.length)
				data=_vertexData;
			var index=9;
			for (var yi=0;yi <=this._segments;++yi){
				for (var xi=0;xi <=this._segments;++xi){
					data[index++]=xi/this._segments;
					data[index++]=1-yi/this._segments;
					index+=skip;
					if (this._doubleSided){
						data[index++]=xi/this._segments;
						data[index++]=1-yi/this._segments;
						index+=skip;
					}
				}
			}
			target.updateVertexAttribute(data,GeomUtil.SUB_GEOMETRY_ATTRIBUTES);
		}

		return PlaneGeometry;
	})(Geometry3D)


	//class specter3d.engine.primitives.SphereGeometry extends specter3d.engine.resources.Geometry3D
	var SphereGeometry=(function(_super){
		function SphereGeometry(radius,segmentsW,segmentsH,yUp){
			this._radius=NaN;
			this._segmentsW=0;
			this._segmentsH=0;
			this._yUp=false;
			(radius===void 0)&& (radius=50);
			(segmentsW===void 0)&& (segmentsW=16);
			(segmentsH===void 0)&& (segmentsH=12);
			(yUp===void 0)&& (yUp=true);
			SphereGeometry.__super.call(this);
			this._radius=radius;
			this._segmentsW=segmentsW;
			this._segmentsH=segmentsH;
			this._yUp=yUp;
			this.buildGeometry();
		}

		__class(SphereGeometry,'specter3d.engine.primitives.SphereGeometry',_super);
		var __proto=SphereGeometry.prototype;
		__proto.buildGeometry=function(){
			var vertices;
			var indices;
			var i=0,j=0,triIndex=0;
			var numVerts=(this._segmentsH+1)*(this._segmentsW+1);
			var stride=13;
			var skip=stride-9;
			vertices=new Float32Array(numVerts*stride);
			indices=new Uint16Array((this._segmentsH-1)*this._segmentsW*6);
			var startIndex=0;
			var index=0;
			var comp1=NaN,comp2=NaN,t1=NaN,t2=NaN;
			for (j=0;j <=this._segmentsH;++j){
				startIndex=index;
				var horangle=Math.PI*j/this._segmentsH;
				var z=-this._radius*Math.cos(horangle);
				var ringradius=this._radius*Math.sin(horangle);
				for (i=0;i <=this._segmentsW;++i){
					var verangle=2*Math.PI*i/this._segmentsW;
					var x=ringradius*Math.cos(verangle);
					var y=ringradius*Math.sin(verangle);
					var normLen=1/Math.sqrt(x*x+y*y+z*z);
					var tanLen=Math.sqrt(y*y+x*x);
					if (this._yUp){
						t1=0;
						t2=tanLen >.007? x/tanLen :0;
						comp1=-z;
						comp2=y;
						}else {
						t1=tanLen >.007? x/tanLen :0;
						t2=0;
						comp1=y;
						comp2=z;
					}
					if (i==this._segmentsW){
						vertices[index++]=vertices[startIndex];
						vertices[index++]=vertices[startIndex+1];
						vertices[index++]=vertices[startIndex+2];
						vertices[index++]=vertices[startIndex+3]+(x*normLen)*.5;
						vertices[index++]=vertices[startIndex+4]+(comp1*normLen)*.5;
						vertices[index++]=vertices[startIndex+5]+(comp2*normLen)*.5;
						vertices[index++]=tanLen >.007?-y/tanLen :1;
						vertices[index++]=t1;
						vertices[index++]=t2;
						}else {
						vertices[index++]=x;
						vertices[index++]=comp1;
						vertices[index++]=comp2;
						vertices[index++]=x*normLen;
						vertices[index++]=comp1*normLen;
						vertices[index++]=comp2*normLen;
						vertices[index++]=tanLen >.007?-y/tanLen :1;
						vertices[index++]=t1;
						vertices[index++]=t2;
					}
					if (i > 0 && j > 0){
						var a=(this._segmentsW+1)*j+i;
						var b=(this._segmentsW+1)*j+i-1;
						var c=(this._segmentsW+1)*(j-1)+i-1;
						var d=(this._segmentsW+1)*(j-1)+i;
						if (j==this._segmentsH){
							vertices[index-9]=vertices[startIndex];
							vertices[index-8]=vertices[startIndex+1];
							vertices[index-7]=vertices[startIndex+2];
							indices[triIndex++]=a;
							indices[triIndex++]=c;
							indices[triIndex++]=d;
							}else if (j==1){
							indices[triIndex++]=a;
							indices[triIndex++]=b;
							indices[triIndex++]=c;
							}else {
							indices[triIndex++]=a;
							indices[triIndex++]=b;
							indices[triIndex++]=c;
							indices[triIndex++]=a;
							indices[triIndex++]=c;
							indices[triIndex++]=d;
						}
					}
					index+=skip;
				}
			};
			var _subGeometry=new SubGeometry3D();
			_subGeometry.indices=indices;
			this.buildUVs(_subGeometry,vertices);
			this.addSubGeometry(_subGeometry);
			_subGeometry.vertexData;
		}

		__proto.buildUVs=function(target,data){
			var i=0,j=0;
			var stride=13;
			var numUvs=(this._segmentsH+1)*(this._segmentsW+1)*stride;
			var skip=stride-2;
			var index=9;
			for (j=0;j <=this._segmentsH;++j){
				for (i=0;i <=this._segmentsW;++i){
					data[index++]=(i/this._segmentsW)*1;
					data[index++]=(j/this._segmentsH)*1;
					index+=skip;
				}
			}
			target.updateVertexAttribute(data,GeomUtil.SUB_GEOMETRY_ATTRIBUTES);
		}

		return SphereGeometry;
	})(Geometry3D)


	/**
	*<code>Texture</code> 是一个纹理处理类。
	*/
	//class laya.resource.Texture extends laya.events.EventDispatcher
	var Texture=(function(_super){
		function Texture(bitmap,uv){
			//this.bitmap=null;
			//this.uv=null;
			this.offsetX=0;
			this.offsetY=0;
			this.sourceWidth=0;
			this.sourceHeight=0;
			//this._loaded=false;
			this._w=0;
			this._h=0;
			//this.$_GID=NaN;
			//this.url=null;
			this._uvID=0;
			Texture.__super.call(this);
			if (bitmap){
				bitmap.useNum++;
			}
			this.setTo(bitmap,uv);
		}

		__class(Texture,'laya.resource.Texture',_super);
		var __proto=Texture.prototype;
		/**
		*设置此对象的位图资源、UV数据信息。
		*@param bitmap 位图资源
		*@param uv UV数据信息
		*/
		__proto.setTo=function(bitmap,uv){
			this.bitmap=bitmap;
			this.uv=uv || Texture.DEF_UV;
			if (bitmap){
				this._w=bitmap.width;
				this._h=bitmap.height;
				this.sourceWidth=this.sourceWidth || this._w;
				this.sourceHeight=this.sourceHeight || this._h
				this._loaded=this._w > 0;
				var _this=this;
				if (this._loaded){
					RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
					}else {
					var bm=bitmap;
					if ((bm instanceof laya.resource.HTMLImage )&& bm.image)
						bm.image.addEventListener('load',function(e){
						RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
					},false);
				}
			}
		}

		/**@private 激活资源。*/
		__proto.active=function(){
			this.bitmap.activeResource();
		}

		/**
		*销毁纹理（分直接销毁，跟计数销毁两种）
		*@param foreDiposeTexture true为强制销毁主纹理，false是通过计数销毁纹理
		*/
		__proto.destroy=function(foreDiposeTexture){
			(foreDiposeTexture===void 0)&& (foreDiposeTexture=false);
			if (this.bitmap && (this.bitmap).useNum > 0){
				if (foreDiposeTexture){
					this.bitmap.dispose();
					(this.bitmap).useNum=0;
					}else {
					(this.bitmap).useNum--;
					if ((this.bitmap).useNum==0){
						this.bitmap.dispose();
					}
				}
				this.bitmap=null;
				if (this.url)Laya.loader.clearRes(this.url);
				this._loaded=false;
			}
		}

		/**
		*加载指定地址的图片。
		*@param url 图片地址。
		*/
		__proto.load=function(url){
			var _$this=this;
			this._loaded=false;
			var fileBitmap=(this.bitmap || (this.bitmap=HTMLImage.create(URL.formatURL(url))));
			if (fileBitmap){
				fileBitmap.useNum++;
			};
			var _this=this;
			fileBitmap.onload=function (){
				fileBitmap.onload=null;
				_this._loaded=true;
				_$this.sourceWidth=_$this._w=fileBitmap.width;
				_$this.sourceHeight=_$this._h=fileBitmap.height;
				_this.event("loaded",this);
				(RunDriver.addToAtlas)&& (RunDriver.addToAtlas(_this));
			};
		}

		/**@private */
		__proto.addTextureToAtlas=function(e){
			RunDriver.addTextureToAtlas(this);
		}

		/**
		*获取Texture上的某个区域的像素点
		*@param x
		*@param y
		*@param width
		*@param height
		*@return 返回像素点集合
		*/
		__proto.getPixels=function(x,y,width,height){
			if (Render.isWebGL){
				return RunDriver.getTexturePixels(this,x,y,width,height);
				}else {
				Browser.canvas.size(x+width,y+height);
				Browser.context.drawImage(this.bitmap.source,0,0);
				Browser.document.body.appendChild(Browser.canvas.source);
				var info=Browser.context.getImageData(x,y,width,height);
			}
			return info.data;
		}

		/**实际高度。*/
		__getset(0,__proto,'height',function(){
			if (this._h)return this._h;
			return (this.uv && this.uv!==Texture.DEF_UV)? (this.uv[5]-this.uv[1])*this.bitmap.height :this.bitmap.height;
			},function(value){
			this._h=value;
			this.sourceHeight || (this.sourceHeight=value);
		});

		/**
		*表示是否加载成功，只能表示初次载入成功（通常包含下载和载入）,并不能完全表示资源是否可立即使用（资源管理机制释放影响等）。
		*/
		__getset(0,__proto,'loaded',function(){
			return this._loaded;
		});

		/**
		*表示资源是否已释放。
		*/
		__getset(0,__proto,'released',function(){
			return this.bitmap.released;
		});

		/**
		*通过外部设置是否启用纹理平铺(后面要改成在着色器里计算)
		*/
		/**
		*获取当前纹理是否启用了纹理平铺
		*/
		__getset(0,__proto,'repeat',function(){
			if (Render.isWebGL && this.bitmap){
				return this.bitmap.repeat;
			}
			return true;
			},function(value){
			if (value){
				if (Render.isWebGL && this.bitmap){
					this.bitmap.repeat=value;
					if (value){
						this.bitmap.enableMerageInAtlas=false;
					}
				}
			}
		});

		/**激活并获取资源。*/
		__getset(0,__proto,'source',function(){
			this.bitmap.activeResource();
			return this.bitmap.source;
		});

		/**实际宽度。*/
		__getset(0,__proto,'width',function(){
			if (this._w)return this._w;
			return (this.uv && this.uv!==Texture.DEF_UV)? (this.uv[2]-this.uv[0])*this.bitmap.width :this.bitmap.width;
			},function(value){
			this._w=value;
			this.sourceWidth || (this.sourceWidth=value);
		});

		/**
		*设置线性采样的状态（目前只能第一次绘制前设置false生效,来关闭线性采样）
		*/
		/**
		*获取当前纹理是否启用了线性采样
		*/
		__getset(0,__proto,'isLinearSampling',function(){
			return Render.isWebGL ? (this.bitmap.minFifter !=0x2600):true;
			},function(value){
			if (!value && Render.isWebGL){
				if (!value && (this.bitmap.minFifter==-1)&& (this.bitmap.magFifter==-1)){
					this.bitmap.minFifter=0x2600;
					this.bitmap.magFifter=0x2600;
					this.bitmap.enableMerageInAtlas=false;
				}
			}
		});

		Texture.moveUV=function(offsetX,offsetY,uv){
			for (var i=0;i < 8;i+=2){
				uv[i]+=offsetX;
				uv[i+1]+=offsetY;
			}
			return uv;
		}

		Texture.create=function(source,x,y,width,height,offsetX,offsetY,sourceWidth,sourceHeight){
			(offsetX===void 0)&& (offsetX=0);
			(offsetY===void 0)&& (offsetY=0);
			(sourceWidth===void 0)&& (sourceWidth=0);
			(sourceHeight===void 0)&& (sourceHeight=0);
			var btex=(source instanceof laya.resource.Texture );
			var uv=btex ? source.uv :Texture.DEF_UV;
			var bitmap=btex ? source.bitmap :source;
			var tex=new Texture(bitmap,null);
			tex.width=width;
			tex.height=height;
			tex.offsetX=offsetX;
			tex.offsetY=offsetY;
			tex.sourceWidth=sourceWidth || width;
			tex.sourceHeight=sourceHeight || height;
			var dwidth=1 / bitmap.width;
			var dheight=1 / bitmap.height;
			x *=dwidth;
			y *=dheight;
			width *=dwidth;
			height *=dheight;
			var u1=tex.uv[0],v1=tex.uv[1],u2=tex.uv[4],v2=tex.uv[5];
			var inAltasUVWidth=(u2-u1),inAltasUVHeight=(v2-v1);
			var oriUV=Texture.moveUV(uv[0],uv[1],[x,y,x+width,y,x+width,y+height,x,y+height]);
			tex.uv=[u1+oriUV[0] *inAltasUVWidth,v1+oriUV[1] *inAltasUVHeight,u2-(1-oriUV[2])*inAltasUVWidth,v1+oriUV[3] *inAltasUVHeight,u2-(1-oriUV[4])*inAltasUVWidth,v2-(1-oriUV[5])*inAltasUVHeight,u1+oriUV[6] *inAltasUVWidth,v2-(1-oriUV[7])*inAltasUVHeight];
			return tex;
		}

		Texture.createFromTexture=function(texture,x,y,width,height){
			var rect=Rectangle.TEMP.setTo(x-texture.offsetX,y-texture.offsetY,width,height);
			var result=rect.intersection(Texture._rect1.setTo(0,0,texture.width,texture.height),Texture._rect2);
			if (result)
				var tex=Texture.create(texture,result.x,result.y,result.width,result.height,result.x-rect.x,result.y-rect.y,width,height);
			else return null;
			tex.bitmap.useNum--;
			return tex;
		}

		Texture.DEF_UV=[0,0,1.0,0,1.0,1.0,0,1.0];
		Texture.INV_UV=[0,1,1.0,1,1.0,0.0,0,0.0];
		Texture._rect1=new Rectangle();
		Texture._rect2=new Rectangle();
		return Texture;
	})(EventDispatcher)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.shader.d2.value.Value2D extends laya.webgl.shader.ShaderValue
	var Value2D=(function(_super){
		function Value2D(mainID,subID){
			this.size=[0,0];
			this.alpha=1.0;
			//this.mmat=null;
			this.ALPHA=1.0;
			//this.shader=null;
			//this.mainID=0;
			this.subID=0;
			//this.filters=null;
			//this.textureHost=null;
			//this.texture=null;
			//this.fillStyle=null;
			//this.color=null;
			//this.strokeStyle=null;
			//this.colorAdd=null;
			//this.glTexture=null;
			//this.u_mmat2=null;
			this.u_pos=[0,0];
			//this._inClassCache=null;
			this._cacheID=0;
			Value2D.__super.call(this);
			this.defines=new ShaderDefines2D();
			this.position=Value2D._POSITION;
			this.mainID=mainID;
			this.subID=subID;
			this.textureHost=null;
			this.texture=null;
			this.fillStyle=null;
			this.color=null;
			this.strokeStyle=null;
			this.colorAdd=null;
			this.glTexture=null;
			this.u_mmat2=null;
			this._cacheID=mainID|subID;
			this._inClassCache=Value2D._cache[this._cacheID];
			if (mainID>0 && !this._inClassCache){
				this._inClassCache=Value2D._cache[this._cacheID]=[];
				this._inClassCache._length=0;
			}
			this.clear();
		}

		__class(Value2D,'laya.webgl.shader.d2.value.Value2D',_super);
		var __proto=Value2D.prototype;
		__proto.setValue=function(value){}
		//throw new Error("todo in subclass");
		__proto.refresh=function(){
			var size=this.size;
			size[0]=RenderState2D.width;
			size[1]=RenderState2D.height;
			this.alpha=this.ALPHA *RenderState2D.worldAlpha;
			this.mmat=RenderState2D.worldMatrix4;
			return this;
		}

		__proto._ShaderWithCompile=function(){
			return Shader.withCompile(0,this.mainID,this.defines.toNameDic(),this.mainID | this.defines._value,Shader2X.create);
		}

		__proto._withWorldShaderDefines=function(){
			var defs=RenderState2D.worldShaderDefines;
			var sd=Shader.sharders [this.mainID | this.defines._value | defs.getValue()];
			if (!sd){
				var def={};
				var dic;
				var name;
				dic=this.defines.toNameDic();for (name in dic)def[name]="";
				dic=defs.toNameDic();for (name in dic)def[name]="";
				sd=Shader.withCompile(0,this.mainID,def,this.mainID | this.defines._value| defs.getValue(),Shader2X.create);
			};
			var worldFilters=RenderState2D.worldFilters;
			if (!worldFilters)return sd;
			var n=worldFilters.length,f;
			for (var i=0;i < n;i++){
				((f=worldFilters[i]))&& f.action.setValue(this);
			}
			return sd;
		}

		__proto.upload=function(){
			var renderstate2d=RenderState2D;
			this.alpha=this.ALPHA *renderstate2d.worldAlpha;
			if (RenderState2D.worldMatrix4!==RenderState2D.TEMPMAT4_ARRAY)this.defines.add(0x80);
			var sd=renderstate2d.worldShaderDefines?this._withWorldShaderDefines():(Shader.sharders [this.mainID | this.defines._value] || this._ShaderWithCompile());
			var params;
			this.size[0]=renderstate2d.width,this.size[1]=renderstate2d.height;
			this.mmat=renderstate2d.worldMatrix4;
			if (Shader.activeShader!==sd){
				if (sd._shaderValueWidth!==renderstate2d.width || sd._shaderValueHeight!==renderstate2d.height){
					sd._shaderValueWidth=renderstate2d.width;
					sd._shaderValueHeight=renderstate2d.height;
				}
				else{
					params=sd._params2dQuick2 || sd._make2dQuick2();
				}
				sd.upload(this,params);
			}
			else{
				if (sd._shaderValueWidth!==renderstate2d.width || sd._shaderValueHeight!==renderstate2d.height){
					sd._shaderValueWidth=renderstate2d.width;
					sd._shaderValueHeight=renderstate2d.height;
				}
				else{
					params=(sd._params2dQuick1)|| sd._make2dQuick1();
				}
				sd.upload(this,params);
			}
		}

		__proto.setFilters=function(value){
			this.filters=value;
			if (!value)
				return;
			var n=value.length,f;
			for (var i=0;i < n;i++){
				f=value[i]
				if (f){
					this.defines.add(f.type);
					f.action.setValue(this);
				}
			}
		}

		__proto.clear=function(){
			this.defines.setValue(this.subID);
		}

		__proto.release=function(){
			this._inClassCache[this._inClassCache._length++]=this;
			this.fillStyle=null;
			this.strokeStyle=null;
			this.clear();
		}

		Value2D._initone=function(type,classT){
			Value2D._typeClass[type]=classT;
			Value2D._cache[type]=[];
			Value2D._cache[type]._length=0;
		}

		Value2D.__init__=function(){
			Value2D._POSITION=[2,0x1406,false,4 *CONST3D2D.BYTES_PE,0];
			Value2D._TEXCOORD=[2,0x1406,false,4 *CONST3D2D.BYTES_PE,2 *CONST3D2D.BYTES_PE];
			Value2D._initone(0x02,Color2dSV);
			Value2D._initone(0x04,PrimitiveSV);
			Value2D._initone(0x01,TextureSV);
			Value2D._initone(0x01 | 0x40,TextSV);
			Value2D._initone(0x01 | 0x08,TextureSV);
		}

		Value2D.create=function(mainType,subType){
			var types=Value2D._cache[mainType|subType];
			if (types._length)
				return types[--types._length];
			else
			return new Value2D._typeClass[mainType|subType](subType);
		}

		Value2D._POSITION=null
		Value2D._TEXCOORD=null
		Value2D._cache=[];
		Value2D._typeClass=[];
		Value2D.TEMPMAT4_ARRAY=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];
		return Value2D;
	})(ShaderValue)


	/**
	*<p> <code>LoaderManager</code> 类用于用于批量加载资源、数据。</p>
	*<p>批量加载器，单例，可以通过Laya.loader访问。</p>
	*多线程(默认5个线程)，5个优先级(0最快，4最慢,默认为1)
	*某个资源加载失败后，会按照最低优先级重试加载(属性retryNum决定重试几次)，如果重试后失败，则调用complete函数，并返回null
	*/
	//class laya.net.LoaderManager extends laya.events.EventDispatcher
	var LoaderManager=(function(_super){
		var ResInfo;
		function LoaderManager(){
			this.retryNum=1;
			this.maxLoader=5;
			this._loaders=[];
			this._loaderCount=0;
			this._resInfos=[];
			this._resMap={};
			this._infoPool=[];
			this._maxPriority=5;
			this._failRes={};
			LoaderManager.__super.call(this);
			for (var i=0;i < this._maxPriority;i++)this._resInfos[i]=[];
		}

		__class(LoaderManager,'laya.net.LoaderManager',_super);
		var __proto=LoaderManager.prototype;
		/**
		*加载资源。
		*@param url 地址，或者资源对象数组(简单数组：["a.png","b.png"]，复杂数组[{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}])。
		*@param complete 结束回调，如果加载失败，则返回 null 。
		*@param progress 进度回调，回调参数为当前文件加载的进度信息(0-1)。
		*@param type 资源类型。
		*@param priority 优先级，0-4，五个优先级，0优先级最高，默认为1。
		*@param cache 是否缓存加载结果。
		*@return 此 LoaderManager 对象。
		*/
		__proto.load=function(url,complete,progress,type,priority,cache){
			(priority===void 0)&& (priority=1);
			(cache===void 0)&& (cache=true);
			if ((url instanceof Array))return this._loadAssets(url,complete,progress,priority,cache);
			url=URL.formatURL(url);
			var content=Loader.getRes(url);
			if (content !=null){
				complete && complete.runWith(content);
				this._loaderCount || this.event("complete");
				}else {
				var info=this._resMap[url];
				if (!info){
					info=this._infoPool.length ? this._infoPool.pop():new ResInfo();
					info.url=url;
					info.type=type;
					info.cache=cache;
					complete && info.on("complete",complete.caller,complete.method,complete.args);
					progress && info.on("progress",progress.caller,progress.method,progress.args);
					this._resMap[url]=info;
					priority=priority < this._maxPriority ? priority :this._maxPriority-1;
					this._resInfos[priority].push(info);
					this._next();
					}else {
					complete && info.on("complete",complete.caller,complete.method,complete.args);
					progress && info.on("progress",progress.caller,progress.method,progress.args);
				}
			}
			return this;
		}

		__proto._next=function(){
			if (this._loaderCount >=this.maxLoader)return;
			for (var i=0;i < this._maxPriority;i++){
				var infos=this._resInfos[i];
				if (infos.length > 0){
					var info=infos.shift();
					if (info)return this._doLoad(info);
				}
			}
			this._loaderCount || this.event("complete");
		}

		__proto._doLoad=function(resInfo){
			this._loaderCount++;
			var loader=this._loaders.length ? this._loaders.pop():new Loader();
			loader.on("complete",null,onLoaded);
			loader.on("progress",null,function(num){
				resInfo.event("progress",num);
			});
			loader.on("error",null,function(msg){
				onLoaded(null);
			});
			var _this=this;
			function onLoaded (data){
				loader.offAll();
				loader._data=null;
				_this._loaders.push(loader);
				_this._endLoad(resInfo,data);
				_this._loaderCount--;
				_this._next();
			}
			loader.load(resInfo.url,resInfo.type,resInfo.cache);
		}

		__proto._endLoad=function(resInfo,content){
			if (content===null){
				var errorCount=this._failRes[resInfo.url] || 0;
				if (errorCount < this.retryNum){
					console.log("[warn]Retry to load:",resInfo.url);
					this._failRes[resInfo.url]=errorCount+1;
					this._resInfos[this._maxPriority-1].push(resInfo);
					return;
					}else {
					console.log("[error]Failed to load:",resInfo.url);
					this.event("error",resInfo.url);
				}
			}
			delete this._resMap[resInfo.url];
			resInfo.event("complete",content);
			resInfo.offAll();
			this._infoPool.push(resInfo);
		}

		/**
		*清理指定资源地址缓存。
		*@param url 资源地址。
		*/
		__proto.clearRes=function(url){
			Loader.clearRes(url);
		}

		/**
		*获取指定资源地址的资源。
		*@param url 资源地址。
		*@return 返回资源。
		*/
		__proto.getRes=function(url){
			return Loader.getRes(url);
		}

		/**清理当前未完成的加载，所有未加载的内容全部停止加载。*/
		__proto.clearUnLoaded=function(){
			for (var i=0;i < this._maxPriority;i++){
				var infos=this._resInfos[i];
				for (var j=infos.length-1;j >-1;j--){
					var info=infos[j];
					if (info){
						info.offAll();
						this._infoPool.push(info);
					}
				}
				infos.length=0;
			}
			this._loaderCount=0;
			this._resMap={};
		}

		/**
		*根据地址集合清理掉未加载的内容
		*@param urls 资源地址集合
		*/
		__proto.cancelLoadByUrls=function(urls){
			if (!urls)return;
			for (var i=0,n=urls.length;i < n;i++){
				this.cancelLoadByUrl(urls[i]);
			}
		}

		/**
		*根据地址清理掉未加载的内容
		*@param url 资源地址
		*/
		__proto.cancelLoadByUrl=function(url){
			url=URL.formatURL(url);
			for (var i=0;i < this._maxPriority;i++){
				var infos=this._resInfos[i];
				for (var j=infos.length-1;j >-1;j--){
					var info=infos[j];
					if (info && info.url===url){
						infos[j]=null;
						info.offAll();
						this._infoPool.push(info);
					}
				}
			}
			if (this._resMap[url])delete this._resMap[url];
		}

		/**
		*@private
		*加载数组里面的资源。
		*@param arr 简单：["a.png","b.png"]，复杂[{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]*/
		__proto._loadAssets=function(arr,complete,progress,priority,cache){
			(priority===void 0)&& (priority=1);
			(cache===void 0)&& (cache=true);
			var itemCount=arr.length;
			var loadedSize=0;
			var totalSize=0;
			var items=[];
			for (var i=0;i < itemCount;i++){
				var item=arr[i];
				if ((typeof item=='string'))item={url:item,type:"image",size:1,priority:priority};
				if (!item.size)item.size=1;
				item.progress=0;
				totalSize+=item.size;
				items.push(item);
				var progressHandler=progress ? Handler.create(this,loadProgress,[item],false):null;
				this.load(item.url,Handler.create(item,loadComplete,[item]),progressHandler,item.type,item.priority || 1,cache);
			}
			function loadComplete (item,content){
				loadedSize++;
				item.progress=1;
				if (loadedSize===itemCount && complete){
					complete.run();
				}
			}
			function loadProgress (item,value){
				if (progress !=null){
					item.progress=value;
					var num=0;
					var count=items.length;
					for (var j=0;j < count;j++){
						var item1=items[j];
						num+=item1.size *item1.progress;
					};
					var v=num / totalSize;
					progress.runWith(v);
				}
			}
			return this;
		}

		LoaderManager.cacheRes=function(url,data){
			Loader.cacheRes(url,data);
		}

		LoaderManager.__init$=function(){
			//class ResInfo extends laya.events.EventDispatcher
			ResInfo=(function(_super){
				function ResInfo(){
					this.url=null;
					this.type=null;
					this.cache=false;
					ResInfo.__super.call(this);
				}
				__class(ResInfo,'',_super);
				return ResInfo;
			})(EventDispatcher)
		}

		return LoaderManager;
	})(EventDispatcher)


	/**
	*@private
	*使用Audio标签播放声音
	*/
	//class laya.media.h5audio.AudioSound extends laya.events.EventDispatcher
	var AudioSound=(function(_super){
		function AudioSound(){
			this.url=null;
			this.audio=null;
			this.loaded=false;
			AudioSound.__super.call(this);
		}

		__class(AudioSound,'laya.media.h5audio.AudioSound',_super);
		var __proto=AudioSound.prototype;
		/**
		*释放声音
		*
		*/
		__proto.dispose=function(){
			var ad=AudioSound._audioCache[this.url];
			if (ad){
				ad.src="";
				delete AudioSound._audioCache[this.url];
			}
		}

		/**
		*加载声音
		*@param url
		*
		*/
		__proto.load=function(url){
			this.url=url;
			var ad=AudioSound._audioCache[url];
			if (ad && ad.readyState >=2){
				this.event("complete");
				return;
			}
			if (!ad){
				ad=Browser.createElement("audio");
				ad.src=url;
				AudioSound._audioCache[url]=ad;
			}
			ad.addEventListener("canplaythrough",onLoaded);
			ad.addEventListener("error",onErr);
			var me=this;
			function onLoaded (){
				offs();
				me.loaded=true;
				me.event("complete");
			}
			function onErr (){
				offs();
				me.event("error");
			}
			function offs (){
				ad.removeEventListener("canplaythrough",onLoaded);
				ad.removeEventListener("error",onErr);
			}
			this.audio=ad;
			ad.load();
		}

		/**
		*播放声音
		*@param startTime 起始时间
		*@param loops 循环次数
		*@return
		*
		*/
		__proto.play=function(startTime,loops){
			(startTime===void 0)&& (startTime=0);
			(loops===void 0)&& (loops=0);
			if (!this.url)return null;
			var ad;
			ad=AudioSound._audioCache[this.url];
			if (!ad)return null;
			var tAd;
			tAd=Pool.getItem("audio:"+this.url);
			tAd=tAd?tAd:ad.cloneNode(true);
			var channel=new AudioSoundChannel(tAd);
			channel.url=this.url;
			channel.loops=loops;
			channel.startTime=startTime;
			channel.play();
			SoundManager.addChannel(channel);
			return channel;
		}

		AudioSound._audioCache={};
		return AudioSound;
	})(EventDispatcher)


	/**
	*<code>SoundChannel</code> 用来控制程序中的声音。
	*/
	//class laya.media.SoundChannel extends laya.events.EventDispatcher
	var SoundChannel=(function(_super){
		function SoundChannel(){
			this.url=null;
			this.loops=0;
			this.startTime=NaN;
			this.isStopped=false;
			this.completeHandler=null;
			SoundChannel.__super.call(this);
		}

		__class(SoundChannel,'laya.media.SoundChannel',_super);
		var __proto=SoundChannel.prototype;
		/**
		*播放。
		*/
		__proto.play=function(){}
		/**
		*停止。
		*/
		__proto.stop=function(){}
		/**
		*private
		*/
		__proto.__runComplete=function(handler){
			if (handler){
				handler.run();
			}
		}

		/**
		*音量。
		*/
		__getset(0,__proto,'volume',function(){
			return 1;
			},function(v){
		});

		/**
		*获取当前播放时间。
		*/
		__getset(0,__proto,'position',function(){
			return 0;
		});

		return SoundChannel;
	})(EventDispatcher)


	/**
	*<code>Sound</code> 类是用来播放控制声音的类。
	*/
	//class laya.media.Sound extends laya.events.EventDispatcher
	var Sound=(function(_super){
		function Sound(){Sound.__super.call(this);;
		};

		__class(Sound,'laya.media.Sound',_super);
		var __proto=Sound.prototype;
		/**
		*加载声音。
		*@param url 地址。
		*
		*/
		__proto.load=function(url){}
		/**
		*播放声音。
		*@param startTime 开始时间,单位秒
		*@param loops 循环次数,0表示一直循环
		*@return 声道 SoundChannel 对象。
		*
		*/
		__proto.play=function(startTime,loops){
			(startTime===void 0)&& (startTime=0);
			(loops===void 0)&& (loops=0);
			return null;
		}

		/**
		*释放声音资源。
		*
		*/
		__proto.dispose=function(){}
		return Sound;
	})(EventDispatcher)


	/**
	*@private
	*web audio api方式播放声音
	*/
	//class laya.media.webaudio.WebAudioSound extends laya.events.EventDispatcher
	var WebAudioSound=(function(_super){
		function WebAudioSound(){
			this.url=null;
			this.loaded=false;
			this.data=null;
			this.audioBuffer=null;
			this.__toPlays=null;
			WebAudioSound.__super.call(this);
		}

		__class(WebAudioSound,'laya.media.webaudio.WebAudioSound',_super);
		var __proto=WebAudioSound.prototype;
		/**
		*加载声音
		*@param url
		*
		*/
		__proto.load=function(url){
			var me=this;
			this.url=url;
			this.audioBuffer=WebAudioSound._dataCache[url];
			if (this.audioBuffer){
				this._loaded(this.audioBuffer);
				return;
			}
			WebAudioSound.e.on("loaded:"+url,this,this._loaded);
			WebAudioSound.e.on("err:"+url,this,this._err);
			if (WebAudioSound.__loadingSound[url]){
				return;
			}
			WebAudioSound.__loadingSound[url]=true;
			var request=new Browser.window.XMLHttpRequest();
			request.open("GET",url,true);
			request.responseType="arraybuffer";
			request.onload=function (){
				me.data=request.response;
				WebAudioSound.buffs.push({"buffer":me.data,"url":me.url});
				WebAudioSound.decode();
			};
			request.send();
		}

		__proto._err=function(){
			this._removeLoadEvents();
			this.event("error");
		}

		__proto._loaded=function(audioBuffer){
			this._removeLoadEvents();
			this.audioBuffer=audioBuffer;
			WebAudioSound._dataCache[this.url]=this.audioBuffer;
			this.loaded=true;
			this.event("complete");
		}

		__proto._removeLoadEvents=function(){
			WebAudioSound.e.off("loaded:"+this.url,this,this._loaded);
			WebAudioSound.e.off("err:"+this.url,this,this._err);
		}

		__proto.__playAfterLoaded=function(){
			if (!this.__toPlays)return;
			var i=0,len=0;
			var toPlays;
			toPlays=this.__toPlays;
			len=toPlays.length;
			var tParams;
			for (i=0;i < len;i++){
				tParams=toPlays[i];
				if(tParams[2]&&!(tParams [2]).isStopped){
					this.play(tParams[0],tParams[1],tParams[2]);
				}
			}
			this.__toPlays.length=0;
		}

		/**
		*播放声音
		*@param startTime 起始时间
		*@param loops 循环次数
		*@return
		*
		*/
		__proto.play=function(startTime,loops,channel){
			(startTime===void 0)&& (startTime=0);
			(loops===void 0)&& (loops=0);
			channel=channel ? channel :new WebAudioSoundChannel();
			if (!this.audioBuffer){
				if (this.url){
					if (!this.__toPlays)this.__toPlays=[];
					this.__toPlays.push([startTime,loops,channel]);
					this.once("complete",this,this.__playAfterLoaded);
					this.load(this.url);
				}
			}
			channel.url=this.url;
			channel.loops=loops;
			channel["audioBuffer"]=this.audioBuffer;
			channel.startTime=startTime;
			channel.play();
			SoundManager.addChannel(channel);
			return channel;
		}

		__proto.dispose=function(){
			delete WebAudioSound._dataCache[this.url];
			delete WebAudioSound.__loadingSound[this.url];
		}

		WebAudioSound.decode=function(){
			if (WebAudioSound.buffs.length <=0 || WebAudioSound.isDecoding){
				return;
			}
			WebAudioSound.isDecoding=true;
			WebAudioSound.tInfo=WebAudioSound.buffs.shift();
			WebAudioSound.ctx.decodeAudioData(WebAudioSound.tInfo["buffer"],WebAudioSound._done,WebAudioSound._fail);
		}

		WebAudioSound._done=function(audioBuffer){
			WebAudioSound.e.event("loaded:"+WebAudioSound.tInfo.url,audioBuffer);
			WebAudioSound.isDecoding=false;
			WebAudioSound.decode();
		}

		WebAudioSound._fail=function(){
			WebAudioSound.e.event("err:"+WebAudioSound.tInfo.url,null);
			WebAudioSound.isDecoding=false;
			WebAudioSound.decode();
		}

		WebAudioSound._playEmptySound=function(){
			if (WebAudioSound.ctx==null){return;};
			var source=WebAudioSound.ctx.createBufferSource();
			source.buffer=WebAudioSound._miniBuffer;
			source.connect(WebAudioSound.ctx.destination);
			source.start(0,0,0);
		}

		WebAudioSound._unlock=function(){
			if (WebAudioSound._unlocked){return;}
				WebAudioSound._playEmptySound();
			if (WebAudioSound.ctx.state=="running"){
				Browser.document.removeEventListener("mousedown",WebAudioSound._unlock,true);
				Browser.document.removeEventListener("touchend",WebAudioSound._unlock,true);
				WebAudioSound._unlocked=true;
			}
		}

		WebAudioSound.initWebAudio=function(){
			if (WebAudioSound.ctx.state !="running"){
				WebAudioSound._unlock();
				Browser.document.addEventListener("mousedown",WebAudioSound._unlock,true);
				Browser.document.addEventListener("touchend",WebAudioSound._unlock,true);
			}
		}

		WebAudioSound._dataCache={};
		WebAudioSound.buffs=[];
		WebAudioSound.isDecoding=false;
		WebAudioSound._unlocked=false;
		WebAudioSound.tInfo=null
		WebAudioSound.__loadingSound={};
		__static(WebAudioSound,
		['window',function(){return this.window=Browser.window;},'webAudioEnabled',function(){return this.webAudioEnabled=WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"];},'ctx',function(){return this.ctx=WebAudioSound.webAudioEnabled ? new (WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"])():undefined;},'_miniBuffer',function(){return this._miniBuffer=WebAudioSound.ctx.createBuffer(1,1,22050);},'e',function(){return this.e=new EventDispatcher();}
		]);
		return WebAudioSound;
	})(EventDispatcher)


	/**
	*<code>HttpRequest</code> 通过 HTTP 协议传送或接收 XML 及其他数据。
	*/
	//class laya.net.HttpRequest extends laya.events.EventDispatcher
	var HttpRequest=(function(_super){
		function HttpRequest(){
			this._responseType=null;
			this._data=null;
			HttpRequest.__super.call(this);
			this._http=new Browser.window.XMLHttpRequest();
		}

		__class(HttpRequest,'laya.net.HttpRequest',_super);
		var __proto=HttpRequest.prototype;
		/**
		*发送请求。
		*@param url 请求的地址。
		*@param data 发送的数据，可选。
		*@param method 发送数据方式，值为“get”或“post”，默认为 “get”方式。
		*@param responseType 返回消息类型，可设置为"text"，"json"，"xml","arraybuffer"。
		*@param headers 头信息，key value数组，比如["Content-Type","application/json"]。
		*/
		__proto.send=function(url,data,method,responseType,headers){
			(method===void 0)&& (method="get");
			(responseType===void 0)&& (responseType="text");
			this._responseType=responseType;
			this._data=null;
			var _this=this;
			var http=this._http;
			http.open(method,url,true);
			if (headers){
				for (var i=0;i < headers.length;i++){
					http.setRequestHeader(headers[i++],headers[i]);
				}
				}else {
				if (!data || (typeof data=='string'))http.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
				else http.setRequestHeader("Content-Type","application/json");
			}
			http.responseType=responseType!=="arraybuffer" ? "text" :"arraybuffer";
			http.onerror=function (e){
				_this._onError(e);
			}
			http.onabort=function (e){
				_this._onAbort(e);
			}
			http.onprogress=function (e){
				_this._onProgress(e);
			}
			http.onload=function (e){
				_this._onLoad(e);
			}
			http.send(data);
		}

		/**
		*@private
		*请求进度的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onProgress=function(e){
			if (e && e.lengthComputable)this.event("progress",e.loaded / e.total);
		}

		/**
		*@private
		*请求中断的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onAbort=function(e){
			this.error("Request was aborted by user");
		}

		/**
		*@private
		*请求出错侦的听处理函数。
		*@param e 事件对象。
		*/
		__proto._onError=function(e){
			this.error("Request failed Status:"+this._http.status+" text:"+this._http.statusText);
		}

		/**
		*@private
		*请求消息返回的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onLoad=function(e){
			var http=this._http;
			var status=http.status!==undefined ? http.status :200;
			if (status===200 || status===204 || status===0){
				this.complete();
				}else {
				this.error("["+http.status+"]"+http.statusText+":"+http.responseURL);
			}
		}

		/**
		*@private
		*请求错误的处理函数。
		*@param message 错误信息。
		*/
		__proto.error=function(message){
			this.clear();
			this.event("error",message);
		}

		/**
		*@private
		*请求成功完成的处理函数。
		*/
		__proto.complete=function(){
			this.clear();
			try {
				if (this._responseType==="json"){
					this._data=JSON.parse(this._http.responseText);
					}else if (this._responseType==="xml"){
					this._data=Utils.parseXMLFromString(this._http.responseText);
					}else {
					this._data=this._http.response || this._http.responseText;
				}
				this.event("complete",(this._data instanceof Array)? [this._data] :this._data);
				}catch (e){
				this.error(e.message);
			}
		}

		/**
		*@private
		*清除当前请求。
		*/
		__proto.clear=function(){
			var http=this._http;
			http.onerror=http.onabort=http.onprogress=http.onload=null;
		}

		/**返回的数据。*/
		__getset(0,__proto,'data',function(){
			return this._data;
		});

		/**请求的地址。*/
		__getset(0,__proto,'url',function(){
			return this._http.responseURL;
		});

		return HttpRequest;
	})(EventDispatcher)


	/**
	*<code>Loader</code> 类可用来加载文本、JSON、XML、二进制、图像等资源。
	*/
	//class laya.net.Loader extends laya.events.EventDispatcher
	var Loader=(function(_super){
		function Loader(){
			this._data=null;
			this._url=null;
			this._type=null;
			this._cache=false;
			this._http=null;
			Loader.__super.call(this);
		}

		__class(Loader,'laya.net.Loader',_super);
		var __proto=Loader.prototype;
		/**
		*加载资源。
		*@param url 地址
		*@param type 类型，如果为null，则根据文件后缀，自动分析类型。
		*@param cache 是否缓存数据。
		*/
		__proto.load=function(url,type,cache){
			(cache===void 0)&& (cache=true);
			url=URL.formatURL(url);
			this._url=url;
			this._type=type || (type=this.getTypeFromUrl(url));
			this._cache=cache;
			this._data=null;
			if (Loader.loadedMap[url]){
				this._data=Loader.loadedMap[url];
				this.event("progress",1);
				this.event("complete",this._data);
				return;
			}
			if (Loader.parserMap[type] !=null){
				if (((Loader.parserMap[type])instanceof laya.utils.Handler ))Loader.parserMap[type].runWith(this);
				else Loader.parserMap[type].call(null,this);
				return;
			}
			if (type==="image" || type==="htmlimage" || type==="nativeimage")return this._loadImage(url);
			if (type==="sound")return this._loadSound(url);
			if (!this._http){
				this._http=new HttpRequest();
				this._http.on("progress",this,this.onProgress);
				this._http.on("error",this,this.onError);
				this._http.on("complete",this,this.onLoaded);
			}
			this._http.send(url,null,"get",type!=="atlas" ? type :"json");
		}

		/**
		*获取指定资源地址的数据类型。
		*@param url 资源地址。
		*@return 数据类型。
		*/
		__proto.getTypeFromUrl=function(url){
			Loader._extReg.lastIndex=url.lastIndexOf(".");
			var result=Loader._extReg.exec(url);
			if (result && result.length > 1){
				return Loader.typeMap[result[1].toLowerCase()];
			}
			console.log("Not recognize the resources suffix",url);
			return "text";
		}

		/**
		*@private
		*加载图片资源。
		*@param url 资源地址。
		*/
		__proto._loadImage=function(url){
			if (this._type==="nativeimage"){
				var image=new Browser.window.Image();
				image.crossOrigin="";
				image.src=url;
				}else {
				image=new HTMLImage.create(url);
			};
			var _this=this;
			image.onload=function (){
				clear();
				_this.onLoaded(image);
			};
			image.onerror=function (){
				clear();
				_this.event("error","Load image filed");
			}
			function clear (){
				image.onload=null;
				image.onerror=null;
			}
		}

		/**
		*@private
		*加载声音资源。
		*@param url 资源地址。
		*/
		__proto._loadSound=function(url){
			var sound=(new SoundManager._soundClass());
			var _this=this;
			sound.on("complete",this,soundOnload);
			sound.on("error",this,soundOnErr);
			sound.load(url);
			function soundOnload (){
				clear();
				_this.onLoaded(sound);
			}
			function soundOnErr (){
				clear();
				_this.event("error","Load sound filed");
			}
			function clear (){
				sound.offAll();
			}
		}

		/**@private */
		__proto.onProgress=function(value){
			if (this._type==="atlas")this.event("progress",value *0.3);
			else this.event("progress",value);
		}

		/**@private */
		__proto.onError=function(message){
			this.event("error",message);
		}

		/**
		*资源加载完成的处理函数。
		*@param data 数据。
		*/
		__proto.onLoaded=function(data){
			var type=this._type;
			if (type==="image"){
				var tex=new Texture(data);
				tex.url=this._url;
				this.complete(tex);
				}else if (type==="sound" || type==="htmlimage" || type==="nativeimage"){
				this.complete(data);
				}else if (type==="atlas"){
				if (!data.src){
					if (!this._data){
						this._data=data;
						if (data.meta && data.meta.image){
							var toloadPics=data.meta.image.split(",");
							var split=this._url.indexOf("/")>=0 ? "/" :"\\";
							var idx=this._url.lastIndexOf(split);
							var folderPath=idx >=0 ? this._url.substr(0,idx+1):"";
							idx=this._url.indexOf("?");
							var ver;
							ver=idx >=0 ? this._url.substr(idx):"";
							for (var i=0,len=toloadPics.length;i < len;i++){
								toloadPics[i]=folderPath+toloadPics[i]+ver;
							}
							}else {
							toloadPics=[this._url.replace(".json",".png")];
						}
						toloadPics.reverse();
						data.toLoads=toloadPics;
						data.pics=[];
					}
					this.event("progress",0.3+1 / toloadPics.length *0.6);
					return this._loadImage(URL.formatURL(toloadPics.pop()));
					}else {
					this._data.pics.push(data);
					if (this._data.toLoads.length > 0){
						this.event("progress",0.3+1 / this._data.toLoads.length *0.6);
						return this._loadImage(URL.formatURL(this._data.toLoads.pop()));
					};
					var frames=this._data.frames;
					var directory=(this._data.meta && this._data.meta.prefix)? URL.basePath+this._data.meta.prefix :this._url.substring(0,this._url.lastIndexOf("."))+"/";
					var pics=this._data.pics;
					var map=Loader.atlasMap[this._url] || (Loader.atlasMap[this._url]=[]);
					for (var name in frames){
						var obj=frames[name];
						var tPic=pics[obj.frame.idx ? obj.frame.idx :0];
						var url=directory+name;
						Loader.loadedMap[url]=Texture.create(tPic,obj.frame.x,obj.frame.y,obj.frame.w,obj.frame.h,obj.spriteSourceSize.x,obj.spriteSourceSize.y,obj.sourceSize.w,obj.sourceSize.h);
						Loader.loadedMap[url].url=url;
						map.push(url);
					}
					this.complete(this._data);
				}
				}else {
				this.complete(data);
			}
		}

		/**
		*加载完成。
		*@param data 加载的数据。
		*/
		__proto.complete=function(data){
			this._data=data;
			Loader._loaders.push(this);
			if (!Loader._isWorking)Loader.checkNext();
		}

		/**
		*结束加载，处理是否缓存及派发完成事件 <code>Event.COMPLETE</code> 。
		*@param content 加载后的数据
		*/
		__proto.endLoad=function(content){
			content && (this._data=content);
			if (this._cache)Loader.loadedMap[this._url]=this._data;
			this.event("progress",1);
			this.event("complete",(this.data instanceof Array)? [this.data] :this.data);
		}

		/**是否缓存。*/
		__getset(0,__proto,'cache',function(){
			return this._cache;
		});

		/**返回的数据。*/
		__getset(0,__proto,'data',function(){
			return this._data;
		});

		/**加载地址。*/
		__getset(0,__proto,'url',function(){
			return this._url;
		});

		/**加载类型。*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		Loader.checkNext=function(){
			Loader._isWorking=true;
			var startTimer=Browser.now();
			var thisTimer=startTimer;
			while (Loader._startIndex < Loader._loaders.length){
				thisTimer=Browser.now();
				Loader._loaders[Loader._startIndex].endLoad();
				Loader._startIndex++;
				if (Browser.now()-startTimer > Loader.maxTimeOut){
					console.log("loader callback cost a long time:"+(Browser.now()-startTimer)+" url="+Loader._loaders[Loader._startIndex-1].url);
					Laya.timer.frameOnce(1,null,Loader.checkNext);
					return;
				}
			}
			Loader._loaders.length=0;
			Loader._startIndex=0;
			Loader._isWorking=false;
		}

		Loader.clearRes=function(url){
			url=URL.formatURL(url);
			var arr=Loader.atlasMap[url];
			if (arr){
				for (var i=0,n=arr.length;i < n;i++){
					var resUrl=arr[i];
					var tex=Loader.getRes(resUrl);
					if (tex)tex.destroy();
					delete Loader.loadedMap[resUrl];
				}
				arr.length=0;
				delete Loader.atlasMap[url];
				delete Loader.loadedMap[url];
				}else {
				var res=Loader.loadedMap[url];
				if ((res instanceof laya.resource.Texture )&& res.bitmap){
					(res).destroy();
					delete Loader.loadedMap[url];
				}
			}
		}

		Loader.getRes=function(url){
			return Loader.loadedMap[URL.formatURL(url)];
		}

		Loader.getAtlas=function(url){
			return Loader.atlasMap[URL.formatURL(url)];
		}

		Loader.cacheRes=function(url,data){
			Loader.loadedMap[URL.formatURL(url)]=data;
		}

		Loader.TEXT="text";
		Loader.JSON="json";
		Loader.XML="xml";
		Loader.BUFFER="arraybuffer";
		Loader.IMAGE="image";
		Loader.SOUND="sound";
		Loader.ATLAS="atlas";
		Loader.typeMap={"png":"image","jpg":"image","jpeg":"image","txt":"text","json":"json","xml":"xml","als":"atlas","mp3":"sound","ogg":"sound","wav":"sound","part":"json"};
		Loader.parserMap={};
		Loader.loadedMap={};
		Loader.maxTimeOut=100;
		Loader.atlasMap={};
		Loader._loaders=[];
		Loader._isWorking=false;
		Loader._startIndex=0;
		Loader._extReg=/\.(\w+)\??/g;
		return Loader;
	})(EventDispatcher)


	/**
	*@private
	*<code>ShaderDefines3D</code> 类用于创建3DshaderDefine相关。
	*/
	//class laya.d3.shader.ShaderDefines3D extends laya.webgl.shader.ShaderDefines
	var ShaderDefines3D=(function(_super){
		function ShaderDefines3D(){
			ShaderDefines3D.__super.call(this,ShaderDefines3D._name2int,ShaderDefines3D._int2name,ShaderDefines3D._int2nameMap);
		}

		__class(ShaderDefines3D,'laya.d3.shader.ShaderDefines3D',_super);
		ShaderDefines3D.__init__=function(){
			ShaderDefines3D.reg("FSHIGHPRECISION",0x100000);
			ShaderDefines3D.reg("DIFFUSEMAP",0x1);
			ShaderDefines3D.reg("NORMALMAP",0x2);
			ShaderDefines3D.reg("SPECULARMAP",0x4);
			ShaderDefines3D.reg("EMISSIVEMAP",0x8);
			ShaderDefines3D.reg("AMBIENTMAP",0x10);
			ShaderDefines3D.reg("REFLECTMAP",0x40000);
			ShaderDefines3D.reg("PARTICLE3D",0x8000);
			ShaderDefines3D.reg("COLOR",0x20);
			ShaderDefines3D.reg("VERTEXSHADERING",0x1000);
			ShaderDefines3D.reg("PIXELSHADERING",0x2000);
			ShaderDefines3D.reg("SKINNED",0x400);
			ShaderDefines3D.reg("DIRECTIONLIGHT",0x40);
			ShaderDefines3D.reg("POINTLIGHT",0x80);
			ShaderDefines3D.reg("SPOTLIGHT",0x100);
			ShaderDefines3D.reg("BONE",0x200);
			ShaderDefines3D.reg("ALPHATEST",0x800);
			ShaderDefines3D.reg("UVTRANSFORM",0x4000);
			ShaderDefines3D.reg("MIXUV",0x10000);
			ShaderDefines3D.reg("FOG",0x20000);
			ShaderDefines3D.reg("VR",0x80000);
		}

		ShaderDefines3D.reg=function(name,value){
			ShaderDefines._reg(name,value,ShaderDefines3D._name2int,ShaderDefines3D._int2name);
		}

		ShaderDefines3D.toText=function(value,_int2name,_int2nameMap){
			return ShaderDefines._toText(value,_int2name,_int2nameMap);
		}

		ShaderDefines3D.toInt=function(names){
			return ShaderDefines._toInt(names,ShaderDefines3D._name2int);
		}

		ShaderDefines3D.DIFFUSEMAP=0x1;
		ShaderDefines3D.NORMALMAP=0x2;
		ShaderDefines3D.SPECULARMAP=0x4;
		ShaderDefines3D.EMISSIVEMAP=0x8;
		ShaderDefines3D.AMBIENTMAP=0x10;
		ShaderDefines3D.REFLECTMAP=0x40000;
		ShaderDefines3D.VR=0x80000;
		ShaderDefines3D.FSHIGHPRECISION=0x100000;
		ShaderDefines3D.UVTRANSFORM=0x4000;
		ShaderDefines3D.MIXUV=0x10000;
		ShaderDefines3D.FOG=0x20000;
		ShaderDefines3D.COLOR=0x20;
		ShaderDefines3D.DIRECTIONLIGHT=0x40;
		ShaderDefines3D.POINTLIGHT=0x80;
		ShaderDefines3D.SPOTLIGHT=0x100;
		ShaderDefines3D.BONE=0x200;
		ShaderDefines3D.SKINNED=0x400;
		ShaderDefines3D.ALPHATEST=0x800;
		ShaderDefines3D.PARTICLE3D=0x8000;
		ShaderDefines3D.VERTEXSHADERING=0x1000;
		ShaderDefines3D.PIXELSHADERING=0x2000;
		ShaderDefines3D._name2int={};
		ShaderDefines3D._int2name=[];
		ShaderDefines3D._int2nameMap=[];
		return ShaderDefines3D;
	})(ShaderDefines)


	/**
	*<code>UIEvent</code> 类用来定义UI组件类的事件类型。
	*/
	//class laya.ui.UIEvent extends laya.events.Event
	var UIEvent=(function(_super){
		function UIEvent(){UIEvent.__super.call(this);;
		};

		__class(UIEvent,'laya.ui.UIEvent',_super);
		UIEvent.SHOW_TIP="showtip";
		UIEvent.HIDE_TIP="hidetip";
		return UIEvent;
	})(Event)


	//class laya.webgl.display.GraphicsGL extends laya.display.Graphics
	var GraphicsGL=(function(_super){
		function GraphicsGL(){
			GraphicsGL.__super.call(this);
		}

		__class(GraphicsGL,'laya.webgl.display.GraphicsGL',_super);
		var __proto=GraphicsGL.prototype;
		__proto.setShader=function(shader){
			this._saveToCmd(Render.context._setShader,[shader]);
		}

		__proto.setIBVB=function(x,y,ib,vb,numElement,shader){
			this._saveToCmd(Render.context._setIBVB,[x,y,ib,vb,numElement,shader]);
		}

		__proto.drawParticle=function(x,y,ps){
			var pt=RunDriver.createParticleTemplate2D(ps);
			pt.x=x;
			pt.y=y;
			this._saveToCmd(Render.context._drawParticle,[pt]);
		}

		return GraphicsGL;
	})(Graphics)


	/**
	*@private
	*<code>CSSStyle</code> 类是元素CSS样式定义类。
	*/
	//class laya.display.css.CSSStyle extends laya.display.css.Style
	var CSSStyle=(function(_super){
		function CSSStyle(ower){
			this._bgground=null;
			this._border=null;
			//this._ower=null;
			this._rect=null;
			this.lineHeight=0;
			CSSStyle.__super.call(this);
			this._padding=CSSStyle._PADDING;
			this._spacing=CSSStyle._SPACING;
			this._aligns=CSSStyle._ALIGNS;
			this._font=Font.EMPTY;
			this._ower=ower;
		}

		__class(CSSStyle,'laya.display.css.CSSStyle',_super);
		var __proto=CSSStyle.prototype;
		/**@inheritDoc */
		__proto.destroy=function(){
			this._ower=null;
			this._font=null;
			this._rect=null;
		}

		/**
		*复制传入的 CSSStyle 属性值。
		*@param src 待复制的 CSSStyle 对象。
		*/
		__proto.inherit=function(src){
			this._font=src._font;
			this._spacing=src._spacing===CSSStyle._SPACING ? CSSStyle._SPACING :src._spacing.slice();
			this.lineHeight=src.lineHeight;
		}

		/**@private */
		__proto._widthAuto=function(){
			return (this._type & 0x40000)!==0;
		}

		/**@inheritDoc */
		__proto.widthed=function(sprite){
			return (this._type & 0x8)!=0;
		}

		__proto._calculation=function(type,value){
			if (value.indexOf('%')< 0)return false;
			var ower=this._ower;
			var parent=ower.parent;
			var rect=this._rect;
			function getValue (pw,w,nums){
				return (pw *nums[0]+w *nums[1]+nums[2]);
			}
			function onParentResize (type){
				var pw=parent.width,w=ower.width;
				rect.width && (ower.width=getValue(pw,w,rect.width));
				rect.height && (ower.height=getValue(pw,w,rect.height));
				rect.left && (ower.x=getValue(pw,w,rect.left));
				rect.top && (ower.y=getValue(pw,w,rect.top));
			}
			if (rect===null){
				parent._getCSSStyle()._type |=0x80000;
				parent.on("resize",this,onParentResize);
				this._rect=rect={input:{}};
			};
			var nums=value.split(' ');
			nums[0]=parseFloat(nums[0])/ 100;
			if (nums.length==1)
				nums[1]=nums[2]=0;
			else {
				nums[1]=parseFloat(nums[1])/ 100;
				nums[2]=parseFloat(nums[2]);
			}
			rect[type]=nums;
			rect.input[type]=value;
			onParentResize(type);
			return true;
		}

		/**
		*是否已设置高度。
		*@param sprite 显示对象 Sprite。
		*@return 一个Boolean 表示是否已设置高度。
		*/
		__proto.heighted=function(sprite){
			return (this._type & 0x2000)!=0;
		}

		/**
		*设置宽高。
		*@param w 宽度。
		*@param h 高度。
		*/
		__proto.size=function(w,h){
			var ower=this._ower;
			var resize=false;
			if (w!==-1 && w !=this._ower.width){
				this._type |=0x8;
				this._ower.width=w;
				resize=true;
			}
			if (h!==-1 && h !=this._ower.height){
				this._type |=0x2000;
				this._ower.height=h;
				resize=true;
			}
			if (resize){
				ower._layoutLater();
				(this._type & 0x80000)&& ower.event("resize",this);
			}
		}

		/**@private */
		__proto._getAlign=function(){
			return this._aligns[0];
		}

		/**@private */
		__proto._getValign=function(){
			return this._aligns[1];
		}

		/**@private */
		__proto._getCssFloat=function(){
			return (this._type & 0x8000)!=0 ? 0x8000 :0;
		}

		__proto._createFont=function(){
			return (this._type & 0x1000)? this._font :(this._type |=0x1000,this._font=new Font(this._font));
		}

		/**@inheritDoc */
		__proto.render=function(sprite,context,x,y){
			var w=sprite.width;
			var h=sprite.height;
			x-=sprite.pivotX;
			y-=sprite.pivotY;
			this._bgground && this._bgground.color !=null && context.ctx.fillRect(x,y,w,h,this._bgground.color);
			this._border && this._border.color && context.drawRect(x,y,w,h,this._border.color.strColor,this._border.size);
		}

		/**@inheritDoc */
		__proto.getCSSStyle=function(){
			return this;
		}

		/**
		*设置 CSS 样式字符串。
		*@param text CSS样式字符串。
		*/
		__proto.cssText=function(text){
			this.attrs(CSSStyle.parseOneCSS(text,';'));
		}

		/**
		*根据传入的属性名、属性值列表，设置此对象的属性值。
		*@param attrs 属性名与属性值列表。
		*/
		__proto.attrs=function(attrs){
			if (attrs){
				for (var i=0,n=attrs.length;i < n;i++){
					var attr=attrs[i];
					this[attr[0]]=attr[1];
				}
			}
		}

		/**@inheritDoc */
		__proto.setTransform=function(value){
			(value==='none')? (this._tf=Style._TF_EMPTY):this.attrs(CSSStyle.parseOneCSS(value,','));
		}

		/**
		*定义 X 轴、Y 轴移动转换。
		*@param x X 轴平移量。
		*@param y Y 轴平移量。
		*/
		__proto.translate=function(x,y){
			this._tf===Style._TF_EMPTY && (this._tf=Style._createTransform());
			this._tf.translateX=x;
			this._tf.translateY=y;
		}

		/**
		*定义 缩放转换。
		*@param x X 轴缩放值。
		*@param y Y 轴缩放值。
		*/
		__proto.scale=function(x,y){
			this._tf===Style._TF_EMPTY && (this._tf=Style._createTransform());
			this._tf.scaleX=x;
			this._tf.scaleY=y;
		}

		/**@private */
		__proto._enableLayout=function(){
			return (this._type & 0x2)===0 && (this._type & 0x4)===0;
		}

		/**
		*水平对齐方式。
		*/
		__getset(0,__proto,'align',function(){
			return CSSStyle._aligndef[this._aligns[0]];
			},function(value){
			this._aligns===CSSStyle._ALIGNS && (this._aligns=[0,0,0]);
			this._aligns[0]=CSSStyle._aligndef[value];
		});

		/**@inheritDoc */
		__getset(0,__proto,'paddingTop',function(){
			return this.padding[0];
		});

		/**
		*是否显示为块级元素。
		*/
		__getset(0,__proto,'block',_super.prototype._$get_block,function(value){
			value ? (this._type |=0x1):(this._type &=(~0x1));
		});

		/**
		*边距信息。
		*/
		__getset(0,__proto,'padding',function(){
			return this._padding;
			},function(value){
			this._padding=value;
		});

		/**
		*宽度。
		*/
		__getset(0,__proto,'width',null,function(w){
			this._type |=0x8;
			if ((typeof w=='string')){
				var offset=w.indexOf('auto');
				if (offset >=0){
					this._type |=0x40000;
					w=w.substr(0,offset);
				}
				if (this._calculation("width",w))return;
				w=parseInt(w);
			}
			this.size(w,-1);
		});

		/**
		*高度。
		*/
		__getset(0,__proto,'height',null,function(h){
			this._type |=0x2000;
			if ((typeof h=='string')){
				if (this._calculation("height",h))return;
				h=parseInt(h);
			}
			this.size(-1,h);
		});

		__getset(0,__proto,'_scale',null,function(value){
			this._ower.scale(value[0],value[1]);
		});

		/**
		*浮动方向。
		*/
		__getset(0,__proto,'cssFloat',function(){
			return (this._type & 0x8000)!=0 ? "right" :"left";
			},function(value){
			this.lineElement=false;
			value==="right" ? (this._type |=0x8000):(this._type &=(~0x8000));
		});

		/**
		*字体信息。
		*/
		__getset(0,__proto,'font',function(){
			return this._font.toString();
			},function(value){
			this._createFont().set(value);
		});

		/**
		*是否是行元素。
		*/
		__getset(0,__proto,'lineElement',function(){
			return (this._type & 0x10000)!=0;
			},function(value){
			value ? (this._type |=0x10000):(this._type &=(~0x10000));
		});

		/**
		*垂直对齐方式。
		*/
		__getset(0,__proto,'valign',function(){
			return CSSStyle._valigndef[this._aligns[1]];
			},function(value){
			this._aligns===CSSStyle._ALIGNS && (this._aligns=[0,0,0]);
			this._aligns[1]=CSSStyle._valigndef[value];
		});

		/**
		*边框属性。
		*/
		__getset(0,__proto,'border',function(){
			return this._border ? this._border.value :"";
			},function(value){
			if (value=='none'){
				this._border=null;
				return;
			}
			this._border || (this._border={});
			this._border.value=value;
			var values=value.split(' ');
			this._border.color=Color.create(values[values.length-1]);
			if (values.length==1){
				this._border.size=1;
				this._border.type='solid';
				return;
			};
			var i=0;
			if (values[0].indexOf('px')> 0){
				this._border.size=parseInt(values[0]);
				i++;
			}else this._border.size=1;
			this._border.type=values[i];
			this._ower._renderType |=0x80;
		});

		/**
		*行间距。
		*/
		__getset(0,__proto,'leading',function(){
			return this._spacing[1];
			},function(d){
			((typeof d=='string'))&& (d=parseInt(d+""));
			this._spacing===CSSStyle._SPACING && (this._spacing=[0,0]);
			this._spacing[1]=d;
		});

		/**
		*表示左边距。
		*/
		__getset(0,__proto,'left',null,function(value){
			var ower=this._ower;
			if (((typeof value=='string'))){
				if (value==="center")
					value="50% -50% 0";
				else if (value==="right")
				value="100% -100% 0";
				if (this._calculation("left",value))return;
				value=parseInt(value);
			}
			ower.x=value;
		});

		/**
		*元素的定位类型。
		*/
		__getset(0,__proto,'position',function(){
			return (this._type & 0x4)? "absolute" :"";
			},function(value){
			value=="absolute" ? (this._type |=0x4):(this._type &=~0x4);
		});

		/**
		*表示上边距。
		*/
		__getset(0,__proto,'top',null,function(value){
			var ower=this._ower;
			if (((typeof value=='string'))){
				if (value==="middle")
					value="50% -50% 0";
				else if (value==="bottom")
				value="100% -100% 0";
				if (this._calculation("top",value))return;
				value=parseInt(value);
			}
			ower.y=value;
		});

		/**
		*设置如何处理元素内的空白。
		*/
		__getset(0,__proto,'whiteSpace',function(){
			return (this._type & 0x20000)? "nowrap" :"";
			},function(type){
			type==="nowrap" && (this._type |=0x20000);
			type==="none" && (this._type &=~0x20000);
		});

		/**
		*表示是否换行。
		*/
		__getset(0,__proto,'wordWrap',function(){
			return (this._type & 0x20000)===0;
			},function(value){
			value ? (this._type &=~0x20000):(this._type |=0x20000);
		});

		/**
		*表示是否加粗。
		*/
		__getset(0,__proto,'bold',function(){
			return this._font.bold;
			},function(value){
			this._createFont().bold=value;
		});

		/**
		*<p>指定文本字段是否是密码文本字段。</p>
		*如果此属性的值为 true，则文本字段被视为密码文本字段，并使用星号而不是实际字符来隐藏输入的字符。如果为 false，则不会将文本字段视为密码文本字段。
		*/
		__getset(0,__proto,'password',function(){
			return this._font.password;
			},function(value){
			this._createFont().password=value;
		});

		/**
		*文本的粗细。
		*/
		__getset(0,__proto,'weight',null,function(value){
			this._createFont().weight=value;
		});

		/**
		*间距。
		*/
		__getset(0,__proto,'letterSpacing',function(){
			return this._spacing[0];
			},function(d){
			((typeof d=='string'))&& (d=parseInt(d+""));
			this._spacing===CSSStyle._SPACING && (this._spacing=[0,0]);
			this._spacing[0]=d;
		});

		/**
		*字体大小。
		*/
		__getset(0,__proto,'fontSize',function(){
			return this._font.size;
			},function(value){
			this._createFont().size=value;
		});

		/**
		*表示是否为斜体。
		*/
		__getset(0,__proto,'italic',function(){
			return this._font.italic;
			},function(value){
			this._createFont().italic=value;
		});

		/**
		*字体系列。
		*/
		__getset(0,__proto,'fontFamily',function(){
			return this._font.family;
			},function(value){
			this._createFont().family=value;
		});

		/**
		*字体粗细。
		*/
		__getset(0,__proto,'fontWeight',function(){
			return this._font.weight;
			},function(value){
			this._createFont().weight=value;
		});

		/**
		*添加到文本的修饰。
		*/
		__getset(0,__proto,'textDecoration',function(){
			return this._font.decoration;
			},function(value){
			this._createFont().decoration=value;
		});

		/**
		*字体颜色。
		*/
		__getset(0,__proto,'color',function(){
			return this._font.color;
			},function(value){
			this._createFont().color=value;
		});

		/**
		*<p>描边颜色，以字符串表示。</p>
		*@default "#000000";
		*/
		__getset(0,__proto,'strokeColor',function(){
			return this._font.stroke[1];
			},function(value){
			if (this._createFont().stroke===Font._STROKE)this._font.stroke=[0,"#000000"];
			this._font.stroke[1]=value;
		});

		/**
		*边框的颜色。
		*/
		__getset(0,__proto,'borderColor',function(){
			return (this._border && this._border.color)? this._border.color.strColor :null;
			},function(value){
			if (!value){
				this._border=null;
				return;
			}
			this._border || (this._border={size:1,type:'solid'});
			this._border.color=(value==null)? null :Color.create(value);
			this._ower.model && this._ower.model.border(this._border.color.strColor);
			this._ower._renderType |=0x80;
		});

		/**
		*<p>描边宽度（以像素为单位）。</p>
		*默认值0，表示不描边。
		*@default 0
		*/
		__getset(0,__proto,'stroke',function(){
			return this._font.stroke[0];
			},function(value){
			if (this._createFont().stroke===Font._STROKE)this._font.stroke=[0,"#000000"];
			this._font.stroke[0]=value;
		});

		/**
		*背景颜色。
		*/
		__getset(0,__proto,'backgroundColor',function(){
			return this._bgground ? this._bgground.color :null;
			},function(value){
			if (value==='none')this._bgground=null;
			else (this._bgground || (this._bgground={}),this._bgground.color=value);
			this._ower.model && this._ower.model.bgColor(value);
			this._ower._renderType |=0x80;
		});

		/**@inheritDoc */
		__getset(0,__proto,'absolute',function(){
			return (this._type & 0x4)!==0;
		});

		__getset(0,__proto,'background',null,function(value){
			if (!value){
				this._bgground=null;
				return;
			}
			this._bgground || (this._bgground={});
			this._bgground.color=value;
			this._ower.model && this._ower.model.bgColor(value);
			this._type |=0x4000;
			this._ower._renderType |=0x80;
		});

		/**@inheritDoc */
		__getset(0,__proto,'paddingLeft',function(){
			return this.padding[3];
		});

		/**
		*规定元素应该生成的框的类型。
		*/
		__getset(0,__proto,'display',null,function(value){
			switch (value){
				case '':
					this._type &=~0x2;
					this.visible=true;
					break ;
				case 'none':
					this._type |=0x2;
					this.visible=false;
					this._ower._layoutLater();
					break ;
				}
		});

		__getset(0,__proto,'_translate',null,function(value){
			this.translate(value[0],value[1]);
		});

		__getset(0,__proto,'_rotate',null,function(value){
			this._ower.rotation=value;
		});

		CSSStyle.parseOneCSS=function(text,clipWord){
			var out=[];
			var attrs=text.split(clipWord);
			var valueArray;
			for (var i=0,n=attrs.length;i < n;i++){
				var attr=attrs[i];
				var ofs=attr.indexOf(':');
				var name=attr.substr(0,ofs).replace(/^\s+|\s+$/g,'');
				if (name.length==0)
					continue ;
				var value=attr.substr(ofs+1).replace(/^\s+|\s+$/g,'');
				var one=[name,value];
				switch (name){
					case 'italic':
					case 'bold':
						one[1]=value=="true";
						break ;
					case 'line-height':
						one[0]='lineHeight';
						one[1]=parseInt(value);
						break ;
					case 'font-size':
						one[0]='fontSize';
						one[1]=parseInt(value);
						break ;
					case 'padding':
						valueArray=value.split(' ');
						valueArray.length > 1 || (valueArray[1]=valueArray[2]=valueArray[3]=valueArray[0]);
						one[1]=[parseInt(valueArray[0]),parseInt(valueArray[1]),parseInt(valueArray[2]),parseInt(valueArray[3])];
						break ;
					case 'rotate':
						one[0]="_rotate";
						one[1]=parseFloat(value);
						break ;
					case 'scale':
						valueArray=value.split(' ');
						one[0]="_scale";
						one[1]=[parseFloat(valueArray[0]),parseFloat(valueArray[1])];
						break ;
					case 'translate':
						valueArray=value.split(' ');
						one[0]="_translate";
						one[1]=[parseInt(valueArray[0]),parseInt(valueArray[1])];
						break ;
					default :
						(one[0]=CSSStyle._CSSTOVALUE[name])|| (one[0]=name);
					}
				out.push(one);
			}
			return out;
		}

		CSSStyle.parseCSS=function(text,uri){
			var one;
			while ((one=CSSStyle._parseCSSRegExp.exec(text))!=null){
				CSSStyle.styleSheets[one[1]]=CSSStyle.parseOneCSS(one[2],';');
			}
		}

		CSSStyle.EMPTY=new CSSStyle(null);
		CSSStyle._CSSTOVALUE={'letter-spacing':'letterSpacing','line-spacing':'lineSpacing','white-space':'whiteSpace','line-height':'lineHeight','scale-x':'scaleX','scale-y':'scaleY','translate-x':'translateX','translate-y':'translateY','font-family':'fontFamily','font-weight':'fontWeight','vertical-align':'valign','text-decoration':'textDecoration','background-color':'backgroundColor','border-color':'borderColor','float':'cssFloat'};
		CSSStyle._parseCSSRegExp=new RegExp("([\.\#]\\w+)\\s*{([\\s\\S]*?)}","g");
		CSSStyle._aligndef={'left':0,'center':1,'right':2,0:'left',1:'center',2:'right'};
		CSSStyle._valigndef={'top':0,'middle':1,'bottom':2,0:'top',1:'middle',2:'bottom'};
		CSSStyle.styleSheets={};
		CSSStyle.ALIGN_CENTER=1;
		CSSStyle.ALIGN_RIGHT=2;
		CSSStyle.VALIGN_MIDDLE=1;
		CSSStyle.VALIGN_BOTTOM=2;
		CSSStyle._CSS_BLOCK=0x1;
		CSSStyle._DISPLAY_NONE=0x2;
		CSSStyle._ABSOLUTE=0x4;
		CSSStyle._WIDTH_SET=0x8;
		CSSStyle._PADDING=[0,0,0,0];
		CSSStyle._RECT=[-1,-1,-1,-1];
		CSSStyle._SPACING=[0,0];
		CSSStyle._ALIGNS=[0,0,0];
		CSSStyle.ADDLAYOUTED=0x200;
		CSSStyle._NEWFONT=0x1000;
		CSSStyle._HEIGHT_SET=0x2000;
		CSSStyle._BACKGROUND_SET=0x4000;
		CSSStyle._FLOAT_RIGHT=0x8000;
		CSSStyle._LINE_ELEMENT=0x10000;
		CSSStyle._NOWARP=0x20000;
		CSSStyle._WIDTHAUTO=0x40000;
		CSSStyle._LISTERRESZIE=0x80000;
		return CSSStyle;
	})(Style)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.shader.d2.ShaderDefines2D extends laya.webgl.shader.ShaderDefines
	var ShaderDefines2D=(function(_super){
		function ShaderDefines2D(){
			ShaderDefines2D.__super.call(this,ShaderDefines2D.__name2int,ShaderDefines2D.__int2name,ShaderDefines2D.__int2nameMap);
		}

		__class(ShaderDefines2D,'laya.webgl.shader.d2.ShaderDefines2D',_super);
		ShaderDefines2D.__init__=function(){
			ShaderDefines2D.reg("TEXTURE2D",0x01);
			ShaderDefines2D.reg("COLOR2D",0x02);
			ShaderDefines2D.reg("PRIMITIVE",0x04);
			ShaderDefines2D.reg("GLOW_FILTER",0x08);
			ShaderDefines2D.reg("BLUR_FILTER",0x10);
			ShaderDefines2D.reg("COLOR_FILTER",0x20);
			ShaderDefines2D.reg("COLOR_ADD",0x40);
			ShaderDefines2D.reg("WORLDMAT",0x80);
		}

		ShaderDefines2D.reg=function(name,value){
			ShaderDefines._reg(name,value,ShaderDefines2D.__name2int,ShaderDefines2D.__int2name);
		}

		ShaderDefines2D.toText=function(value,int2name,int2nameMap){
			return ShaderDefines._toText(value,int2name,int2nameMap);
		}

		ShaderDefines2D.toInt=function(names){
			return ShaderDefines._toInt(names,ShaderDefines2D.__name2int);
		}

		ShaderDefines2D.TEXTURE2D=0x01;
		ShaderDefines2D.COLOR2D=0x02;
		ShaderDefines2D.PRIMITIVE=0x04;
		ShaderDefines2D.FILTERGLOW=0x08;
		ShaderDefines2D.FILTERBLUR=0x10;
		ShaderDefines2D.FILTERCOLOR=0x20;
		ShaderDefines2D.COLORADD=0x40;
		ShaderDefines2D.WORLDMAT=0x80;
		ShaderDefines2D.__name2int={};
		ShaderDefines2D.__int2name=[];
		ShaderDefines2D.__int2nameMap=[];
		return ShaderDefines2D;
	})(ShaderDefines)


	/**
	*<p><code>ColorFilter</code> 是颜色滤镜。</p>
	*/
	//class laya.filters.ColorFilter extends laya.filters.Filter
	var ColorFilter=(function(_super){
		function ColorFilter(mat){
			//this._mat=null;
			//this._alpha=null;
			ColorFilter.__super.call(this);
			if (!mat){
				mat=[0.3,0.59,0.11,0,0,0.3,0.59,0.11,0,0,0.3,0.59,0.11,0,0,0,0,0,1,0];
			}
			this._mat=new Float32Array(16);
			this._alpha=new Float32Array(4);
			var j=0;
			var z=0;
			for (var i=0;i < 20;i++){
				if (i % 5 !=4){
					this._mat[j++]=mat[i];
					}else {
					this._alpha[z++]=mat[i];
				}
			}
			this._action=RunDriver.createFilterAction(0x20);
			this._action.data=this;
		}

		__class(ColorFilter,'laya.filters.ColorFilter',_super);
		var __proto=ColorFilter.prototype;
		Laya.imps(__proto,{"laya.filters.IFilter":true})
		/**
		*@private 通知微端
		*/
		__proto.callNative=function(sp){
			var t=sp._$P.cf=this;
			sp.model && sp.model.setFilterMatrix&&sp.model.setFilterMatrix(this._mat,this._alpha);
		}

		/**@private */
		__getset(0,__proto,'type',function(){
			return 0x20;
		});

		/**@private */
		__getset(0,__proto,'action',function(){
			return this._action;
		});

		__getset(1,ColorFilter,'DEFAULT',function(){
			if (!ColorFilter._DEFAULT){
				ColorFilter._DEFAULT=new ColorFilter([1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0]);
			}
			return ColorFilter._DEFAULT;
		},laya.filters.Filter._$SET_DEFAULT);

		__getset(1,ColorFilter,'GRAY',function(){
			if (!ColorFilter._GRAY){
				ColorFilter._GRAY=new ColorFilter([0.3,0.59,0.11,0,0,0.3,0.59,0.11,0,0,0.3,0.59,0.11,0,0,0,0,0,1,0]);
			}
			return ColorFilter._GRAY;
		},laya.filters.Filter._$SET_GRAY);

		ColorFilter._DEFAULT=null
		ColorFilter._GRAY=null
		return ColorFilter;
	})(Filter)


	//class laya.filters.webgl.ColorFilterActionGL extends laya.filters.webgl.FilterActionGL
	var ColorFilterActionGL=(function(_super){
		function ColorFilterActionGL(){
			this.data=null;
			ColorFilterActionGL.__super.call(this);
		}

		__class(ColorFilterActionGL,'laya.filters.webgl.ColorFilterActionGL',_super);
		var __proto=ColorFilterActionGL.prototype;
		Laya.imps(__proto,{"laya.filters.IFilterActionGL":true})
		__proto.setValue=function(shader){
			shader.colorMat=this.data._mat;
			shader.colorAlpha=this.data._alpha;
		}

		__proto.apply3d=function(scope,sprite,context,x,y){
			var b=scope.getValue("bounds");
			var shaderValue=Value2D.create(0x01,0);
			shaderValue.setFilters([this.data]);
			var tMatrix=Matrix.EMPTY;
			tMatrix.identity();
			context.ctx.drawTarget(scope,0,0,b.width,b.height,tMatrix,"src",shaderValue);
		}

		return ColorFilterActionGL;
	})(FilterActionGL)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.canvas.WebGLContext2D extends laya.resource.Context
	var WebGLContext2D=(function(_super){
		var ContextParams;
		function WebGLContext2D(c){
			this._x=0;
			this._y=0;
			this._id=++WebGLContext2D._COUNT;
			//this._other=null;
			this._path=null;
			//this._primitiveValue2D=null;
			this._drawCount=1;
			this._maxNumEle=0;
			this._clear=false;
			this._isMain=false;
			this._atlasResourceChange=0;
			this._submits=[];
			this._curSubmit=null;
			this._ib=null;
			this._vb=null;
			//this._curMat=null;
			this._nBlendType=0;
			//this._save=null;
			//this._targets=null;
			this._saveMark=null;
			//this.sprite=null;
			this.mId=-1;
			this.mHaveKey=false;
			this.mHaveLineKey=false;
			this.mX=0;
			this.mY=0;
			WebGLContext2D.__super.call(this);
			this._width=99999999;
			this._height=99999999;
			this._clipRect=WebGLContext2D.MAXCLIPRECT;
			this._shader2D=new Shader2D();
			this.mOutPoint
			this.drawTexture=this._drawTextureM;
			this._canvas=c;
			this._curMat=Matrix.create();
			if (Render.isFlash){
				this._ib=IndexBuffer2D.create(0x88E4);
				GlUtils.fillIBQuadrangle(this._ib,16);
			}else this._ib=IndexBuffer2D.QuadrangleIB;
			this._vb=VertexBuffer2D.create(-1);
			this._other=ContextParams.DEFAULT;
			this._save=[SaveMark.Create(this)];
			this._save.length=10;
			this.clear();
		}

		__class(WebGLContext2D,'laya.webgl.canvas.WebGLContext2D',_super);
		var __proto=WebGLContext2D.prototype;
		__proto.setIsMainContext=function(){
			this._isMain=true;
		}

		__proto.clearBG=function(r,g,b,a){
			var gl=WebGL.mainContext;
			gl.clearColor(r,g,b,a);
			gl.clear(0x00004000 | 0x00000100);
		}

		__proto._getSubmits=function(){
			return this._submits;
		}

		__proto.destroy=function(){
			this._curMat && this._curMat.destroy();
			this._targets && this._targets.destroy();
			this._vb && this._vb.releaseResource();
			this._ib && (this._ib !=IndexBuffer2D.QuadrangleIB)&& this._ib.releaseResource();
		}

		__proto.clear=function(){
			this._vb.clear();
			this._targets && (this._targets.repaint=true);
			this._other=ContextParams.DEFAULT;
			this._clear=true;
			this._repaint=false;
			this._drawCount=1;
			this._other.lineWidth=this._shader2D.ALPHA=1.0;
			this._nBlendType=0;
			this._clipRect=WebGLContext2D.MAXCLIPRECT;
			this._curSubmit=Submit.RENDERBASE;
			this._shader2D.glTexture=null;
			this._shader2D.fillStyle=this._shader2D.strokeStyle=DrawStyle.DEFAULT;
			for (var i=0,n=this._submits._length;i < n;i++)
			this._submits[i].releaseRender();
			this._submits._length=0;
			this._curMat.identity();
			this._other.clear();
			this._saveMark=this._save[0];
			this._save._length=1;
		}

		__proto.size=function(w,h){
			this._width=w;
			this._height=h;
			this._targets && (this._targets.size(w,h));
		}

		__proto._getTransformMatrix=function(){
			return this._curMat;
		}

		__proto.translate=function(x,y){
			if (x!==0 || y!==0){
				SaveTranslate.save(this);
				if (this._curMat.bTransform){
					SaveTransform.save(this);
					this._curMat.transformPoint(Point.TEMP.setTo(x,y));
					x=Point.TEMP.x;
					y=Point.TEMP.y;
				}
				this._x+=x;
				this._y+=y;
			}
		}

		__proto.save=function(){
			this._save[this._save._length++]=SaveMark.Create(this);
		}

		__proto.restore=function(){
			var sz=this._save._length;
			if (sz < 1)
				return;
			for (var i=sz-1;i >=0;i--){
				var o=this._save[i];
				o.restore(this);
				if (o.isSaveMark()){
					this._save._length=i;
					return;
				}
			}
		}

		__proto.measureText=function(text){
			return RunDriver.measureText(text,this._other.font.toString());
		}

		__proto._fillText=function(txt,words,x,y,fontStr,color,textAlign){
			var shader=this._shader2D;
			var curShader=this._curSubmit.shaderValue;
			var font=fontStr ? FontInContext.create(fontStr):this._other.font;
			if (AtlasResourceManager.enabled){
				if (shader.ALPHA!==curShader.ALPHA)
					shader.glTexture=null;
				DrawText.drawText(this,txt,words,this._curMat,font,textAlign || this._other.textAlign,color,null,-1,x,y);
				}else {
				var preDef=this._shader2D.defines.getValue();
				var colorAdd=color ? Color.create(color)._color :shader.colorAdd;
				if (shader.ALPHA!==curShader.ALPHA || colorAdd!==shader.colorAdd || curShader.colorAdd!==shader.colorAdd){
					shader.glTexture=null;
					shader.colorAdd=colorAdd;
				}
				DrawText.drawText(this,txt,words,this._curMat,font,textAlign || this._other.textAlign,color,null,-1,x,y);
			}
		}

		//shader.defines.setValue(preDef);
		__proto.fillWords=function(words,x,y,fontStr,color){
			words.length > 0 && this._fillText(null,words,x,y,fontStr,color,null);
		}

		__proto.fillText=function(txt,x,y,fontStr,color,textAlign){
			txt.length > 0 && this._fillText(txt,null,x,y,fontStr,color,textAlign);
		}

		__proto.strokeText=function(txt,x,y,fontStr,color,lineWidth,textAlign){
			if (txt.length===0)
				return;
			var shader=this._shader2D;
			var curShader=this._curSubmit.shaderValue;
			var font=fontStr ? (WebGLContext2D._fontTemp.setFont(fontStr),WebGLContext2D._fontTemp):this._other.font;
			if (AtlasResourceManager.enabled){
				if (shader.ALPHA!==curShader.ALPHA){
					shader.glTexture=null;
				}
				DrawText.drawText(this,txt,null,this._curMat,font,textAlign || this._other.textAlign,null,color,lineWidth || 1,x,y);
				}else {
				var preDef=this._shader2D.defines.getValue();
				var colorAdd=color ? Color.create(color)._color :shader.colorAdd;
				if (shader.ALPHA!==curShader.ALPHA || colorAdd!==shader.colorAdd || curShader.colorAdd!==shader.colorAdd){
					shader.glTexture=null;
					shader.colorAdd=colorAdd;
				}
				DrawText.drawText(this,txt,null,this._curMat,font,textAlign || this._other.textAlign,null,color,lineWidth || 1,x,y);
			}
		}

		//shader.defines.setValue(preDef);
		__proto.fillBorderText=function(txt,x,y,fontStr,fillColor,borderColor,lineWidth,textAlign){
			if (txt.length===0)
				return;
			if (!AtlasResourceManager.enabled){
				this.strokeText(txt,x,y,fontStr,borderColor,lineWidth,textAlign);
				this.fillText(txt,x,y,fontStr,fillColor,textAlign);
				return;
			};
			var shader=this._shader2D;
			var curShader=this._curSubmit.shaderValue;
			if (shader.ALPHA!==curShader.ALPHA)
				shader.glTexture=null;
			var font=fontStr ? (WebGLContext2D._fontTemp.setFont(fontStr),WebGLContext2D._fontTemp):this._other.font;
			DrawText.drawText(this,txt,null,this._curMat,font,textAlign || this._other.textAlign,fillColor,borderColor,lineWidth || 1,x,y);
		}

		__proto.fillRect=function(x,y,width,height,fillStyle){
			var vb=this._vb;
			if (GlUtils.fillRectImgVb(vb,this._clipRect,x,y,width,height,Texture.DEF_UV,this._curMat,this._x,this._y,0,0)){
				var pre=this._shader2D.fillStyle;
				fillStyle && (this._shader2D.fillStyle=DrawStyle.create(fillStyle));
				var shader=this._shader2D;
				var curShader=this._curSubmit.shaderValue;
				if (shader.fillStyle!==curShader.fillStyle || shader.ALPHA!==curShader.ALPHA){
					shader.glTexture=null;
					var submit=this._curSubmit=Submit.create(this,this._ib,vb,((vb._byteLength-16 *4)/ 32)*3,Value2D.create(0x02,0));
					submit.shaderValue.color=shader.fillStyle._color._color;
					submit.shaderValue.ALPHA=shader.ALPHA;
					this._submits[this._submits._length++]=submit;
				}
				this._curSubmit._numEle+=6;
				this._shader2D.fillStyle=pre;
			}
		}

		__proto.setShader=function(shader){
			SaveBase.save(this,0x80000,this._shader2D,true);
			this._shader2D.shader=shader;
		}

		__proto.setFilters=function(value){
			SaveBase.save(this,0x100000,this._shader2D,true);
			this._shader2D.filters=value;
			this._curSubmit=Submit.RENDERBASE;
			this._drawCount++;
		}

		__proto.drawTexture=function(tex,x,y,width,height,tx,ty){
			this._drawTextureM(tex,x,y,width,height,tx,ty,null);
		}

		__proto._drawTextureM=function(tex,x,y,width,height,tx,ty,m){
			if (!(tex.loaded && tex.bitmap && tex.source)){
				if (this.sprite){
					Laya.timer.callLater(this,this._repaintSprite);
				}
				return;
			};
			var webGLImg=tex.bitmap;
			var shader=this._shader2D;
			var curShader=this._curSubmit.shaderValue;
			this._drawCount++;
			if (this._curSubmit._renderType!==16 || shader.glTexture!==webGLImg || shader.ALPHA!==curShader.ALPHA){
				shader.glTexture=webGLImg;
				var vb=this._vb;
				var submit=null;
				var vbSize=(vb._byteLength / 32)*3;
				submit=SubmitTexture.create(this,this._ib,vb,vbSize,Value2D.create(0x01,0));
				this._submits[this._submits._length++]=submit;
				submit.shaderValue.textureHost=tex;
				submit._renderType=16;
				submit._preIsSameTextureShader=this._curSubmit._renderType===16 && shader.ALPHA===curShader.ALPHA;
				this._curSubmit=submit;
			};
			var finalVB=this._curSubmit._vb || this._vb;
			if (GlUtils.fillRectImgVb(finalVB,this._clipRect,x+tx,y+ty,width || tex.width,height || tex.height,tex.uv,m || this._curMat,this._x,this._y,0,0)){
				if (AtlasResourceManager.enabled && !this._isMain)
					(this._curSubmit).addTexture(tex,(finalVB._byteLength >> 2)-16);
				this._curSubmit._numEle+=6;
				this._maxNumEle=Math.max(this._maxNumEle,this._curSubmit._numEle);
			}
		}

		__proto._repaintSprite=function(){
			this.sprite.repaint();
		}

		//}
		__proto._drawText=function(tex,x,y,width,height,m,tx,ty,dx,dy){
			var webGLImg=tex.bitmap;
			var shader=this._shader2D;
			var curShader=this._curSubmit.shaderValue;
			this._drawCount++;
			if (this._curSubmit._renderType!==16 || shader.glTexture!==webGLImg || shader.ALPHA!==curShader.ALPHA){
				shader.glTexture=webGLImg;
				var vb=this._vb;
				var submit=null;
				var submitID=NaN;
				var vbSize=(vb._byteLength / 32)*3;
				if (AtlasResourceManager.enabled){
					submit=SubmitTexture.create(this,this._ib,vb,vbSize,Value2D.create(0x01,0));
					}else {
					submit=SubmitTexture.create(this,this._ib,vb,vbSize,TextSV.create());
				}
				submit._preIsSameTextureShader=this._curSubmit._renderType===16 && shader.ALPHA===curShader.ALPHA;
				this._submits[this._submits._length++]=submit;
				submit.shaderValue.textureHost=tex;
				submit._renderType=16;
				this._curSubmit=submit;
			}
			tex.active();
			var finalVB=this._curSubmit._vb || this._vb;
			if (GlUtils.fillRectImgVb(finalVB,this._clipRect,x+tx,y+ty,width || tex.width,height || tex.height,tex.uv,m || this._curMat,this._x,this._y,dx,dy,true)){
				if (AtlasResourceManager.enabled && !this._isMain){
					(this._curSubmit).addTexture(tex,(finalVB._byteLength >> 2)-16);
				}
				this._curSubmit._numEle+=6;
				this._maxNumEle=Math.max(this._maxNumEle,this._curSubmit._numEle);
			}
		}

		__proto.drawTextureWithTransform=function(tex,x,y,width,height,transform,tx,ty){
			var curMat=this._curMat;
			(tx!==0 || ty!==0)&& (this._x=tx *curMat.a+ty *curMat.c,this._y=ty *curMat.d+tx *curMat.b);
			if (transform && curMat.bTransform){
				Matrix.mul(transform,curMat,WebGLContext2D._tmpMatrix);
				transform=WebGLContext2D._tmpMatrix;
				transform._checkTransform();
				}else {
				this._x+=curMat.tx;
				this._y+=curMat.ty;
			}
			this._drawTextureM(tex,x,y,width,height,0,0,transform);
			this._x=this._y=0;
		}

		__proto.fillQuadrangle=function(tex,x,y,point4,m){
			var submit=this._curSubmit;
			var vb=this._vb;
			var shader=this._shader2D;
			var curShader=submit.shaderValue;
			if (tex.bitmap){
				var t_tex=tex.bitmap;
				if (shader.glTexture !=t_tex || shader.ALPHA!==curShader.ALPHA){
					shader.glTexture=t_tex;
					submit=this._curSubmit=Submit.create(this,this._ib,vb,((vb._byteLength)/ 32)*3,Value2D.create(0x01,0));
					submit.shaderValue.glTexture=t_tex;
					this._submits[this._submits._length++]=submit;
				}
				GlUtils.fillQuadrangleImgVb(vb,x,y,point4,tex.uv,m || this._curMat,this._x,this._y);
				}else {
				if (!submit.shaderValue.fillStyle || !submit.shaderValue.fillStyle.equal(tex)|| shader.ALPHA!==curShader.ALPHA){
					shader.glTexture=null;
					submit=this._curSubmit=Submit.create(this,this._ib,vb,((vb._byteLength)/ 32)*3,Value2D.create(0x02,0));
					submit.shaderValue.defines.add(0x02);
					submit.shaderValue.fillStyle=DrawStyle.create(tex);
					this._submits[this._submits._length++]=submit;
				}
				GlUtils.fillQuadrangleImgVb(vb,x,y,point4,Texture.DEF_UV,m || this._curMat,this._x,this._y);
			}
			submit._numEle+=6;
		}

		__proto.drawTexture2=function(x,y,pivotX,pivotY,transform,alpha,blendMode,args){
			var curMat=this._curMat;
			this._x=x *curMat.a+y *curMat.c;
			this._y=y *curMat.d+x *curMat.b;
			if (transform){
				if (curMat.bTransform || transform.bTransform){
					Matrix.mul(transform,curMat,WebGLContext2D._tmpMatrix);
					transform=WebGLContext2D._tmpMatrix;
					}else {
					this._x+=transform.tx+curMat.tx;
					this._y+=transform.ty+curMat.ty;
					transform=Matrix.EMPTY;
				}
			}
			if (alpha===1 && !blendMode)
				this._drawTextureM(args[0],args[1]-pivotX,args[2]-pivotY,args[3],args[4],0,0,transform);
			else {
				var preAlpha=this._shader2D.ALPHA;
				var preblendType=this._nBlendType;
				this._shader2D.ALPHA=alpha;
				blendMode && (this._nBlendType=BlendMode.TOINT(blendMode));
				this._drawTextureM(args[0],args[1]-pivotX,args[2]-pivotY,args[3],args[4],0,0,transform);
				this._shader2D.ALPHA=preAlpha;
				this._nBlendType=preblendType;
			}
			this._x=this._y=0;
		}

		__proto.drawCanvas=function(canvas,x,y,width,height){
			var src=canvas.context;
			if (src._targets){
				this._submits[this._submits._length++]=SubmitCanvas.create(src,0,null);
				this._curSubmit=Submit.RENDERBASE;
				src._targets.drawTo(this,x,y,width,height);
				}else {
				var submit=this._submits[this._submits._length++]=SubmitCanvas.create(src,this._shader2D.ALPHA,this._shader2D.filters);
				var sx=width / canvas.width;
				var sy=height / canvas.height;
				var mat=submit._matrix;
				this._curMat.copyTo(mat);
				sx !=1 && sy !=1 && mat.scale(sx,sy);
				var tx=mat.tx,ty=mat.ty;
				mat.tx=mat.ty=0;
				mat.transformPoint(Point.TEMP.setTo(x,y));
				mat.translate(Point.TEMP.x+tx,Point.TEMP.y+ty);
				this._curSubmit=Submit.RENDERBASE;
			}
			if (Config.showCanvasMark){
				this.save();
				this.lineWidth=4;
				this.strokeStyle=src._targets ? "yellow" :"green";
				this.strokeRect(x-1,y-1,width+2,height+2,1);
				this.strokeRect(x,y,width,height,1);
				this.restore();
			}
		}

		__proto.drawTarget=function(scope,x,y,width,height,m,proName,shaderValue,uv,blend){
			(blend===void 0)&& (blend=-1);
			var vb=this._vb;
			if (GlUtils.fillRectImgVb(vb,this._clipRect,x,y,width,height,uv || Texture.DEF_UV,m || this._curMat,this._x,this._y,0,0)){
				var shader=this._shader2D;
				shader.glTexture=null;
				var curShader=this._curSubmit.shaderValue;
				var submit=this._curSubmit=SubmitTarget.create(this,this._ib,vb,((vb._byteLength-16 *4)/ 32)*3,shaderValue,proName);
				if (blend==-1){
					submit.blendType=this._nBlendType;
					}else {
					submit.blendType=blend;
				}
				submit.scope=scope;
				this._submits[this._submits._length++]=submit;
				this._curSubmit._numEle+=6;
			}
		}

		__proto.transform=function(a,b,c,d,tx,ty){
			SaveTransform.save(this);
			Matrix.mul(Matrix.TEMP.setTo(a,b,c,d,tx,ty),this._curMat,this._curMat);
			this._curMat._checkTransform();
		}

		__proto.setTransformByMatrix=function(value){
			value.copyTo(this._curMat);
		}

		__proto.transformByMatrix=function(value){
			SaveTransform.save(this);
			Matrix.mul(value,this._curMat,this._curMat);
			this._curMat._checkTransform();
		}

		__proto.rotate=function(angle){
			SaveTransform.save(this);
			this._curMat.rotate(angle);
		}

		__proto.scale=function(scaleX,scaleY){
			SaveTransform.save(this);
			this._curMat.scale(scaleX,scaleY);
		}

		__proto.clipRect=function(x,y,width,height){
			width *=this._curMat.a;
			height *=this._curMat.d;
			var p=Point.TEMP;
			this._curMat.transformPoint(p.setTo(x,y));
			var submit=this._curSubmit=SubmitScissor.create(this);
			this._submits[this._submits._length++]=submit;
			submit.submitIndex=this._submits._length;
			submit.submitLength=9999999;
			SaveClipRect.save(this,submit);
			var clip=this._clipRect;
			var x1=clip.x,y1=clip.y;
			var r=p.x+width,b=p.y+height;
			x1 < p.x && (clip.x=p.x);
			y1 < p.y && (clip.y=p.y);
			clip.width=Math.min(r,x1+clip.width)-clip.x;
			clip.height=Math.min(b,y1+clip.height)-clip.y;
			this._shader2D.glTexture=null;
			submit.clipRect.copyFrom(clip);
			this._curSubmit=Submit.RENDERBASE;
		}

		__proto.setIBVB=function(x,y,ib,vb,numElement,mat,shader,shaderValues,startIndex,offset){
			(startIndex===void 0)&& (startIndex=0);
			(offset===void 0)&& (offset=0);
			if (ib===null){
				if (!Render.isFlash){
					ib=this._ib;
					}else {
					var falshVB=vb;
					(falshVB._selfIB)|| (falshVB._selfIB=IndexBuffer2D.create(0x88E4));
					falshVB._selfIB.clear();
					ib=falshVB._selfIB;
				}
				GlUtils.expandIBQuadrangle(ib,(vb.byteLength / (4 *vb.vertexStride *4)));
			}
			if (!shaderValues || !shader)
				throw Error("setIBVB must input:shader shaderValues");
			var submit=SubmitOtherIBVB.create(this,vb,ib,numElement,shader,shaderValues,startIndex,offset);
			mat || (mat=Matrix.EMPTY);
			mat.translate(x,y);
			Matrix.mul(mat,this._curMat,submit._mat);
			mat.translate(-x,-y);
			this._submits[this._submits._length++]=submit;
			this._curSubmit=Submit.RENDERBASE;
		}

		__proto.addRenderObject=function(o){
			this._submits[this._submits._length++]=o;
		}

		__proto.fillTrangles=function(tex,x,y,points,m){
			var submit=this._curSubmit;
			var vb=this._vb;
			var shader=this._shader2D;
			var curShader=submit.shaderValue;
			var length=points.length >> 4;
			var t_tex=tex.bitmap;
			if (shader.glTexture !=t_tex || shader.ALPHA!==curShader.ALPHA){
				submit=this._curSubmit=Submit.create(this,this._ib,vb,((vb._byteLength)/ 32)*3,Value2D.create(0x01,0));
				submit.shaderValue.textureHost=tex;
				this._submits[this._submits._length++]=submit;
			}
			GlUtils.fillTranglesVB(vb,x,y,points,m || this._curMat,this._x,this._y);
			submit._numEle+=length *6;
		}

		__proto.submitElement=function(start,end){
			var renderList=this._submits;
			end < 0 && (end=renderList._length);
			while (start < end){
				start+=renderList[start].renderSubmit();
			}
		}

		__proto.finish=function(){
			WebGL.mainContext.finish();
		}

		__proto.flush=function(){
			var maxNum=Math.max(this._vb.byteLength / (4 *16),this._maxNumEle / 6)+8;
			if (maxNum > (this._ib.bufferLength / (6 *2))){
				GlUtils.expandIBQuadrangle(this._ib,maxNum);
			}
			if (!this._isMain && AtlasResourceManager.enabled && AtlasResourceManager._atlasRestore > this._atlasResourceChange){
				this._atlasResourceChange=AtlasResourceManager._atlasRestore;
				var renderList=this._submits;
				for (var i=0,s=renderList._length;i < s;i++){
					var submit=renderList [i];
					if (submit.getRenderType()===16)
						(submit).checkTexture();
				}
			}
			this.submitElement(0,this._submits._length);
			this._path && this._path.reset();
			this._curSubmit=Submit.RENDERBASE;
			return this._submits._length;
		}

		__proto.setPathId=function(id){
			this.mId=id;
			if (this.mId !=-1){
				this.mHaveKey=false;
				var tVGM=VectorGraphManager.getInstance();
				if (tVGM.shapeDic[this.mId]){
					this.mHaveKey=true;
				}
				this.mHaveLineKey=false;
				if (tVGM.shapeLineDic[this.mId]){
					this.mHaveLineKey=true;
				}
			}
		}

		__proto.movePath=function(x,y){
			this.mX+=x;
			this.mY+=y;
		}

		__proto.beginPath=function(){
			var tPath=this._getPath();
			tPath.tempArray.length=0;
			tPath.closePath=false;
			this.mX=0;
			this.mY=0;
		}

		__proto.closePath=function(){
			this._path.closePath=true;
		}

		__proto.fill=function(isConvexPolygon){
			(isConvexPolygon===void 0)&& (isConvexPolygon=false);
			var tPath=this._getPath();
			this.drawPoly(0,0,tPath.tempArray,this.fillStyle._color.numColor,0,0,isConvexPolygon);
		}

		__proto.stroke=function(){
			var tPath=this._getPath();
			if (this.lineWidth > 0){
				if (this.mId==-1){
					tPath.drawLine(0,0,tPath.tempArray,this.lineWidth,this.strokeStyle._color.numColor);
					}else {
					if (this.mHaveLineKey){
						var tShapeLine=VectorGraphManager.getInstance().shapeLineDic[this.mId];
						tPath.setGeomtry(tShapeLine);
						}else {
						VectorGraphManager.getInstance().addLine(this.mId,tPath.drawLine(0,0,tPath.tempArray,this.lineWidth,this.strokeStyle._color.numColor));
					}
				}
				tPath.update();
				var tArray=RenderState2D.getMatrArray();
				RenderState2D.mat2MatArray(this._curMat,tArray);
				var tPosArray=[this.mX,this.mY];
				var tempSubmit=Submit.createShape(this,tPath.ib,tPath.vb,tPath.count,tPath.offset,Value2D.create(0x04,0));
				tempSubmit.shaderValue.ALPHA=this._shader2D.ALPHA;
				tempSubmit.shaderValue.u_pos=tPosArray;
				tempSubmit.shaderValue.u_mmat2=tArray;
				this._submits[this._submits._length++]=tempSubmit;
			}
		}

		__proto.line=function(fromX,fromY,toX,toY,lineWidth,mat){
			var submit=this._curSubmit;
			var vb=this._vb;
			if (GlUtils.fillLineVb(vb,this._clipRect,fromX,fromY,toX,toY,lineWidth,mat)){
				var shader=this._shader2D;
				var curShader=submit.shaderValue;
				if (shader.strokeStyle!==curShader.strokeStyle || shader.ALPHA!==curShader.ALPHA){
					shader.glTexture=null;
					submit=this._curSubmit=Submit.create(this,this._ib,vb,((vb._byteLength-16 *4)/ 32)*3,Value2D.create(0x02,0));
					submit.shaderValue.strokeStyle=shader.strokeStyle;
					submit.shaderValue.mainID=0x02;
					submit.shaderValue.ALPHA=shader.ALPHA;
					this._submits[this._submits._length++]=submit;
				}
				submit._numEle+=6;
			}
		}

		__proto.moveTo=function(x,y){
			var tPath=this._getPath();
			tPath.addPoint(x,y);
		}

		__proto.lineTo=function(x,y){
			var tPath=this._getPath();
			tPath.addPoint(x,y);
		}

		__proto.arcTo=function(x1,y1,x2,y2,r){
			if (this.mId !=-1){
				if (this.mHaveKey){
					return;
				}
			};
			var tPath=this._getPath();
			var x0=tPath.getEndPointX();
			var y0=tPath.getEndPointY();
			var dx0=NaN,dy0=NaN,dx1=NaN,dy1=NaN,a=NaN,d=NaN,cx=NaN,cy=NaN,a0=NaN,a1=NaN;
			var dir=false;
			dx0=x0-x1;
			dy0=y0-y1;
			dx1=x2-x1;
			dy1=y2-y1;
			Point.TEMP.setTo(dx0,dy0);
			Point.TEMP.normalize();
			dx0=Point.TEMP.x;
			dy0=Point.TEMP.y;
			Point.TEMP.setTo(dx1,dy1);
			Point.TEMP.normalize();
			dx1=Point.TEMP.x;
			dy1=Point.TEMP.y;
			a=Math.acos(dx0 *dx1+dy0 *dy1);
			var tTemp=Math.tan(a / 2.0);
			d=r / tTemp;
			if (d > 10000){
				this.lineTo(x1,y1);
				return;
			}
			if (dx0 *dy1-dx1 *dy0 <=0.0){
				cx=x1+dx0 *d+dy0 *r;
				cy=y1+dy0 *d-dx0 *r;
				a0=Math.atan2(dx0,-dy0);
				a1=Math.atan2(-dx1,dy1);
				dir=false;
				}else {
				cx=x1+dx0 *d-dy0 *r;
				cy=y1+dy0 *d+dx0 *r;
				a0=Math.atan2(-dx0,dy0);
				a1=Math.atan2(dx1,-dy1);
				dir=true;
			}
			this.arc(cx,cy,r,a0,a1,dir);
		}

		__proto.arc=function(cx,cy,r,startAngle,endAngle,counterclockwise){
			(counterclockwise===void 0)&& (counterclockwise=false);
			if (this.mId !=-1){
				if (this.mHaveKey){
					return;
				}
				cx=0;
				cy=0;
			};
			var a=0,da=0,hda=0,kappa=0;
			var dx=0,dy=0,x=0,y=0,tanx=0,tany=0;
			var px=0,py=0,ptanx=0,ptany=0;
			var i=0,ndivs=0,nvals=0;
			da=endAngle-startAngle;
			if (!counterclockwise){
				if (Math.abs(da)>=Math.PI *2){
					da=Math.PI *2;
					}else {
					while (da < 0.0){
						da+=Math.PI *2;
					}
				}
				}else {
				if (Math.abs(da)>=Math.PI *2){
					da=-Math.PI *2;
					}else {
					while (da > 0.0){
						da-=Math.PI *2;
					}
				}
			}
			if (r < 101){
				ndivs=Math.max(10,da *r / 5);
				}else if (r < 201){
				ndivs=Math.max(10,da *r / 20);
				}else {
				ndivs=Math.max(10,da *r / 40);
			}
			hda=(da / ndivs)/ 2.0;
			kappa=Math.abs(4 / 3 *(1-Math.cos(hda))/ Math.sin(hda));
			if (counterclockwise)
				kappa=-kappa;
			nvals=0;
			var tPath=this._getPath();
			for (i=0;i <=ndivs;i++){
				a=startAngle+da *(i / ndivs);
				dx=Math.cos(a);
				dy=Math.sin(a);
				x=cx+dx *r;
				y=cy+dy *r;
				if (x !=this._path.getEndPointX()|| y !=this._path.getEndPointY()){
					tPath.addPoint(x,y);
				}
			}
			dx=Math.cos(endAngle);
			dy=Math.sin(endAngle);
			x=cx+dx *r;
			y=cy+dy *r;
			if (x !=this._path.getEndPointX()|| y !=this._path.getEndPointY()){
				tPath.addPoint(x,y);
			}
		}

		__proto.quadraticCurveTo=function(cpx,cpy,x,y){
			var tBezier=Bezier.I;
			var tResultArray=[];
			var tArray=tBezier.getBezierPoints([this._path.getEndPointX(),this._path.getEndPointY(),cpx,cpy,x,y],30,2);
			for (var i=0,n=tArray.length / 2;i < n;i++){
				this.lineTo(tArray[i *2],tArray[i *2+1]);
			}
			this.lineTo(x,y);
		}

		__proto.rect=function(x,y,width,height){
			this._other=this._other.make();
			this._other.path || (this._other.path=new Path());
			this._other.path.rect(x,y,width,height);
		}

		__proto.strokeRect=function(x,y,width,height,parameterLineWidth){
			var tW=parameterLineWidth *0.5;
			this.line(x-tW,y,x+width+tW,y,parameterLineWidth,this._curMat);
			this.line(x+width,y,x+width,y+height,parameterLineWidth,this._curMat);
			this.line(x,y,x,y+height,parameterLineWidth,this._curMat);
			this.line(x-tW,y+height,x+width+tW,y+height,parameterLineWidth,this._curMat);
		}

		__proto.clip=function(){}
		/**
		*画多边形(用)
		*@param x
		*@param y
		*@param points
		*/
		__proto.drawPoly=function(x,y,points,color,lineWidth,boderColor,isConvexPolygon){
			(isConvexPolygon===void 0)&& (isConvexPolygon=false);
			this._shader2D.glTexture=null;
			var tPath=this._getPath();
			if (this.mId==-1){
				tPath.polygon(x,y,points,color,lineWidth ? lineWidth :1,boderColor)
				}else {
				if (this.mHaveKey){
					var tShape=VectorGraphManager.getInstance().shapeDic[this.mId];
					tPath.setGeomtry(tShape);
					}else {
					VectorGraphManager.getInstance().addShape(this.mId,tPath.polygon(x,y,points,color,lineWidth ? lineWidth :1,boderColor));
				}
			}
			tPath.update();
			var tPosArray=[this.mX,this.mY];
			var tArray=RenderState2D.getMatrArray();
			RenderState2D.mat2MatArray(this._curMat,tArray);
			var tempSubmit;
			if (!isConvexPolygon){
				var submit=SubmitStencil.create(4);
				this.addRenderObject(submit);
				tempSubmit=Submit.createShape(this,tPath.ib,tPath.vb,tPath.count,tPath.offset,Value2D.create(0x04,0));
				tempSubmit.shaderValue.ALPHA=this._shader2D.ALPHA;
				tempSubmit.shaderValue.u_pos=tPosArray;
				tempSubmit.shaderValue.u_mmat2=tArray;
				this._submits[this._submits._length++]=tempSubmit;
				submit=SubmitStencil.create(5);
				this.addRenderObject(submit);
			}
			tempSubmit=Submit.createShape(this,tPath.ib,tPath.vb,tPath.count,tPath.offset,Value2D.create(0x04,0));
			tempSubmit.shaderValue.ALPHA=this._shader2D.ALPHA;
			tempSubmit.shaderValue.u_pos=tPosArray;
			tempSubmit.shaderValue.u_mmat2=tArray;
			this._submits[this._submits._length++]=tempSubmit;
			if (!isConvexPolygon){
				submit=SubmitStencil.create(3);
				this.addRenderObject(submit);
			}
			if (lineWidth > 0){
				if (this.mHaveLineKey){
					var tShapeLine=VectorGraphManager.getInstance().shapeLineDic[this.mId];
					tPath.setGeomtry(tShapeLine);
					}else {
					VectorGraphManager.getInstance().addShape(this.mId,tPath.drawLine(x,y,points,lineWidth,boderColor));
				}
				tPath.update();
				tempSubmit=Submit.createShape(this,tPath.ib,tPath.vb,tPath.count,tPath.offset,Value2D.create(0x04,0));
				tempSubmit.shaderValue.ALPHA=this._shader2D.ALPHA;
				tempSubmit.shaderValue.u_mmat2=tArray;
				this._submits[this._submits._length++]=tempSubmit;
			}
		}

		/*******************************************end矢量绘制***************************************************/
		__proto.drawParticle=function(x,y,pt){
			pt.x=x;
			pt.y=y;
			this._submits[this._submits._length++]=pt;
		}

		__proto._getPath=function(){
			return this._path || (this._path=new Path());
		}

		__getset(0,__proto,'asBitmap',null,function(value){
			if (value){
				this._targets || (this._targets=new RenderTargetMAX());
				this._targets.repaint=true;
				if (!this._width || !this._height)throw Error("asBitmap no size!");
				this._targets.size(this._width,this._height);
			}else this._targets=null;
		});

		__getset(0,__proto,'fillStyle',function(){
			return this._shader2D.fillStyle;
			},function(value){
			this._shader2D.fillStyle.equal(value)|| (SaveBase.save(this,0x2,this._shader2D,false),this._shader2D.fillStyle=DrawStyle.create(value));
		});

		/*,_shader2D.ALPHA=1*/
		__getset(0,__proto,'globalCompositeOperation',function(){
			return BlendMode.NAMES[this._nBlendType];
			},function(value){
			var n=BlendMode.TOINT[value];
			n==null || (this._nBlendType===n)|| (SaveBase.save(this,0x10000,this,true),this._curSubmit=Submit.RENDERBASE,this._nBlendType=n);
		});

		__getset(0,__proto,'textAlign',function(){
			return this._other.textAlign;
			},function(value){
			(this._other.textAlign===value)|| (this._other=this._other.make(),SaveBase.save(this,0x8000,this._other,false),this._other.textAlign=value);
		});

		__getset(0,__proto,'globalAlpha',function(){
			return this._shader2D.ALPHA;
			},function(value){
			value=Math.floor(value *1000)/ 1000;
			if (value !=this._shader2D.ALPHA){
				SaveBase.save(this,0x1,this._shader2D,true);
				this._shader2D.ALPHA=value;
			}
		});

		__getset(0,__proto,'textBaseline',function(){
			return this._other.textBaseline;
			},function(value){
			(this._other.textBaseline===value)|| (this._other=this._other.make(),SaveBase.save(this,0x4000,this._other,false),this._other.textBaseline=value);
		});

		__getset(0,__proto,'font',null,function(str){
			if (str==this._other.font.toString())
				return;
			this._other=this._other.make();
			SaveBase.save(this,0x8,this._other,false);
			this._other.font===FontInContext.EMPTY ? (this._other.font=new FontInContext(str)):(this._other.font.setFont(str));
		});

		__getset(0,__proto,'strokeStyle',function(){
			return this._shader2D.strokeStyle;
			},function(value){
			this._shader2D.strokeStyle.equal(value)|| (SaveBase.save(this,0x200,this._shader2D,false),this._shader2D.strokeStyle=DrawStyle.create(value));
		});

		__getset(0,__proto,'lineWidth',function(){
			return this._other.lineWidth;
			},function(value){
			(this._other.lineWidth===value)|| (this._other=this._other.make(),SaveBase.save(this,0x100,this._other,false),this._other.lineWidth=value);
		});

		WebGLContext2D.__init__=function(){
			ContextParams.DEFAULT=new ContextParams();
		}

		WebGLContext2D._SUBMITVBSIZE=32000;
		WebGLContext2D._MAXSIZE=99999999;
		WebGLContext2D._RECTVBSIZE=16;
		WebGLContext2D.MAXCLIPRECT=new Rectangle(0,0,99999999,99999999);
		WebGLContext2D._COUNT=0;
		WebGLContext2D._tmpMatrix=new Matrix();
		__static(WebGLContext2D,
		['_fontTemp',function(){return this._fontTemp=new FontInContext();},'_drawStyleTemp',function(){return this._drawStyleTemp=new DrawStyle(null);}
		]);
		WebGLContext2D.__init$=function(){
			//class ContextParams
			ContextParams=(function(){
				function ContextParams(){
					this.lineWidth=1;
					this.path=null;
					this.textAlign=null;
					this.textBaseline=null;
					this.font=FontInContext.EMPTY;
				}
				__class(ContextParams,'');
				var __proto=ContextParams.prototype;
				__proto.clear=function(){
					this.lineWidth=1;
					this.path && this.path.clear();
					this.textAlign=this.textBaseline=null;
					this.font=FontInContext.EMPTY;
				}
				__proto.make=function(){
					return this===ContextParams.DEFAULT ? new ContextParams():this;
				}
				ContextParams.DEFAULT=null
				return ContextParams;
			})()
		}

		return WebGLContext2D;
	})(Context)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.utils.RenderSprite3D extends laya.renders.RenderSprite
	var RenderSprite3D=(function(_super){
		function RenderSprite3D(type,next){
			RenderSprite3D.__super.call(this,type,next);
		}

		__class(RenderSprite3D,'laya.webgl.utils.RenderSprite3D',_super);
		var __proto=RenderSprite3D.prototype;
		__proto.onCreate=function(type){
			switch (type){
				case 0x20:
					this._fun=this._blend;
					return;
				case 0x04:
					this._fun=this._transform;
					return;
				}
		}

		__proto._blend=function(sprite,context,x,y){
			var style=sprite._style;
			var next=this._next;
			var mask=sprite.mask;
			var submitCMD;
			var submitStencil;
			context.ctx.save();
			if (mask){
				var preBlendMode=(context.ctx).globalCompositeOperation;
				var tRect=new Rectangle();
				tRect.copyFrom(mask.getBounds());
				if (tRect.width > 0 && tRect.height > 0){
					var scope=SubmitCMDScope.create();
					scope.addValue("bounds",tRect);
					submitCMD=SubmitCMD.create([scope,context],laya.webgl.utils.RenderSprite3D.tmpTarget);
					context.addRenderObject(submitCMD);
					mask.render(context,-tRect.x,-tRect.y);
					submitCMD=SubmitCMD.create([scope],laya.webgl.utils.RenderSprite3D.endTmpTarget);
					context.addRenderObject(submitCMD);
					context.ctx.save();
					context.clipRect(x+tRect.x,y+tRect.y,tRect.width,tRect.height);
					next._fun.call(next,sprite,context,x,y);
					context.ctx.restore();
					submitStencil=SubmitStencil.create(6);
					preBlendMode=(context.ctx).globalCompositeOperation;
					submitStencil.blendMode="mask";
					context.addRenderObject(submitStencil);
					Matrix.TEMP.identity();
					var shaderValue=Value2D.create(0x01,0);
					(context.ctx).drawTarget(scope,x+tRect.x,y+tRect.y,tRect.width,tRect.height,Matrix.TEMP,"tmpTarget",shaderValue,Texture.INV_UV,6);
					submitCMD=SubmitCMD.create([scope],laya.webgl.utils.RenderSprite3D.recycleTarget);
					context.addRenderObject(submitCMD);
					submitStencil=SubmitStencil.create(6);
					submitStencil.blendMode=preBlendMode;
					context.addRenderObject(submitStencil);
				}
				}else {
				context.ctx.globalCompositeOperation=style.blendMode;
				next=this._next;
				next._fun.call(next,sprite,context,x,y);
			}
			context.ctx.restore();
		}

		__proto._transform=function(sprite,context,x,y){
			'use strict';
			var transform=sprite.transform,_next=this._next;
			if (transform && _next !=RenderSprite.NORENDER){
				var ctx=context.ctx;
				var style=sprite._style;
				transform.tx=x;
				transform.ty=y;
				var m2=ctx._getTransformMatrix();
				var m1=m2.clone();
				Matrix.mul(transform,m2,m2);
				m2._checkTransform();
				_next._fun.call(_next,sprite,context,0,0);
				m1.copyTo(m2);
				m1.destroy();
				transform.tx=transform.ty=0;
				}else {
				_next._fun.call(_next,sprite,context,x,y);
			}
		}

		RenderSprite3D.tmpTarget=function(scope,context){
			var b=scope.getValue("bounds");
			var tmpTarget=RenderTarget2D.create(b.width,b.height);
			tmpTarget.start();
			tmpTarget.clear(0,0,0,0);
			scope.addValue("tmpTarget",tmpTarget);
		}

		RenderSprite3D.endTmpTarget=function(scope){
			var tmpTarget=scope.getValue("tmpTarget");
			tmpTarget.end();
		}

		RenderSprite3D.recycleTarget=function(scope){
			var tmpTarget=scope.getValue("tmpTarget");
			tmpTarget.recycle();
			scope.recycle();
		}

		return RenderSprite3D;
	})(RenderSprite)


	//class laya.webgl.atlas.Atlaser extends laya.webgl.atlas.AtlasGrid
	var Atlaser=(function(_super){
		function Atlaser(gridNumX,gridNumY,width,height,atlasID){
			this._atlasCanvas=null;
			this._inAtlasTextureKey=null;
			this._inAtlasTextureBitmapValue=null;
			this._inAtlasTextureOriUVValue=null;
			this._InAtlasWebGLImagesKey=null;
			this._InAtlasWebGLImagesOffsetValue=null;
			Atlaser.__super.call(this,gridNumX,gridNumY,atlasID);
			this._inAtlasTextureKey=[];
			this._inAtlasTextureBitmapValue=[];
			this._inAtlasTextureOriUVValue=[];
			this._InAtlasWebGLImagesKey=[];
			this._InAtlasWebGLImagesOffsetValue=[];
			this._atlasCanvas=new AtlasWebGLCanvas();
			this._atlasCanvas.width=width;
			this._atlasCanvas.height=height;
			this._atlasCanvas.activeResource();
			this._atlasCanvas.lock=true;
		}

		__class(Atlaser,'laya.webgl.atlas.Atlaser',_super);
		var __proto=Atlaser.prototype;
		__proto.computeUVinAtlasTexture=function(texture,oriUV,offsetX,offsetY){
			var tex=texture;
			var _width=AtlasResourceManager.atlasTextureWidth;
			var _height=AtlasResourceManager.atlasTextureHeight;
			var u1=offsetX / _width,v1=offsetY / _height,u2=(offsetX+texture.bitmap.width)/ _width,v2=(offsetY+texture.bitmap.height)/ _height;
			var inAltasUVWidth=texture.bitmap.width / _width,inAltasUVHeight=texture.bitmap.height / _height;
			texture.uv=[u1+oriUV[0] *inAltasUVWidth,v1+oriUV[1] *inAltasUVHeight,u2-(1-oriUV[2])*inAltasUVWidth,v1+oriUV[3] *inAltasUVHeight,u2-(1-oriUV[4])*inAltasUVWidth,v2-(1-oriUV[5])*inAltasUVHeight,u1+oriUV[6] *inAltasUVWidth,v2-(1-oriUV[7])*inAltasUVHeight];
		}

		/**
		*
		*@param inAtlasRes
		*@return 是否已经存在队列中
		*/
		__proto.addToAtlasTexture=function(mergeAtlasBitmap,offsetX,offsetY){
			((mergeAtlasBitmap instanceof laya.webgl.resource.WebGLImage ))&& (this._InAtlasWebGLImagesKey.push(mergeAtlasBitmap),this._InAtlasWebGLImagesOffsetValue.push([offsetX,offsetY]));
			this._atlasCanvas.texSubImage2D(offsetX,offsetY,mergeAtlasBitmap.atlasSource);
			mergeAtlasBitmap.clearAtlasSource();
		}

		__proto.addToAtlas=function(texture,offsetX,offsetY){
			var oriUV=texture.uv.slice();
			var oriBitmap=texture.bitmap;
			this._inAtlasTextureKey.push(texture);
			this._inAtlasTextureOriUVValue.push(oriUV);
			this._inAtlasTextureBitmapValue.push(oriBitmap);
			this.computeUVinAtlasTexture(texture,oriUV,offsetX,offsetY);
			texture.bitmap=this._atlasCanvas;
		}

		__proto.clear=function(){
			for (var i=0,n=this._inAtlasTextureKey.length;i < n;i++){
				this._inAtlasTextureKey[i].bitmap=this._inAtlasTextureBitmapValue[i];
				this._inAtlasTextureKey[i].uv=this._inAtlasTextureOriUVValue[i];
				this._inAtlasTextureKey[i].bitmap.lock=false;
				this._inAtlasTextureKey[i].bitmap.releaseResource();
			}
			this._inAtlasTextureKey.length=0;
			this._inAtlasTextureBitmapValue.length=0;
			this._inAtlasTextureOriUVValue.length=0;
			this._InAtlasWebGLImagesKey.length=0;
			this._InAtlasWebGLImagesOffsetValue.length=0;
		}

		__proto.dispose=function(){
			this.clear();
			this._atlasCanvas.dispose();
		}

		__getset(0,__proto,'texture',function(){
			return this._atlasCanvas;
		});

		__getset(0,__proto,'inAtlasWebGLImagesKey',function(){
			return this._InAtlasWebGLImagesKey;
		});

		__getset(0,__proto,'InAtlasWebGLImagesOffsetValue',function(){
			return this._InAtlasWebGLImagesOffsetValue;
		});

		return Atlaser;
	})(AtlasGrid)


	//class laya.webgl.shapes.Line extends laya.webgl.shapes.BasePoly
	var Line=(function(_super){
		function Line(x,y,points,borderWidth,color){
			this._points=[];
			var tCurrX=NaN;
			var tCurrY=NaN;
			var tLastX=-1;
			var tLastY=-1;
			var tLen=points.length / 2-1;
			for (var i=0;i < tLen;i++){
				tCurrX=points[i *2];
				tCurrY=points[i *2+1];
				if (Math.abs(tLastX-tCurrX)> 0.01 || Math.abs(tLastY-tCurrY)>0.01){
					this._points.push(tCurrX,tCurrY);
				}
				tLastX=tCurrX;
				tLastY=tCurrY;
			}
			tCurrX=points[tLen *2];
			tCurrY=points[tLen *2+1];
			tLastX=this._points[0];
			tLastY=this._points[1];
			if (Math.abs(tLastX-tCurrX)> 0.01 || Math.abs(tLastY-tCurrY)>0.01){
				this._points.push(tCurrX,tCurrY);
			}
			Line.__super.call(this,x,y,0,0,0,color,borderWidth,color,0);
		}

		__class(Line,'laya.webgl.shapes.Line',_super);
		var __proto=Line.prototype;
		__proto.getData=function(ib,vb,start){
			var indices=[];
			var verts=[];
			(this.borderWidth > 0)&& this.createLine2(this._points,indices,this.borderWidth,start,verts,this._points.length / 2);
			ib.append(new Uint16Array(indices));
			vb.append(new Float32Array(verts));
		}

		return Line;
	})(BasePoly)


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.shapes.LoopLine extends laya.webgl.shapes.BasePoly
	var LoopLine=(function(_super){
		function LoopLine(x,y,points,width,color){
			this._points=[];
			var tCurrX=NaN;
			var tCurrY=NaN;
			var tLastX=-1;
			var tLastY=-1;
			var tLen=points.length / 2-1;
			for (var i=0;i < tLen;i++){
				tCurrX=points[i *2];
				tCurrY=points[i *2+1];
				if (Math.abs(tLastX-tCurrX)> 0.01 || Math.abs(tLastY-tCurrY)>0.01){
					this._points.push(tCurrX,tCurrY);
				}
				tLastX=tCurrX;
				tLastY=tCurrY;
			}
			tCurrX=points[tLen *2];
			tCurrY=points[tLen *2+1];
			tLastX=this._points[0];
			tLastY=this._points[1];
			if (Math.abs(tLastX-tCurrX)> 0.01 || Math.abs(tLastY-tCurrY)>0.01){
				this._points.push(tCurrX,tCurrY);
			}
			LoopLine.__super.call(this,x,y,0,0,this._points.length / 2,0,width,color);
		}

		__class(LoopLine,'laya.webgl.shapes.LoopLine',_super);
		var __proto=LoopLine.prototype;
		__proto.getData=function(ib,vb,start){
			if (this.borderWidth > 0){
				var color=this.color;
				var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
				var verts=[];
				var tLastX=-1,tLastY=-1;
				var tCurrX=0,tCurrY=0;
				var indices=[];
				var tLen=Math.floor(this._points.length / 2);
				for (var i=0;i < tLen;i++){
					tCurrX=this._points[i *2];
					tCurrY=this._points[i *2+1];
					verts.push(this.x+tCurrX,this.y+tCurrY,r,g,b);
				}
				this.createLoopLine(verts,indices,this.borderWidth,start+verts.length / 5);
				ib.append(new Uint16Array(indices));
				vb.append(new Float32Array(verts));
			}
		}

		__proto.createLoopLine=function(p,indices,lineWidth,len,outVertex,outIndex){
			var tLen=p.length / 5;
			var points=p.concat();
			var result=outVertex ? outVertex :p;
			var color=this.borderColor;
			var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
			var firstPoint=[points[0],points[1]];
			var lastPoint=[points[points.length-5],points[points.length-4]];
			var midPointX=lastPoint[0]+(firstPoint[0]-lastPoint[0])*0.5;
			var midPointY=lastPoint[1]+(firstPoint[1]-lastPoint[1])*0.5;
			points.unshift(midPointX,midPointY,0,0,0);
			points.push(midPointX,midPointY,0,0,0);
			var length=points.length / 5;
			var iStart=len,w=lineWidth / 2;
			var px,py,p1x,p1y,p2x,p2y,p3x,p3y;
			var perpx,perpy,perp2x,perp2y,perp3x,perp3y;
			var a1,b1,c1,a2,b2,c2;
			var denom,pdist,dist;
			p1x=points[0];
			p1y=points[1];
			p2x=points[5];
			p2y=points[6];
			perpx=-(p1y-p2y);
			perpy=p1x-p2x;
			dist=Math.sqrt(perpx *perpx+perpy *perpy);
			perpx=perpx / dist *w;
			perpy=perpy / dist *w;
			result.push(p1x-perpx,p1y-perpy,r,g,b,p1x+perpx,p1y+perpy,r,g,b);
			for (var i=1;i < length-1;i++){
				p1x=points[(i-1)*5];
				p1y=points[(i-1)*5+1];
				p2x=points[(i)*5];
				p2y=points[(i)*5+1];
				p3x=points[(i+1)*5];
				p3y=points[(i+1)*5+1];
				perpx=-(p1y-p2y);
				perpy=p1x-p2x;
				dist=Math.sqrt(perpx *perpx+perpy *perpy);
				perpx=perpx / dist *w;
				perpy=perpy / dist *w;
				perp2x=-(p2y-p3y);
				perp2y=p2x-p3x;
				dist=Math.sqrt(perp2x *perp2x+perp2y *perp2y);
				perp2x=perp2x / dist *w;
				perp2y=perp2y / dist *w;
				a1=(-perpy+p1y)-(-perpy+p2y);
				b1=(-perpx+p2x)-(-perpx+p1x);
				c1=(-perpx+p1x)*(-perpy+p2y)-(-perpx+p2x)*(-perpy+p1y);
				a2=(-perp2y+p3y)-(-perp2y+p2y);
				b2=(-perp2x+p2x)-(-perp2x+p3x);
				c2=(-perp2x+p3x)*(-perp2y+p2y)-(-perp2x+p2x)*(-perp2y+p3y);
				denom=a1 *b2-a2 *b1;
				if (Math.abs(denom)< 0.1){
					denom+=10.1;
					result.push(p2x-perpx,p2y-perpy,r,g,b,p2x+perpx,p2y+perpy,r,g,b);
					continue ;
				}
				px=(b1 *c2-b2 *c1)/ denom;
				py=(a2 *c1-a1 *c2)/ denom;
				pdist=(px-p2x)*(px-p2x)+(py-p2y)+(py-p2y);
				result.push(px,py,r,g,b,p2x-(px-p2x),p2y-(py-p2y),r,g,b);
			}
			if (outIndex){
				indices=outIndex;
			};
			var groupLen=this.edges+1;
			for (i=1;i < groupLen;i++){
				indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+i *2+1,iStart+i *2+1,iStart+i *2,iStart+(i-1)*2);
			}
			indices.push(iStart+(i-1)*2,iStart+(i-1)*2+1,iStart+1,iStart+1,iStart,iStart+(i-1)*2);
			return result;
		}

		return LoopLine;
	})(BasePoly)


	//class laya.webgl.shapes.Polygon extends laya.webgl.shapes.BasePoly
	var Polygon=(function(_super){
		function Polygon(x,y,points,color,borderWidth,borderColor){
			this._points=null;
			this.mUint16Array=null;
			this.mFloat32Array=null;
			this._points=points.slice(0,points.length);
			Polygon.__super.call(this,x,y,0,0,this._points.length / 2,color,borderWidth,borderColor);
		}

		__class(Polygon,'laya.webgl.shapes.Polygon',_super);
		var __proto=Polygon.prototype;
		__proto.getData=function(ib,vb,start){
			if (!(this.mUint16Array && this.mFloat32Array)){
				var indices=[];
				var verts=[];
				var color=this.color;
				var r=((color >> 16)& 0x0000ff)/ 255,g=((color >> 8)& 0xff)/ 255,b=(color & 0x0000ff)/ 255;
				var tArray;
				tArray=this._points;
				var i=0,tLen=Math.floor(tArray.length / 2);
				for (i=0;i < tLen;i++){
					verts.push(this.x+tArray[i *2],this.y+tArray[i *2+1],r,g,b);
				}
				for (i=2;i < tLen;i++){
					indices.push(start,start+i-1,start+i);
				}
				this.mUint16Array=new Uint16Array(indices);
				this.mFloat32Array=new Float32Array(verts);
			}
			ib.append(this.mUint16Array);
			vb.append(this.mFloat32Array);
		}

		return Polygon;
	})(BasePoly)


	/**
	*...
	*@author wk
	*/
	//class laya.webgl.submit.SubmitCanvas extends laya.webgl.submit.Submit
	var SubmitCanvas=(function(_super){
		function SubmitCanvas(){
			//this._ctx_src=null;
			this._matrix=new Matrix();
			this._matrix4=CONST3D2D.defaultMatrix4.concat();
			SubmitCanvas.__super.call(this,1);
			this.shaderValue=new Value2D(0,0);
		}

		__class(SubmitCanvas,'laya.webgl.submit.SubmitCanvas',_super);
		var __proto=SubmitCanvas.prototype;
		__proto.renderSubmit=function(){
			if (this._ctx_src._targets){
				this._ctx_src._targets.flush(this._ctx_src);
				return 1;
			};
			var preAlpha=RenderState2D.worldAlpha;
			var preMatrix4=RenderState2D.worldMatrix4;
			var preMatrix=RenderState2D.worldMatrix;
			var preFilters=RenderState2D.worldFilters;
			var preWorldShaderDefines=RenderState2D.worldShaderDefines;
			var v=this.shaderValue;
			var m=this._matrix;
			var m4=this._matrix4;
			var mout=Matrix.TEMP;
			Matrix.mul(m,preMatrix,mout);
			m4[0]=mout.a;
			m4[1]=mout.b;
			m4[4]=mout.c;
			m4[5]=mout.d;
			m4[12]=mout.tx;
			m4[13]=mout.ty;
			RenderState2D.worldMatrix=mout.clone();
			RenderState2D.worldMatrix4=m4;
			RenderState2D.worldAlpha=RenderState2D.worldAlpha *v.alpha;
			if (v.filters && v.filters.length){
				RenderState2D.worldFilters=v.filters;
				RenderState2D.worldShaderDefines=v.defines;
			}
			this._ctx_src.flush();
			RenderState2D.worldAlpha=preAlpha;
			RenderState2D.worldMatrix4=preMatrix4;
			RenderState2D.worldMatrix.destroy();
			RenderState2D.worldMatrix=preMatrix;
			RenderState2D.worldFilters=preFilters;
			RenderState2D.worldShaderDefines=preWorldShaderDefines;
			return 1;
		}

		__proto.releaseRender=function(){
			var cache=SubmitCanvas._cache;
			cache[cache._length++]=this;
		}

		__proto.getRenderType=function(){
			return 3;
		}

		SubmitCanvas.create=function(ctx_src,alpha,filters){
			var o=(!SubmitCanvas._cache._length)?(new SubmitCanvas()):SubmitCanvas._cache[--SubmitCanvas._cache._length];
			o._ctx_src=ctx_src;
			var v=o.shaderValue;
			v.alpha=alpha;
			v.defines.setValue(0);
			filters && filters.length && v.setFilters(filters);
			return o;
		}

		SubmitCanvas._cache=(SubmitCanvas._cache=[],SubmitCanvas._cache._length=0,SubmitCanvas._cache);
		return SubmitCanvas;
	})(Submit)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.submit.SubmitTexture extends laya.webgl.submit.Submit
	var SubmitTexture=(function(_super){
		function SubmitTexture(renderType){
			this._preIsSameTextureShader=false;
			this._isSameTexture=true;
			this._texs=new Array;
			this._texsID=new Array;
			this._vbPos=new Array;
			(renderType===void 0)&& (renderType=1);
			SubmitTexture.__super.call(this,renderType);
		}

		__class(SubmitTexture,'laya.webgl.submit.SubmitTexture',_super);
		var __proto=SubmitTexture.prototype;
		__proto.releaseRender=function(){
			var cache=SubmitTexture._cache;
			cache[cache._length++]=this;
			this.shaderValue.release();
			this._preIsSameTextureShader=false;
			this._vb=null;
			this._texs.length=0;
			this._isSameTexture=true;
		}

		__proto.addTexture=function(tex,vbpos){
			this._texsID[this._texs.length]=tex._uvID;
			this._texs.push(tex);
			this._vbPos.push(vbpos);
		}

		//检查材质是否修改，修改UV，设置是否是同一材质
		__proto.checkTexture=function(){
			if (this._texs.length < 1){
				this._isSameTexture=true;
				return;
			};
			var _tex=this.shaderValue.textureHost;
			var webGLImg=_tex.bitmap;
			if (webGLImg===null)return;
			var vbdata=this._vb.getFloat32Array();
			for (var i=0,s=this._texs.length;i < s;i++){
				var tex=this._texs[i];
				tex.active();
				var newUV=tex.uv;
				if (this._texsID[i]!==tex._uvID){
					this._texsID[i]=tex._uvID;
					var vbPos=this._vbPos[i];
					vbdata[vbPos+2]=newUV[0];
					vbdata[vbPos+3]=newUV[1];
					vbdata[vbPos+6]=newUV[2];
					vbdata[vbPos+7]=newUV[3];
					vbdata[vbPos+10]=newUV[4];
					vbdata[vbPos+11]=newUV[5];
					vbdata[vbPos+14]=newUV[6];
					vbdata[vbPos+15]=newUV[7];
					this._vb.setNeedUpload();
				}
				if (tex.bitmap!==webGLImg){
					this._isSameTexture=false;
				}
			}
		}

		__proto.renderSubmit=function(){
			if (this._numEle===0)return 1;
			var _tex=this.shaderValue.textureHost;
			if (_tex){
				var source=_tex.source;
				if (!_tex.bitmap || !source){
					SubmitTexture._shaderSet=false;
					return 1;
				}
				this.shaderValue.texture=source;
			}
			this._vb.bind_upload(this._ib);
			var gl=WebGL.mainContext;
			if (BlendMode.activeBlendFunction!==this._blendFn){
				gl.enable(0x0BE2);
				this._blendFn(gl);
				BlendMode.activeBlendFunction=this._blendFn;
			}
			Stat.drawCall++;
			Stat.trianglesFaces+=this._numEle / 3;
			if (this._preIsSameTextureShader && Shader.activeShader && SubmitTexture._shaderSet)
				Shader.activeShader.uploadTexture2D(this.shaderValue.texture);
			else this.shaderValue.upload();
			SubmitTexture._shaderSet=true;
			if (this._texs.length > 1 && !this._isSameTexture){
				var webGLImg=_tex.bitmap;
				var index=0;
				var shader=Shader.activeShader;
				for (var i=0,s=this._texs.length;i < s;i++){
					var tex2=this._texs[i];
					if (tex2.bitmap!==webGLImg || (i+1)===s){
						shader.uploadTexture2D(tex2.source);
						gl.drawElements(0x0004,(i-index+1)*6,0x1403,this._startIdx+index *6 *CONST3D2D.BYTES_PIDX);
						webGLImg=tex2.bitmap;
						index=i;
					}
				}
				}else {
				gl.drawElements(0x0004,this._numEle,0x1403,this._startIdx);
			}
			return 1;
		}

		SubmitTexture.create=function(context,ib,vb,pos,sv){
			var o=SubmitTexture._cache._length ? SubmitTexture._cache[--SubmitTexture._cache._length] :new SubmitTexture();
			if (vb==null){
				vb=o._selfVb || (o._selfVb=VertexBuffer2D.create(-1));
				vb.clear();
				pos=0;
			}
			o._ib=ib;
			o._vb=vb;
			o._startIdx=pos *CONST3D2D.BYTES_PIDX;
			o._numEle=0;
			var blendType=context._nBlendType;
			o._blendFn=context._targets ? BlendMode.targetFns[blendType] :BlendMode.fns[blendType];
			o.shaderValue=sv;
			o.shaderValue.setValue(context._shader2D);
			var filters=context._shader2D.filters;
			filters && o.shaderValue.setFilters(filters);
			return o;
		}

		SubmitTexture._cache=(SubmitTexture._cache=[],SubmitTexture._cache._length=0,SubmitTexture._cache);
		SubmitTexture._shaderSet=true;
		return SubmitTexture;
	})(Submit)


	//class specter3d.engine.core.camera.Camera3D extends specter3d.engine.core.Object3D
	var Camera3D=(function(_super){
		function Camera3D(aspect,near,far){
			this.orthographic=false;
			this._aspect=1.0;
			this._near=NaN;
			this._far=NaN;
			this._dirty=false;
			this._viewProjection=new Matrix3D();
			this._projectMatrix=new Matrix3D();
			this._unprojectMatrix=new Matrix3D();
			this._viewMatrix=new Matrix3D();
			(aspect===void 0)&& (aspect=1);
			(near===void 0)&& (near=0.1);
			(far===void 0)&& (far=2000);
			Camera3D.__super.call(this);
			this._aspect=aspect;
			this._near=near;
			this._far=far;
			this.transform.setPosition(0,0,-1000);
			this._dirty=true;
		}

		__class(Camera3D,'specter3d.engine.core.camera.Camera3D',_super);
		var __proto=Camera3D.prototype;
		__proto.updateProjectionMatrix=function(){}
		// 重载
		__proto.setViewPort=function(x,y,width,height){
			this._aspect=width / height;
			this._dirty=true;
		}

		__proto.project=function(point3d,v){
			if (!v)
				v=new Vector3D();
			this.projectMatrix.transformVector(point3d,v);
			v.x=v.x / v.w;
			v.y=-v.y / v.w;
			v.z=v.z;
			return v;
		}

		__proto.unproject=function(nX,nY,sZ,v){
			if (!v)
				v=new Vector3D();
			v.x=nX;
			v.y=-nY;
			v.z=sZ;
			v.w=1;
			v.x *=sZ;
			v.y *=sZ;
			this.unprojectMatrix.transformVector(v,v);
			v.z=sZ;
			return v;
		}

		__proto.screen2DToScene3D=function(sX,sY,sZ,v){
			if (!v)
				v=new Vector3D();
			var nX=(sX*2-AppGlobalContext.stageWidth)/ AppGlobalContext.stageWidth;
			var nY=(sY*2-AppGlobalContext.stageHeight)/ AppGlobalContext.stageHeight;
			this.unproject(nX,nY,sZ,v);
			this.transform.world.transformVector(v,v);
			return v;
		}

		__proto.scene3DToScreen2D=function(point3d,v){
			if (!v)
				v=new Vector3D();
			this.viewMatrix.transformVector(point3d,v);
			this.project(v,v);
			v.x=(v.x+1.0)*AppGlobalContext.stageWidth / 2.0;
			v.y=(v.y+1.0)*AppGlobalContext.stageHeight / 2.0;
			return v;
		}

		__proto.screenPositionToRay=function(nX,nY,sZ,v){
			var ray=new Ray();
			ray.origin=this.transform.getPosition(false,ray.origin);
			var target=this.unproject(nX,nY,sZ);
			ray.direction=target.subtract(ray.origin);
			return ray;
		}

		__getset(0,__proto,'aspect',function(){
			return this._aspect;
			},function(value){
			this._aspect=value;
			this._dirty=true;
		});

		__getset(0,__proto,'near',function(){
			return this._near;
			},function(value){
			this._near=value;
			this._dirty=true;
		});

		__getset(0,__proto,'viewMatrix',function(){
			this._viewMatrix.copyFrom(this.transform.world);
			this._viewMatrix.invert();
			return this._viewMatrix;
		});

		__getset(0,__proto,'far',function(){
			return this._far;
			},function(value){
			this._far=value;
			this._dirty=true;
		});

		/**
		*模型变换矩阵
		*@return
		*
		*/
		__getset(0,__proto,'modelViewMatrix',function(){
			this._viewProjection.copyFrom(this.transform.world);
			this._viewProjection.invert();
			this._viewProjection.append(this.projectMatrix);
			return this._viewProjection;
		});

		/**
		*透视矩阵
		*@return
		*
		*/
		__getset(0,__proto,'projectMatrix',function(){
			if (this._dirty){
				this._dirty=false;
				this.updateProjectionMatrix();
			}
			return this._projectMatrix;
		});

		__getset(0,__proto,'unprojectMatrix',function(){
			this._unprojectMatrix.copyFrom(this.projectMatrix);
			this._unprojectMatrix.invert();
			return this._unprojectMatrix;
		});

		return Camera3D;
	})(Object3D)


	/**
	*Extended camera used to hover round a specified target object.
	*
	*@see away3d.containers.View3D
	*/
	//class specter3d.engine.controllers.HoverController extends specter3d.engine.controllers.LookAtController
	var HoverController=(function(_super){
		function HoverController(targetObject,lookAtObject,panAngle,tiltAngle,distance,minTiltAngle,maxTiltAngle,minPanAngle,maxPanAngle,steps,yFactor,wrapPanAngle){
			this._currentPanAngle=0;
			this._currentTiltAngle=90;
			this._panAngle=0;
			this._tiltAngle=90;
			this._distance=1000;
			this._minPanAngle=-Infinity;
			this._minTiltAngle=-90;
			this._maxTiltAngle=90;
			this._steps=8;
			this._yFactor=2;
			this._wrapPanAngle=false;
			this._maxPanAngle=Infinity;
			this._$2__pos=new Vector3D();
			(panAngle===void 0)&& (panAngle=0);
			(tiltAngle===void 0)&& (tiltAngle=90);
			(distance===void 0)&& (distance=1000);
			(minTiltAngle===void 0)&& (minTiltAngle=-90);
			(maxTiltAngle===void 0)&& (maxTiltAngle=90);
			(minPanAngle===void 0)&& (minPanAngle=NaN);
			(maxPanAngle===void 0)&& (maxPanAngle=NaN);
			(steps===void 0)&& (steps=8);
			(yFactor===void 0)&& (yFactor=2);
			(wrapPanAngle===void 0)&& (wrapPanAngle=false);
			HoverController.__super.call(this,targetObject,lookAtObject);
			this.distance=distance;
			this.panAngle=panAngle;
			this.tiltAngle=tiltAngle;
			this.minPanAngle=minPanAngle ||-Infinity;
			this.maxPanAngle=maxPanAngle || Infinity;
			this.minTiltAngle=minTiltAngle;
			this.maxTiltAngle=maxTiltAngle;
			this.steps=steps;
			this.yFactor=yFactor;
			this.wrapPanAngle=wrapPanAngle;
			this._currentPanAngle=this._panAngle;
			this._currentTiltAngle=this._tiltAngle;
		}

		__class(HoverController,'specter3d.engine.controllers.HoverController',_super);
		var __proto=HoverController.prototype;
		/**
		*Updates the current tilt angle and pan angle values.
		*
		*Values are calculated using the defined <code>tiltAngle</code>,<code>panAngle</code> and <code>steps</code> variables.
		*
		*@param interpolate If the update to a target pan-or tiltAngle is interpolated. Default is true.
		*
		*@see #tiltAngle
		*@see #panAngle
		*@see #steps
		*/
		__proto.update=function(interpolate){
			(interpolate===void 0)&& (interpolate=true);
			if (this._tiltAngle !=this._currentTiltAngle || this._panAngle !=this._currentPanAngle){
				this.notifyUpdate();
				if (this._wrapPanAngle){
					if (this._panAngle < 0){
						this._currentPanAngle+=this._panAngle%360+360-this._panAngle;
						this._panAngle=this._panAngle%360+360;
						}else {
						this._currentPanAngle+=this._panAngle%360-this._panAngle;
						this._panAngle=this._panAngle%360;
					}
					while (this._panAngle-this._currentPanAngle <-180)
					this._currentPanAngle-=360;
					while (this._panAngle-this._currentPanAngle > 180)
					this._currentPanAngle+=360;
				}
				if (interpolate){
					this._currentTiltAngle+=(this._tiltAngle-this._currentTiltAngle)/(this.steps+1);
					this._currentPanAngle+=(this._panAngle-this._currentPanAngle)/(this.steps+1);
					}else {
					this._currentPanAngle=this._panAngle;
					this._currentTiltAngle=this._tiltAngle;
				}
				if ((Math.abs(this.tiltAngle-this._currentTiltAngle)< 0.01)&& (Math.abs(this._panAngle-this._currentPanAngle)< 0.01)){
					this._currentTiltAngle=this._tiltAngle;
					this._currentPanAngle=this._panAngle;
				}
			}
			if(!this._targetObject)return;
			if (this._lookAtPosition){
				this._$2__pos.x=this._lookAtPosition.x;
				this._$2__pos.y=this._lookAtPosition.y;
				this._$2__pos.z=this._lookAtPosition.z;
				}else if (this._lookAtObject){
				this._$2__pos=this._lookAtObject.transform.getPosition(false,this._$2__pos);
				if (this._targetObject.parent){
					Matrix3DUtils.transformVector(this._targetObject.parent.transform.invWorld,this._$2__pos,this._$2__pos);
				}
				}else{
				this._$2__pos.x=this._origin.x;
				this._$2__pos.y=this._origin.y;
				this._$2__pos.z=this._origin.z;
			}
			this._sVector3D.x=this._$2__pos.x+this._distance*Math.sin(this._currentPanAngle*MathConsts.DEGREES_TO_RADIANS)*Math.cos(this._currentTiltAngle*MathConsts.DEGREES_TO_RADIANS);
			this._sVector3D.z=this._$2__pos.z+this._distance*Math.cos(this._currentPanAngle*MathConsts.DEGREES_TO_RADIANS)*Math.cos(this._currentTiltAngle*MathConsts.DEGREES_TO_RADIANS);
			this._sVector3D.y=this._$2__pos.y+this._distance*Math.sin(this._currentTiltAngle*MathConsts.DEGREES_TO_RADIANS)*this._yFactor;
			this._targetObject.transform.setPosition(this._sVector3D.x,this._sVector3D.y,this._sVector3D.z);
			_super.prototype.update.call(this);
		}

		/**
		*Fractional step taken each time the <code>hover()</code> method is called. Defaults to 8.
		*
		*Affects the speed at which the <code>tiltAngle</code> and <code>panAngle</code> resolve to their targets.
		*
		*@see #tiltAngle
		*@see #panAngle
		*/
		__getset(0,__proto,'steps',function(){
			return this._steps;
			},function(val){
			val=(val < 1)? 1 :val;
			if (this._steps==val)
				return;
			this._steps=val;
			this.notifyUpdate();
		});

		/**
		*Rotation of the camera in degrees around the y axis. Defaults to 0.
		*/
		__getset(0,__proto,'panAngle',function(){
			return this._panAngle;
			},function(val){
			val=Math.max(this._minPanAngle,Math.min(this._maxPanAngle,val));
			if (this._panAngle==val)
				return;
			this._panAngle=val;
			this.notifyUpdate();
		});

		/**
		*Maximum bounds for the <code>tiltAngle</code>. Defaults to 90.
		*
		*@see #tiltAngle
		*/
		__getset(0,__proto,'maxTiltAngle',function(){
			return this._maxTiltAngle;
			},function(val){
			if (this._maxTiltAngle==val)
				return;
			this._maxTiltAngle=val;
			this.tiltAngle=Math.max(this._minTiltAngle,Math.min(this._maxTiltAngle,this._tiltAngle));
		});

		/**
		*Elevation angle of the camera in degrees. Defaults to 90.
		*/
		__getset(0,__proto,'tiltAngle',function(){
			return this._tiltAngle;
			},function(val){
			val=Math.max(this._minTiltAngle,Math.min(this._maxTiltAngle,val));
			if (this._tiltAngle==val)
				return;
			this._tiltAngle=val;
			this.notifyUpdate();
		});

		/**
		*Distance between the camera and the specified target. Defaults to 1000.
		*/
		__getset(0,__proto,'distance',function(){
			return this._distance;
			},function(val){
			if (this._distance==val)
				return;
			this._distance=val;
			this.notifyUpdate();
		});

		/**
		*Fractional difference in distance between the horizontal camera orientation and vertical camera orientation. Defaults to 2.
		*
		*@see #distance
		*/
		__getset(0,__proto,'yFactor',function(){
			return this._yFactor;
			},function(val){
			if (this._yFactor==val)
				return;
			this._yFactor=val;
			this.notifyUpdate();
		});

		/**
		*Minimum bounds for the <code>panAngle</code>. Defaults to-Infinity.
		*
		*@see #panAngle
		*/
		__getset(0,__proto,'minPanAngle',function(){
			return this._minPanAngle;
			},function(val){
			if (this._minPanAngle==val)
				return;
			this._minPanAngle=val;
			this.panAngle=Math.max(this._minPanAngle,Math.min(this._maxPanAngle,this._panAngle));
		});

		/**
		*Minimum bounds for the <code>tiltAngle</code>. Defaults to-90.
		*
		*@see #tiltAngle
		*/
		__getset(0,__proto,'minTiltAngle',function(){
			return this._minTiltAngle;
			},function(val){
			if (this._minTiltAngle==val)
				return;
			this._minTiltAngle=val;
			this.tiltAngle=Math.max(this._minTiltAngle,Math.min(this._maxTiltAngle,this._tiltAngle));
		});

		/**
		*Maximum bounds for the <code>panAngle</code>. Defaults to Infinity.
		*
		*@see #panAngle
		*/
		__getset(0,__proto,'maxPanAngle',function(){
			return this._maxPanAngle;
			},function(val){
			if (this._maxPanAngle==val)
				return;
			this._maxPanAngle=val;
			this.panAngle=Math.max(this._minPanAngle,Math.min(this._maxPanAngle,this._panAngle));
		});

		/**
		*Defines whether the value of the pan angle wraps when over 360 degrees or under 0 degrees. Defaults to false.
		*/
		__getset(0,__proto,'wrapPanAngle',function(){
			return this._wrapPanAngle;
			},function(val){
			if (this._wrapPanAngle==val)
				return;
			this._wrapPanAngle=val;
			this.notifyUpdate();
		});

		return HoverController;
	})(LookAtController)


	;
	//class specter3d.engine.core.Entity3D extends specter3d.engine.core.Object3D
	var Entity3D=(function(_super){
		function Entity3D(){
			this._bound=null;
			this._boundDirty=true;
			this._pickEnabled=false;
			this._pickVO=null;
			this._pickType=PickerType.BOUND;
			Entity3D.__super.call(this);
		}

		__class(Entity3D,'specter3d.engine.core.Entity3D',_super);
		var __proto=Entity3D.prototype;
		__proto.updateBounds=function(){
			this._boundDirty=false;
		}

		__getset(0,__proto,'pickEnabled',function(){
			return this._pickEnabled;
			},function(value){
			this._pickEnabled=value;
		});

		__getset(0,__proto,'pickVO',function(){
			if (!this._pickVO)
				this._pickVO=new PickerVO(this);
			return this._pickVO;
			},function(value){
			this._pickVO=value;
		});

		__getset(0,__proto,'pickType',function(){
			return this._pickType;
			},function(value){
			this._pickType=value;
		});

		__getset(0,__proto,'bound',function(){
			if (this._boundDirty)
				this.updateBounds();
			return this._bound;
			},function(value){
			if (this._bound !=value)
				this._bound=value;
		});

		return Entity3D;
	})(Object3D)


	;
	/**
	*灯光基类
	*@author wangcx
	*
	*/
	//class specter3d.engine.lights.LightBase extends specter3d.engine.core.Object3D
	var LightBase=(function(_super){
		function LightBase(_type){
			this._ambientColor=0xffffff;
			this._ambientRGB=null;
			this._castsShadows=false;
			this._color=0xffffff;
			this._diffuseRGB=null;
			this._specularRGBS=null;
			this._ambient=1;
			this._diffuse=1;
			this._lightType=0;
			this._specular=1;
			this._colorRGB
			/*namespace*/;
			LightBase.__super.call(this);
			this._lightType=_type;
			this._colorRGB=new Vector3D(1,1,1);
			this._diffuseRGB=new Vector3D(1,1,1);
			this._ambientRGB=new Vector3D(1,1,1);
			this._specularRGBS=new Vector3D(1,1,1,10);
		}

		__class(LightBase,'specter3d.engine.lights.LightBase',_super);
		var __proto=LightBase.prototype;
		__proto.addChild=function(child){
			throw new AbstractMethodError();
		}

		__proto.addChildAt=function(child,index){
			throw new AbstractMethodError();
		}

		__proto.contains=function(child){
			throw new AbstractMethodError();
		}

		__proto.getChildAt=function(index){
			throw new AbstractMethodError();
		}

		__proto.getChildByName=function(name){
			throw new AbstractMethodError();
		}

		__proto.getChildIndex=function(child){
			throw new AbstractMethodError();
		}

		__proto.removeChild=function(child){
			throw new AbstractMethodError();
		}

		__proto.removeChildAt=function(index){
			throw new AbstractMethodError();
		}

		__proto.removeChildren=function(beginIndex,endIndex){
			(beginIndex===void 0)&& (beginIndex=0);
			(endIndex===void 0)&& (endIndex=2147483647);
			throw new AbstractMethodError();
		}

		__proto.collectRender=function(camera,_context3d,_renderUnits){
			var _drawUnit=new DrawUnit(0);
			_renderUnits.push(_drawUnit);
		}

		__proto.updateAmbient=function(){
			this._ambientRGB.x=((this._ambientColor >> 16)& 0xff)/ 0xff *this._ambient;
			this._ambientRGB.y=((this._ambientColor >> 8)& 0xff)/ 0xff *this._ambient;
			this._ambientRGB.z=(this._ambientColor & 0xff)/ 0xff *this._ambient;
		}

		__proto.updateDiffuse=function(){
			this._diffuseRGB.x=this._colorRGB.x *this._diffuse;
			this._diffuseRGB.y=this._colorRGB.y *this._diffuse;
			this._diffuseRGB.z=this._colorRGB.z *this._diffuse;
		}

		__proto.updateSpecular=function(){
			this._specularRGBS.x=this._colorRGB.x *this._specular;
			this._specularRGBS.y=this._colorRGB.y *this._specular;
			this._specularRGBS.z=this._colorRGB.z *this._specular;
		}

		__getset(0,__proto,'ambient',function(){
			return this._ambient;
			},function(value){
			this._ambient=value < 0 ? 0 :value > 1 ? 1 :value;
			this.updateAmbient();
		});

		__getset(0,__proto,'ambientColor',function(){
			return this._ambientColor;
			},function(value){
			this._ambientColor=value;
			this.updateAmbient();
		});

		__getset(0,__proto,'specularShininess',function(){
			return this._specularRGBS.w;
			},function(value){
			value=value < 0 ? 0.1 :value;
			this._specularRGBS.w=value *100;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
			},function(value){
			this._color=value;
			this._colorRGB.x=((this._color >> 16)& 0xff)/ 0xff;
			this._colorRGB.y=((this._color >> 8)& 0xff)/ 0xff;
			this._colorRGB.z=(this._color & 0xff)/ 0xff;
			this.updateDiffuse();
			this.updateSpecular();
		});

		__getset(0,__proto,'numChildren',function(){
			throw new AbstractMethodError();
		});

		__getset(0,__proto,'diffuse',function(){
			return this._diffuse;
			},function(value){
			this._diffuse=value < 0 ? 0 :value;
			this.updateDiffuse();
		});

		__getset(0,__proto,'lightType',function(){
			return this._lightType;
		});

		__getset(0,__proto,'specular',function(){
			return this._specular;
			},function(value){
			this._specular=value < 0 ? 0 :value;
			this.updateSpecular();
		});

		LightBase.__init$=function(){
			/*namespace*/;
			/*namespace*/;
			/*namespace*/;
			/*namespace*/;
			/*namespace*/;
			/*namespace*/;
		}

		return LightBase;
	})(Object3D)


	/**
	*支持多维材质的 3ds解析器
	*@author wangcx
	*
	*/
	//class specter3d.engine.loaders.parsers.C3DSParser extends specter3d.engine.loaders.parsers.ParserBase
	var C3DSParser=(function(_super){
		function C3DSParser(){
			this.tempName=null;
			this._byteData=null;
			this._cur_mat=null;
			this._cur_mat_end=0;
			this._cur_obj=null;
			this._cur_obj_end=0;
			this._firstTex=null;
			this._materials=null;
			this._unfinalized_objects=null;
			this.flag=true;
			C3DSParser.__super.call(this,"binary");
		}

		__class(C3DSParser,'specter3d.engine.loaders.parsers.C3DSParser',_super);
		var __proto=C3DSParser.prototype;
		__proto.proceedParsing=function(){
			if (!this._byteData){
				this._byteData=this.getByteData();
				this._byteData.pos=0;
				this._byteData.endian="littleEndian";
				this._materials={};
				this._unfinalized_objects={};
			}
			if (this._cur_mat && this._byteData.pos >=this._cur_mat_end){
				this.finalizeCurrentMaterial();
			}
			else if (this._cur_obj && this._byteData.pos >=this._cur_obj_end){
				this._unfinalized_objects[this._cur_obj.name]=this._cur_obj;
				this._cur_obj_end=4294967295;
				this._cur_obj=null;
			}
			while (this.flag){
				if (this._byteData.bytesAvailable){
					var cid=0;
					var len=0;
					var end=0;
					cid=this._byteData.getUint16();
					len=this._byteData.getUint32();
					end=this._byteData.pos+(len-6);
					switch (cid){
						case 0x4D4D:
						case 0x3D3D:
						case 0xB000:
							break ;
						case 0x4000:
							this._cur_obj_end=end;
							this._cur_obj=new ObjectVO();
							this._cur_obj.name=this.readNulTermString();
							this._cur_obj.materials=[];
							this._cur_obj.materialFaces={};
							break ;
						case 0x4100:
							this._cur_obj.type='mesh';
							break ;
						case 0x4110:
							this.parseVertexList();
							break ;
						case 0x4120:
							this.parseFaceList();
							break ;
						case 0x4140:
							this.parseUVList();
							break ;
						case 0x4160:
							this._cur_obj.transform=this.readTransform();
							break ;
						case 0x4150:
							this.parseSmoothingGroups();
							break ;
						default :
							this._byteData.pos+=(len-6);
							break ;
						}
				}
				else{
					this.flag=false;
				}
			}
			if (this._byteData.bytesAvailable || this._cur_obj || this._cur_mat){
				return ParserBase.MORE_TO_PARSE;
			}
			else{
				var name;
				for (name in this._unfinalized_objects){
					var obj=this.constructObject(this._unfinalized_objects[name]);
					obj && this.finalizeAsset(obj);
				}
				return ParserBase.PARSING_DONE;
			}
		}

		// 分解多级材质
		__proto.applyMultiMaterial=function(vertices,faces,obj){
			var i=0;
			var j=0;
			var k=0;
			var l=0;
			var len=0;
			var numVerts=vertices.length;
			var numFaces=faces.length;
			var vMaterilas=new Array(numVerts);
			for (i=0;i < numVerts;i++)
			vMaterilas[i]=new Array;
			for (i=0;i < numFaces;i++){
				var face=(faces[i]);
				for (j=0;j < 3;j++){
					var materials=vMaterilas[(j==0)? face.a :((j==1)? face.b :face.c)];
					if (materials.indexOf(face.materialId)==-1)
						materials.push(face.materialId);
				}
			};
			var vClones=new Array(numVerts);
			for (i=0;i < numVerts;i++){
				var v0=vertices[i];
				v0.materialId=vMaterilas[i][0];
				if ((len=vMaterilas[i].length)<=1)
					continue ;
				var clones=new Array(len);
				vClones[i]=clones;
				clones[0]=i;
				for (j=1;j < len;j++){
					var v1=new VertexVO;
					v1.x=v0.x;
					v1.y=v0.y;
					v1.z=v0.z;
					v1.u=v0.u;
					v1.v=v0.v;
					v1.materialId=vMaterilas[i][j];
					clones[j]=vertices.length;
					vertices.push(v1);
				}
			}
			numVerts=vertices.length;
			for (i=0;i < numFaces;i++){
				face=(faces[i]);
				for (j=0;j < 3;j++){
					k=(j==0)? face.a :((j==1)? face.b :face.c);
					materials=vMaterilas[k];
					len=materials.length;
					clones=vClones[k];
					if (!clones)
						continue ;
					var ci=materials.indexOf(face.materialId);
					var index=clones[ci];
					if (j==0)
						face.a=index;
					else if (j==1)
					face.b=index;
					else
					face.c=index;
				}
			}
		}

		// 分解平滑组
		__proto.applySmoothGroups=function(vertices,faces){
			var i=0;
			var j=0;
			var k=0;
			var l=0;
			var len=0;
			var numVerts=vertices.length;
			var numFaces=faces.length;
			var vGroups=new Array(numVerts);
			for (i=0;i < numVerts;i++){
				vGroups[i]=new Array;
			}
			for (i=0;i < numFaces;i++){
				var face=(faces[i]);
				for (j=0;j < 3;j++){
					var groups=vGroups[(j==0)? face.a :((j==1)? face.b :face.c)];
					var group=face.smoothGroup;
					for (k=groups.length-1;k >=0;k--){
						if ((group & groups[k])> 0){
							group|=groups[k];
							groups.splice(k,1);
							k=groups.length-1;
						}
					}
					groups.push(group);
				}
			};
			var vClones=new Array(numVerts);
			for (i=0;i < numVerts;i++){
				if ((len=vGroups[i].length)< 1)
					continue ;
				var clones=new Array(len);
				vClones[i]=clones;
				clones[0]=i;
				var v0=vertices[i];
				for (j=1;j < len;j++){
					var v1=new VertexVO;
					v1.x=v0.x;
					v1.y=v0.y;
					v1.z=v0.z;
					v1.u=v0.u;
					v1.v=v0.v;
					clones[j]=vertices.length;
					vertices.push(v1);
				}
			}
			numVerts=vertices.length;
			for (i=0;i < numFaces;i++){
				face=(faces[i]);
				group=face.smoothGroup;
				for (j=0;j < 3;j++){
					k=(j==0)? face.a :((j==1)? face.b :face.c);
					groups=vGroups[k];
					len=groups.length;
					clones=vClones[k];
					for (l=0;l < len;l++){
						if (((group==0)&& (groups[l]==0))|| ((group & groups[l])> 0)){
							var index=clones[l];
							if (group==0){
								groups.splice(l,1);
								clones.splice(l,1);
							}
							if (j==0)
								face.a=index;
							else if (j==1)
							face.b=index;
							else
							face.c=index;
							l=len;
						}
					}
				}
			}
		}

		// 构建数据
		__proto.constructObject=function(obj){
			if (obj.type=='mesh'){
				var i=0;
				var subs;
				if (!obj.indices || obj.indices.length==0)
					return null;
				var vertices=new Array(obj.verts.length / 3);
				var faces=new Array(obj.indices.length / 3);
				this.prepareData(vertices,faces,obj);
				this.applySmoothGroups(vertices,faces);
				var geom=new Geometry3D();
				if (obj.materials.length > 1){
					this.applyMultiMaterial(vertices,faces,obj);
					var matLen=obj.materials.length;
					var vertsArray=new Array(matLen);
					var uvsArray=new Array(matLen);
					var indeicesArray=new Array(matLen);
					for (i=0;i < matLen;i++){
						vertsArray[i]=new Array;
						uvsArray[i]=new Array;
						indeicesArray[i]=new Array;
					};
					var correspond_table=new Dictionary;
					for (i=0;i < vertices.length;i++){
						var fi=0;
						var vertexVO=vertices[i];
						var matId=vertexVO.materialId;
						vertsArray[matId].push(vertexVO.x);
						vertsArray[matId].push(vertexVO.y);
						vertsArray[matId].push(vertexVO.z);
						uvsArray[matId].push(vertexVO.u);
						uvsArray[matId].push(vertexVO.v);
						var newIndex=vertsArray[matId].length / 3-1;
						correspond_table[i]=newIndex;
					}
					for (fi=0;fi < faces.length;fi++){
						faces[fi].a=correspond_table[faces[fi].a];
						faces[fi].b=correspond_table[faces[fi].b];
						faces[fi].c=correspond_table[faces[fi].c];
					}
					for (i=0;i < faces.length;i++){
						var face=faces[i];
						indeicesArray[face.materialId].push(face.a);
						indeicesArray[face.materialId].push(face.b);
						indeicesArray[face.materialId].push(face.c);
					}
					for (i=0;i < matLen;i++){
						if (vertsArray[i].length==0){
							continue ;
						}
						subs=GeomUtil.fromVectors(vertsArray[i],indeicesArray[i],uvsArray[i],null,null);
						geom.addSubGeometry(subs[0]);
					}
				}
				else{
					obj.verts=new Array(vertices.length *3);
					for (i=0;i < vertices.length;i++){
						var verVo=vertices[i];
						obj.verts[i *3]=verVo.x;
						obj.verts[i *3+1]=verVo.y;
						obj.verts[i *3+2]=verVo.z;
					}
					obj.indices=new Array(faces.length *3);
					for (i=0;i < faces.length;i++){
						obj.indices[i *3]=faces[i].a;
						obj.indices[i *3+1]=faces[i].b;
						obj.indices[i *3+2]=faces[i].c;
					}
					if (obj.uvs){
						obj.uvs=new Array(vertices.length *2);
						for (i=0;i < vertices.length;i++){
							var tverVo=vertices[i];
							obj.uvs[i *2]=tverVo.u;
							obj.uvs[i *2+1]=tverVo.v;
						}
					}
					subs=GeomUtil.fromVectors(obj.verts,obj.indices,obj.uvs,null,null);
					for (i=0;i < subs.length;i++){
						if(obj.uvs==null){
							subs[i].autoGenerateUVs=true;
						}
						geom.subGeometry.push(subs[i]);
					}
				}
			}
			return geom;
		}

		__proto.finalizeCurrentMaterial=function(){
			this._materials[this._cur_mat.name]=this._cur_mat;
			this._cur_mat=null;
		}

		/**
		*解析面
		*
		*/
		__proto.parseFaceList=function(){
			var i=0;
			var len=0;
			var count=0;
			count=this._byteData.getUint16();
			this._cur_obj.indices=new Array(count *3);
			i=0;
			len=this._cur_obj.indices.length;
			while (i < len){
				var i0=0,i1=0,i2=0;
				i0=this._byteData.getUint16();
				i1=this._byteData.getUint16();
				i2=this._byteData.getUint16();
				this._cur_obj.indices[i++]=i0;
				this._cur_obj.indices[i++]=i2;
				this._cur_obj.indices[i++]=i1;
				this._byteData.pos+=2;
			}
			this._cur_obj.smoothingGroups=new Array(count);
		}

		__proto.parseSmoothingGroups=function(){
			var len=this._cur_obj.indices.length / 3;
			var i=0;
			while (i < len){
				this._cur_obj.smoothingGroups[i]=this._byteData.getUint32();
				i++;
			}
		}

		// 贴图
		__proto.parseTexture=function(end){
			var tex;
			tex=new TextureVO();
			while (this._byteData.pos < end){
				var cid=0;
				var len=0;
				cid=this._byteData.getUint16();
				len=this._byteData.getUint32();
				switch (cid){
					case 0xA300:
						tex.url=this.readNulTermString();
						break ;
					default :
						this._byteData.pos+=(len-6);
						break ;
					}
			}
			!this._firstTex && (this._firstTex=tex);
			return tex;
		}

		/**
		*解析UV信息
		*
		*/
		__proto.parseUVList=function(){
			var i=0;
			var len=0;
			var count=0;
			count=this._byteData.getUint16();
			this._cur_obj.uvs=new Array(count *2);
			i=0;
			len=this._cur_obj.uvs.length;
			while (i < len){
				this._cur_obj.uvs[i++]=this._byteData.getFloat32();
				this._cur_obj.uvs[i++]=1.0-this._byteData.getFloat32();
			}
		}

		/**
		*解析顶点数据
		*
		*/
		__proto.parseVertexList=function(){
			var i=0;
			var len=0;
			var count=0;
			count=this._byteData.getUint16();
			this._cur_obj.verts=new Array(count *3);
			i=0;
			len=this._cur_obj.verts.length;
			while (i < len){
				var x=NaN,y=NaN,z=NaN;
				x=this._byteData.getFloat32();
				y=this._byteData.getFloat32();
				z=this._byteData.getFloat32();
				this._cur_obj.verts[i++]=x;
				this._cur_obj.verts[i++]=z;
				this._cur_obj.verts[i++]=y;
			}
		}

		// 写入顶点和面数据
		__proto.prepareData=function(vertices,faces,obj){
			var i=0;
			var j=0;
			var k=0;
			var len=obj.verts.length;
			for (i=0,j=0,k=0;i < len;){
				var v=new VertexVO;
				v.x=obj.verts[i++];
				v.y=obj.verts[i++];
				v.z=obj.verts[i++];
				if (obj.uvs){
					v.u=obj.uvs[j++];
					v.v=obj.uvs[j++];
				}
				vertices[k++]=v;
			}
			len=obj.indices.length;
			for (i=0,k=0;i < len;){
				var f=new FaceVO();
				f.a=obj.indices[i++];
				f.b=obj.indices[i++];
				f.c=obj.indices[i++];
				f.smoothGroup=obj.smoothingGroups[k];
				for (var mi=0;mi < obj.materials.length;mi++){
					var facelist=obj.materialFaces[obj.materials[mi]];
					if (facelist.indexOf(k)>=0)
						f.materialId=mi;
				}
				faces[k++]=f;
			}
		}

		__proto.readColor=function(){
			var cid=0;
			var len=0;
			var r=0,g=0,b=0;
			cid=this._byteData.getUint16();
			len=this._byteData.getUint32();
			switch (cid){
				case 0x0010:
					r=this._byteData.getFloat32()*255;
					g=this._byteData.getFloat32()*255;
					b=this._byteData.getFloat32()*255;
					break ;
				case 0x0011:
					r=this._byteData.readByte();
					g=this._byteData.readByte();
					b=this._byteData.readByte();
					break ;
				default :
					this._byteData.pos+=(len-6);
					break ;
				}
			return (r << 16)| (g << 8)| b;
		}

		__proto.readNulTermString=function(){
			var chr=0;
			var str=new String();
			while ((chr=this._byteData.readByte())> 0){
				str+=String.fromCharCode(chr);
			}
			return str;
		}

		/**
		*解析位置
		*@return
		*
		*/
		__proto.readTransform=function(){
			var data=new Float32Array(16);
			data[0]=this._byteData.getFloat32();
			data[2]=this._byteData.getFloat32();
			data[1]=this._byteData.getFloat32();
			data[3]=0;
			data[8]=this._byteData.getFloat32();
			data[10]=this._byteData.getFloat32();
			data[9]=this._byteData.getFloat32();
			data[11]=0;
			data[4]=this._byteData.getFloat32();
			data[6]=this._byteData.getFloat32();
			data[5]=this._byteData.getFloat32();
			data[7]=0;
			data[12]=this._byteData.getFloat32();
			data[14]=this._byteData.getFloat32();
			data[13]=this._byteData.getFloat32();
			data[15]=1;
			return data;
		}

		return C3DSParser;
	})(ParserBase)


	/**
	*MD5MeshParser provides a parser for the md5mesh data type,providing the geometry of the md5 format.
	*
	*todo:optimize
	*/
	//class specter3d.engine.loaders.parsers.MD5MeshParser extends specter3d.engine.loaders.parsers.ParserBase
	var MD5MeshParser=(function(_super){
		var VertexData,JointData,MeshData;
		function MD5MeshParser(additionalRotationAxis,additionalRotationRadians){
			this._textData=null;
			this._startedParsing=false;
			this._parseIndex=0;
			this._reachedEOF=false;
			this._line=0;
			this._charLineIndex=0;
			this._version=0;
			this._numJoints=0;
			this._numMeshes=0;
			this._mesh=null;
			this._shaders=null;
			this._meshData=null;
			this._bindPoses=null;
			this._geometry=null;
			this._skeleton=null;
			this._rotationQuat=null;
			(additionalRotationRadians===void 0)&& (additionalRotationRadians=0);
			MD5MeshParser.__super.call(this,"plainText");
			this._rotationQuat=new Quaternion();
			this._rotationQuat.fromAxisAngle(Vector3D.X_AXIS,-Math.PI*.5);
			if (additionalRotationAxis){
				var quat=new Quaternion();
				quat.fromAxisAngle(additionalRotationAxis,additionalRotationRadians);
				this._rotationQuat.multiply(this._rotationQuat,quat);
			}
		}

		__class(MD5MeshParser,'specter3d.engine.loaders.parsers.MD5MeshParser',_super);
		var __proto=MD5MeshParser.prototype;
		/**
		*@inheritDoc
		*/
		__proto.proceedParsing=function(){
			var token;
			if (!this._startedParsing){
				this._textData=this.getTextData();
				this._startedParsing=true;
			}
			token=this.getNextToken();
			switch (token){
				case "//":
					this.ignoreLine();
					break ;
				case "MD5Version":
					this._version=this.getNextInt();
					if (this._version !=10)
						throw new Error("Unknown version number encountered!");
					break ;
				case "commandline":
					this.parseCMD();
					break ;
				case "numJoints":
					this._numJoints=this.getNextInt();
					this._bindPoses=new Array(this._numJoints);
					break ;
				case "numMeshes":
					this._numMeshes=this.getNextInt();
					break ;
				case "joints":
					this.parseJoints();
					break ;
				case "mesh":
					this.parseMesh();
					break ;
				default :
					if (!this._reachedEOF)
						this.sendUnknownKeywordError();
				}
			if (this._reachedEOF){
				this.calculateMaxJointCount();
				this._mesh=new Mesh3D(new Geometry3D(),null);
				this._geometry=this._mesh.geometry;
				for (var i=0;i < this._meshData.length;++i)
				this._geometry.addSubGeometry(this.translateGeom(this._meshData[i].vertexData,this._meshData[i].weightData,this._meshData[i].indices,this._meshData[i].maxJointCount));
				this.finalizeAsset(this._geometry);
				return ParserBase.PARSING_DONE;
			}
			return ParserBase.MORE_TO_PARSE;
		}

		__proto.calculateMaxJointCount=function(){
			var numMeshData=this._meshData.length;
			for (var i=0;i < numMeshData;++i){
				var meshData=this._meshData[i];
				var vertexData=meshData.vertexData;
				var numVerts=vertexData.length;
				for (var j=0;j < numVerts;++j){
					var zeroWeights=this.countZeroWeightJoints(vertexData[j],meshData.weightData);
					var totalJoints=vertexData[j].countWeight-zeroWeights;
					if (totalJoints > meshData.maxJointCount)
						meshData.maxJointCount=totalJoints;
				}
			}
		}

		__proto.countZeroWeightJoints=function(vertex,weights){
			var start=vertex.startWeight;
			var end=vertex.startWeight+vertex.countWeight;
			var count=0;
			var weight=NaN;
			for (var i=start;i < end;++i){
				weight=weights[i].bias;
				if (weight==0)
					++count;
			}
			return count;
		}

		/**
		*Parses the skeleton's joints.
		*/
		__proto.parseJoints=function(){
			var ch;
			var joint;
			var pos;
			var quat;
			var i=0;
			var token=this.getNextToken();
			if (token !="{")
				this.sendUnknownKeywordError();
			this._skeleton=new Skeleton();
			do {
				if (this._reachedEOF)
					this.sendEOFError();
				joint=new SkeletonJoint();
				joint.name=this.parseLiteralString();
				joint.parentIndex=this.getNextInt();
				pos=this.parseVector3D();
				pos=this._rotationQuat.rotatePoint(pos);
				quat=this.parseQuaternion();
				this._bindPoses[i]=quat.toMatrix3D();
				this._bindPoses[i].appendTranslation(pos.x,pos.y,pos.z);
				var inv=this._bindPoses[i].clone();
				inv.invert();
				joint.inverseBindPose=inv.rawData;
				this._skeleton.joints[i++]=joint;
				ch=this.getNextChar();
				if (ch=="/"){
					this.putBack();
					ch=this.getNextToken();
					if (ch=="//")
						this.ignoreLine();
					ch=this.getNextChar();
				}
				if (ch !="}")
					this.putBack();
			}while (ch !="}");
		}

		/**
		*Puts back the last read character into the data stream.
		*/
		__proto.putBack=function(){
			this._parseIndex--;
			this._charLineIndex--;
			this._reachedEOF=this._parseIndex >=this._textData.length;
		}

		/**
		*Parses the mesh geometry.
		*/
		__proto.parseMesh=function(){
			var token=this.getNextToken();
			var ch;
			var vertexData;
			var weights;
			var indices;
			if (token !="{")
				this.sendUnknownKeywordError();this._shaders=this._shaders|| [];
			while (ch !="}"){
				ch=this.getNextToken();
				switch (ch){
					case "//":
						this.ignoreLine();
						break ;
					case "shader":
						this._shaders.push(this.parseLiteralString());
						break ;
					case "numverts":
						vertexData=new Array(this.getNextInt());
						break ;
					case "numtris":
						indices=new Array(this.getNextInt()*3);
						break ;
					case "numweights":
						weights=new Array(this.getNextInt());
						break ;
					case "vert":
						this.parseVertex(vertexData);
						break ;
					case "tri":
						this.parseTri(indices);
						break ;
					case "weight":
						this.parseJoint(weights);
						break ;
					}
			}this._meshData=this._meshData|| [];
			var i=this._meshData.length;
			this._meshData[i]=new MeshData();
			this._meshData[i].vertexData=vertexData;
			this._meshData[i].weightData=weights;
			this._meshData[i].indices=indices;
		}

		/**
		*Converts the mesh data to a SkinnedSub instance.
		*@param vertexData The mesh's vertices.
		*@param weights The joint weights per vertex.
		*@param indices The indices for the faces.
		*@return A SkinnedSubGeometry instance containing all geometrical data for the current mesh.
		*/
		__proto.translateGeom=function(vertexData,weights,indices,maxJointCount){
			var len=vertexData.length;
			var v1=0,v2=0,v3=0;
			var vertex;
			var weight;
			var bindPose;
			var pos;
			var subGeom;
			var uvs=new Array(len*2);
			var vertices=new Array(len*3);
			var jointIndices=new Array(len*maxJointCount);
			var jointWeights=new Array(len*maxJointCount);
			var l=0;
			var nonZeroWeights=0;
			for (var i=0;i < len;++i){
				vertex=vertexData[i];
				v1=vertex.index *3;
				v2=v1+1;
				v3=v1+2;
				vertices[v1]=vertices[v2]=vertices[v3]=0;
				nonZeroWeights=0;
				for (var j=0;j < vertex.countWeight;++j){
					weight=weights[vertex.startWeight+j];
					if (weight.bias > 0){
						bindPose=this._bindPoses[weight.joint];
						pos=bindPose.transformVector(weight.pos);
						vertices[v1]+=pos.x*weight.bias;
						vertices[v2]+=pos.y*weight.bias;
						vertices[v3]+=pos.z*weight.bias;
						jointIndices[l]=weight.joint*3;
						jointWeights[l++]=weight.bias;
						++nonZeroWeights;
					}
				}
				for (j=nonZeroWeights;j < maxJointCount;++j){
					jointIndices[l]=0;
					jointWeights[l++]=0;
				}
				v1=vertex.index << 1;
				uvs[v1++]=vertex.s;
				uvs[v1]=vertex.t;
			}
			subGeom=GeomUtil.constructSubGeometry(vertices,indices,uvs,null,null);
			subGeom.vertexData;
			return subGeom;
		}

		/**
		*Retrieve the next triplet of vertex indices that form a face.
		*@param indices The index list in which to store the read data.
		*/
		__proto.parseTri=function(indices){
			var index=this.getNextInt()*3;
			indices[index]=this.getNextInt();
			indices[index+1]=this.getNextInt();
			indices[index+2]=this.getNextInt();
		}

		/**
		*Reads a new joint data set for a single joint.
		*@param weights the target list to contain the weight data.
		*/
		__proto.parseJoint=function(weights){
			var weight=new JointData();
			weight.index=this.getNextInt();
			weight.joint=this.getNextInt();
			weight.bias=this.getNextNumber();
			weight.pos=this.parseVector3D();
			weights[weight.index]=weight;
		}

		/**
		*Reads the data for a single vertex.
		*@param vertexData The list to contain the vertex data.
		*/
		__proto.parseVertex=function(vertexData){
			var vertex=new VertexData();
			vertex.index=this.getNextInt();
			this.parseUV(vertex);
			vertex.startWeight=this.getNextInt();
			vertex.countWeight=this.getNextInt();
			vertexData[vertex.index]=vertex;
		}

		/**
		*Reads the next uv coordinate.
		*@param vertexData The vertexData to contain the UV coordinates.
		*/
		__proto.parseUV=function(vertexData){
			var ch=this.getNextToken();
			if (ch !="(")
				this.sendParseError("(");
			vertexData.s=this.getNextNumber();
			vertexData.t=this.getNextNumber();
			if (this.getNextToken()!=")")
				this.sendParseError(")");
		}

		/**
		*Gets the next token in the data stream.
		*/
		__proto.getNextToken=function(){
			var ch;
			var token="";
			while (!this._reachedEOF){
				ch=this.getNextChar();
				if (ch==" " || ch=="\r" || ch=="\n" || ch=="\t"){
					if (token !="//")
						this.skipWhiteSpace();
					if (token !="")
						return token;
				}else
				token+=ch;
				if (token=="//")
					return token;
			}
			return token;
		}

		/**
		*Skips all whitespace in the data stream.
		*/
		__proto.skipWhiteSpace=function(){
			var ch;
			do
			ch=this.getNextChar();
			while (ch=="\n" || ch==" " || ch=="\r" || ch=="\t");
			this.putBack();
		}

		/**
		*Skips to the next line.
		*/
		__proto.ignoreLine=function(){
			var ch;
			while (!this._reachedEOF && ch !="\n")
			ch=this.getNextChar();
		}

		/**
		*Retrieves the next single character in the data stream.
		*/
		__proto.getNextChar=function(){
			var ch=this._textData.charAt(this._parseIndex++);
			if (ch=="\n"){
				++this._line;
				this._charLineIndex=0;
			}else if (ch !="\r")
			++this._charLineIndex;
			if (this._parseIndex >=this._textData.length)
				this._reachedEOF=true;
			return ch;
		}

		/**
		*Retrieves the next integer in the data stream.
		*/
		__proto.getNextInt=function(){
			var i=parseInt(this.getNextToken());
			if (isNaN(i))
				this.sendParseError("int type");
			return i;
		}

		/**
		*Retrieves the next floating point number in the data stream.
		*/
		__proto.getNextNumber=function(){
			var f=parseFloat(this.getNextToken());
			if (isNaN(f))
				this.sendParseError("float type");
			return f;
		}

		/**
		*Retrieves the next 3d vector in the data stream.
		*/
		__proto.parseVector3D=function(){
			var vec=new Vector3D();
			var ch=this.getNextToken();
			if (ch !="(")
				this.sendParseError("(");
			vec.x=-this.getNextNumber();
			vec.y=this.getNextNumber();
			vec.z=this.getNextNumber();
			if (this.getNextToken()!=")")
				this.sendParseError(")");
			return vec;
		}

		/**
		*Retrieves the next quaternion in the data stream.
		*/
		__proto.parseQuaternion=function(){
			var quat=new Quaternion();
			var ch=this.getNextToken();
			if (ch !="(")
				this.sendParseError("(");
			quat.x=this.getNextNumber();
			quat.y=-this.getNextNumber();
			quat.z=-this.getNextNumber();
			var t=1-quat.x*quat.x-quat.y*quat.y-quat.z*quat.z;
			quat.w=t < 0? 0 :-Math.sqrt(t);
			if (this.getNextToken()!=")")
				this.sendParseError(")");
			var rotQuat=new Quaternion();
			rotQuat.multiply(this._rotationQuat,quat);
			return rotQuat;
		}

		/**
		*Parses the command line data.
		*/
		__proto.parseCMD=function(){
			this.parseLiteralString();
		}

		/**
		*Retrieves the next literal string in the data stream. A literal string is a sequence of characters bounded
		*by double quotes.
		*/
		__proto.parseLiteralString=function(){
			this.skipWhiteSpace();
			var ch=this.getNextChar();
			var str="";
			if (ch !="\"")
				this.sendParseError("\"");
			do {
				if (this._reachedEOF)
					this.sendEOFError();
				ch=this.getNextChar();
				if (ch !="\"")
					str+=ch;
			}while (ch !="\"");
			return str;
		}

		/**
		*Throws an end-of-file error when a premature end of file was encountered.
		*/
		__proto.sendEOFError=function(){
			throw new Error("Unexpected end of file");
		}

		/**
		*Throws an error when an unexpected token was encountered.
		*@param expected The token type that was actually expected.
		*/
		__proto.sendParseError=function(expected){
			throw new Error("Unexpected token at line "+(this._line+1)+", character "+this._charLineIndex+". "+expected+" expected, but "+this._textData.charAt(this._parseIndex-1)+" encountered");
		}

		/**
		*Throws an error when an unknown keyword was encountered.
		*/
		__proto.sendUnknownKeywordError=function(){
			throw new Error("Unknown keyword at line "+(this._line+1)+", character "+this._charLineIndex+". ");
		}

		MD5MeshParser.supportsType=function(extension){
			extension=extension.toLowerCase();
			return extension=="md5mesh";
		}

		MD5MeshParser.supportsData=function(data){
			data=data;
			return false;
		}

		MD5MeshParser.VERSION_TOKEN="MD5Version";
		MD5MeshParser.COMMAND_LINE_TOKEN="commandline";
		MD5MeshParser.NUM_JOINTS_TOKEN="numJoints";
		MD5MeshParser.NUM_MESHES_TOKEN="numMeshes";
		MD5MeshParser.COMMENT_TOKEN="//";
		MD5MeshParser.JOINTS_TOKEN="joints";
		MD5MeshParser.MESH_TOKEN="mesh";
		MD5MeshParser.MESH_SHADER_TOKEN="shader";
		MD5MeshParser.MESH_NUM_VERTS_TOKEN="numverts";
		MD5MeshParser.MESH_VERT_TOKEN="vert";
		MD5MeshParser.MESH_NUM_TRIS_TOKEN="numtris";
		MD5MeshParser.MESH_TRI_TOKEN="tri";
		MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN="numweights";
		MD5MeshParser.MESH_WEIGHT_TOKEN="weight";
		MD5MeshParser.__init$=function(){
			//class VertexData
			VertexData=(function(){
				function VertexData(){
					this.index=0;
					this.s=NaN;
					this.t=NaN;
					this.startWeight=0;
					this.countWeight=0;
				}
				__class(VertexData,'');
				return VertexData;
			})()
			//class JointData
			JointData=(function(){
				function JointData(){
					this.index=0;
					this.joint=0;
					this.bias=NaN;
					this.pos=null;
				}
				__class(JointData,'');
				return JointData;
			})()
			//class MeshData
			MeshData=(function(){
				function MeshData(){
					this.vertexData=null;
					this.weightData=null;
					this.indices=null;
					this.maxJointCount=0;
				}
				__class(MeshData,'');
				return MeshData;
			})()
		}

		return MD5MeshParser;
	})(ParserBase)


	//class specter3d.engine.loaders.QueueFileLoader extends specter3d.engine.loaders.FileLoader
	var QueueFileLoader=(function(_super){
		function QueueFileLoader(){
			this._byteAll=0;
			this._byteNow=0;
			this._loaderArr=[];
			this._nowPer=0;
			this._timerRunning=false;
			this._updataProgress=null;
			this.currentResourceVo=null;
			this.loading=false;
			this.token=0;
			QueueFileLoader.__super.call(this);
			this.existQueueHashMap=new HashMap();
			this.resourceHashMap=new HashMap();
			this.resourceVoArr=[];
		}

		__class(QueueFileLoader,'specter3d.engine.loaders.QueueFileLoader',_super);
		var __proto=QueueFileLoader.prototype;
		/**
		*加载单个资源
		*@param resourceVo
		*@param callbackHandler,资源加载完回调函数
		*用法实例：
		*AppGlobalContext.QueueLoader.loadOne(new ResourceVo("aaaa",1),test1);
		*加载完成之后从AssetLib这里面获取资源,例子:获取图片 var data:ImageObject=AssetLib.getData(url)as ImageObject;
		*/
		__proto.loadOne=function(resourceVo,callbackHandler,group){
			(group===void 0)&& (group="default_group");
			if (resourceVo.url==AssetLib.relativePath){
				Debug.error("engine","加载空目录.");
				return;
			}
			this._nowPer=0;
			this._byteAll=0;
			this._byteNow=0;
			var num=0;
			resourceVo.group=group;
			if (this.operationResourceVo(resourceVo)){
				num=num+1;
			}
			this.startLoader(num,callbackHandler);
		}

		/**
		*加载一组资源
		*@param arr ResourceVo 数组
		*@param callbackHandler,资源加载完回调函数
		*用法实例：
		*var arr:Vector.<ResourceVo>=new Vector.<ResourceVo>();
		arr.push(new ResourceVo("aaaa",1,test));//单个资源加载完完成
		arr.push(new ResourceVo("aaaa",2,test));//单个资源加载完完成
		arr.push(new ResourceVo("aaaa",3,test));//单个资源加载完完成
		AppGlobalContext.QueueLoader.loads(arr,test1);//该组所有资源加载完成
		加载完成之后从AssetLib这里面获取资源,例子:获取图片 var data:ImageObject=AssetLib.getData(url)as ImageObject;
		*/
		__proto.loads=function(arr,callbackHandler,group){
			(group===void 0)&& (group="default_group");
			this._nowPer=0;
			this._byteAll=0;
			this._byteNow=0;
			var num=0;
			while (arr.length > 0){
				var resourceVo=arr.pop();
				resourceVo.group=group;
				if (this.operationResourceVo(resourceVo)){
					num=num+1;
				}
			}
			this.startLoader(num,callbackHandler);
		}

		/**
		*处理resourceVo
		*@param resourceVo
		*@return
		*
		*/
		__proto.operationResourceVo=function(resourceVo){
			resourceVo.token="token"+this.token;
			if (QueueFileLoader._invalidURLMap.get(resourceVo.url)){
				if (resourceVo.errorCallBackHandler !=null){
					resourceVo.errorCallBackHandler.runWith(resourceVo.url);
				}
				return false;
			}
			if (resourceVo.url==AssetLib.relativePath){
				return false;
			}
			if (!this.checkResourceExist(resourceVo)){
				Debug.dotrace("engine","加载资源"+resourceVo.url);
				if (!this.checkExistQueueExist(resourceVo)){
					this.resourceVoArr.push(resourceVo);
					return true;
				}
				else{
					if (this.existQueueHashMap.getValue(resourceVo.url)==null){
						this.existQueueHashMap.put(resourceVo.url,[]);
					}
					(this.existQueueHashMap.getValue(resourceVo.url)).push(["token"+this.token,resourceVo.callBackHandler,resourceVo.url]);
					return true;
				}
			}
			else{
				if (resourceVo.callBackHandler !=null){
					resourceVo.callBackHandler.runWith(resourceVo.url);
				}
			}
			return false;
		}

		/**
		*开始加载
		*@param num
		*@param callbackHandler
		*
		*/
		__proto.startLoader=function(num,callbackHandler){
			if (num==0){
				callbackHandler && callbackHandler.run();
			}
			else{
				this.resourceHashMap.put("token"+this.token,[num,callbackHandler]);
				this.resourceVoArr.sort(this.resourceVoCompare);
			}
			this.token=this.token+1;
			this.execute();
			if (this.resourceVoArr.length && !this._timerRunning){
				AppGlobalContext.timer.loop(10,this,this._updatePer);
				this._timerRunning=true;
			}
		}

		__proto.clean=function(){
			while (this.resourceVoArr.length){
				var vo=this.resourceVoArr.pop();
				vo.callBackHandler=null;
			}
			this.resourceVoArr.length=0;
		}

		__proto.nextLoad=function(failure){
			(failure===void 0)&& (failure=false);
			_super.prototype.nextLoad.call(this,failure);
			this.loadComplete(failure);
			this.loading=false;
			this.execute();
		}

		/**
		*加载失败
		*@param event
		*
		*/
		__proto.onFileLoaderError=function(event){
			_super.prototype.onFileLoaderError.call(this,event);
			this.currentResourceVo.loadTime=this.currentResourceVo.loadTime+1;
			if (this.currentResourceVo.loadTime > 1){
				QueueFileLoader._invalidURLMap.set(this.currentResourceVo.url,this.currentResourceVo.url);
				this.loadComplete(true);
			}
			else{
				this.resourceVoArr.splice(0,0,this.currentResourceVo);
			}
			this.loading=false;
			this.execute();
		}

		/**
		*加载完成
		*@param event
		*
		*/
		__proto.onFileLoaderOver=function(event){
			_super.prototype.onFileLoaderOver.call(this,event);
			this.parseData((event.currentTarget).data);
		}

		__proto._updatePer=function(){
			var _tmpAll=0;
			var _tmpNow=0;
			var ld;
			for(var $each_ld in this._loaderArr){
				ld=this._loaderArr[$each_ld];
				_tmpAll+=(ld).bytesTotal;
				_tmpNow+=(ld).bytesLoaded;
			}
			this._byteAll=_tmpAll;
			this._byteNow=_tmpNow;
			this._nowPer=this.byteNow / this.byteAll *100;
			this._updataProgress && this._updataProgress.runWith([this._byteNow,this._byteAll,this._nowPer]);
		}

		/**
		*判断资源是否存在加载队列
		*@return
		*
		*/
		__proto.checkExistQueueExist=function(resourceVo){
			for (var i=0;i < this.resourceVoArr.length;i++){
				if (this.resourceVoArr[i].url==resourceVo.url){
					return true;
				}
			}
			return false;
		}

		/**
		*判断资源是否存在
		*@return
		*
		*/
		__proto.checkResourceExist=function(resourceVo){
			return AssetLib.hasAsset(resourceVo.url);
		}

		/**
		*执行加载
		*
		*/
		__proto.execute=function(){
			if (!this.loading){
				this.loading=true;
				this.currentResourceVo=this.resourceVoArr.pop();
				if (this.currentResourceVo){
					if (this.currentResourceVo.hasListener("start")){
						var event=new Event();
						event.type="start";
						this.currentResourceVo.dispatchEvent(event);
					}
					this._loaderArr.push(this.load(this.currentResourceVo.url,this.currentResourceVo.group));
				}
				else{
					this.loading=false;
					AppGlobalContext.timer.clear(this,this._updatePer);
					this._timerRunning=false;
					this._updataProgress=null;
					this._byteAll=0;
					this._byteNow=0;
					this._nowPer=0;
					this._loaderArr=[];
				}
			}
		}

		/**
		*加载结束
		*
		*/
		__proto.loadComplete=function(failure){
			(failure===void 0)&& (failure=false);
			var resourceInfoArr=this.resourceHashMap.getValue(this.currentResourceVo.token);
			resourceInfoArr[0]=resourceInfoArr[0]-1;
			QueueFileLoader._history.set(this.currentResourceVo.url,true);
			if (this.currentResourceVo.hasListener(failure ? "error" :"finish")){
				var event=new Event();
				event.type=failure ? "error" :"finish"
				this.currentResourceVo.dispatchEvent(event);
			}
			if(!failure){
				if (this.currentResourceVo.callBackHandler !=null){
					this.currentResourceVo.callBackHandler.runWith(this.currentResourceVo.url);
				}
			}
			else{
				if (this.currentResourceVo.errorCallBackHandler !=null){
					this.currentResourceVo.errorCallBackHandler.runWith(this.currentResourceVo.url);
				}
			}
			if (resourceInfoArr[0] <=0){
				if (resourceInfoArr [1]){
					(resourceInfoArr [1]).run();
				}
				this.resourceHashMap.remove(this.currentResourceVo.token);
			};
			var existTokenArr=this.existQueueHashMap.getValue(this.currentResourceVo.url);
			if (existTokenArr){
				for (var i=0;i < existTokenArr.length;i++){
					var existTokenArrItem=existTokenArr [i];
					var tokenTemp=existTokenArrItem[0].toString();
					resourceInfoArr=this.resourceHashMap.getValue(tokenTemp);
					resourceInfoArr[0]=resourceInfoArr[0]-1;
					if ((existTokenArrItem [1])!=null){
						(existTokenArrItem [1]).runWith(existTokenArrItem[2].toString());
					}
					if (resourceInfoArr[0] <=0){
						if (resourceInfoArr [1]){
							(resourceInfoArr [1]).run();
						}
						this.resourceHashMap.remove(tokenTemp);
					}
				}
				this.existQueueHashMap.remove(this.currentResourceVo.url);
			}
		}

		/**
		*resourceVoArr 比较器
		*@param a
		*@param b
		*@return
		*
		*/
		__proto.resourceVoCompare=function(a,b){
			if (a.level < b.level){
				return-1;
			}
			else if (a.level > b.level){
				return 1;
			}
			else{
				return 0;
			}
		}

		__proto.progressing=function(event){
			event.target.off(event.type,this.progressing);
			if (this.currentResourceVo && this.currentResourceVo.url==this.url)
				this.currentResourceVo.progressing(event);
		}

		/**
		*所有要下载的字节数
		*/
		__getset(0,__proto,'byteAll',function(){
			return this._byteAll;
		});

		/**
		*目前已下载的字节数
		*/
		__getset(0,__proto,'byteNow',function(){
			return this._byteNow;
		});

		/**
		*更新进度函数
		*/
		__getset(0,__proto,'updataProgress',null,function(value){
			this._updataProgress=value;
		});

		/**
		*总下载下载进度
		*/
		__getset(0,__proto,'nowPer',function(){
			return this._nowPer;
		});

		__getset(0,__proto,'waitLoadSize',function(){
			if (this.resourceVoArr){
				return this.resourceVoArr.length;
			}
			return 0;
		});

		QueueFileLoader.hasLoaded=function(url){
			return url && QueueFileLoader._history.get(url);
		}

		__static(QueueFileLoader,
		['_invalidURLMap',function(){return this._invalidURLMap=new Dictionary();},'_history',function(){return this._history=new Dictionary();}
		]);
		return QueueFileLoader;
	})(FileLoader)


	;
	/**
	*CompiledPass
	*@author wangcx
	*
	*/
	//class specter3d.engine.materials.passes.CompiledPass extends specter3d.engine.materials.passes.Material3DPass
	var CompiledPass=(function(_super){
		function CompiledPass(material){
			this._ambientColor=0xffffff;
			this._diffuseColor=0xffffff;
			this._lightPicker=null;
			this._specular=1;
			this._specularColor=0xffffff;
			CompiledPass.__super.call(this,material);
		}

		__class(CompiledPass,'specter3d.engine.materials.passes.CompiledPass',_super);
		var __proto=CompiledPass.prototype;
		__proto.getFragmentCode=function(_code){
			this._useUV && _code.useMacro("USE_UV");
			this._useNormal && _code.useMacro("USE_NORMAL");
			this._useTangent && _code.useMacro("USE_TANGENT");
			this._diffuseTexture && _code.useMacro("USE_DIFFUSE_MAP");
			this._normalMapTexture && _code.useMacro("USE_NORMAL_MAP");
			if (this._lightPicker){
				this._lightPicker.numDirectionalLights > 0 && _code.useMacro("USE_LIGHT_DIRECTION");
				this._lightPicker.numPointLights > 0 && _code.useMacro("USER_LIGHT_POINT");
			}
			_code.additional(ShaderCompiler.FRAGMENTS_PROGRAM);
			return _code;
		}

		__proto.getVertexCode=function(_code){
			this._useUV && _code.useMacro("USE_UV");
			this._useNormal && _code.useMacro("USE_NORMAL");
			this._useTangent && _code.useMacro("USE_TANGENT");
			if (this._lightPicker){
				this._lightPicker.numDirectionalLights > 0 && _code.useMacro("USE_LIGHT_DIRECTION");
				this._lightPicker.numPointLights > 0 && _code.useMacro("USER_LIGHT_POINT");
			}
			_code.additional(ShaderCompiler.VERTEX_PROGRAM);
			return _code;
		}

		__proto.render=function(_context3d,renderable,camera){
			_super.prototype.render.call(this,_context3d,renderable,camera);
			if (this._lightPicker && this._lightPicker.numLight > 0){
				var u_diffuseColor,u_direction,u_ambientColor,u_specularColor,u_specularShininess,u_position,u_range,u_attenuation;
				for (var i=0;i < this._lightPicker.numDirectionalLights;i++){
					u_direction=_context3d.getUniformLocation(this._program,"u_DirectionLight.direction");
					u_diffuseColor=_context3d.getUniformLocation(this._program,"u_DirectionLight.diffuseColor");
					u_ambientColor=_context3d.getUniformLocation(this._program,"u_DirectionLight.ambientColor");
					u_specularColor=_context3d.getUniformLocation(this._program,"u_DirectionLight.specularColor");
					u_specularShininess=_context3d.getUniformLocation(this._program,"u_DirectionLight.specularShininess");
					var _dlight=this._lightPicker.directionalLights[i];
					_context3d.uniform3fv(u_direction,_dlight.direction.elementsForVec3);
					_context3d.uniform3fv(u_diffuseColor,_dlight._diffuseRGB.elementsForVec3);
					_context3d.uniform3fv(u_ambientColor,_dlight._ambientRGB.elementsForVec3);
					_context3d.uniform3fv(u_specularColor,_dlight._specularRGBS.elementsForVec3);
					_context3d.uniform1f(u_specularShininess,_dlight.specularShininess);
				};
				var numPointLight=_context3d.getUniformLocation(this._program,"numPointLight");
				_context3d.uniform1i(numPointLight,this._lightPicker.numPointLights);
				for (var j=0;j < this._lightPicker.numPointLights;j++){
					u_position=_context3d.getUniformLocation(this._program,"u_PointLight["+j+"].position");
					u_diffuseColor=_context3d.getUniformLocation(this._program,"u_PointLight["+j+"].diffuseColor");
					u_ambientColor=_context3d.getUniformLocation(this._program,"u_PointLight["+j+"].ambientColor");
					u_specularColor=_context3d.getUniformLocation(this._program,"u_PointLight["+j+"].specularColor");
					u_specularShininess=_context3d.getUniformLocation(this._program,"u_PointLight["+j+"].specularShininess");
					u_range=_context3d.getUniformLocation(this._program,"u_PointLight["+j+"].range");
					u_attenuation=_context3d.getUniformLocation(this._program,"u_PointLight["+j+"].attenuation");
					var _plight=this._lightPicker.pointLights[j];
					var _position=_plight.transform.getPosition(false);
					_context3d.uniform3fv(u_position,_position.elementsForVec3);
					_context3d.uniform3fv(u_diffuseColor,_plight._diffuseRGB.elementsForVec3);
					_context3d.uniform3fv(u_ambientColor,_plight._ambientRGB.elementsForVec3);
					_context3d.uniform3fv(u_specularColor,_plight._specularRGBS.elementsForVec3);
					_context3d.uniform1f(u_specularShininess,_plight.specularShininess);
					_context3d.uniform1f(u_range,_plight.range);
					_context3d.uniform3fv(u_attenuation,_plight.attenuation.elementsForVec3);
				}
			}
		}

		__getset(0,__proto,'lightPicker',function(){
			return this._lightPicker;
			},function(value){
			this._lightPicker=value;
		});

		return CompiledPass;
	})(Material3DPass)


	;
	//class specter3d.engine.resources.TextureResource extends specter3d.engine.resources.ResourceBase
	var TextureResource=(function(_super){
		function TextureResource(name){
			this._height=0;
			this._width=0;
			this._glTexture=null;
			TextureResource.__super.call(this,name);
		}

		__class(TextureResource,'specter3d.engine.resources.TextureResource',_super);
		var __proto=TextureResource.prototype;
		/**
		*@inheritDoc
		*/
		__proto.dispose=function(){
			var _context3d=AppGlobalContext.stage3d.webglContext;
			if (this._glTexture !=null){
				_context3d.deleteTexture(this._glTexture);
				this._glTexture=null;
				_context3d=null;
			}
		}

		__getset(0,__proto,'height',function(){
			return this._height;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'isUploaded',function(){
			return this._glTexture !=null;
		});

		__getset(0,__proto,'width',function(){
			return this._width;
		});

		return TextureResource;
	})(ResourceBase)


	;
	/**
	*几何体
	*@author wangcx
	*
	*/
	//class specter3d.engine.resources.SubGeometry3D extends specter3d.engine.resources.ResourceBase
	var SubGeometry3D=(function(_super){
		function SubGeometry3D(){
			this.parentGeometry=null;
			this._autoDeriveVertexNormals=true;
			this._autoDeriveVertexTangents=true;
			this._autoGenerateUVs=false;
			this._faceNormals=null;
			this._faceNormalsDirty=true;
			this._faceTangents=null;
			this._faceTangentsDirty=true;
			this._faceWeights=null;
			this._indexBuffer=null;
			this._indices=null;
			this._invalidBuffer=false;
			this._isUploaded=false;
			this._numTriangles=0;
			this._numVertices=0;
			this._secondaryUvs=null;
			this._uvsDirty=true;
			this._vertexBuffer=null;
			this._vertexData=null;
			this._vertexDeclaration=null;
			this._vertexNormalsDirty=true;
			this._vertexTangentsDirty=true;
			this._attributes=null;
			this._useFaceWeights=false;
			SubGeometry3D.__super.call(this);
		}

		__class(SubGeometry3D,'specter3d.engine.resources.SubGeometry3D',_super);
		var __proto=SubGeometry3D.prototype;
		__proto.bindBuffer=function(){
			this._vertexBuffer.bindWithIndexBuffer(this._indexBuffer);
		}

		__proto.clone=function(){
			var _clone=new SubGeometry3D();
			_clone.indices=this._indices.concat();
			_clone.updateVertexAttribute(this._vertexData.concat(),this._attributes.concat());
			return _clone;
		}

		__proto.updateVertexAttribute=function(data,attributes){
			if (this.isDispose)
				return;
			this._attributes=attributes;
			var numAttribute=attributes ? attributes.length :0;
			if (numAttribute < 1){
				throw new Error("Must be at least one attribute ??to create the buffer.");
			};
			var _vertexStride=0;
			for (var i=0;i < numAttribute;i++){
				var format=attributes[i].elementFormat;
				switch (format){
					case "single":
						_vertexStride+=4;
						break ;
					case "vector2":
						_vertexStride+=2 *4;
						break ;
					case "vector3":
						_vertexStride+=3 *4;
						break ;
					case "vector4":
						_vertexStride+=4 *4;
						break ;
					}
			};
			var numVertices=(data.length / (_vertexStride / 4));
			if (numVertices !=this._numVertices){
				this._vertexDeclaration=new VertexDeclaration(_vertexStride,attributes);
				this._vertexData=data;
				this._numVertices=numVertices;
				this._invalidBuffer=true;
			}
		}

		__proto.upload=function(_context3d){
			if (this.isDispose)
				return;
			if (this._invalidBuffer){
				if (!this._indexBuffer){
					this._indexBuffer=IndexBuffer3D.create("ushort",this._indices.length,0x88E4);
				}
				if (!this._vertexBuffer){
					this._vertexBuffer=VertexBuffer3D.create(this._vertexDeclaration,this._numVertices,0x88E4);
				}
				this._vertexBuffer.setData(this._vertexData);
				this._indexBuffer.setData(this._indices);
				this._vertexBuffer.bindWithIndexBuffer(this._indexBuffer);
				this._invalidBuffer=false;
				this._isUploaded=true;
			}
		}

		__proto.updateDummyUVs=function(target){
			this._uvsDirty=false;
			var idx=0,uvIdx=0;
			var stride=13;
			var skip=stride-2;
			var len=this._vertexData.length / 13 *stride;
			if (!target)
				target=new Float32Array();
			target.fixed=false;
			target.length=len;
			target.fixed=true;
			idx=9;
			uvIdx=0;
			while (idx < len){
				target[idx++]=uvIdx *.5;
				target[idx++]=1.0-(uvIdx & 1);
				idx+=skip;
				if (++uvIdx==3)
					uvIdx=0;
			}
			return target;
		}

		__proto.updateFaceTangents=function(){
			var i=0;
			var index1=0,index2=0,index3=0;
			var len=this._indices.length;
			var ui=0,vi=0;
			var v0=NaN;
			var dv1=NaN,dv2=NaN;
			var denom=NaN;
			var x0=NaN,y0=NaN,z0=NaN;
			var dx1=NaN,dy1=NaN,dz1=NaN;
			var dx2=NaN,dy2=NaN,dz2=NaN;
			var cx=NaN,cy=NaN,cz=NaN;
			var vertices=this._vertexData;
			var uvs=this._vertexData;
			var posStride=13;
			var posOffset=0;
			var texStride=13;
			var texOffset=9;this._faceTangents=this._faceTangents||new Float32Array(this._indices.length);
			while (i < len){
				index1=this._indices[i];
				index2=this._indices[i+1];
				index3=this._indices[i+2];
				ui=texOffset+index1 *texStride+1;
				v0=uvs[ui];
				ui=texOffset+index2 *texStride+1;
				dv1=uvs[ui]-v0;
				ui=texOffset+index3 *texStride+1;
				dv2=uvs[ui]-v0;
				vi=posOffset+index1 *posStride;
				x0=vertices[vi];
				y0=vertices[vi+1];
				z0=vertices[vi+2];
				vi=posOffset+index2 *posStride;
				dx1=vertices[vi]-x0;
				dy1=vertices[vi+1]-y0;
				dz1=vertices[vi+2]-z0;
				vi=posOffset+index3 *posStride;
				dx2=vertices[vi]-x0;
				dy2=vertices[vi+1]-y0;
				dz2=vertices[vi+2]-z0;
				cx=dv2 *dx1-dv1 *dx2;
				cy=dv2 *dy1-dv1 *dy2;
				cz=dv2 *dz1-dv1 *dz2;
				var r=Math.sqrt(cx *cx+cy *cy+cz *cz);
				denom=r > 0 ? 1 / r :0;
				this._faceTangents[i++]=denom *cx;
				this._faceTangents[i++]=denom *cy;
				this._faceTangents[i++]=denom *cz;
			}
			this._faceTangentsDirty=false;
		}

		__proto.updateVertexNormals=function(target){
			if (this._faceNormalsDirty)
				this.updateFaceNormals();
			var v1=0;
			var f1=0,f2=1,f3=2;
			var lenV=this._vertexData.length;
			var normalStride=13;
			var normalOffset=3;target=target||new Float32Array(lenV);
			v1=normalOffset;
			while (v1 < lenV){
				target[v1]=0.0;
				target[v1+1]=0.0;
				target[v1+2]=0.0;
				v1+=normalStride;
			};
			var i=0,k=0;
			var lenI=this._indices.length;
			var index=0;
			var weight=0;
			while (i < lenI){
				weight=this._useFaceWeights ? this._faceWeights[k++] :1;
				index=normalOffset+this._indices[i++] *normalStride;
				target[index++]+=this._faceNormals[f1] *weight;
				target[index++]+=this._faceNormals[f2] *weight;
				target[index]+=this._faceNormals[f3] *weight;
				index=normalOffset+this._indices[i++] *normalStride;
				target[index++]+=this._faceNormals[f1] *weight;
				target[index++]+=this._faceNormals[f2] *weight;
				target[index]+=this._faceNormals[f3] *weight;
				index=normalOffset+this._indices[i++] *normalStride;
				target[index++]+=this._faceNormals[f1] *weight;
				target[index++]+=this._faceNormals[f2] *weight;
				target[index]+=this._faceNormals[f3] *weight;
				f1+=3;
				f2+=3;
				f3+=3;
			}
			v1=normalOffset;
			while (v1 < lenV){
				var vx=target[v1];
				var vy=target[v1+1];
				var vz=target[v1+2];
				var d=1.0 / Math.sqrt(vx *vx+vy *vy+vz *vz);
				target[v1]=vx *d;
				target[v1+1]=vy *d;
				target[v1+2]=vz *d;
				v1+=normalStride;
			}
			this._vertexNormalsDirty=false;
			return target;
		}

		__proto.updateVertexTangents=function(target){
			if (this._faceTangentsDirty)
				this.updateFaceTangents();
			var i=0;
			var lenV=this._vertexData.length;
			var tangentStride=13;
			var tangentOffset=6;target=target||new Float32Array(lenV);
			i=tangentOffset;
			while (i < lenV){
				target[i]=0.0;
				target[i+1]=0.0;
				target[i+2]=0.0;
				i+=tangentStride;
			};
			var k=0;
			var lenI=this._indices.length;
			var index=0;
			var weight=0;
			var f1=0,f2=1,f3=2;
			i=0;
			while (i < lenI){
				weight=this._useFaceWeights ? this._faceWeights[k++] :1;
				index=tangentOffset+this._indices[i++] *tangentStride;
				target[index++]+=this._faceTangents[f1] *weight;
				target[index++]+=this._faceTangents[f2] *weight;
				target[index]+=this._faceTangents[f3] *weight;
				index=tangentOffset+this._indices[i++] *tangentStride;
				target[index++]+=this._faceTangents[f1] *weight;
				target[index++]+=this._faceTangents[f2] *weight;
				target[index]+=this._faceTangents[f3] *weight;
				index=tangentOffset+this._indices[i++] *tangentStride;
				target[index++]+=this._faceTangents[f1] *weight;
				target[index++]+=this._faceTangents[f2] *weight;
				target[index]+=this._faceTangents[f3] *weight;
				f1+=3;
				f2+=3;
				f3+=3;
			}
			i=tangentOffset;
			while (i < lenV){
				var vx=target[i];
				var vy=target[i+1];
				var vz=target[i+2];
				var _r=Math.sqrt(vx *vx+vy *vy+vz *vz);
				var d=_r > 0 ? 1.0 / _r :0;
				target[i]=vx *d;
				target[i+1]=vy *d;
				target[i+2]=vz *d;
				i+=tangentStride;
			}
			this._vertexTangentsDirty=false;
			return target;
		}

		__proto.activate=function(_context3d,_camera3d,_program){
			!this.isUploaded && this.upload(_context3d);
			this.bindBuffer();
			var _size=-1;
			for (var i=0;i < this._attributes.length;i++){
				var _element=this._attributes[i];
				switch (_element.elementFormat){
					case "single":
						_size=1;
						break ;
					case "vector2":
						_size=2;
						break ;
					case "vector3":
						_size=3;
						break ;
					case "vector4":
						_size=4;
						break ;
					}
				this.activeAttribute(_context3d,_program,_size,_element.offset,this.vertexStride,_element.elementUsage);
			}
		}

		/**
		*激活Attribute
		*@param _context3d
		*@param size
		*@param offset
		*@param vertexStride
		*@param attribName
		*
		*/
		__proto.activeAttribute=function(_context3d,_program,size,offset,vertexStride,attribName){
			var attribute=_context3d.getAttribLocation(_program,attribName);
			if (attribute !=-1){
				_context3d.vertexAttribPointer(attribute,size,0x1406,false,vertexStride,offset);
				_context3d.enableVertexAttribArray(attribute);
			}
		}

		__proto.updateFaceNormals=function(){
			var i=0,j=0,k=0;
			var index=0;
			var len=this._indices.length;
			var x1=NaN,x2=NaN,x3=NaN;
			var y1=NaN,y2=NaN,y3=NaN;
			var z1=NaN,z2=NaN,z3=NaN;
			var dx1=NaN,dy1=NaN,dz1=NaN;
			var dx2=NaN,dy2=NaN,dz2=NaN;
			var cx=NaN,cy=NaN,cz=NaN;
			var d=NaN;
			var vertices=this._vertexData;
			var posStride=13;
			var posOffset=0;this._faceNormals=this._faceNormals||new Float32Array(len);
			if (this._useFaceWeights)this._faceWeights=this._faceWeights||new Float32Array(len / 3);
			while (i < len){
				index=posOffset+this._indices[i++] *posStride;
				x1=vertices[index];
				y1=vertices[index+1];
				z1=vertices[index+2];
				index=posOffset+this._indices[i++] *posStride;
				x2=vertices[index];
				y2=vertices[index+1];
				z2=vertices[index+2];
				index=posOffset+this._indices[i++] *posStride;
				x3=vertices[index];
				y3=vertices[index+1];
				z3=vertices[index+2];
				dx1=x3-x1;
				dy1=y3-y1;
				dz1=z3-z1;
				dx2=x2-x1;
				dy2=y2-y1;
				dz2=z2-z1;
				cx=dz1 *dy2-dy1 *dz2;
				cy=dx1 *dz2-dz1 *dx2;
				cz=dy1 *dx2-dx1 *dy2;
				d=Math.sqrt(cx *cx+cy *cy+cz *cz);
				if (this._useFaceWeights){
					var w=d *10000;
					if (w < 1)
						w=1;
					this._faceWeights[k++]=w;
				}
				d=1 / d;
				this._faceNormals[j++]=cx *d;
				this._faceNormals[j++]=cy *d;
				this._faceNormals[j++]=cz *d;
			}
			this._faceNormalsDirty=false;
		}

		__getset(0,__proto,'UVData',function(){
			if (this._uvsDirty && this._autoGenerateUVs)
				this._vertexData=this.updateDummyUVs(this._vertexData);
			return this._vertexData;
		});

		__getset(0,__proto,'autoGenerateUVs',function(){
			return this._autoGenerateUVs;
			},function(value){
			this._autoGenerateUVs=value;
		});

		__getset(0,__proto,'UVStride',function(){
			return 2;
		});

		__getset(0,__proto,'isUploaded',function(){
			return this._isUploaded;
		});

		__getset(0,__proto,'numVertices',function(){
			return this._numVertices;
		});

		__getset(0,__proto,'UVOffset',function(){
			return 0;
		});

		__getset(0,__proto,'autoDeriveVertexNormals',function(){
			return this._autoDeriveVertexNormals;
			},function(value){
			this._autoDeriveVertexNormals=value;
			this._vertexNormalsDirty=value;
		});

		__getset(0,__proto,'autoDeriveVertexTangents',function(){
			return this._autoDeriveVertexTangents;
			},function(value){
			this._autoDeriveVertexTangents=value;
		});

		__getset(0,__proto,'indices',function(){
			return this._indices !=null ? this._indices :null;
			},function(value){
			if (this.isDispose)
				return;
			this._indices=value;
			var numTriangles=value.length / 3;
			this._numTriangles=numTriangles;
			this._invalidBuffer=true;
		});

		__getset(0,__proto,'numTriangles',function(){
			return this._indices !=null ? this._indices.length / 3 :0;
		});

		__getset(0,__proto,'secondaryUVOffset',function(){
			return 0;
		});

		__getset(0,__proto,'secondaryUVStride',function(){
			return 2;
		});

		__getset(0,__proto,'vertexData',function(){
			if (this._autoDeriveVertexNormals && this._vertexNormalsDirty)
				this._vertexData=this.updateVertexNormals(this._vertexData);
			if (this._autoDeriveVertexTangents && this._vertexTangentsDirty)
				this._vertexData=this.updateVertexTangents(this._vertexData);
			if (this._uvsDirty && this._autoGenerateUVs)
				this._vertexData=this.updateDummyUVs(this._vertexData);
			return this._vertexData;
		});

		__getset(0,__proto,'vertexOffset',function(){
			return 0;
		});

		__getset(0,__proto,'vertexStride',function(){
			return this._vertexDeclaration ? this._vertexDeclaration.vertexStride :-1;
		});

		SubGeometry3D.__init$=function(){
			;
			/*namespace*/;
		}

		return SubGeometry3D;
	})(ResourceBase)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.shader.Shader extends laya.resource.Resource
	var Shader=(function(_super){
		function Shader(vs,ps,saveName,nameMap){
			this.customCompile=false;
			//this._nameMap=null;
			//this._vs=null;
			//this._ps=null;
			this._curActTexIndex=0;
			//this._reCompile=false;
			this.tag={};
			//this._vshader=null;
			//this._pshader=null;
			this._program=null;
			this._params=null;
			this._paramsMap={};
			this._offset=0;
			//this._id=0;
			Shader.__super.call(this);
			if ((!vs)|| (!ps))throw "Shader Error";
			if (Render.isConchApp || Render.isFlash){
				this.customCompile=true;
			}
			this._id=++Shader._count;
			this._vs=vs;
			this._ps=ps;
			this._nameMap=nameMap ? nameMap :{};
			saveName !=null && (Shader.sharders[saveName]=this);
		}

		__class(Shader,'laya.webgl.shader.Shader',_super);
		var __proto=Shader.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			this._compile();
			this.compoleteCreate();
			this.memorySize=0;
		}

		//忽略尺寸尺寸
		__proto.detoryResource=function(){
			WebGL.mainContext.deleteShader(this._vshader);
			WebGL.mainContext.deleteShader(this._pshader);
			WebGL.mainContext.deleteProgram(this._program);
			this._vshader=this._pshader=this._program=null;
			this._params=null;
			this._paramsMap={};
			this.memorySize=0;
			this._curActTexIndex=0;
		}

		__proto._compile=function(){
			if (!this._vs || !this._ps || this._params)
				return;
			this._reCompile=true;
			this._params=[];
			var text=[this._vs,this._ps];
			var result;
			if (this.customCompile)
				result=this._preGetParams(this._vs,this._ps);
			var gl=WebGL.mainContext;
			this._program=gl.createProgram();
			this._vshader=Shader._createShader(gl,text[0],0x8B31);
			this._pshader=Shader._createShader(gl,text[1],0x8B30);
			gl.attachShader(this._program,this._vshader);
			gl.attachShader(this._program,this._pshader);
			gl.linkProgram(this._program);
			if (!this.customCompile && !gl.getProgramParameter(this._program,0x8B82)){
				throw gl.getProgramInfoLog(this._program);
			};
			var one,i=0,j=0,n=0,location;
			var attribNum=this.customCompile?result.attributes.length:gl.getProgramParameter(this._program,0x8B89);
			for (i=0;i < attribNum;i++){
				var attrib=this.customCompile?result.attributes[i]:gl.getActiveAttrib(this._program,i);
				location=gl.getAttribLocation(this._program,attrib.name);
				one={vartype:"attribute",ivartype:0,attrib:attrib,location:location,name:attrib.name,type:attrib.type,isArray:false,isSame:false,preValue:null,indexOfParams:0};
				this._params.push(one);
			};
			var nUniformNum=this.customCompile?result.uniforms.length:gl.getProgramParameter(this._program,0x8B86);
			for (i=0;i < nUniformNum;i++){
				var uniform=this.customCompile?result.uniforms[i]:gl.getActiveUniform(this._program,i);
				location=gl.getUniformLocation(this._program,uniform.name);
				one={vartype:"uniform",ivartype:1,attrib:attrib,location:location,name:uniform.name,type:uniform.type,isArray:false,isSame:false,preValue:null,indexOfParams:0};
				if (one.name.indexOf('[0]')> 0){
					one.name=one.name.substr(0,one.name.length-3);
					one.isArray=true;
					one.location=gl.getUniformLocation(this._program,one.name);
				}
				this._params.push(one);
			}
			for (i=0,n=this._params.length;i < n;i++){
				one=this._params[i];
				one.indexOfParams=i;
				one.index=1;
				one.value=[one.location,null];
				one.codename=one.name;
				one.name=this._nameMap[one.codename] ? this._nameMap[one.codename] :one.codename;
				this._paramsMap[one.name]=one;
				one._this=this;
				one.saveValue=[];
				if (one.vartype==="attribute"){
					one.fun=this._attribute;
					continue ;
				}
				switch (one.type){
					case 0x1406:
						one.fun=one.isArray ? this._uniform1fv :this._uniform1f;
						break ;
					case 0x8B50:
						one.fun=this._uniform_vec2;
						break ;
					case 0x8B51:
						one.fun=this._uniform_vec3;
						break ;
					case 0x8B52:
						one.fun=this._uniform_vec4;
						break ;
					case 0x8B5E:
						one.fun=this._uniform_sampler2D;
						break ;
					case 0x8B60:
						one.fun=this._uniform_samplerCube;
						break ;
					case 0x8B5C:
						one.fun=this._uniformMatrix4fv;
						break ;
					case 0x8B56:
						one.fun=this._uniform1i;
						break ;
					case 0x8B5A:
					case 0x8B5B:
						throw new Error("compile shader err!");
						break ;
					default :
						throw new Error("compile shader err!");
						break ;
					}
			}
		}

		/**
		*根据变量名字获得
		*@param name
		*@return
		*/
		__proto.getUniform=function(name){
			return this._paramsMap[name];
		}

		__proto._attribute=function(one,value){
			var gl=WebGL.mainContext;
			gl.enableVertexAttribArray(one.location);
			gl.vertexAttribPointer(one.location,value[0],value[1],value[2],value[3],value[4]+this._offset);
			return 2;
		}

		__proto._uniformMatrix4fv=function(one,value){
			WebGL.mainContext.uniformMatrix4fv(one.location,false,value);
			return 1;
		}

		__proto._uniform1i=function(one,value){
			var saveValue=one.saveValue;
			if (saveValue[0]!==value){
				WebGL.mainContext.uniform1i(one.location,saveValue[0]=value);
				return 1;
			}
			return 0;
		}

		__proto._uniform1f=function(one,value){
			var saveValue=one.saveValue;
			if (saveValue[0]!==value){
				WebGL.mainContext.uniform1f(one.location,saveValue[0]=value);
				return 1;
			}
			return 0;
		}

		__proto._uniform1fv=function(one,value){
			var saveValue=one.saveValue;
			if (saveValue[0]!==value){
				WebGL.mainContext.uniform1fv(one.location,saveValue[0]=value);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec2=function(one,value){
			var saveValue=one.saveValue;
			if (saveValue[0]!==value[0] || saveValue[1]!==value[1]){
				WebGL.mainContext.uniform2f(one.location,saveValue[0]=value[0],saveValue[1]=value[1]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec3=function(one,value){
			WebGL.mainContext.uniform3f(one.location,value[0],value[1],value[2]);
			return 1;
		}

		__proto._uniform_vec4=function(one,value){
			WebGL.mainContext.uniform4f(one.location,value[0],value[1],value[2],value[3]);
			return 1;
		}

		__proto._uniform_sampler2D=function(one,value){
			var gl=WebGL.mainContext;
			var saveValue=one.saveValue;
			if (saveValue[0]==null){
				saveValue[0]=this._curActTexIndex;
				gl.uniform1i(one.location,this._curActTexIndex);
				gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
				WebGLContext.bindTexture(gl,0x0DE1,value);
				this._curActTexIndex++;
				return 1;
			}
			else{
				gl.activeTexture(Shader._TEXTURES[saveValue[0]]);
				WebGLContext.bindTexture(gl,0x0DE1,value);
				return 0;
			}
		}

		__proto._uniform_samplerCube=function(one,value){
			var gl=WebGL.mainContext;
			var saveValue=one.saveValue;
			if (saveValue[0]==null){
				saveValue[0]=this._curActTexIndex;
				gl.uniform1i(one.location,this._curActTexIndex);
				gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
				WebGLContext.bindTexture(gl,0x8513,value);
				this._curActTexIndex++;
				return 1;
			}
			else{
				gl.activeTexture(Shader._TEXTURES[saveValue[0]]);
				WebGLContext.bindTexture(gl,0x8513,value);
				return 0;
			}
		}

		__proto._noSetValue=function(one){
			console.log("no....:"+one.name);
		}

		//throw new Error("upload shader err,must set value:"+one.name);
		__proto.uploadOne=function(name,value){
			this.activeResource();
			WebGLContext.UseProgram(this._program);
			var one=this._paramsMap[name];
			one.fun.call(this,one,value);
		}

		__proto.uploadTexture2D=function(value){
			Stat.shaderCall++;
			var gl=WebGL.mainContext;
			gl.activeTexture(0x84C0);
			WebGLContext.bindTexture(gl,0x0DE1,value);
		}

		/**
		*提交shader到GPU
		*@param shaderValue
		*/
		__proto.upload=function(shaderValue,params){
			Shader.activeShader=this;
			this.activeResource();
			WebGLContext.UseProgram(this._program);
			if (this._reCompile){
				params=this._params;
				this._reCompile=false;
				}else {
				params=params || this._params;
			};
			var one,value,n=params.length,shaderCall=0;
			for (var i=0;i < n;i++){
				one=params[i];
				((value=shaderValue[one.name])!==null)&& (shaderCall+=one.fun.call(this,one,value));
			}
			Stat.shaderCall+=shaderCall;
		}

		/**
		*按数组的定义提交
		*@param shaderValue 数组格式[name,[value,id],...]
		*/
		__proto.uploadArray=function(shaderValue,length,_bufferUsage){
			Shader.activeShader=this;
			this.activeResource();
			var sameProgram=!WebGLContext.UseProgram(this._program);
			var params=this._params,value;
			var one,shaderCall=0,uploadArrayCount=Shader._uploadArrayCount++;
			for (var i=length-2;i >=0;i-=2){
				one=this._paramsMap[shaderValue[i]];
				if (!one || one._uploadArrayCount===uploadArrayCount)
					continue ;
				one._uploadArrayCount=uploadArrayCount;
				var v=shaderValue[i+1];
				var uid=v[1];
				if (sameProgram && one.ivartype===1 && uid > 0 && uid===one.__uploadid)
					continue ;
				value=v[0];
				if (value !=null){
					_bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind();
					shaderCall+=one.fun.call(this,one,value);
					one.__uploadid=uid;
				}
			}
			Stat.shaderCall+=shaderCall;
		}

		/**
		*得到编译后的变量及相关预定义
		*@return
		*/
		__proto.getParams=function(){
			return this._params;
		}

		__proto._preGetParams=function(vs,ps){
			var text=[vs,ps];
			var result={};
			var attributes=[];
			var uniforms=[];
			var definesInfo={};
			var definesName=[];
			result.attributes=attributes;
			result.uniforms=uniforms;
			result.defines=definesInfo;
			var removeAnnotation=new RegExp("(/\\*([^*]|[\\r\\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)","g");
			var reg=new RegExp("(\".*\")|('.*')|([#\\w\\*-\\.+/()=<>{}\\\\]+)|([,;:\\\\])","g");
			var i=0,n=0,one;
			for (var s=0;s < 2;s++){
				text[s]=text[s].replace(removeAnnotation,"");
				var words=text[s].match(reg);
				var tempelse;
				for (i=0,n=words.length;i < n;i++){
					var word=words[i];
					if (word !="attribute" && word !="uniform"){
						if (word=="#define"){
							word=words[++i];
							definesName[word]=1;
							continue ;
						}
						else if (word=="#ifdef"){
							tempelse=words[++i];
							var def=definesInfo[tempelse]=definesInfo[tempelse]||[];
							for (i++;i < n;i++){
								word=words[i];
								if (word !="attribute" && word !="uniform"){
									if (word=="#else"){
										for (i++;i < n;i++){
											word=words[i];
											if (word !="attribute" && word !="uniform"){
												if (word=="#endif"){
													break ;
												}
												continue ;
											}
											i=this.parseOne(attributes,uniforms,words,i,word,!definesName[tempelse]);
										}
									}
									continue ;
								}
								i=this.parseOne(attributes,uniforms,words,i,word,definesName[tempelse]);
							}
						}
						continue ;
					}
					i=this.parseOne(attributes,uniforms,words,i,word,true);
				}
			}
			return result;
		}

		__proto.parseOne=function(attributes,uniforms,words,i,word,b){
			var one={type:Shader.shaderParamsMap[words[i+1]],name:words[i+2],size:isNaN(parseInt(words[i+3]))? 1 :parseInt(words[i+3])};
			if (b){
				if (word=="attribute"){
					attributes.push(one);
					}else {
					uniforms.push(one);
				}
			}
			if (words[i+3]==':'){
				one.type=words[i+4];
				i+=2;
			}
			i+=2;
			return i;
		}

		__proto.dispose=function(){
			this.resourceManager.removeResource(this);
			_super.prototype.dispose.call(this);
		}

		Shader.getShader=function(name){
			return Shader.sharders[name];
		}

		Shader.create=function(vs,ps,saveName,nameMap){
			return new Shader(vs,ps,saveName,nameMap);
		}

		Shader.withCompile=function(nameID,mainID,define,shaderName,createShader){
			if (shaderName && Shader.sharders[shaderName])
				return Shader.sharders[shaderName];
			var pre=Shader._preCompileShader[0.0002 *nameID+mainID];
			if (!pre)
				throw new Error("withCompile shader err!"+nameID+" "+mainID);
			return pre.createShader(define,shaderName,createShader);
		}

		Shader.addInclude=function(fileName,txt){
			if (!txt || txt.length===0)
				throw new Error("add shader include file err:"+fileName);
			if (Shader._includeFiles[fileName])
				throw new Error("add shader include file err, has add:"+fileName);
			Shader._includeFiles[fileName]=txt;
		}

		Shader.preCompile=function(nameID,mainID,vs,ps,nameMap){
			var id=0.0002 *nameID+mainID;
			Shader._preCompileShader[id]=new ShaderCompile(id,vs,ps,nameMap,Shader._includeFiles);
		}

		Shader._createShader=function(gl,str,type){
			var shader=gl.createShader(type);
			gl.shaderSource(shader,str);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader,0x8B81)){
				throw gl.getShaderInfoLog(shader);
			}
			return shader;
		}

		Shader._TEXTURES=[0x84C0,0x84C1,0x84C2,0x84C3,0x84C4,0x84C5,0x84C6,,0x84C7,0x84C8];
		Shader._includeFiles={};
		Shader._count=0;
		Shader._preCompileShader={};
		Shader._uploadArrayCount=1;
		Shader.SHADERNAME2ID=0.0002;
		Shader.activeShader=null
		Shader.sharders=(Shader.sharders=[],Shader.sharders.length=0x20,Shader.sharders);
		__static(Shader,
		['shaderParamsMap',function(){return this.shaderParamsMap={"float":0x1406,"int":0x1404,"bool":0x8B56,"vec2":0x8B50,"vec3":0x8B51,"vec4":0x8B52,"ivec2":0x8B53,"ivec3":0x8B54,"ivec4":0x8B55,"bvec2":0x8B57,"bvec3":0x8B58,"bvec4":0x8B59,"mat2":0x8B5A,"mat3":0x8B5B,"mat4":0x8B5C,"sampler2D":0x8B5E,"samplerCube":0x8B60};},'nameKey',function(){return this.nameKey=new StringKey();}
		]);
		return Shader;
	})(Resource)


	/**
	*<p> <code>Sprite</code> 类是基本显示列表构造块：一个可显示图形并且也可包含子项的显示列表节点。</p>
	*
	*@example 以下示例代码，创建了一个 <code>Text</code> 实例。
	*<listing version="3.0">
	*package
	*{
		*import laya.display.Sprite;
		*import laya.events.Event;
		*
		*public class Sprite_Example
		*{
			*private var sprite:Sprite;
			*private var shape:Sprite
			*public function Sprite_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*sprite=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
				*sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
				*sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
				*sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
				*sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
				*sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
				*Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
				*sprite.on(Event.CLICK,this,onClickSprite);//给 sprite 对象添加点击事件侦听。
				*shape=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
				*shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
				*shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
				*shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
				*shape.width=100;//设置 shape 对象的宽度。
				*shape.height=100;//设置 shape 对象的高度。
				*shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
				*shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
				*Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
				*shape.on(Event.CLICK,this,onClickShape);//给 shape 对象添加点击事件侦听。
				*}
			*private function onClickSprite():void
			*{
				*trace("点击 sprite 对象。");
				*sprite.rotation+=5;//旋转 sprite 对象。
				*}
			*private function onClickShape():void
			*{
				*trace("点击 shape 对象。");
				*shape.rotation+=5;//旋转 shape 对象。
				*}
			*}
		*}
	*</listing>
	*<listing version="3.0">
	*var sprite;
	*var shape;
	*Sprite_Example();
	*function Sprite_Example()
	*{
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*onInit();
		*}
	*function onInit()
	*{
		*sprite=new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
		*sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
		*sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
		*sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
		*sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
		*sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
		*Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
		*sprite.on(Event.CLICK,this,onClickSprite);//给 sprite 对象添加点击事件侦听。
		*shape=new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
		*shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
		*shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
		*shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
		*shape.width=100;//设置 shape 对象的宽度。
		*shape.height=100;//设置 shape 对象的高度。
		*shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
		*shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
		*Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
		*shape.on(laya.events.Event.CLICK,this,onClickShape);//给 shape 对象添加点击事件侦听。
		*}
	*function onClickSprite()
	*{
		*console.log("点击 sprite 对象。");
		*sprite.rotation+=5;//旋转 sprite 对象。
		*}
	*function onClickShape()
	*{
		*console.log("点击 shape 对象。");
		*shape.rotation+=5;//旋转 shape 对象。
		*}
	*</listing>
	*<listing version="3.0">
	*import Sprite=laya.display.Sprite;
	*class Sprite_Example {
		*private sprite:Sprite;
		*private shape:Sprite
		*public Sprite_Example(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*this.sprite=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
			*this.sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
			*this.sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
			*this.sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
			*this.sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
			*this.sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
			*Laya.stage.addChild(this.sprite);//将此 sprite 对象添加到显示列表。
			*this.sprite.on(laya.events.Event.CLICK,this,this.onClickSprite);//给 sprite 对象添加点击事件侦听。
			*this.shape=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
			*this.shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
			*this.shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
			*this.shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
			*this.shape.width=100;//设置 shape 对象的宽度。
			*this.shape.height=100;//设置 shape 对象的高度。
			*this.shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
			*this.shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
			*Laya.stage.addChild(this.shape);//将此 shape 对象添加到显示列表。
			*this.shape.on(laya.events.Event.CLICK,this,this.onClickShape);//给 shape 对象添加点击事件侦听。
			*}
		*private onClickSprite():void {
			*console.log("点击 sprite 对象。");
			*this.sprite.rotation+=5;//旋转 sprite 对象。
			*}
		*private onClickShape():void {
			*console.log("点击 shape 对象。");
			*this.shape.rotation+=5;//旋转 shape 对象。
			*}
		*}
	*</listing>
	*/
	//class laya.display.Sprite extends laya.display.Node
	var Sprite=(function(_super){
		function Sprite(){
			this.mouseThrough=false;
			this._transform=null;
			this._tfChanged=false;
			this._x=0;
			this._y=0;
			this._width=0;
			this._height=0;
			this._repaint=1;
			this._mouseEnableState=0;
			this._zOrder=0;
			this._graphics=null;
			this._renderType=0;
			this.autoSize=false;
			this.hitTestPrior=false;
			this._optimizeScrollRect=false;
			Sprite.__super.call(this);
			this._style=Style.EMPTY;
		}

		__class(Sprite,'laya.display.Sprite',_super);
		var __proto=Sprite.prototype;
		Laya.imps(__proto,{"laya.display.ILayout":true})
		/**@inheritDoc */
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			this._style && this._style.destroy();
			this._transform=null;
			this._style=null;
			this._graphics=null;
		}

		/**根据zOrder进行重新排序。*/
		__proto.updateZOrder=function(){
			Utils.updateOrder(this._childs)&& this.repaint();
		}

		/**在设置cacheAs或staticCache=true的情况下，调用此方法会重新刷新缓存。*/
		__proto.reCache=function(){
			if (this._$P.cacheCanvas)this._$P.cacheCanvas.reCache=true;
		}

		/**
		*设置bounds大小，如果有设置，则不再通过getBounds计算
		*@param bound bounds矩形区域
		*/
		__proto.setBounds=function(bound){
			this._set$P("uBounds",bound);
		}

		/**
		*获取本对象在父容器坐标系的矩形显示区域。
		*<p><b>注意：</b>计算量较大，尽量少用。</p>
		*@return 矩形区域。
		*/
		__proto.getBounds=function(){
			if (!this._$P.mBounds)this._set$P("mBounds",new Rectangle());
			return Rectangle._getWrapRec(this._boundPointsToParent(),this._$P.mBounds);
		}

		/**
		*获取本对象在自己坐标系的矩形显示区域。
		*<p><b>注意：</b>计算量较大，尽量少用。</p>
		*@return 矩形区域。
		*/
		__proto.getSelfBounds=function(){
			if (!this._$P.mBounds)this._set$P("mBounds",new Rectangle());
			return Rectangle._getWrapRec(this._getBoundPointsM(false),this._$P.mBounds);
		}

		/**
		*@private
		*获取本对象在父容器坐标系的显示区域多边形顶点列表。
		*当显示对象链中有旋转时，返回多边形顶点列表，无旋转时返回矩形的四个顶点。
		*@param ifRotate 之前的对象链中是否有旋转。
		*@return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
		*/
		__proto._boundPointsToParent=function(ifRotate){
			(ifRotate===void 0)&& (ifRotate=false);
			var pX=0,pY=0;
			if (this._style){
				pX=this._style._tf.translateX;
				pY=this._style._tf.translateY;
				ifRotate=ifRotate || (this._style._tf.rotate!==0);
				if (this._style.scrollRect){
					pX+=this._style.scrollRect.x;
					pY+=this._style.scrollRect.y;
				}
			};
			var pList=this._getBoundPointsM(ifRotate);
			if (!pList || pList.length < 1)return pList;
			if (pList.length !=8){
				pList=ifRotate ? GrahamScan.scanPList(pList):Rectangle._getWrapRec(pList,Rectangle.TEMP)._getBoundPoints();
			}
			if (!this.transform){
				Utils.transPointList(pList,this.x-pX,this.y-pY);
				return pList;
			};
			var tPoint=Point.TEMP;
			var i=0,len=pList.length;
			for (i=0;i < len;i+=2){
				tPoint.x=pList[i];
				tPoint.y=pList[i+1];
				this.toParentPoint(tPoint);
				pList[i]=tPoint.x;
				pList[i+1]=tPoint.y;
			}
			return pList;
		}

		/**
		*返回此实例中的绘图对象（ <code>Graphics</code> ）的显示区域。
		*@return 一个 Rectangle 对象，表示获取到的显示区域。
		*/
		__proto.getGraphicBounds=function(){
			if (!this._graphics)return Rectangle.TEMP.setTo(0,0,0,0);
			return this._graphics.getBounds();
		}

		/**
		*@private
		*获取自己坐标系的显示区域多边形顶点列表
		*@param ifRotate 当前的显示对象链是否由旋转
		*@return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
		*/
		__proto._getBoundPointsM=function(ifRotate){
			(ifRotate===void 0)&& (ifRotate=false);
			if (this._$P.uBounds)return this._$P.uBounds._getBoundPoints();
			if (!this._$P.temBM)this._set$P("temBM",[]);
			if (this.scrollRect){
				var rst=Utils.clearArray(this._$P.temBM);
				var rec=Rectangle.TEMP;
				rec.copyFrom(this.scrollRect);
				Utils.concatArray(rst,rec._getBoundPoints());
				return rst;
			};
			var pList=this._graphics ? this._graphics.getBoundPoints():Utils.clearArray(this._$P.temBM);
			var child;
			var cList;
			var __childs;
			__childs=this._childs;
			for (var i=0,n=__childs.length;i < n;i++){
				child=__childs [i];
				if ((child instanceof laya.display.Sprite )&& child.visible==true){
					cList=child._boundPointsToParent(ifRotate);
					if (cList)
						pList=pList ? Utils.concatArray(pList,cList):cList;
				}
			}
			return pList;
		}

		/**
		*@private
		*获取样式。
		*@return 样式 Style 。
		*/
		__proto.getStyle=function(){
			this._style===Style.EMPTY && (this._style=new Style());
			return this._style;
		}

		/**
		*@private
		*设置样式。
		*@param value 样式。
		*/
		__proto.setStyle=function(value){
			this._style=value;
		}

		/**@private */
		__proto._adjustTransform=function(){
			'use strict';
			this._tfChanged=false;
			var style=this._style;
			var tf=style._tf;
			var sx=tf.scaleX,sy=tf.scaleY;
			var m;
			if (tf.rotate || sx!==1 || sy!==1 || tf.skewX || tf.skewY){
				m=this._transform || (this._transform=Matrix.create());
				m.bTransform=true;
				if (tf.rotate){
					var angle=tf.rotate *0.0174532922222222;
					var cos=m.cos=Math.cos(angle);
					var sin=m.sin=Math.sin(angle);
					m.a=sx *cos;
					m.b=sx *sin;
					m.c=-sy *sin;
					m.d=sy *cos;
					m.tx=m.ty=0;
					return m;
					}else {
					m.a=sx;
					m.d=sy;
					m.c=m.b=m.tx=m.ty=0;
					if (tf.skewX || tf.skewY){
						return m.skew(tf.skewX *0.0174532922222222,tf.skewY *0.0174532922222222);
					}
					return m;
				}
				}else {
				this._transform && this._transform.destroy();
				this._transform=null;
				this._renderType &=~0x04;
			}
			return m;
		}

		/**
		*设置坐标位置。
		*@param x X 轴坐标。
		*@param y Y 轴坐标。
		*@return 返回对象本身。
		*/
		__proto.pos=function(x,y){
			if (this._x!==x || this._y!==y){
				this.x=x;
				this.y=y;
			}
			return this;
		}

		/**
		*设置轴心点。
		*@param x X轴心点。
		*@param y Y轴心点。
		*@return 返回对象本身。
		*/
		__proto.pivot=function(x,y){
			this.pivotX=x;
			this.pivotY=y;
			return this;
		}

		/**
		*设置宽高。
		*@param width 宽度。
		*@param hegiht 高度。
		*@return 返回对象本身。
		*/
		__proto.size=function(width,height){
			this.width=width;
			this.height=height;
			return this;
		}

		/**
		*设置缩放。
		*@param scaleX X轴缩放比例。
		*@param scaleY Y轴缩放比例。
		*@return 返回对象本身。
		*/
		__proto.scale=function(scaleX,scaleY){
			this.scaleX=scaleX;
			this.scaleY=scaleY;
			return this;
		}

		/**
		*设置倾斜角度。
		*@param skewX 水平倾斜角度。
		*@param skewY 垂直倾斜角度。
		*@return 返回对象本身
		*/
		__proto.skew=function(skewX,skewY){
			this.skewX=skewX;
			this.skewY=skewY;
			return this;
		}

		/**
		*更新、呈现显示对象。
		*@param context 渲染的上下文引用。
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*/
		__proto.render=function(context,x,y){
			Stat.spriteCount++;
			RenderSprite.renders[this._renderType]._fun(this,context,x+this._x,y+this._y);
			this._repaint=0;
		}

		/**
		*绘制 <code>Sprite</code> 到 <code>canvas</code> 上。
		*@param canvasWidth 画布宽度。
		*@param canvasHeight 画布高度。
		*@param x 绘制的 X 轴偏移量。
		*@param y 绘制的 Y 轴偏移量。
		*@return HTMLCanvas 对象。
		*/
		__proto.drawToCanvas=function(canvasWidth,canvasHeight,offsetX,offsetY){
			return RunDriver.drawToCanvas(this,this._renderType,canvasWidth,canvasHeight,offsetX,offsetY);
		}

		/**
		*自定义更新、呈现显示对象。
		*<p><b>注意</b>不要在此函数内增加或删除树节点，否则会树节点遍历照成影响。</p>
		*@param context 渲染的上下文引用。
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*/
		__proto.customRender=function(context,x,y){
			this._renderType |=0x200;
		}

		/**
		*@private
		*应用滤镜。
		*/
		__proto._applyFilters=function(){
			if (Render.isWebGL)return;
			var _filters;
			_filters=this._$P.filters;
			if (!_filters || _filters.length < 1)return;
			for (var i=0,n=_filters.length;i < n;i++){
				_filters[i].action.apply(this._$P.cacheCanvas);
			}
		}

		/**
		*@private
		*查看当前原件中是否包含发光滤镜。
		*@return 一个 Boolean 值，表示当前原件中是否包含发光滤镜。
		*/
		__proto._isHaveGlowFilter=function(){
			var i=0,len=0;
			if (this.filters){
				for (i=0;i < this.filters.length;i++){
					if (this.filters[i].type==0x08){
						return true;
					}
				}
			}
			for (i=0,len=this._childs.length;i < len;i++){
				if (this._childs[i]._isHaveGlowFilter()){
					return true;
				}
			}
			return false;
		}

		/**
		*本地坐标转全局坐标。
		*@param point 本地坐标点。
		*@param createNewPoint 用于存储转换后的坐标的点。
		*@return 转换后的坐标的点。
		*/
		__proto.localToGlobal=function(point,createNewPoint){
			(createNewPoint===void 0)&& (createNewPoint=false);
			if (!this._displayedInStage || !point)return point;
			if (createNewPoint===true){
				point=new Point(point.x,point.y);
			};
			var ele=this;
			while (ele){
				if (ele==Laya.stage)break ;
				point=ele.toParentPoint(point);
				ele=ele.parent;
			}
			return point;
		}

		/**
		*全局坐标转本地坐标。
		*@param point 全局坐标点。
		*@param createNewPoint 用于存储转换后的坐标的点。
		*@return 转换后的坐标的点。
		*/
		__proto.globalToLocal=function(point,createNewPoint){
			(createNewPoint===void 0)&& (createNewPoint=false);
			if (!this._displayedInStage || !point)return point;
			if (createNewPoint===true){
				point=new Point(point.x,point.y);
			};
			var ele=this;
			var list=[];
			while (ele){
				if (ele==Laya.stage)break ;
				list.push(ele);
				ele=ele.parent;
			};
			var i=list.length-1;
			while (i >=0){
				ele=list[i];
				point=ele.fromParentPoint(point);
				i--;
			}
			return point;
		}

		/**
		*将本地坐标系坐标转换到父容器坐标系。
		*@param point 本地坐标点。
		*@return 转换后的点。
		*/
		__proto.toParentPoint=function(point){
			if (!point)return point;
			point.x-=this.pivotX;
			point.y-=this.pivotY;
			if (this.transform){
				this._transform.transformPoint(point);
			}
			point.x+=this._x;
			point.y+=this._y;
			var scroll=this._style.scrollRect;
			if (scroll){
				point.x-=scroll.x;
				point.y-=scroll.y;
			}
			return point;
		}

		/**
		*将父容器坐标系坐标转换到本地坐标系。
		*@param point 父容器坐标点。
		*@return 转换后的点。
		*/
		__proto.fromParentPoint=function(point){
			if (!point)return point;
			point.x-=this._x;
			point.y-=this._y;
			var scroll=this._style.scrollRect;
			if (scroll){
				point.x+=scroll.x;
				point.y+=scroll.y;
			}
			if (this.transform){
				this._transform.invertTransformPoint(point);
			}
			point.x+=this.pivotX;
			point.y+=this.pivotY;
			return point;
		}

		/**
		*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
		*如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnable 的值为 true。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args 事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.on=function(type,caller,listener,args){
			if (this._mouseEnableState!==1 && this.isMouseEvent(type)){
				if (this._displayedInStage)this._$2__onDisplay();
				else laya.events.EventDispatcher.prototype.once.call(this,"display",this,this._$2__onDisplay);
			}
			return laya.events.EventDispatcher.prototype.on.call(this,type,caller,listener,args);
		}

		/**
		*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
		*如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args 事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.once=function(type,caller,listener,args){
			if (this._mouseEnableState!==1 && this.isMouseEvent(type)){
				if (this._displayedInStage)this._$2__onDisplay();
				else laya.events.EventDispatcher.prototype.once.call(this,"display",this,this._$2__onDisplay);
			}
			return laya.events.EventDispatcher.prototype.once.call(this,type,caller,listener,args);
		}

		/**@private */
		__proto._$2__onDisplay=function(){
			if (this._mouseEnableState!==1){
				var ele=this;
				while (ele && ele._mouseEnableState!==1){
					ele.mouseEnabled=true;
					ele=ele.parent;
				}
			}
		}

		/**
		*加载并显示一个图片。功能等同于Graphics.loadImage
		*@param url 图片地址。
		*@param x 显示图片的x位置
		*@param y 显示图片的y位置
		*@param width 显示图片的宽度，设置为0表示使用图片默认宽度
		*@param height 显示图片的高度，设置为0表示使用图片默认高度
		*@param complete 加载完成回调
		*@return 返回精灵对象本身
		*/
		__proto.loadImage=function(url,x,y,width,height,complete){
			var _$this=this;
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(width===void 0)&& (width=0);
			(height===void 0)&& (height=0);
			function loaded (tex){
				if (!_$this.destroyed){
					_$this.size(x+(width || tex.width),y+(height || tex.height));
					_$this.repaint();
					complete && complete.runWith(tex);
				}
			}
			this.graphics.loadImage(url,x,y,width,height,loaded);
			return this;
		}

		/**cacheAs后，设置自己和父对象缓存失效。*/
		__proto.repaint=function(){
			this.model&&this.model.repaint&&this.model.repaint();
			(this._repaint===0)&& (this._repaint=1,this.parentRepaint());
			if (this._$P && this._$P.maskParent){
				this._$P.maskParent.repaint();
			}
		}

		/**
		*@private
		*获取是否重新缓存。
		*@return 如果重新缓存值为 true，否则值为 false。
		*/
		__proto._needRepaint=function(){
			return (this._repaint!==0)&& this._$P.cacheCanvas && this._$P.cacheCanvas.reCache;
		}

		/**@inheritDoc */
		__proto._childChanged=function(child){
			if (this._childs.length)this._renderType |=0x800;
			else this._renderType &=~0x800;
			if (child && (child).zOrder)Laya.timer.callLater(this,this.updateZOrder);
			this.repaint();
		}

		/**cacheAs时，设置所有父对象缓存失效。 */
		__proto.parentRepaint=function(){
			var p=this._parent;
			p && p._repaint===0 && (p._repaint=1,p.parentRepaint());
		}

		/**
		*开始拖动此对象。
		*@param area 拖动区域，此区域为当前对象注册点活动区域（不包括对象宽高），可选。
		*@param hasInertia 鼠标松开后，是否还惯性滑动，默认为false，可选。
		*@param elasticDistance 橡皮筋效果的距离值，0为无橡皮筋效果，默认为0，可选。
		*@param elasticBackTime 橡皮筋回弹时间，单位为毫秒，默认为300毫秒，可选。
		*@param data 拖动事件携带的数据，可选。
		*@param disableMouseEvent 禁用其他对象的鼠标检测，默认为false，设置为true能提高性能
		*/
		__proto.startDrag=function(area,hasInertia,elasticDistance,elasticBackTime,data,disableMouseEvent){
			(hasInertia===void 0)&& (hasInertia=false);
			(elasticDistance===void 0)&& (elasticDistance=0);
			(elasticBackTime===void 0)&& (elasticBackTime=300);
			(disableMouseEvent===void 0)&& (disableMouseEvent=false);
			this._$P.dragging || (this._set$P("dragging",new Dragging()));
			this._$P.dragging.start(this,area,hasInertia,elasticDistance,elasticBackTime,data,disableMouseEvent);
		}

		/**停止拖动此对象。*/
		__proto.stopDrag=function(){
			this._$P.dragging && this._$P.dragging.stop();
		}

		/**@private */
		__proto._setDisplay=function(value){
			if (!value && this._$P.cacheCanvas && this._$P.cacheCanvas.ctx){
				Pool.recover("RenderContext",this._$P.cacheCanvas.ctx);
				this._$P.cacheCanvas.ctx=null;
			}
			if (!value){
				var fc=this._$P._filterCache;
				if (fc){
					fc.destroy();
					fc.recycle();
					this._set$P('_filterCache',null);
				}
				this._$P._isHaveGlowFilter && this._set$P('_isHaveGlowFilter',false);
			}
			_super.prototype._setDisplay.call(this,value);
		}

		/**
		*检测某个点是否在此对象内。
		*@param x 全局x坐标。
		*@param y 全局y坐标。
		*@return 表示是否在对象内。
		*/
		__proto.hitTestPoint=function(x,y){
			var point=this.globalToLocal(Point.TEMP.setTo(x,y));
			var rect=this._$P.hitArea ? this._$P.hitArea :Rectangle.EMPTY.setTo(0,0,this._width,this._height);
			return rect.contains(point.x,point.y);
		}

		/**获得相对于本对象上的鼠标坐标信息。*/
		__proto.getMousePoint=function(){
			return this.globalToLocal(Point.TEMP.setTo(Laya.stage.mouseX,Laya.stage.mouseY));
		}

		/**@private */
		__proto._getWords=function(){
			return null;
		}

		/**@private */
		__proto._addChildsToLayout=function(out){
			var words=this._getWords();
			if (words==null && this._childs.length==0)return false;
			if (words){
				for (var i=0,n=words.length;i < n;i++){
					out.push(words[i]);
				}
			}
			this._childs.forEach(function(o){
				o._style._enableLayout()&& o._addToLayout(out);
			});
			return true;
		}

		/**@private */
		__proto._addToLayout=function(out){
			if (this._style.absolute)return;
			this._style.block ? out.push(this):(this._addChildsToLayout(out)&& (this.x=this.y=0));
		}

		/**@private */
		__proto._isChar=function(){
			return false;
		}

		/**@private */
		__proto._getCSSStyle=function(){
			return this._style.getCSSStyle();
		}

		/**
		*@private
		*设置指定属性名的属性值。
		*@param name 属性名。
		*@param value 属性值。
		*/
		__proto._setAttributes=function(name,value){
			switch (name){
				case 'x':
					this.x=parseFloat(value);
					break ;
				case 'y':
					this.y=parseFloat(value);
					break ;
				case 'width':
					this.width=parseFloat(value);
					break ;
				case 'height':
					this.height=parseFloat(value);
					break ;
				default :
					this[name]=value;
				}
		}

		/**
		*@private
		*/
		__proto._layoutLater=function(){
			this.parent && (this.parent)._layoutLater();
		}

		/**
		*<p>指定是否对使用了 scrollRect 的显示对象进行优化处理。</p>
		*<p>默认为false(不优化)。</p>
		*<p>当值为ture时：将对此对象使用了scrollRect 设定的显示区域以外的显示内容不进行渲染，以提高性能。</p>
		*/
		__getset(0,__proto,'optimizeScrollRect',function(){
			return this._optimizeScrollRect;
			},function(b){
			if (this._optimizeScrollRect !=b){
				this._optimizeScrollRect=b;
				this.model && this.model.optimizeScrollRect(b);
			}
		});

		/**X轴缩放值，默认值为1。*/
		__getset(0,__proto,'scaleX',function(){
			return this._style._tf.scaleX;
			},function(value){
			var style=this.getStyle();
			if (style._tf.scaleX!==value){
				style.setScaleX(value);
				this._tfChanged=true;
				this.model && this.model.scale(value,style._tf.scaleY);
				this._renderType |=0x04;
				var p=this._parent;
				p && p._repaint===0 && (p._repaint=1,p.parentRepaint());
			}
		});

		/**
		*指定显示对象是否缓存为静态图像。功能同cacheAs的normal模式。
		*/
		__getset(0,__proto,'cacheAsBitmap',function(){
			return this.cacheAs!=="none";
			},function(value){
			this.cacheAs=value ? (this._$P["hasFilter"] ? "none" :"normal"):"none";
		});

		/**
		*开启自定义渲染，只有开启自定义渲染，才能使用customRender函数渲染
		*/
		__getset(0,__proto,'customRenderEnable',null,function(b){
			if (b){
				this._renderType |=0x200;
				if (Render.isConchNode){
					laya.display.Sprite.CustomList.push(this);
					var canvas=new HTMLCanvas("2d");
					canvas._setContext(new CanvasRenderingContext2D());
					this.customContext=new RenderContext(0,0,canvas);
					canvas.context.setCanvasType && canvas.context.setCanvasType(2);
					this.model.custom(canvas.context);
				}
			}
		});

		/**
		*<p>指定显示对象是否缓存为静态图像，cacheAs时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。</p>
		*建议把不经常变化的复杂内容缓存为静态图像，能极大提高渲染性能，有"none"，"normal"和"bitmap"三个值可选。
		*<li>默认为"none"，不做任何缓存。</li>
		*<li>当值为"normal"时，canvas下进行画布缓存，webgl模式下进行命令缓存。</li>
		*<li>当值为"bitmap"时，canvas下进行依然是画布缓存，webgl模式下使用renderTarget缓存。</li>
		*webgl下renderTarget缓存模式有最大2048大小限制，会额外增加内存开销，不断重绘时开销比较大，但是会减少drawcall，渲染性能最高。
		*webgl下命令缓存模式只会减少节点遍历及命令组织，不会减少drawcall，性能中等。
		*/
		__getset(0,__proto,'cacheAs',function(){
			return this._$P.cacheCanvas==null ? "none" :this._$P.cacheCanvas.type;
			},function(value){
			var cacheCanvas=this._$P.cacheCanvas;
			if (value===(cacheCanvas ? cacheCanvas.type :"none"))return;
			if (value!=="none"){
				cacheCanvas || (cacheCanvas=this._set$P("cacheCanvas",Pool.getItemByClass("cacheCanvas",Object)));
				cacheCanvas.type=value;
				cacheCanvas.reCache=true;
				this._renderType |=0x08;
				if (value=="bitmap")this.model && this.model.cacheAs(1);
				this._set$P("cacheForFilters",false);
				}else {
				if (this._$P["hasFilter"]){
					this._set$P("cacheForFilters",true);
					}else {
					if (cacheCanvas)Pool.recover("cacheCanvas",cacheCanvas);
					this._$P.cacheCanvas=null;
					this._renderType &=~0x08;
					this.model && this.model.cacheAs(0);
				}
			}
			this.repaint();
		});

		/**设置cacheAs为非空时此值才有效，staticCache=true时，子对象变化时不会自动更新缓存，只能通过调用reCache方法手动刷新。*/
		__getset(0,__proto,'staticCache',function(){
			return this._$P.staticCache;
			},function(value){
			this._set$P("staticCache",value);
			if (!value && this._$P.cacheCanvas){
				this._$P.cacheCanvas.reCache=true;
			}
		});

		/**表示显示对象相对于父容器的水平方向坐标值。*/
		__getset(0,__proto,'x',function(){
			return this._x;
			},function(value){
			if (this.destroyed)return;
			var p=this._parent;
			this._x!==value && (this._x=value,this.model && this.model.pos(value,this._y),p && p._repaint===0 && (p._repaint=1,p.parentRepaint()),this._$P.maskParent && this._$P.maskParent._repaint===0 && (this._$P.maskParent._repaint=1,this._$P.maskParent.parentRepaint()));
		});

		/**表示显示对象相对于父容器的垂直方向坐标值。*/
		__getset(0,__proto,'y',function(){
			return this._y;
			},function(value){
			if (this.destroyed)return;
			var p=this._parent;
			this._y!==value && (this._y=value,this.model && this.model.pos(this._x,value),p && p._repaint===0 && (p._repaint=1,p.parentRepaint()),this._$P.maskParent && this._$P.maskParent._repaint===0 && (this._$P.maskParent._repaint=1,this._$P.maskParent.parentRepaint()));
		});

		/**水平倾斜角度，默认值为0。*/
		__getset(0,__proto,'skewX',function(){
			return this._style._tf.skewX;
			},function(value){
			var style=this.getStyle();
			if (style._tf.skewX!==value){
				style.setSkewX(value);
				this._tfChanged=true;
				this._renderType |=0x04;
				var p=this._parent;
				p && p._repaint===0 && (p._repaint=1,p.parentRepaint());
			}
		});

		/**
		*表示显示对象的宽度，以像素为单位。
		*/
		__getset(0,__proto,'width',function(){
			if (!this.autoSize)return this._width;
			return this.getSelfBounds().width;
			},function(value){
			this._width!==value && (this._width=value,this.model && this.model.size(value,this._height),this.repaint());
		});

		/**
		*表示显示对象的高度，以像素为单位。
		*/
		__getset(0,__proto,'height',function(){
			if (!this.autoSize)return this._height;
			return this.getSelfBounds().height;
			},function(value){
			this._height!==value && (this._height=value,this.model && this.model.size(this._width,value),this.repaint());
		});

		/**手动设置的可点击区域，或者一个HitArea区域。*/
		__getset(0,__proto,'hitArea',function(){
			return this._$P.hitArea;
			},function(value){
			this._set$P("hitArea",value);
		});

		/**旋转角度，默认值为0。*/
		__getset(0,__proto,'rotation',function(){
			return this._style._tf.rotate;
			},function(value){
			var style=this.getStyle();
			if (style._tf.rotate!==value){
				style.setRotate(value);
				this._tfChanged=true;
				this.model && this.model.rotate(value);
				this._renderType |=0x04;
				var p=this._parent;
				p && p._repaint===0 && (p._repaint=1,p.parentRepaint());
			}
		});

		/**Y轴缩放值，默认值为1。*/
		__getset(0,__proto,'scaleY',function(){
			return this._style._tf.scaleY;
			},function(value){
			var style=this.getStyle();
			if (style._tf.scaleY!==value){
				style.setScaleY(value);
				this._tfChanged=true;
				this.model && this.model.scale(style._tf.scaleX,value);
				this._renderType |=0x04;
				var p=this._parent;
				p && p._repaint===0 && (p._repaint=1,p.parentRepaint());
			}
		});

		/**指定要使用的混合模式。*/
		__getset(0,__proto,'blendMode',function(){
			return this._style.blendMode;
			},function(value){
			this.getStyle().blendMode=value;
			this.model && this.model.blendMode(value);
			if (value && value !="source-over")this._renderType |=0x20;
			else this._renderType &=~0x20;
			this.parentRepaint();
		});

		/**垂直倾斜角度，默认值为0。*/
		__getset(0,__proto,'skewY',function(){
			return this._style._tf.skewY;
			},function(value){
			var style=this.getStyle();
			if (style._tf.skewY!==value){
				style.setSkewY(value);
				this._tfChanged=true;
				this.model && this.model.skew(style._tf.skewX,value);
				this._renderType |=0x04;
				var p=this._parent;
				p && p._repaint===0 && (p._repaint=1,p.parentRepaint());
			}
		});

		/**
		*对象的矩阵信息。
		*/
		__getset(0,__proto,'transform',function(){
			return this._tfChanged ? this._adjustTransform():this._transform;
			},function(value){
			this._tfChanged=false;
			this._transform=value;
			if (value){
				this._x=value.tx;
				this._y=value.ty;
				value.tx=value.ty=0;
				this.model && this.model.transform(value.a,value.b,value.c,value.d,this._x,this._y);
			}
			if (value)this._renderType |=0x04;
			else {
				this._renderType &=~0x04;
				this.model && this.model.removeType(0x04);
			}
			this.parentRepaint();
		});

		/**X轴 轴心点的位置，单位为像素，默认为0，轴心点会影响对象位置，缩放，旋转。*/
		__getset(0,__proto,'pivotX',function(){
			return this._style._tf.translateX;
			},function(value){
			this.getStyle().setTranslateX(value);
			this.model && this.model.pivot(value,this._style._tf.translateY);
			this.repaint();
		});

		/**Y轴 轴心点的位置，单位为像素，默认为0，轴心点会影响对象位置，缩放，旋转。*/
		__getset(0,__proto,'pivotY',function(){
			return this._style._tf.translateY;
			},function(value){
			this.getStyle().setTranslateY(value);
			this.model && this.model.pivot(this._style._tf.translateX,value);
			this.repaint();
		});

		/**透明度，值为0-1，默认值为1，表示不透明。*/
		__getset(0,__proto,'alpha',function(){
			return this._style.alpha;
			},function(value){
			if (this._style && this._style.alpha!==value){
				value=value < 0 ? 0 :(value > 1 ? 1 :value);
				this.getStyle().alpha=value;
				this.model && this.model.alpha(value);
				if (value!==1)this._renderType |=0x02;
				else this._renderType &=~0x02;
				this.parentRepaint();
			}
		});

		/**表示是否可见，默认为true。*/
		__getset(0,__proto,'visible',function(){
			return this._style.visible;
			},function(value){
			if (this._style && this._style.visible!==value){
				this.getStyle().visible=value;
				this.model && this.model.visible(value);
				this.parentRepaint();
			}
		});

		/**
		*获得全局Y轴缩放值
		*/
		__getset(0,__proto,'globalScaleY',function(){
			var scale=1;
			var ele=this;
			while (ele){
				if (ele===Laya.stage)break ;
				scale *=ele.scaleX;
				ele=ele.parent;
			}
			return scale;
		});

		/**绘图对象。*/
		__getset(0,__proto,'graphics',function(){
			return this._graphics || (this.graphics=RunDriver.createGraphics());
			},function(value){
			if (this._graphics)this._graphics._sp=null;
			this._graphics=value;
			if (value){
				this._renderType &=~0x01;
				this._renderType |=0x100;
				value._sp=this;
				this.model && this.model.graphics(this._graphics);
				}else {
				this._renderType &=~0x100;
				this._renderType &=~0x01;
				this.model && this.model.removeType(0x100);
			}
			this.repaint();
		});

		/**显示对象的滚动矩形范围。*/
		__getset(0,__proto,'scrollRect',function(){
			return this._style.scrollRect;
			},function(value){
			this.getStyle().scrollRect=value;
			this.repaint();
			if (value){
				this._renderType |=0x40;
				this.model && this.model.scrollRect(value.x,value.y,value.width,value.height);
				}else {
				this._renderType &=~0x40;
				this.model && this.model.removeType(0x40);
			}
		});

		/**滤镜集合。*/
		__getset(0,__proto,'filters',function(){
			return this._$P.filters;
			},function(value){
			value && value.length===0 && (value=null);
			if (this._$P.filters==value)return;
			this._set$P("filters",value ? value.slice():null);
			if (Render.isConchApp){
				this.model && this.model.removeType(0x10);
				if (this._$P.filters && this._$P.filters.length==1){
					this._$P.filters[0].callNative(this);
				}
			}
			if (Render.isWebGL){
				if (value && value.length){
					this._renderType |=0x10;
					}else {
					this._renderType &=~0x10;
				}
			}
			if (value && value.length > 0){
				if (!(Render.isWebGL && value.length==1 && (((value[0])instanceof laya.filters.ColorFilter )))){
					if (this.cacheAs !="bitmap"){
						if (!Render.isConchNode)this.cacheAs="bitmap";
						this._set$P("cacheForFilters",true);
					}
					this._set$P("hasFilter",true);
				}
				}else {
				this._set$P("hasFilter",false);
				if (this._$P["cacheForFilters"] && this.cacheAs=="bitmap"){
					this.cacheAs="none";
				}
			}
			this.repaint();
		});

		/**遮罩，可以设置一个对象或者图片，根据对象形状进行遮罩显示。*/
		__getset(0,__proto,'mask',function(){
			return this._$P._mask;
			},function(value){
			if (value && this.mask && this.mask._$P.maskParent)return;
			if (value){
				this.cacheAs="bitmap";
				this._set$P("_mask",value);
				value._set$P("maskParent",this);
				}else {
				this.cacheAs="none";
				this.mask && this.mask._set$P("maskParent",null);
				this._set$P("_mask",value);
			}
			this.model && this.model.mask(value ? value.model :null);
			this._renderType |=0x20;
			this.parentRepaint();
		});

		/**对舞台 <code>stage</code> 的引用。*/
		__getset(0,__proto,'stage',function(){
			return Laya.stage;
		});

		/**
		*是否接受鼠标事件。
		*默认为false，如果监听鼠标事件，则会自动设置本对象及父节点的属性 mouseEnable 的值都为 true（如果父节点手动设置为false，则不会更改）。
		**/
		__getset(0,__proto,'mouseEnabled',function(){
			return this._mouseEnableState > 1;
			},function(value){
			this._mouseEnableState=value ? 2 :1;
		});

		/**
		*获得全局X轴缩放值
		*/
		__getset(0,__proto,'globalScaleX',function(){
			var scale=1;
			var ele=this;
			while (ele){
				if (ele===Laya.stage)break ;
				scale *=ele.scaleX;
				ele=ele.parent;
			}
			return scale;
		});

		/**
		*表示鼠标在此对象上的 X 轴坐标信息。
		*/
		__getset(0,__proto,'mouseX',function(){
			return this.getMousePoint().x;
		});

		/**
		*表示鼠标在此对象上的 Y 轴坐标信息。
		*/
		__getset(0,__proto,'mouseY',function(){
			return this.getMousePoint().y;
		});

		/**z排序，更改此值，按照值的大小进行显示层级排序。*/
		__getset(0,__proto,'zOrder',function(){
			return this._zOrder;
			},function(value){
			if (this._zOrder !=value){
				this._zOrder=value;
				this._parent && Laya.timer.callLater(this._parent,this.updateZOrder);
			}
		});

		Sprite.fromImage=function(url){
			return new Sprite().loadImage(url);
		}

		Sprite.CustomList=[];
		return Sprite;
	})(Node)


	/**
	*<code>Sprite3D</code> 类用于实现3D精灵。
	*/
	//class laya.d3.core.Sprite3D extends laya.display.Node
	var Sprite3D1=(function(_super){
		function Sprite3D(name){
			this._id=0;
			this._enable=false;
			this._layerMask=0;
			this._componentsMap=[];
			this.transform=null;
			this.isStatic=false;
			Sprite3D.__super.call(this);
			this._components=[];
			this._wvpMatrix=new Matrix4x4();
			var _$this=this;
			(name)? (this.name=name):(this.name="Sprite3D-"+Sprite3D._nameNumberCounter++);
			this._enable=true;
			this._id=Sprite3D._uniqueIDCounter;
			Sprite3D._uniqueIDCounter++;
			this.layer=Layer.currentCreationLayer;
			this.transform=new Transform3D1(this);
			this.on("added",this,function(){
				_$this.transform._parent=(_$this._parent).transform;
			});
			this.on("removed",this,function(){
				_$this.transform._parent=null;
			});
		}

		__class(Sprite3D,'laya.d3.core.Sprite3D',_super,'Sprite3D1');
		var __proto=Sprite3D.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IUpdate":true,"laya.resource.IDispose":true})
		/**
		*清理自身渲染物体。
		*/
		__proto._clearSelfRenderObjects=function(){}
		/**
		*添加自身渲染物体。
		*/
		__proto._addSelfRenderObjects=function(){}
		/**
		*清理自身和子节点渲染物体,重写此函数。
		*/
		__proto._clearSelfAndChildrenRenderObjects=function(){
			this._clearSelfRenderObjects();
			for (var i=0;i < this._childs.length;i++)
			(this._childs [i])._clearSelfAndChildrenRenderObjects();
		}

		/**
		*添加自身和子节点渲染物体,重写此函数。
		*/
		__proto._addSelfAndChildrenRenderObjects=function(){
			this._addSelfRenderObjects();
			for (var i=0;i < this._childs.length;i++)
			(this._childs [i])._addSelfAndChildrenRenderObjects();
		}

		/**
		*更新组件update函数。
		*@param state 渲染相关状态。
		*/
		__proto._updateComponents=function(state){
			for (var i=0;i < this._components.length;i++){
				var component=this._components[i];
				(!component.started)&& (component._start(state),component.started=true);
				(component.isActive)&& (component._update(state));
			}
		}

		/**
		*更新组件lateUpdate函数。
		*@param state 渲染相关状态。
		*/
		__proto._lateUpdateComponents=function(state){
			for (var i=0;i < this._components.length;i++){
				var component=this._components[i];
				(!component.started)&& (component._start(state),component.started=true);
				(component.isActive)&& (component._lateUpdate(state));
			}
		}

		/**
		*更新子节点。
		*@param state 渲染相关状态。
		*/
		__proto._updateChilds=function(state){
			var n=this._childs.length;
			if (n===0)return;
			for (var i=0;i < n;++i){
				var child=this._childs[i];
				child._update((state));
			}
		}

		/**
		*排序函数。
		*@param state 渲染相关状态。
		*/
		__proto._getSortID=function(renderElement,material){
			return material.id *1000+renderElement.getVertexBuffer().vertexDeclaration.id;
		}

		/**
		*更新
		*@param state 渲染相关状态
		*/
		__proto._update=function(state){
			state.owner=this;
			var canView=state.renderClip.view(this);
			(canView)&& (this._updateComponents(state));
			(canView)&& (this._lateUpdateComponents(state));
			this._childs.length && this._updateChilds(state);
		}

		__proto.addChildAt=function(node,index){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			var returnNode=_super.prototype.addChildAt.call(this,node,index);
			(node!==this)&& ((node)._addSelfAndChildrenRenderObjects());
			return returnNode;
		}

		__proto.addChild=function(node){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			var returnNode=_super.prototype.addChild.call(this,node);
			(node!==this)&& ((node)._addSelfAndChildrenRenderObjects());
			return returnNode;
		}

		__proto.removeChildAt=function(index){
			var node=this.getChildAt(index);
			if (node){
				this._childs.splice(index,1);
				this.model && this.model.removeChild(node.model);
				node.parent=null;
				(node)._clearSelfAndChildrenRenderObjects();
			}
			return node;
		}

		/**
		*添加指定类型组件。
		*@param type 组件类型。
		*@return 组件。
		*/
		__proto.addComponent=function(type){
			if (!(this._componentsMap[type]===undefined))
				throw new Error("无法创建"+type+"组件"+"，"+type+"组件已存在！");
			var component=ClassUtils.getInstance(type);
			component._initialize(this);
			this._componentsMap[type]=this._components.length;
			this._components.push(component);
			this.event("componentadded",component);
			return component;
		}

		/**
		*获得指定类型组件。
		*@param type 组件类型。
		*@return 组件。
		*/
		__proto.getComponentByType=function(type){
			if (this._componentsMap[type]===undefined)
				return null;
			return this._components[this._componentsMap[type]];
		}

		/**
		*获得指定类型组件。
		*@param type 组件类型。
		*@return 组件。
		*/
		__proto.getComponentByIndex=function(index){
			return this._components[index];
		}

		/**
		*移除指定类型组件。
		*@param type 组件类型。
		*/
		__proto.removeComponent=function(type){
			if (this._componentsMap[type]===undefined)
				return;
			var component=this._components[this._componentsMap[type]];
			this._components.splice(this._componentsMap[type],1);
			delete this._componentsMap[type];
			this.event("componentremoved",component);
		}

		/**
		*移除全部组件。
		*/
		__proto.removeAllComponent=function(){
			for (var component in this._componentsMap)
			this.removeComponent(component);
		}

		/**
		*加载场景文件。
		*@param url 地址。
		*/
		__proto.loadHierarchy=function(url){
			var _$this=this;
			if (url===null)return;
			var loader=new Loader();
			url=URL.formatURL(url);
			var _this=this;
			var onComp=function (data){
				var preBasePath=URL.basePath;
				URL.basePath=URL.getPath(URL.formatURL(url));
				var sprite=ClassUtils.createByJson(data,null,_this,Handler.create(null,Utils3D._parseHierarchyProp,null,false),Handler.create(null,Utils3D._parseHierarchyNode,null,false));
				_$this.addChild(sprite);
				URL.basePath=preBasePath;
				_$this.event("hierarchyloaded",[_this,sprite]);
			}
			loader.once("complete",null,onComp);
			loader.load(url,"text");
		}

		__proto.dispose=function(){}
		/**
		*获取唯一标识ID。
		*@return 唯一标识ID。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*设置是否启用。
		*@param value 是否启动。
		*/
		/**
		*获取是否启用。
		*@return 是否激活。
		*/
		__getset(0,__proto,'enable',function(){
			return this._enable;
			},function(value){
			this._enable=value;
			this.event("enabledchanged",this._enable);
		});

		/**
		*获得WorldViewProjection矩阵。
		*@return 矩阵。
		*/
		__getset(0,__proto,'wvpMatrix',function(){
			return this._wvpMatrix;
		});

		/**
		*获取是否激活。
		*@return 是否激活。
		*/
		__getset(0,__proto,'active',function(){
			return Layer.isActive(this._layerMask)&& this._enable;
		});

		/**
		*获取是否显示。
		*@return 是否显示。
		*/
		__getset(0,__proto,'visible',function(){
			return Layer.isVisible(this._layerMask)&& this._enable;
		});

		/**
		*设置蒙版。
		*@param value 蒙版。
		*/
		/**
		*获取蒙版。
		*@return 蒙版。
		*/
		__getset(0,__proto,'layer',function(){
			return Layer.getLayerByMask(this._layerMask);
			},function(value){
			this._layerMask=value.mask;
			this.event("layerchanged",value);
		});

		/**
		*获得组件的数量。
		*@return 组件数量。
		*/
		__getset(0,__proto,'componentsCount',function(){
			return this._components.length;
		});

		/**
		*获得所属场景。
		*@return 场景。
		*/
		__getset(0,__proto,'scene',function(){
			return this.parent ? (this.parent).scene :null;
		});

		Sprite3D._uniqueIDCounter=1;
		Sprite3D._nameNumberCounter=0;
		return Sprite3D;
	})(Node)


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.utils.Buffer extends laya.resource.Resource
	var Buffer=(function(_super){
		function Buffer(){
			this._glBuffer=null;
			this._buffer=null;
			this._bufferType=0;
			this._bufferUsage=0;
			this._byteLength=0;
			Buffer.__super.call(this);
			Buffer._gl=WebGL.mainContext;
		}

		__class(Buffer,'laya.webgl.utils.Buffer',_super);
		var __proto=Buffer.prototype;
		__proto._bind=function(){
			this.activeResource();
			(Buffer._bindActive[this._bufferType]===this._glBuffer)|| (Buffer._gl.bindBuffer(this._bufferType,Buffer._bindActive[this._bufferType]=this._glBuffer),Shader.activeShader=null);
		}

		__proto.recreateResource=function(){
			this.startCreate();
			this._glBuffer || (this._glBuffer=Buffer._gl.createBuffer());
			this.compoleteCreate();
		}

		__proto.detoryResource=function(){
			if (this._glBuffer){
				WebGL.mainContext.deleteBuffer(this._glBuffer);
				this._glBuffer=null;
			}
			this.memorySize=0;
		}

		__proto.dispose=function(){
			this.resourceManager.removeResource(this);
			_super.prototype.dispose.call(this);
		}

		//TODO:私有
		__getset(0,__proto,'byteLength',function(){
			return this._byteLength;
		});

		__getset(0,__proto,'bufferType',function(){
			return this._bufferType;
		});

		__getset(0,__proto,'bufferUsage',function(){
			return this._bufferUsage;
		});

		Buffer._gl=null
		Buffer._bindActive={};
		return Buffer;
	})(Resource)


	/**
	*<code>BaseMesh</code> 类用于创建网格,抽象类,不允许实例。
	*/
	//class laya.d3.resource.models.BaseMesh extends laya.resource.Resource
	var BaseMesh=(function(_super){
		function BaseMesh(){
			this._loaded=false;
			this._subMeshCount=0;
			this._boundingBox=null;
			this._boundingSphere=null;
			BaseMesh.__super.call(this);
			this._loaded=false;
			this._boundingBox=new BoundBox1(new Vector3(),new Vector3());
			this._boundingSphere=new BoundSphere1(new Vector3(),0);
		}

		__class(BaseMesh,'laya.d3.resource.models.BaseMesh',_super);
		var __proto=BaseMesh.prototype;
		/**
		*获取渲染单元数量,请重载此方法。
		*@return 渲染单元数量。
		*/
		__proto.getRenderElementsCount=function(){
			throw new Error("未Override,请重载该属性！");
		}

		/**
		*获取渲染单元,请重载此方法。
		*@param index 索引。
		*@return 渲染单元。
		*/
		__proto.getRenderElement=function(index){
			throw new Error("未Override,请重载该属性！");
		}

		/**@private 待开放。*/
		__proto.Render=function(){
			throw new Error("未Override,请重载该方法！");
		}

		/**@private 待开放。*/
		__proto.RenderSubMesh=function(subMeshIndex){
			throw new Error("未Override,请重载该方法！");
		}

		/**
		*获取是否已载入。
		*@return 是否已载入。
		*/
		__getset(0,__proto,'loaded',function(){
			return this._loaded;
		});

		/**
		*获取SubMesh的个数。
		*@return SubMesh的个数。
		*/
		__getset(0,__proto,'subMeshCount',function(){
			return this._subMeshCount;
		});

		/**
		*获取网格顶点,请重载此方法。
		*@return 网格顶点。
		*/
		__getset(0,__proto,'positions',function(){
			throw new Error("未Override,请重载该属性！");
		});

		return BaseMesh;
	})(Resource)


	/**
	*<code>RenderTarget</code> 类用于创建渲染目标。
	*/
	//class laya.d3.resource.RenderTarget extends laya.resource.Texture
	var RenderTarget=(function(_super){
		function RenderTarget(width,height,surfaceFormat,surfaceType,depthStencilFormat,mipMap,repeat,minFifter,magFifter){
			this._alreadyResolved=false;
			this._looked=false;
			this._surfaceFormat=0;
			this._surfaceType=0;
			this._depthStencilFormat=0;
			this._mipMap=false;
			this._repeat=false;
			this._minFifter=0;
			this._magFifter=0;
			this._size=null;
			RenderTarget.__super.call(this);
			(surfaceFormat===void 0)&& (surfaceFormat=0x1908);
			(surfaceType===void 0)&& (surfaceType=0x1401);
			(depthStencilFormat===void 0)&& (depthStencilFormat=0x81A5);
			(mipMap===void 0)&& (mipMap=false);
			(repeat===void 0)&& (repeat=false);
			(minFifter===void 0)&& (minFifter=-1);
			(magFifter===void 0)&& (magFifter=-1);
			this._w=width;
			this._h=height;
			this._surfaceFormat=surfaceFormat;
			this._surfaceType=surfaceType;
			this._depthStencilFormat=depthStencilFormat;
			this._mipMap=mipMap;
			this._repeat=repeat;
			this._minFifter=minFifter;
			this._magFifter=magFifter;
			this._size=new Size(width,height);
			this._createWebGLRenderTarget();
			this.bitmap.lock=true;
		}

		__class(RenderTarget,'laya.d3.resource.RenderTarget',_super);
		var __proto=RenderTarget.prototype;
		Laya.imps(__proto,{"laya.resource.IDispose":true})
		/**@private */
		__proto._createWebGLRenderTarget=function(){
			this.bitmap=new WebGLRenderTarget(this.width,this.height,this._surfaceFormat,this._surfaceType,this._depthStencilFormat,this._mipMap,this._repeat,this._minFifter,this._magFifter);
			this.bitmap.activeResource();
			this._alreadyResolved=true;
		}

		/**
		*开始绑定。
		*/
		__proto.start=function(){
			var gl=WebGL.mainContext;
			gl.bindFramebuffer(0x8D40,(this.bitmap).frameBuffer);
			RenderTarget._currentRenderTarget=this;
			this._alreadyResolved=false;
			RenderTarget._currentRenderTarget=this;
		}

		/**
		*清理并着色。
		*/
		__proto.clear=function(r,g,b,a){
			(r===void 0)&& (r=0.0);
			(g===void 0)&& (g=0.0);
			(b===void 0)&& (b=0.0);
			(a===void 0)&& (a=1.0);
			var gl=WebGL.mainContext;
			gl.clearColor(r,g,b,a);
			var clearFlag=0x00004000;
			switch (this._depthStencilFormat){
				case 0x81A5:
					clearFlag |=0x00000100;
					break ;
				case 0x8D48:
					clearFlag |=0x00000400;
					break ;
				case 0x84F9:
					clearFlag |=0x00000100;
					clearFlag |=0x00000400
					break ;
				}
			gl.clear(clearFlag);
		}

		/**
		*结束绑定。
		*/
		__proto.end=function(){
			var gl=WebGL.mainContext;
			gl.bindFramebuffer(0x8D40,null);
			RenderTarget._currentRenderTarget=null;
			this._alreadyResolved=true;
		}

		/**
		*获得像素数据。
		*@param x X像素坐标。
		*@param y Y像素坐标。
		*@param width 宽度。
		*@param height 高度。
		*@return 像素数据。
		*/
		__proto.getData=function(x,y,width,height){
			var gl=WebGL.mainContext;
			gl.bindFramebuffer(0x8D40,(this.bitmap).frameBuffer);
			var canRead=(gl.checkFramebufferStatus(0x8D40)===0x8CD5);
			if (!canRead){
				gl.bindFramebuffer(0x8D40,null);
				return null;
			};
			var pixels=new Uint8Array(this._w *this._h *4);
			gl.readPixels(x,y,width,height,this._surfaceFormat,this._surfaceType,pixels);
			gl.bindFramebuffer(0x8D40,null);
			return pixels;
		}

		/**
		*彻底清理资源,注意会强制解锁清理
		*/
		__proto.dispose=function(){
			this.bitmap.dispose();
		}

		__getset(0,__proto,'size',function(){
			return this._size;
		});

		/**
		*获取表面格式。
		*@return 表面格式。
		*/
		__getset(0,__proto,'surfaceFormat',function(){
			return this._surfaceFormat;
		});

		//}
		__getset(0,__proto,'minFifter',function(){
			return this._minFifter;
		});

		/**
		*获取表面类型。
		*@return 表面类型。
		*/
		__getset(0,__proto,'surfaceType',function(){
			return this._surfaceType;
		});

		/**
		*获取深度格式。
		*@return 深度格式。
		*/
		__getset(0,__proto,'depthStencilFormat',function(){
			return this._depthStencilFormat;
		});

		/**
		*获取是否为多级纹理。
		*@return 是否为多级纹理。
		*/
		__getset(0,__proto,'mipMap',function(){
			return this._mipMap;
		});

		__getset(0,__proto,'magFifter',function(){
			return this._magFifter;
		});

		/**
		*获取RenderTarget数据源。
		*@return RenderTarget数据源。
		*/
		__getset(0,__proto,'source',function(){
			if (this._alreadyResolved)
				return _super.prototype._$get_source.call(this);
			throw new Error("RenderTarget  还未准备好！");
		});

		RenderTarget._currentRenderTarget=null
		return RenderTarget;
	})(Texture)


	/**
	*@private
	*<code>Bitmap</code> 是图片资源类。
	*/
	//class laya.resource.Bitmap extends laya.resource.Resource
	var Bitmap=(function(_super){
		function Bitmap(){
			//this._source=null;
			//this._w=NaN;
			//this._h=NaN;
			this.useNum=0;
			Bitmap.__super.call(this);
			this._w=0;
			this._h=0;
		}

		__class(Bitmap,'laya.resource.Bitmap',_super);
		var __proto=Bitmap.prototype;
		/**
		*彻底清理资源。
		*/
		__proto.dispose=function(){
			this._resourceManager.removeResource(this);
			_super.prototype.dispose.call(this);
		}

		/***
		*HTML Image 或 HTML Canvas 或 WebGL Texture 。
		*/
		__getset(0,__proto,'source',function(){
			return this._source;
		});

		/***
		*宽度。
		*/
		__getset(0,__proto,'width',function(){
			return this._w;
		});

		/***
		*高度。
		*/
		__getset(0,__proto,'height',function(){
			return this._h;
		});

		return Bitmap;
	})(Resource)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.resource.RenderTarget2D extends laya.resource.Texture
	var RenderTarget2D=(function(_super){
		function RenderTarget2D(width,height,surfaceFormat,surfaceType,depthStencilFormat,mipMap,repeat,minFifter,magFifter){
			this._type=0;
			this._svWidth=NaN;
			this._svHeight=NaN;
			this._preRenderTarget=null;
			this._alreadyResolved=false;
			this._looked=false;
			this._surfaceFormat=0;
			this._surfaceType=0;
			this._depthStencilFormat=0;
			this._mipMap=false;
			this._repeat=false;
			this._minFifter=0;
			this._magFifter=0;
			this._destroy=false;
			(surfaceFormat===void 0)&& (surfaceFormat=0x1908);
			(surfaceType===void 0)&& (surfaceType=0x1401);
			(depthStencilFormat===void 0)&& (depthStencilFormat=0x81A5);
			(mipMap===void 0)&& (mipMap=false);
			(repeat===void 0)&& (repeat=false);
			(minFifter===void 0)&& (minFifter=-1);
			(magFifter===void 0)&& (magFifter=-1);
			this._type=1;
			this._w=width;
			this._h=height;
			this._surfaceFormat=surfaceFormat;
			this._surfaceType=surfaceType;
			this._depthStencilFormat=depthStencilFormat;
			this._mipMap=mipMap;
			this._repeat=repeat;
			this._minFifter=minFifter;
			this._magFifter=magFifter;
			this._createWebGLRenderTarget();
			this.bitmap.lock=true;
			RenderTarget2D.__super.call(this,this.bitmap,Texture.INV_UV);
		}

		__class(RenderTarget2D,'laya.webgl.resource.RenderTarget2D',_super);
		var __proto=RenderTarget2D.prototype;
		Laya.imps(__proto,{"laya.resource.IDispose":true})
		//TODO:临时......................................................
		__proto.getType=function(){
			return this._type;
		}

		//*/
		__proto.getTexture=function(){
			return this;
		}

		__proto.size=function(w,h){
			if (this.bitmap && this._w==w && this._h==h)
				return;
			this._w=w;
			this._h=h;
			this.release();
			this._createWebGLRenderTarget();
		}

		__proto.release=function(){
			this.destroy();
		}

		__proto.recycle=function(){
			RenderTarget2D.POOL.push(this);
		}

		__proto.start=function(){
			var gl=WebGL.mainContext;
			this._preRenderTarget=RenderState2D.curRenderTarget;
			RenderState2D.curRenderTarget=this;
			gl.bindFramebuffer(0x8D40,this.bitmap.frameBuffer);
			this._alreadyResolved=false;
			if (this._type==1){
				gl.viewport(0,0,this._w,this._h);
				this._svWidth=RenderState2D.width;
				this._svHeight=RenderState2D.height;
				RenderState2D.width=this._w;
				RenderState2D.height=this._h;
				Shader.activeShader=null;
			}
			return this;
		}

		__proto.clear=function(r,g,b,a){
			(r===void 0)&& (r=0.0);
			(g===void 0)&& (g=0.0);
			(b===void 0)&& (b=0.0);
			(a===void 0)&& (a=1.0);
			var gl=WebGL.mainContext;
			gl.clearColor(r,g,b,a);
			var clearFlag=0x00004000;
			switch (this._depthStencilFormat){
				case 0x81A5:
					clearFlag |=0x00000100;
					break ;
				case 0x8D48:
					clearFlag |=0x00000400;
					break ;
				case 0x84F9:
					clearFlag |=0x00000100;
					clearFlag |=0x00000400
					break ;
				}
			gl.clear(clearFlag);
		}

		__proto.end=function(){
			var gl=WebGL.mainContext;
			gl.bindFramebuffer(0x8D40,this._preRenderTarget ? this._preRenderTarget.bitmap.frameBuffer :null);
			this._alreadyResolved=true;
			RenderState2D.curRenderTarget=this._preRenderTarget;
			if (this._type==1){
				gl.viewport(0,0,this._svWidth,this._svHeight);
				RenderState2D.width=this._svWidth;
				RenderState2D.height=this._svHeight;
				Shader.activeShader=null;
			}else gl.viewport(0,0,Laya.stage.width,Laya.stage.height);
		}

		__proto.getData=function(x,y,width,height){
			var gl=WebGL.mainContext;
			gl.bindFramebuffer(0x8D40,(this.bitmap).frameBuffer);
			var canRead=(gl.checkFramebufferStatus(0x8D40)===0x8CD5);
			if (!canRead){
				gl.bindFramebuffer(0x8D40,null);
				return null;
			};
			var pixels=new Uint8Array(this._w *this._h *4);
			gl.readPixels(x,y,width,height,this._surfaceFormat,this._surfaceType,pixels);
			gl.bindFramebuffer(0x8D40,null);
			return pixels;
		}

		/**彻底清理资源,注意会强制解锁清理*/
		__proto.destroy=function(foreDiposeTexture){
			(foreDiposeTexture===void 0)&& (foreDiposeTexture=false);
			if (!this._destroy){
				this._loaded=false;
				this.bitmap.dispose();
				this.bitmap=null;
				this._destroy=true;
				_super.prototype.destroy.call(this);
			}
		}

		//待测试
		__proto.dispose=function(){}
		__proto._createWebGLRenderTarget=function(){
			this.bitmap=new WebGLRenderTarget(this.width,this.height,this._surfaceFormat,this._surfaceType,this._depthStencilFormat,this._mipMap,this._repeat,this._minFifter,this._magFifter);
			this.bitmap.activeResource();
			this._alreadyResolved=true;
			this._destroy=false;
			this._loaded=true;
		}

		__getset(0,__proto,'surfaceFormat',function(){
			return this._surfaceFormat;
		});

		//}
		__getset(0,__proto,'minFifter',function(){
			return this._minFifter;
		});

		__getset(0,__proto,'surfaceType',function(){
			return this._surfaceType;
		});

		__getset(0,__proto,'depthStencilFormat',function(){
			return this._depthStencilFormat;
		});

		__getset(0,__proto,'mipMap',function(){
			return this._mipMap;
		});

		__getset(0,__proto,'magFifter',function(){
			return this._magFifter;
		});

		/**返回RenderTarget的Texture*/
		__getset(0,__proto,'source',function(){
			if (this._alreadyResolved)
				return _super.prototype._$get_source.call(this);
			throw new Error("RenderTarget  还未准备好！");
		});

		RenderTarget2D.create=function(w,h,surfaceFormat,surfaceType,depthStencilFormat,mipMap,repeat,minFifter,magFifter){
			(surfaceFormat===void 0)&& (surfaceFormat=0x1908);
			(surfaceType===void 0)&& (surfaceType=0x1401);
			(depthStencilFormat===void 0)&& (depthStencilFormat=0x81A5);
			(mipMap===void 0)&& (mipMap=false);
			(repeat===void 0)&& (repeat=false);
			(minFifter===void 0)&& (minFifter=-1);
			(magFifter===void 0)&& (magFifter=-1);
			var t=RenderTarget2D.POOL.pop();
			t || (t=new RenderTarget2D(w,h));
			if (!t.bitmap ||
				t._w !=w ||
			t._h !=h ||
			t._surfaceFormat !=surfaceFormat ||
			t._surfaceType !=surfaceType ||
			t._depthStencilFormat !=depthStencilFormat ||
			t._mipMap !=mipMap ||
			t._repeat !=repeat ||
			t._minFifter !=minFifter ||
			t._magFifter !=magFifter){
				t._w=w;
				t._h=h;
				t._surfaceFormat=surfaceFormat;
				t._surfaceType=surfaceType;
				t._depthStencilFormat=depthStencilFormat;
				t._mipMap=mipMap;
				t._repeat=repeat;
				t._minFifter=minFifter;
				t._magFifter=magFifter;
				t.release();
				t._createWebGLRenderTarget();
			}
			return t;
		}

		RenderTarget2D.TYPE2D=1;
		RenderTarget2D.TYPE3D=2;
		RenderTarget2D.POOL=[];
		return RenderTarget2D;
	})(Texture)


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.shader.d2.fillTexture.FillTextureShaderValue extends laya.webgl.shader.d2.value.Value2D
	var FillTextureShaderValue=(function(_super){
		function FillTextureShaderValue(){
			this.texcoord=null;
			this.u_texRange=[0,1,0,1];
			this.u_offset=[0.5,0.5];
			FillTextureShaderValue.__super.call(this,0,0);
			var _vlen=8 *CONST3D2D.BYTES_PE;
			this.position=[2,0x1406,false,_vlen,0];
			this.texcoord=[2,0x1406,false,_vlen,2 *CONST3D2D.BYTES_PE];
			this.color=[4,0x1406,false,_vlen,4 *CONST3D2D.BYTES_PE];
		}

		__class(FillTextureShaderValue,'laya.webgl.shader.d2.fillTexture.FillTextureShaderValue',_super);
		FillTextureShaderValue.instance=function(){
			return FillTextureShaderValue._fillTextureShaderValue=FillTextureShaderValue._fillTextureShaderValue|| new FillTextureShaderValue();
		}

		FillTextureShaderValue._fillTextureShaderValue=null
		return FillTextureShaderValue;
	})(Value2D)


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.shader.d2.skinAnishader.aniShaderValue extends laya.webgl.shader.d2.value.Value2D
	var aniShaderValue1=(function(_super){
		function aniShaderValue(){
			this.texcoord=null;
			aniShaderValue.__super.call(this,0,0);
			var _vlen=8 *CONST3D2D.BYTES_PE;
			this.position=[2,0x1406,false,_vlen,0];
			this.texcoord=[2,0x1406,false,_vlen,2 *CONST3D2D.BYTES_PE];
			this.color=[4,0x1406,false,_vlen,4 *CONST3D2D.BYTES_PE];
		}

		__class(aniShaderValue,'laya.webgl.shader.d2.skinAnishader.aniShaderValue',_super,'aniShaderValue1');
		aniShaderValue.instance=function(){
			return aniShaderValue._aniShaderValue=aniShaderValue._aniShaderValue|| new aniShaderValue();
		}

		aniShaderValue._aniShaderValue=null
		return aniShaderValue;
	})(Value2D)


	//class laya.webgl.shader.d2.value.Color2dSV extends laya.webgl.shader.d2.value.Value2D
	var Color2dSV=(function(_super){
		function Color2dSV(args){
			Color2dSV.__super.call(this,0x02,0);
			this.color=[];
		}

		__class(Color2dSV,'laya.webgl.shader.d2.value.Color2dSV',_super);
		var __proto=Color2dSV.prototype;
		__proto.setValue=function(value){
			value.fillStyle&&(this.color=value.fillStyle._color._color);
			value.strokeStyle&&(this.color=value.strokeStyle._color._color);
		}

		return Color2dSV;
	})(Value2D)


	//class laya.webgl.shader.d2.value.TextureSV extends laya.webgl.shader.d2.value.Value2D
	var TextureSV=(function(_super){
		function TextureSV(subID){
			this.u_colorMatrix=null;
			this.strength=0;
			this.colorMat=null;
			this.colorAlpha=null;
			this.texcoord=Value2D._TEXCOORD;
			(subID===void 0)&& (subID=0);
			TextureSV.__super.call(this,0x01,subID);
		}

		__class(TextureSV,'laya.webgl.shader.d2.value.TextureSV',_super);
		var __proto=TextureSV.prototype;
		__proto.setValue=function(vo){
			this.ALPHA=vo.ALPHA;
			vo.filters && this.setFilters(vo.filters);
		}

		__proto.clear=function(){
			this.texture=null;
			this.shader=null;
			this.defines.setValue(0);
		}

		return TextureSV;
	})(Value2D)


	//class laya.webgl.shader.d2.value.PrimitiveSV extends laya.webgl.shader.d2.value.Value2D
	var PrimitiveSV=(function(_super){
		function PrimitiveSV(args){
			this.a_color=null;
			PrimitiveSV.__super.call(this,0x04,0);
			this.position=[2,0x1406,false,5 *CONST3D2D.BYTES_PE,0];
			this.a_color=[3,0x1406,false,5 *CONST3D2D.BYTES_PE,2 *CONST3D2D.BYTES_PE];
		}

		__class(PrimitiveSV,'laya.webgl.shader.d2.value.PrimitiveSV',_super);
		return PrimitiveSV;
	})(Value2D)


	/**
	*@private
	*audio标签播放声音的音轨控制
	*/
	//class laya.media.h5audio.AudioSoundChannel extends laya.media.SoundChannel
	var AudioSoundChannel=(function(_super){
		function AudioSoundChannel(audio){
			this._audio=null;
			this._onEnd=null;
			this._resumePlay=null;
			AudioSoundChannel.__super.call(this);
			this._onEnd=Utils.bind(this.__onEnd,this);
			this._resumePlay=Utils.bind(this.__resumePlay,this);
			audio.addEventListener("ended",this._onEnd);
			this._audio=audio;
		}

		__class(AudioSoundChannel,'laya.media.h5audio.AudioSoundChannel',_super);
		var __proto=AudioSoundChannel.prototype;
		__proto.__onEnd=function(){
			if (this.loops==1){
				if (this.completeHandler){
					Laya.timer.once(10,this,this.__runComplete,[this.completeHandler],false);
					this.completeHandler=null;
				}
				this.stop();
				this.event("complete");
				return;
			}
			if (this.loops > 0){
				this.loops--;
			}
			this.play();
		}

		__proto.__resumePlay=function(){
			try {
				this._audio.removeEventListener("canplay",this._resumePlay);
				this._audio.currentTime=this.startTime;
				Browser.container.appendChild(this._audio);
				this._audio.play();
				}catch (e){
				this.event("error");
			}
		}

		/**
		*播放
		*/
		__proto.play=function(){
			try {
				this._audio.currentTime=this.startTime;
				}catch (e){
				this._audio.addEventListener("canplay",this._resumePlay);
				return;
			}
			Browser.container.appendChild(this._audio);
			this._audio.play();
		}

		/**
		*停止播放
		*
		*/
		__proto.stop=function(){
			this.isStopped=true;
			SoundManager.removeChannel(this);
			this.completeHandler=null;
			if (!this._audio)
				return;
			this._audio.pause();
			this._audio.removeEventListener("ended",this._onEnd);
			this._audio.removeEventListener("canplay",this._resumePlay);
			Pool.recover("audio:"+this.url,this._audio);
			Browser.removeElement(this._audio);
			this._audio=null;
		}

		/**
		*当前播放到的位置
		*@return
		*
		*/
		__getset(0,__proto,'position',function(){
			if (!this._audio)
				return 0;
			return this._audio.currentTime;
		});

		/**
		*设置音量
		*@param v
		*
		*/
		/**
		*获取音量
		*@return
		*
		*/
		__getset(0,__proto,'volume',function(){
			if (!this._audio)return 1;
			return this._audio.volume;
			},function(v){
			if (!this._audio)return;
			this._audio.volume=v;
		});

		return AudioSoundChannel;
	})(SoundChannel)


	/**
	*@private
	*web audio api方式播放声音的音轨控制
	*/
	//class laya.media.webaudio.WebAudioSoundChannel extends laya.media.SoundChannel
	var WebAudioSoundChannel=(function(_super){
		function WebAudioSoundChannel(){
			this.audioBuffer=null;
			this.gain=null;
			this.bufferSource=null;
			this._currentTime=0;
			this._volume=1;
			this._startTime=0;
			this._onPlayEnd=null;
			this.context=WebAudioSound.ctx;
			WebAudioSoundChannel.__super.call(this);
			this._onPlayEnd=Utils.bind(this.__onPlayEnd,this);
			if (this.context["createGain"]){
				this.gain=this.context["createGain"]();
				}else {
				this.gain=this.context["createGainNode"]();
			}
		}

		__class(WebAudioSoundChannel,'laya.media.webaudio.WebAudioSoundChannel',_super);
		var __proto=WebAudioSoundChannel.prototype;
		/**
		*播放声音
		*/
		__proto.play=function(){
			this._clearBufferSource();
			if (!this.audioBuffer)return;
			var context=this.context;
			var gain=this.gain;
			var bufferSource=context.createBufferSource();
			this.bufferSource=bufferSource;
			bufferSource.buffer=this.audioBuffer;
			bufferSource.connect(gain);
			if (gain)
				gain.disconnect();
			gain.connect(context.destination);
			bufferSource.onended=this._onPlayEnd;
			this._startTime=Browser.now();
			this.gain.gain.value=this._volume;
			if (this.loops==0){
				bufferSource.loop=true;
			}
			bufferSource.start(0,this.startTime);
			this._currentTime=0;
		}

		__proto.__onPlayEnd=function(){
			if (this.loops==1){
				if (this.completeHandler){
					Laya.timer.once(10,this,this.__runComplete,[this.completeHandler],false);
					this.completeHandler=null;
				}
				this.stop();
				this.event("complete");
				return;
			}
			if (this.loops > 0){
				this.loops--;
			}
			this.play();
		}

		__proto._clearBufferSource=function(){
			if (this.bufferSource){
				var sourceNode=this.bufferSource;
				if (sourceNode.stop){
					sourceNode.stop(0);
					}else {
					sourceNode.noteOff(0);
				}
				sourceNode.disconnect(0);
				sourceNode.onended=null;
				if (!WebAudioSoundChannel._tryCleanFailed)this._tryClearBuffer(sourceNode);
				this.bufferSource=null;
			}
		}

		__proto._tryClearBuffer=function(sourceNode){
			try {sourceNode.buffer=WebAudioSound._miniBuffer;}catch (e){WebAudioSoundChannel._tryCleanFailed=true;}
		}

		/**
		*停止播放
		*/
		__proto.stop=function(){
			this._clearBufferSource();
			this.audioBuffer=null;
			if (this.gain)
				this.gain.disconnect();
			this.isStopped=true;
			SoundManager.removeChannel(this);
			this.completeHandler=null;
		}

		/**
		*获取当前播放位置
		*/
		__getset(0,__proto,'position',function(){
			if (this.bufferSource){
				return (Browser.now()-this._startTime)/ 1000+this.startTime;
			}
			return 0;
		});

		/**
		*设置音量
		*/
		/**
		*获取音量
		*/
		__getset(0,__proto,'volume',function(){
			return this._volume;
			},function(v){
			if (this.isStopped){
				return;
			}
			this._volume=v;
			this.gain.gain.value=v;
		});

		WebAudioSoundChannel._tryCleanFailed=false;
		return WebAudioSoundChannel;
	})(SoundChannel)


	//class specter3d.engine.core.camera.PerspectiveCamera3D extends specter3d.engine.core.camera.Camera3D
	var PerspectiveCamera3D=(function(_super){
		function PerspectiveCamera3D(fov,aspect,near,far){
			this._fov=45;
			(fov===void 0)&& (fov=45);
			(aspect===void 0)&& (aspect=1);
			(near===void 0)&& (near=0.1);
			(far===void 0)&& (far=2000);
			this._fov=fov;
			PerspectiveCamera3D.__super.call(this,aspect,near,far);
		}

		__class(PerspectiveCamera3D,'specter3d.engine.core.camera.PerspectiveCamera3D',_super);
		var __proto=PerspectiveCamera3D.prototype;
		__proto.updateProjectionMatrix=function(){
			var m=this._projectMatrix.rawData;
			var angle=this.fov *(Math.PI / 180.0);
			var yScale=Math.tan((Math.PI-angle)/ 2.0);
			var xScale=yScale / this.aspect;
			m[0]=xScale;
			m[1]=0;
			m[2]=0;
			m[3]=0;
			m[4]=0;
			m[5]=yScale;
			m[6]=0;
			m[7]=0;
			m[8]=0;
			m[9]=0;
			m[10]=this.far / (this.far-this.near);
			m[11]=1;
			m[12]=0;
			m[13]=0;
			m[14]=-this.near *this.far / (this.far-this.near);
			m[15]=0;
			this._projectMatrix.copyRawDataFrom(m);
		}

		__getset(0,__proto,'fov',function(){
			return this._fov;
			},function(value){
			this._fov=value;
			this._dirty=true;
		});

		return PerspectiveCamera3D;
	})(Camera3D)


	;
	/**
	*平行光
	*@author wangcx
	*
	*/
	//class specter3d.engine.lights.DirectionLight extends specter3d.engine.lights.LightBase
	var DirectionLight=(function(_super){
		function DirectionLight(xDir,yDir,zDir){
			this._direction=null;
			(xDir===void 0)&& (xDir=0);
			(yDir===void 0)&& (yDir=-1);
			(zDir===void 0)&& (zDir=1);
			DirectionLight.__super.call(this,0x00);
			this.direction=new Vector3D(xDir,yDir,zDir);
		}

		__class(DirectionLight,'specter3d.engine.lights.DirectionLight',_super);
		var __proto=DirectionLight.prototype;
		__getset(0,__proto,'direction',function(){
			return this._direction;
			},function(value){
			this._direction=value;
			this._direction.normalize();
		});

		return DirectionLight;
	})(LightBase)


	/**
	*点光源
	*@author wangcx
	*
	*/
	//class specter3d.engine.lights.PointLight extends specter3d.engine.lights.LightBase
	var PointLight=(function(_super){
		function PointLight(){
			this._range=6.0;
			this._attenuation=new Vector3D(0.5,0.5,0.5);
			PointLight.__super.call(this,0x01);
		}

		__class(PointLight,'specter3d.engine.lights.PointLight',_super);
		var __proto=PointLight.prototype;
		/**
		*@private
		*/
		/**
		*衰减
		*/
		__getset(0,__proto,'attenuation',function(){
			return this._attenuation;
			},function(value){
			this._attenuation=value;
		});

		/**
		*@private
		*/
		/**
		*范围半径
		*/
		__getset(0,__proto,'range',function(){
			return this._range;
			},function(value){
			this._range=value < 1 ? 1 :value;
		});

		return PointLight;
	})(LightBase)


	;
	/**
	*网格
	*@author wangcx
	*
	*/
	//class specter3d.engine.objects.Mesh3D extends specter3d.engine.core.Entity3D
	var Mesh3D=(function(_super){
		function Mesh3D(geos,mats){
			this._geometry=null;
			this._materials=null;
			this._render=null;
			this._animator=null;
			this._surfaces=[];
			Mesh3D.__super.call(this);
			this._geometry=geos;
			this._materials=mats;
			if(this._geometry){
				for (var i=0;i < this._geometry.subGeometry.length;i++){
					var subGeometry=this._geometry.subGeometry[i];
					this.addSurface(i,subGeometry,this._materials);
				}
			}
			this._bound=new BoundBox();
		}

		__class(Mesh3D,'specter3d.engine.objects.Mesh3D',_super);
		var __proto=Mesh3D.prototype;
		__proto.updateBounds=function(){
			this._bound.fromGeometry(this._geometry);
			this._boundDirty=false;
		}

		__proto.addSurface=function(index,subGeometry,material){
			var surface3d=new Surface3D(index,subGeometry,this,material);
			this._surfaces.push(surface3d);
			return surface3d;
		}

		__proto.collectRender=function(camera,_context3d,_renderUnits){
			if (this.visible && this._surfaces.length > 0){
				for (var i=0;i < this._surfaces.length;i++){
					_renderUnits.push(this._surfaces[i]);
				}
			}
			specter3d.engine.core.Object3D.prototype.collectRender.call(this,camera,_context3d,_renderUnits);
		}

		__proto.getSurfaceIndex=function(surface3D){
			var index=0;
			for (var i=0;i < this._surfaces.length;++i){
				if (this._surfaces[i]==surface3D){
					index=i;
					break ;
				}
			}
			return index;
		}

		__getset(0,__proto,'animator',function(){
			return this._animator;
			},function(value){
			this._animator=value;
		});

		__getset(0,__proto,'geometry',function(){
			return this._geometry;
			},function(value){
			if (this._geometry !=value){
				this._geometry=value;
				this._boundDirty=true;
			}
		});

		__getset(0,__proto,'materials',function(){
			return this._materials;
			},function(value){
			this._materials=value;
		});

		__getset(0,__proto,'surfaces',function(){
			return this._surfaces;
		});

		return Mesh3D;
	})(Entity3D)


	;
	/**
	*纹理
	*@author wangcx
	*
	*/
	//class specter3d.engine.resources.BitmapTexture extends specter3d.engine.resources.TextureResource
	var BitmapTexture=(function(_super){
		function BitmapTexture(image,generateMipmaps){
			this._repeat=false;
			this._smooth=false;
			this._generateMipmaps=false;
			this._image=null;
			BitmapTexture.__super.call(this);
			(generateMipmaps===void 0)&& (generateMipmaps=false);
			this._image=image;
			this._generateMipmaps=generateMipmaps;
		}

		__class(BitmapTexture,'specter3d.engine.resources.BitmapTexture',_super);
		var __proto=BitmapTexture.prototype;
		__proto.upload=function(_context3d){
			if (HTMLImageValidate.isBitmapDataValid(this._image)){
				this._width=this._image.width;
				this._height=this._image.height;
				if (this._glTexture){
					_context3d.deleteTexture(this._glTexture);
				}
				this._glTexture=_context3d.createTexture();
				this._glTexture.image=this._image;
				_context3d.pixelStorei(0x9240,false);
				_context3d.bindTexture(0x0DE1,this._glTexture);
				_context3d.texImage2D(0x0DE1,0,0x1908,0x1908,0x1401,this._image.source);
				_context3d.texParameteri(0x0DE1,0x2802,this._repeat ? 0x2901 :0x812F);
				_context3d.texParameteri(0x0DE1,0x2803,this._repeat ? 0x2901 :0x812F);
				_context3d.texParameteri(0x0DE1,0x2800,this._smooth ? 0x2601 :0x2600);
				if (!this._generateMipmaps){
					_context3d.texParameteri(0x0DE1,0x2801,this._smooth ? 0x2601 :0x2600);
				}
				else{
					_context3d.texParameteri(0x0DE1,0x2801,this._smooth ? 0x2703 :0x2701);
					_context3d.generateMipmap(0x0DE1);
				}
			}
		}

		__proto.activeTexture=function(_context3d,activeIndex){
			_context3d.activeTexture(activeIndex);
			_context3d.bindTexture(0x0DE1,this._glTexture);
		}

		/**
		*@private
		*/
		/**HTML Image*/
		__getset(0,__proto,'image',function(){
			return this._image;
			},function(value){
			this._image=value;
		});

		BitmapTexture.__init$=function(){
			/*namespace*/;
			/*namespace*/;
			/*namespace*/;
		}

		return BitmapTexture;
	})(TextureResource)


	/**
	*<code>BaseCamera</code> 类用于创建摄像机的父类。
	*/
	//class laya.d3.core.BaseCamera extends laya.d3.core.Sprite3D
	var BaseCamera=(function(_super){
		function BaseCamera(nearPlane,farPlane){
			//this._tempVector3=null;
			//this._position=null;
			//this._up=null;
			//this._forward=null;
			//this._right=null;
			//this._masterCamera=null;
			//this._slavesCameras=null;
			//this._renderTarget=null;
			//this._renderingOrder=0;
			//this._renderTargetSize=null;
			//this._nearPlane=NaN;
			//this._farPlane=NaN;
			//this._fieldOfView=NaN;
			//this._orthographic=false;
			//this._orthographicVerticalSize=NaN;
			//this._useUserProjectionMatrix=false;
			//this._viewportExpressedInClipSpace=false;
			this._projectionMatrixModifyID=0;
			//this._partialRenderTarget=null;
			//this.clearColor=null;
			//this.cullingMask=0;
			BaseCamera.__super.call(this);
			(nearPlane===void 0)&& (nearPlane=0.1);
			(farPlane===void 0)&& (farPlane=1000);
			this._tempVector3=new Vector3();
			this._up=new Vector3();
			this._forward=new Vector3();
			this._right=new Vector3();
			this._fieldOfView=60;
			this._useUserProjectionMatrix=false;
			this._orthographic=false;
			this._viewportExpressedInClipSpace=true;
			this._slavesCameras=[];
			this._renderTargetSize=Size.fullScreen;
			this._orthographicVerticalSize=10;
			this.renderingOrder=0;
			this._nearPlane=nearPlane;
			this._farPlane=farPlane;
			this.cullingMask=2147483647;
			this.clearColor=new Vector4(100.0 / 255.0,149.0 / 255.0,237.0 / 255.0,255.0 / 255.0);
			this._calculateProjectionMatrix();
			Laya.stage.on("resize",this,this._onScreenSizeChanged);
		}

		__class(BaseCamera,'laya.d3.core.BaseCamera',_super);
		var __proto=BaseCamera.prototype;
		__proto._calculateProjectionMatrix=function(){}
		__proto._onScreenSizeChanged=function(){
			this._calculateProjectionMatrix();
		}

		/**
		*增加可视图层。
		*@param layer 图层。
		*/
		__proto.addLayer=function(layer){
			if (layer.number===29 || layer.number==30)
				return;
			this.cullingMask=this.cullingMask | layer.mask;
		}

		/**
		*移除可视图层。
		*@param layer 图层。
		*/
		__proto.removeLayer=function(layer){
			if (layer.number===29 || layer.number==30)
				return;
			this.cullingMask=this.cullingMask & ~layer.mask;
		}

		/**
		*增加所有图层。
		*/
		__proto.addAllLayers=function(){
			this.cullingMask=2147483647;
		}

		/**
		*移除所有图层。
		*/
		__proto.removeAllLayers=function(){
			this.cullingMask=0 | Layer.getLayerByNumber(29).mask | Layer.getLayerByNumber(30).mask;
		}

		__proto.ResetProjectionMatrix=function(){
			this._useUserProjectionMatrix=false;
			this._calculateProjectionMatrix();
		}

		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			this.masterCamera=null;
			this.renderTarget=null;
			Laya.stage.off("resize",this,this._onScreenSizeChanged);
			laya.display.Node.prototype.destroy.call(this,destroyChild);
		}

		/**
		*向前移动。
		*@param distance 移动距离。
		*/
		__proto.moveForward=function(distance){
			this._tempVector3.elements[0]=this._tempVector3.elements[1]=0;
			this._tempVector3.elements[2]=distance;
			this.transform.translate(this._tempVector3);
		}

		/**
		*向右移动。
		*@param distance 移动距离。
		*/
		__proto.moveRight=function(distance){
			this._tempVector3.elements[1]=this._tempVector3.elements[2]=0;
			this._tempVector3.elements[0]=distance;
			this.transform.translate(this._tempVector3);
		}

		/**
		*向上移动。
		*@param distance 移动距离。
		*/
		__proto.moveVertical=function(distance){
			this._tempVector3.elements[0]=this._tempVector3.elements[2]=0;
			this._tempVector3.elements[1]=distance;
			this.transform.translate(this._tempVector3,false);
		}

		/**获取位置。*/
		__getset(0,__proto,'position',function(){
			var worldMatrixe=this.transform.worldMatrix.elements;
			var positione=this._position.elements;
			positione[0]=worldMatrixe[12];
			positione[1]=worldMatrixe[13];
			positione[2]=worldMatrixe[14];
			return this._position;
		});

		/**
		*设置渲染目标的尺寸
		*@param value 渲染目标的尺寸。
		*/
		/**
		*获取渲染目标的尺寸
		*@return 渲染目标的尺寸。
		*/
		__getset(0,__proto,'renderTargetSize',function(){
			if (this._masterCamera !=null)
				return this._masterCamera.renderTargetSize;
			return this._renderTargetSize;
			},function(value){
			if (this._masterCamera !=null)
				return;
			if (this.renderTarget !=null && this._renderTargetSize !=value){}
				this._renderTargetSize=value;
			this._calculateProjectionMatrix();
		});

		/**
		*获取上向量。
		*@return 上向量。
		*/
		__getset(0,__proto,'up',function(){
			var worldMatrixe=this.transform.worldMatrix.elements;
			var upe=this._up.elements;
			upe[0]=worldMatrixe[4];
			upe[1]=worldMatrixe[5];
			upe[2]=worldMatrixe[6];
			return this._up;
		});

		/**
		*设置视野。
		*@param value 视野。
		*/
		/**
		*获取视野。
		*@return 视野。
		*/
		__getset(0,__proto,'fieldOfView',function(){
			return this._fieldOfView;
			},function(value){
			this._fieldOfView=value;
			this._calculateProjectionMatrix();
		});

		/**
		*获取前向量。
		*@return 前向量。
		*/
		__getset(0,__proto,'forward',function(){
			var worldMatrixe=this.transform.worldMatrix.elements;
			var forwarde=this._forward.elements;
			forwarde[0]=-worldMatrixe[8];
			forwarde[1]=-worldMatrixe[9];
			forwarde[2]=-worldMatrixe[10];
			return this._forward;
		});

		/**
		*获取右向量。
		*@return 右向量。
		*/
		__getset(0,__proto,'right',function(){
			var worldMatrixe=this.transform.worldMatrix.elements;
			var righte=this._right.elements;
			righte[0]=worldMatrixe[0];
			righte[1]=worldMatrixe[1];
			righte[2]=worldMatrixe[2];
			return this._right;
		});

		/**
		*设置主人摄像机，渲染类型、清除颜色和渲染目标值均来自主人摄像机。
		*@param 主人摄像机。
		*/
		/**
		*获取主人摄像机，渲染类型、清除颜色和渲染目标值均来自主人摄像机。
		*@return 主人摄像机。
		*/
		__getset(0,__proto,'masterCamera',function(){
			return this._masterCamera;
			},function(value){
			if (this._slavesCameras.length !=0 || (value !=null && value.masterCamera !=null))
				throw new Error("BaseCamera: A camera can't be master and slave simultaneity.");
			if (this.masterCamera !=null){
				var slavesCameras=this.masterCamera._slavesCameras;
				slavesCameras.splice(slavesCameras.indexOf(this),1);
			}
			this.masterCamera=value;
			if (value !=null){
				value._slavesCameras.push(this);
				for (var i=0;i < value._slavesCameras.length;i++){
					var count=value._slavesCameras.length;
					if (value._slavesCameras[i].renderingOrder > value._slavesCameras[count-1].renderingOrder){
						var temp=value._slavesCameras[count-1];
						value._slavesCameras[count-1]=value._slavesCameras[i];
						value._slavesCameras[i]=temp;
					}
				}
				this._renderTarget=null;
			}
		});

		/**
		*设置渲染场景的渲染目标，渲染目标同时存储主人相机和奴隶相机的结果。
		*@param value 渲染场景的渲染目标。
		*/
		/**
		*获取渲染场景的渲染目标，渲染目标同时存储主人相机和奴隶相机的结果。
		*@return 渲染场景的渲染目标。
		*/
		__getset(0,__proto,'renderTarget',function(){
			if (this._masterCamera !=null)
				return this._masterCamera.renderTarget;
			return this._renderTarget;
			},function(value){
			if (this._masterCamera !=null)
				return;
			this._renderTarget=value;
			if (value !=null)
				this._renderTargetSize=value.size;
		});

		/**
		*设置近裁面。
		*@param value 近裁面。
		*/
		/**
		*获取近裁面。
		*@return 近裁面。
		*/
		__getset(0,__proto,'nearPlane',function(){
			return this._nearPlane;
			},function(value){
			this._nearPlane=value;
			this._calculateProjectionMatrix();
		});

		/**
		*设置远裁面。
		*@param value 远裁面。
		*/
		/**
		*获取远裁面。
		*@return 远裁面。
		*/
		__getset(0,__proto,'farPlane',function(){
			return this._farPlane;
			},function(vaule){
			this._farPlane=vaule;
			this._calculateProjectionMatrix();
		});

		__getset(0,__proto,'renderingOrder',function(){
			return this._renderingOrder;
			},function(value){
			this._renderingOrder=value;
		});

		/**
		*设置是否正交投影矩阵。
		*@param 是否正交投影矩阵。
		*/
		/**
		*获取是否正交投影矩阵。
		*@return 是否正交投影矩阵。
		*/
		__getset(0,__proto,'orthographicProjection',function(){
			return this._orthographic;
			},function(vaule){
			this._orthographic=vaule;
			this._calculateProjectionMatrix();
		});

		/**
		*设置正交投影垂直矩阵尺寸。
		*@param 正交投影垂直矩阵尺寸。
		*/
		/**
		*获取正交投影垂直矩阵尺寸。
		*@return 正交投影垂直矩阵尺寸。
		*/
		__getset(0,__proto,'orthographicVerticalSize',function(){
			return this._orthographicVerticalSize;
			},function(vaule){
			this._orthographicVerticalSize=vaule;
			this._calculateProjectionMatrix();
		});

		/**
		*获取主摄像机，确保已经使用RenderingOrder排序。
		*@return 主摄像机。
		*/
		__getset(1,BaseCamera,'mainCamera',function(){
			for (var i=BaseCamera._cameraPool.length-1;i >=0;i--){
				if (BaseCamera._cameraPool[i].masterCamera==null && BaseCamera._cameraPool[i].enable)
					return BaseCamera._cameraPool[i];
			}
			return null;
		},laya.d3.core.Sprite3D._$SET_mainCamera);

		BaseCamera._sortCamerasByRenderingOrder=function(){
			var n=BaseCamera._cameraPool.length-1;
			for (var i=0;i < n;i++){
				if (BaseCamera._cameraPool[i].renderingOrder > BaseCamera._cameraPool[n].renderingOrder){
					var tempCamera=BaseCamera._cameraPool[i];
					BaseCamera._cameraPool[i]=BaseCamera._cameraPool[n];
					BaseCamera._cameraPool[n]=tempCamera;
				}
			}
		}

		BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING="DEFERREDLIGHTING";
		BaseCamera.RENDERINGTYPE_FORWARDRENDERING="FORWARDRENDERING";
		__static(BaseCamera,
		['_cameraPool',function(){return this._cameraPool=__newvec(2,null);}
		]);
		return BaseCamera;
	})(Sprite3D1)


	/**
	*<code>BaseScene</code> 类用于实现场景的父类。
	*/
	//class laya.d3.core.scene.BaseScene extends laya.display.Sprite
	var BaseScene=(function(_super){
		function BaseScene(){
			this._enableLightCount=3;
			this._renderTargetTexture=null;
			this._customRenderQueneIndex=11;
			this._lastCurrentTime=NaN;
			this.enableFog=false;
			this.fogStart=NaN;
			this.fogRange=NaN;
			this.fogColor=null;
			this.enableLight=true;
			this.currentCamera=null;
			BaseScene.__super.call(this);
			this._renderState=new RenderState();
			this._lights=new Array;
			this._shadingMode=0x2000;
			this._renderConfigs=[];
			this._quenes=[];
			this.enableFog=false;
			this.fogStart=300;
			this.fogRange=1000;
			this.fogColor=new Vector3(0.7,0.7,0.7);
			this._renderConfigs[0]=new RenderConfig();
			this._renderConfigs[0].depthTest=false;
			this._renderConfigs[1]=new RenderConfig();
			this._renderConfigs[2]=new RenderConfig();
			this._renderConfigs[2].cullFace=false;
			this._renderConfigs[4]=new RenderConfig();
			this._renderConfigs[4].cullFace=false;
			this._renderConfigs[4].blend=true;
			this._renderConfigs[4].sFactor=0x0302;
			this._renderConfigs[4].dFactor=0x0303;
			this._renderConfigs[6]=new RenderConfig();
			this._renderConfigs[6].cullFace=false;
			this._renderConfigs[6].blend=true;
			this._renderConfigs[6].sFactor=0x0302;
			this._renderConfigs[6].dFactor=1;
			this._renderConfigs[3]=new RenderConfig();
			this._renderConfigs[3].blend=true;
			this._renderConfigs[3].sFactor=0x0302;
			this._renderConfigs[3].dFactor=0x0303;
			this._renderConfigs[5]=new RenderConfig();
			this._renderConfigs[5].blend=true;
			this._renderConfigs[5].sFactor=0x0302;
			this._renderConfigs[5].dFactor=1;
			this._renderConfigs[8]=new RenderConfig();
			this._renderConfigs[8].cullFace=false;
			this._renderConfigs[8].blend=true;
			this._renderConfigs[8].depthMask=0;
			this._renderConfigs[8].sFactor=0x0302;
			this._renderConfigs[8].dFactor=0x0303;
			this._renderConfigs[10]=new RenderConfig();
			this._renderConfigs[10].cullFace=false;
			this._renderConfigs[10].blend=true;
			this._renderConfigs[10].depthMask=0;
			this._renderConfigs[10].sFactor=0x0302;
			this._renderConfigs[10].dFactor=1;
			this._renderConfigs[7]=new RenderConfig();
			this._renderConfigs[7].blend=true;
			this._renderConfigs[7].depthMask=0;
			this._renderConfigs[7].sFactor=0x0302;
			this._renderConfigs[7].dFactor=0x0303;
			this._renderConfigs[9]=new RenderConfig();
			this._renderConfigs[9].blend=true;
			this._renderConfigs[9].depthMask=0;
			this._renderConfigs[9].sFactor=0x0302;
			this._renderConfigs[9].dFactor=1;
		}

		__class(BaseScene,'laya.d3.core.scene.BaseScene',_super);
		var __proto=BaseScene.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		/**
		*@private
		*清除背景色。
		*@param gl WebGL上下文。
		*/
		__proto._clearColor=function(gl){
			var clearColore=this.currentCamera.clearColor.elements;
			gl.clearColor(clearColore[0],clearColore[1],clearColore[2],clearColore[3]);
			gl.clear(0x00004000 | 0x00000100);
		}

		/**
		*@private
		*场景相关渲染准备设置。
		*@param gl WebGL上下文。
		*@return state 渲染状态。
		*/
		__proto._prepareScene=function(gl,state){
			Layer._currentCameraCullingMask=this.currentCamera.cullingMask;
			state.context=WebGL.mainContext;
			state.elapsedTime=this._lastCurrentTime ? this.timer.currTimer-this._lastCurrentTime :0;
			this._lastCurrentTime=this.timer.currTimer;
			state.reset();
			state.loopCount=Stat.loopCount;
			state.shadingMode=this._shadingMode;
			state.scene=this;
			state.camera=this.currentCamera;
			var shaderValue=state.worldShaderValue;
			var loopCount=Stat.loopCount;
			this.currentCamera && shaderValue.pushValue("CAMERAPOS",this.currentCamera.transform.position.elements,loopCount);
			if (this._lights.length > 0){
				var lightCount=0;
				for (var i=0;i < this._lights.length;i++){
					var light=this._lights[i];
					if (!light.active)continue ;
					lightCount++;
					if (lightCount > this._enableLightCount)
						break ;
					light.updateToWorldState(state);
				}
			}
			if (this.enableFog){
				state.worldShaderValue.pushValue("FOGSTART",this.fogStart,loopCount);
				state.worldShaderValue.pushValue("FOGRANGE",this.fogRange,loopCount);
				state.worldShaderValue.pushValue("FOGCOLOR",this.fogColor.elements,loopCount);
			}
		}

		/**
		*@private
		*/
		__proto._updateScene=function(state){
			this._updateChilds(state);
		}

		/**
		*@private
		*/
		__proto._updateChilds=function(state){
			for (var i=0,n=this._childs.length;i < n;++i){
				var child=this._childs[i];
				child._update(state);
			}
		}

		/**
		*@private
		*/
		__proto._preRenderScene=function(gl,state){
			for (var i=0;i < this._quenes.length;i++){
				if (this._quenes[i]){
					this._quenes[i]._preRender(state);
				}
			}
		}

		/**
		*@private
		*/
		__proto._renderScene=function(gl,state){
			var viewport=state.viewport;
			gl.viewport(viewport.x,RenderState.clientHeight-viewport.y-viewport.height,viewport.width,viewport.height);
			for (var i=0;i < this._quenes.length;i++){
				if (this._quenes[i]){
					this._quenes[i]._setState(gl);
					this._quenes[i]._render(state);
				}
			}
		}

		/**
		*@private
		*/
		__proto._set3DRenderConfig=function(gl){
			gl.disable(0x0BE2);
			WebGLContext._blend=false;
			gl.blendFunc(0x0302,0x0303);
			WebGLContext._sFactor=0x0302;
			WebGLContext._dFactor=0x0303;
			gl.disable(0x0B71);
			WebGLContext._depthTest=false;
			gl.enable(0x0B44);
			WebGLContext._cullFace=true;
			gl.depthMask(1);
			WebGLContext._depthMask=1;
			gl.frontFace(0x0900);
			WebGLContext._frontFace=0x0900;
		}

		/**
		*@private
		*/
		__proto._set2DRenderConfig=function(gl){
			WebGLContext.setBlend(gl,true);
			WebGLContext.setBlendFunc(gl,0x0302,0x0303);
			WebGLContext.setDepthTest(gl,false);
			WebGLContext.setCullFace(gl,true);
			WebGLContext.setDepthMask(gl,1);
			WebGLContext.setFrontFaceCCW(gl,0x0901);
			gl.viewport(0,0,RenderState2D.width,RenderState2D.height);
		}

		/**
		*@private
		*/
		__proto._addLight=function(light){
			if (this._lights.indexOf(light)< 0)this._lights.push(light);
		}

		/**
		*@private
		*/
		__proto._removeLight=function(light){
			var index=this._lights.indexOf(light);
			index >=0 && (this._lights.splice(index,1));
		}

		__proto.addChildAt=function(node,index){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			var returnNode=laya.display.Node.prototype.addChildAt.call(this,node,index);
			(node!==this)&& ((node)._addSelfAndChildrenRenderObjects());
			return returnNode;
		}

		__proto.addChild=function(node){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			var returnNode=laya.display.Node.prototype.addChild.call(this,node);
			(node!==this)&& ((node)._addSelfAndChildrenRenderObjects());
			return returnNode;
		}

		__proto.removeChildAt=function(index){
			var node=this.getChildAt(index);
			if (node){
				this._childs.splice(index,1);
				this.model && this.model.removeChild(node.model);
				node.parent=null;
				(node)._clearSelfAndChildrenRenderObjects();
			}
			return node;
		}

		/**
		*获得某个渲染队列。
		*@param index 渲染队列索引。
		*@return 渲染队列。
		*/
		__proto.getRenderQueue=function(index){
			return (this._quenes[index] || (this._quenes[index]=new RenderQueue(this._renderConfigs[index])));
		}

		/**
		*获得某个渲染队列的渲染物体。
		*@param index 渲染队列索引。
		*@return 渲染物体。
		*/
		__proto.getRenderObject=function(index){
			return (this._quenes[index] || (this._quenes[index]=new RenderQueue(this._renderConfigs[index]))).getRenderObj();
		}

		/**
		*添加渲染队列。
		*@param renderConfig 渲染队列配置文件。
		*/
		__proto.addRenderQuene=function(renderConfig){
			this._quenes[this._customRenderQueneIndex++]=new RenderQueue(renderConfig);
		}

		/**
		*更新前处理,可重写此函数。
		*@param state 渲染相关状态。
		*/
		__proto.beforeUpate=function(state){}
		/**
		*更新后处理,可重写此函数。
		*@param state 渲染相关状态。
		*/
		__proto.lateUpate=function(state){}
		/**
		*渲染前处理,可重写此函数。
		*@param state 渲染相关状态。
		*/
		__proto.beforeRender=function(state){}
		/**
		*渲染后处理,可重写此函数。
		*@param state 渲染相关状态。
		*/
		__proto.lateRender=function(state){}
		/**
		*@private
		*/
		__proto.render=function(context,x,y){
			(Render._context.ctx)._shader2D.glTexture=null;
			this._childs.length > 0 && context.addRenderObject(this);
			this._renderType &=~0x800;
			_super.prototype.render.call(this,context,x,y);
		}

		/**
		*@private
		*/
		__proto.renderSubmit=function(){
			return 1;
		}

		/**
		*@private
		*/
		__proto.getRenderType=function(){
			return 0;
		}

		/**
		*@private
		*/
		__proto.releaseRender=function(){}
		/**
		*获取当前场景。
		*@return 当前场景。
		*/
		__getset(0,__proto,'scene',function(){
			return this;
		});

		/**
		*设置着色模式。
		*@param value 着色模式。
		*/
		/**
		*获取着色模式。
		*@return 着色模式。
		*/
		__getset(0,__proto,'shadingMode',function(){
			return this._shadingMode==0x1000 ? 0 :0x2000;
			},function(value){
			if (value!==0 && value!==1)throw Error("Scene set shadingMode,must:0 or 1,value="+value);
			this._shadingMode=value===0 ? 0x1000 :0x2000;
		});

		BaseScene.VERTEX_SHADING=0;
		BaseScene.PIXEL_SHADING=1;
		return BaseScene;
	})(Sprite)


	/**
	*<code>LightSprite</code> 类用于创建灯光的父类。
	*/
	//class laya.d3.core.light.LightSprite extends laya.d3.core.Sprite3D
	var LightSprite=(function(_super){
		function LightSprite(){
			this._diffuseColor=null;
			this._ambientColor=null;
			this._specularColor=null;
			this._reflectColor=null;
			LightSprite.__super.call(this);
			this.on("added",this,this._onAdded);
			this.on("removed",this,this._onRemoved);
			this._diffuseColor=new Vector3(0.8,0.8,0.8);
			this._ambientColor=new Vector3(0.6,0.6,0.6);
			this._specularColor=new Vector3(1.0,1.0,1.0);
			this._reflectColor=new Vector3(1.0,1.0,1.0);
		}

		__class(LightSprite,'laya.d3.core.light.LightSprite',_super);
		var __proto=LightSprite.prototype;
		/**
		*@private
		*灯光节点移除事件处理函数。
		*/
		__proto._onRemoved=function(){
			this.scene._removeLight(this);
		}

		/**
		*@private
		*灯光节点添加事件处理函数。
		*/
		__proto._onAdded=function(){
			this.scene._addLight(this);
		}

		/**
		*更新灯光相关渲染状态参数。
		*@param state 渲染状态参数。
		*/
		__proto.updateToWorldState=function(state){}
		/**
		*设置灯光的漫反射颜色。
		*@param value 灯光的漫反射颜色。
		*/
		/**
		*获取灯光的漫反射颜色。
		*@return 灯光的漫反射颜色。
		*/
		__getset(0,__proto,'diffuseColor',function(){
			return this._diffuseColor;
			},function(value){
			this._diffuseColor=value;
		});

		/**
		*获取灯光的类型。
		*@return 灯光的类型。
		*/
		__getset(0,__proto,'lightType',function(){
			return-1;
		});

		/**
		*设置灯光的环境光颜色。
		*@param value 灯光的环境光颜色。
		*/
		/**
		*获取灯光的环境光颜色。
		*@return 灯光的环境光颜色。
		*/
		__getset(0,__proto,'ambientColor',function(){
			return this._ambientColor;
			},function(value){
			this._ambientColor=value;
		});

		/**
		*设置灯光的高光颜色。
		*@param value 灯光的高光颜色。
		*/
		/**
		*获取灯光的高光颜色。
		*@return 灯光的高光颜色。
		*/
		__getset(0,__proto,'specularColor',function(){
			return this._specularColor;
			},function(value){
			this._specularColor=value;
		});

		/**
		*设置灯光的反射颜色。
		*@param value 灯光的反射颜色。
		*/
		/**
		*获取灯光的反射颜色。
		*@return 灯光的反射颜色。
		*/
		__getset(0,__proto,'reflectColor',function(){
			return this._reflectColor;
			},function(value){
			this._reflectColor=value;
		});

		LightSprite.TYPE_DIRECTIONLIGHT=1;
		LightSprite.TYPE_POINTLIGHT=2;
		LightSprite.TYPE_SPOTLIGHT=3;
		return LightSprite;
	})(Sprite3D1)


	/**
	*<code>MeshSprite3D</code> 类用于创建网格。
	*/
	//class laya.d3.core.MeshSprite3D extends laya.d3.core.Sprite3D
	var MeshSprite3D=(function(_super){
		function MeshSprite3D(mesh,name){
			this._renderObjects=null;
			this._meshFilter=null;
			this._meshRender=null;
			this._iAsyncLodingMeshMaterial=false;
			this._iAsyncLodingMeshMaterials=false;
			MeshSprite3D.__super.call(this,name);
			this._renderObjects=[];
			this._meshFilter=new MeshFilter(this);
			this._meshRender=new MeshRender(this);
			this._meshFilter.on("meshchanged",this,this._onMeshChanged);
			this._meshRender.on("materialchanged",this,this._onMaterialChanged);
			this._meshFilter.sharedMesh=mesh;
			if ((mesh instanceof laya.d3.resource.models.Mesh ))
				if (mesh.loaded){
				this._iAsyncLodingMeshMaterial=this._iAsyncLodingMeshMaterials=false;
				this._meshRender.shadredMaterials=(mesh).materials;
				}else {
				this._iAsyncLodingMeshMaterial=this._iAsyncLodingMeshMaterials=true;
				mesh.once("loaded",this,this._copyMaterials);
			}
		}

		__class(MeshSprite3D,'laya.d3.core.MeshSprite3D',_super);
		var __proto=MeshSprite3D.prototype;
		/**@private */
		__proto._onMeshChanged=function(meshFilter){}
		/**@private */
		__proto._onMaterialChanged=function(meshRender,materials){}
		/**@private */
		__proto._copyMaterials=function(mesh){
			if (this._iAsyncLodingMeshMaterials){
				if (this._iAsyncLodingMeshMaterial)
					this._meshRender.shadredMaterials=mesh.materials;
				else {
					var meshMaterials=mesh.materials;
					if (meshMaterials.length > 0){
						meshMaterials[0]=this._meshRender.shadredMaterial;
						this._meshRender.shadredMaterials=meshMaterials;
					}
				}
			}
			this._iAsyncLodingMeshMaterial=this._iAsyncLodingMeshMaterials=false;
		}

		/**@private */
		__proto._clearSelfRenderObjects=function(){
			for (var i=0,n=this._renderObjects.length;i < n;i++){
				var renderObj=this._renderObjects[i];
				renderObj.renderQneue.deleteRenderObj(renderObj);
			}
			this._renderObjects.length=0;
		}

		/**
		*@private
		*/
		__proto._update=function(state){
			state.owner=this;
			this._updateComponents(state);
			if (this.active){
				var renderElementsCount=this._meshFilter.sharedMesh.getRenderElementsCount();
				for (var i=0;i < renderElementsCount;i++){
					var obj=this._renderObjects[i];
					var materials=this._meshRender.shadredMaterials;
					if (obj){
						var material=materials[i];
						var renderQueue=state.scene.getRenderQueue(material.renderQueue);
						if (obj.renderQneue !=renderQueue){
							obj.renderQneue.deleteRenderObj(obj);
							obj=this._addRenderObject(state,i,material);
						}
						}else {
						obj=this._addRenderObject(state,i,materials[i]);
					}
				}
				this._lateUpdateComponents(state);
				}else {
				this._clearSelfRenderObjects();
			}
			Stat.spriteCount++;
			this._childs.length && this._updateChilds(state);
		}

		__proto._addRenderObject=function(state,index,material){
			var renderObj=state.scene.getRenderObject(material.renderQueue);
			this._renderObjects[index]=renderObj;
			var renderElement=this._meshFilter.sharedMesh.getRenderElement(index);
			renderObj.mainSortID=state.owner._getSortID(renderElement,material);
			renderObj.triangleCount=renderElement.triangleCount;
			renderObj.owner=state.owner;
			renderObj.renderElement=renderElement;
			renderObj.material=material;
			return renderObj;
		}

		__proto.dispose=function(){
			_super.prototype.dispose.call(this);
			this._meshFilter.off("meshchanged",this,this._onMeshChanged);
			this._meshRender.off("materialchanged",this,this._onMaterialChanged);
		}

		/**
		*获取网格过滤器。
		*@return 网格过滤器。
		*/
		__getset(0,__proto,'meshFilter',function(){
			return this._meshFilter;
		});

		/**
		*获取网格渲染器。
		*@return 网格渲染器。
		*/
		__getset(0,__proto,'meshRender',function(){
			return this._meshRender;
		});

		return MeshSprite3D;
	})(Sprite3D1)


	/**
	*<code>IndexBuffer3D</code> 类用于创建索引缓冲。
	*/
	//class laya.d3.graphics.IndexBuffer3D extends laya.webgl.utils.Buffer
	var IndexBuffer3D=(function(_super){
		function IndexBuffer3D(indexType,indexCount,bufferUsage,canRead){
			this._indexType=null;
			this._indexTypeByteCount=0;
			this._indexCount=0;
			this._canRead=false;
			(bufferUsage===void 0)&& (bufferUsage=0x88E4);
			(canRead===void 0)&& (canRead=false);
			IndexBuffer3D.__super.call(this);
			this._indexType=indexType;
			this._indexCount=indexCount;
			this._bufferUsage=bufferUsage;
			this._bufferType=0x8893;
			this._canRead=canRead;
			this._bind();
			var byteLength=0;
			if (indexType=="ushort")
				this._indexTypeByteCount=2;
			else if (indexType=="ubyte")
			this._indexTypeByteCount=1;
			else
			throw new Error("unidentification index type.");
			byteLength=this._indexTypeByteCount *indexCount;
			this._byteLength=byteLength;
			Buffer._gl.bufferData(this._bufferType,byteLength,this._bufferUsage);
			if (canRead){
				if (indexType=="ushort")
					this._buffer=new Uint16Array(indexCount);
				else if (indexType=="ubyte")
				this._buffer=new Uint8Array(indexCount);
				this.memorySize=byteLength *2;
				}else {
				this.memorySize=byteLength;
			}
		}

		__class(IndexBuffer3D,'laya.d3.graphics.IndexBuffer3D',_super);
		var __proto=IndexBuffer3D.prototype;
		/**
		*设置数据。
		*@param data 索引数据。
		*@param bufferOffset 索引缓冲中的偏移。
		*@param dataStartIndex 索引数据的偏移。
		*@param dataCount 索引数据的数量。
		*/
		__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
			(bufferOffset===void 0)&& (bufferOffset=0);
			(dataStartIndex===void 0)&& (dataStartIndex=0);
			(dataCount===void 0)&& (dataCount=4294967295);
			var byteCount=0;
			if (this._indexType=="ushort"){
				byteCount=2;
				if (dataStartIndex!==0 || dataCount!==4294967295)
					data=new Uint16Array(data.buffer,dataStartIndex *byteCount,dataCount);
				}else if (this._indexType=="ubyte"){
				byteCount=1;
				if (dataStartIndex!==0 || dataCount!==4294967295)
					data=new Uint8Array(data.buffer,dataStartIndex *byteCount,dataCount);
			}
			this._bind();
			Buffer._gl.bufferSubData(this._bufferType,bufferOffset *byteCount,data);
			if (this._canRead){
				if (bufferOffset!==0 || dataStartIndex!==0 || dataCount!==4294967295){
					var maxLength=this._buffer.length-bufferOffset;
					if (dataCount > maxLength)
						dataCount=maxLength;
					for (var i=0;i < dataCount;i++)
					this._buffer[bufferOffset+i]=data[i];
					}else {
					this._buffer=data;
				}
			}
		}

		/**
		*获取索引数据。
		*@return 索引数据。
		*/
		__proto.getData=function(){
			if (this._canRead)
				return this._buffer;
			else
			throw new Error("Can't read data from VertexBuffer with only write flag!");
		}

		/**彻底销毁索引缓冲。*/
		__proto.dispose=function(){
			this._buffer=null;
			_super.prototype.dispose.call(this);
			this.memorySize=0;
		}

		/**
		*获取索引类型。
		*@return 索引类型。
		*/
		__getset(0,__proto,'indexType',function(){
			return this._indexType;
		});

		/**
		*获取索引类型字节数量。
		*@return 索引类型字节数量。
		*/
		__getset(0,__proto,'indexTypeByteCount',function(){
			return this._indexTypeByteCount;
		});

		/**
		*获取索引个数。
		*@return 索引个数。
		*/
		__getset(0,__proto,'indexCount',function(){
			return this._indexCount;
		});

		/**
		*获取是否可读。
		*@return 是否可读。
		*/
		__getset(0,__proto,'canRead',function(){
			return this._canRead;
		});

		IndexBuffer3D.INDEXTYPE_UBYTE="ubyte";
		IndexBuffer3D.INDEXTYPE_USHORT="ushort";
		IndexBuffer3D.create=function(indexType,indexCount,bufferUsage,canRead){
			(bufferUsage===void 0)&& (bufferUsage=0x88E4);
			(canRead===void 0)&& (canRead=false);
			return new IndexBuffer3D(indexType,indexCount,bufferUsage,canRead);
		}

		return IndexBuffer3D;
	})(Buffer)


	/**
	*<code>VertexBuffer3D</code> 类用于创建顶点缓冲。
	*/
	//class laya.d3.graphics.VertexBuffer3D extends laya.webgl.utils.Buffer
	var VertexBuffer3D=(function(_super){
		function VertexBuffer3D(vertexDeclaration,vertexCount,bufferUsage,canRead){
			this._vertexDeclaration=null;
			this._vertexCount=0;
			this._canRead=false;
			(canRead===void 0)&& (canRead=false);
			VertexBuffer3D.__super.call(this);
			this._vertexDeclaration=vertexDeclaration;
			this._vertexCount=vertexCount;
			this._bufferUsage=bufferUsage;
			this._bufferType=0x8892;
			this._canRead=canRead;
			this._bind();
			var byteLength=this._vertexDeclaration.vertexStride *vertexCount;
			this._byteLength=byteLength;
			Buffer._gl.bufferData(this._bufferType,byteLength,this._bufferUsage);
			canRead && (this._buffer=new Float32Array(byteLength / 4));
		}

		__class(VertexBuffer3D,'laya.d3.graphics.VertexBuffer3D',_super);
		var __proto=VertexBuffer3D.prototype;
		/**
		*和索引缓冲一起绑定。
		*@param ib 索引缓冲。
		*/
		__proto.bindWithIndexBuffer=function(ib){
			(ib)&& (ib._bind());
			this._bind();
		}

		/**
		*设置数据。
		*@param data 顶点数据。
		*@param bufferOffset 顶点缓冲中的偏移。
		*@param dataStartIndex 顶点数据的偏移。
		*@param dataCount 顶点数据的数量。
		*/
		__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
			(bufferOffset===void 0)&& (bufferOffset=0);
			(dataStartIndex===void 0)&& (dataStartIndex=0);
			(dataCount===void 0)&& (dataCount=4294967295);
			if (dataStartIndex!==0 || dataCount!==4294967295)
				data=new Float32Array(data.buffer,dataStartIndex *4,dataCount);
			this._bind();
			Buffer._gl.bufferSubData(this._bufferType,bufferOffset *4,data);
			if (this._canRead){
				if (bufferOffset!==0 || dataStartIndex!==0 || dataCount!==4294967295){
					var maxLength=this._buffer.length-bufferOffset;
					if (dataCount > maxLength)
						dataCount=maxLength;
					for (var i=0;i < dataCount;i++)
					this._buffer[bufferOffset+i]=data[i];
					}else {
					this._buffer=data;
				}
			}
		}

		/**
		*获取顶点数据。
		*@return 顶点数据。
		*/
		__proto.getData=function(){
			if (this._canRead)
				return this._buffer;
			else
			throw new Error("Can't read data from VertexBuffer with only write flag!");
		}

		/**销毁顶点缓冲。*/
		__proto.detoryResource=function(){
			var elements=this._vertexDeclaration.getVertexElements();
			for (var i=0;i < elements.length;i++)
			WebGL.mainContext.disableVertexAttribArray(i);
			_super.prototype.detoryResource.call(this);
		}

		/**彻底销毁顶点缓冲。*/
		__proto.dispose=function(){
			_super.prototype.dispose.call(this);
			this._buffer=null;
			this._vertexDeclaration=null;
		}

		/**
		*获取顶点结构声明。
		*@return 顶点结构声明。
		*/
		__getset(0,__proto,'vertexDeclaration',function(){
			return this._vertexDeclaration;
		});

		/**
		*获取顶点个数。
		*@return 顶点个数。
		*/
		__getset(0,__proto,'vertexCount',function(){
			return this._vertexCount;
		});

		/**
		*获取是否可读。
		*@return 是否可读。
		*/
		__getset(0,__proto,'canRead',function(){
			return this._canRead;
		});

		VertexBuffer3D.create=function(vertexDeclaration,vertexCount,bufferUsage,canRead){
			(bufferUsage===void 0)&& (bufferUsage=0x88E4);
			(canRead===void 0)&& (canRead=false);
			return new VertexBuffer3D(vertexDeclaration,vertexCount,bufferUsage,canRead);
		}

		return VertexBuffer3D;
	})(Buffer)


	/**
	*<p> <code>Text</code> 类用于创建显示对象以显示文本。</p>
	*@example 以下示例代码，创建了一个 <code>Text</code> 实例。
	*<listing version="3.0">
	*package
	*{
		*import laya.display.Text;
		*public class Text_Example
		*{
			*public function Text_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*var text:Text=new Text();//创建一个 Text 类的实例对象 text 。
				*text.text="这个是一个 Text 文本示例。";
				*text.color="#008fff";//设置 text 的文本颜色。
				*text.font="Arial";//设置 text 的文本字体。
				*text.bold=true;//设置 text 的文本显示为粗体。
				*text.fontSize=30;//设置 text 的字体大小。
				*text.wordWrap=true;//设置 text 的文本自动换行。
				*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
				*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
				*text.width=300;//设置 text 的宽度。
				*text.height=200;//设置 text 的高度。
				*text.italic=true;//设置 text 的文本显示为斜体。
				*text.borderColor="#fff000";//设置 text 的文本边框颜色。
				*Laya.stage.addChild(text);//将 text 添加到显示列表。
				*}
			*}
		*}
	*</listing>
	*<listing version="3.0">
	*Text_Example();
	*function Text_Example()
	*{
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*onInit();
		*}
	*function onInit()
	*{
		*var text=new laya.display.Text();//创建一个 Text 类的实例对象 text 。
		*text.text="这个是一个 Text 文本示例。";
		*text.color="#008fff";//设置 text 的文本颜色。
		*text.font="Arial";//设置 text 的文本字体。
		*text.bold=true;//设置 text 的文本显示为粗体。
		*text.fontSize=30;//设置 text 的字体大小。
		*text.wordWrap=true;//设置 text 的文本自动换行。
		*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
		*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
		*text.width=300;//设置 text 的宽度。
		*text.height=200;//设置 text 的高度。
		*text.italic=true;//设置 text 的文本显示为斜体。
		*text.borderColor="#fff000";//设置 text 的文本边框颜色。
		*Laya.stage.addChild(text);//将 text 添加到显示列表。
		*}
	*</listing>
	*<listing version="3.0">
	*class Text_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*var text:laya.display.Text=new laya.display.Text();//创建一个 Text 类的实例对象 text 。
			*text.text="这个是一个 Text 文本示例。";
			*text.color="#008fff";//设置 text 的文本颜色。
			*text.font="Arial";//设置 text 的文本字体。
			*text.bold=true;//设置 text 的文本显示为粗体。
			*text.fontSize=30;//设置 text 的字体大小。
			*text.wordWrap=true;//设置 text 的文本自动换行。
			*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
			*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
			*text.width=300;//设置 text 的宽度。
			*text.height=200;//设置 text 的高度。
			*text.italic=true;//设置 text 的文本显示为斜体。
			*text.borderColor="#fff000";//设置 text 的文本边框颜色。
			*Laya.stage.addChild(text);//将 text 添加到显示列表。
			*}
		*}
	*</listing>
	*/
	//class laya.display.Text extends laya.display.Sprite
	var Text=(function(_super){
		function Text(){
			this._clipPoint=null;
			this._currBitmapFont=null;
			this._text=null;
			this._isChanged=false;
			this._textWidth=0;
			this._textHeight=0;
			this._lines=[];
			this._lineWidths=[];
			this._startX=NaN;
			this._startY=NaN;
			this._lastVisibleLineIndex=-1;
			this._words=null;
			this._charSize={};
			this.underline=false;
			this.underlineColor=null;
			Text.__super.call(this);
			this.overflow=Text.VISIBLE;
			this._style=new CSSStyle(this);
			(this._style).wordWrap=false;
		}

		__class(Text,'laya.display.Text',_super);
		var __proto=Text.prototype;
		/**@inheritDoc */
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			this._lines=null;
			if (this._words){
				this._words.length=0;
				this._words=null;
			}
		}

		/**
		*@private
		*@inheritDoc
		*/
		__proto._getBoundPointsM=function(ifRotate){
			(ifRotate===void 0)&& (ifRotate=false);
			var rec=Rectangle.TEMP;
			rec.setTo(0,0,this.width,this.height);
			return rec._getBoundPoints();
		}

		/**
		*@inheritDoc
		*/
		__proto.getGraphicBounds=function(){
			var rec=Rectangle.TEMP;
			rec.setTo(0,0,this.width,this.height);
			return rec;
		}

		/**
		*@private
		*@inheritDoc
		*/
		__proto._getCSSStyle=function(){
			return this._style;
		}

		/**
		*<p>根据指定的文本，从语言包中取当前语言的文本内容。并对此文本中的{i}文本进行替换。</p>
		*<p>例如：
		*<li>（1）text 的值为“我的名字”，先取到这个文本对应的当前语言版本里的值“My name”，将“My name”设置为当前文本的内容。</li>
		*<li>（2）text 的值为“恭喜你赢得{0}个钻石，{1}经验。”，arg1 的值为100，arg2 的值为200。
		*则先取到这个文本对应的当前语言版本里的值“Congratulations on your winning {0}diamonds,{1}experience.”，
		*然后将文本里的{0}、{1}，依据括号里的数字从0开始替换为 arg1、arg2 的值。
		*将替换处理后的文本“Congratulations on your winning 100 diamonds,200 experience.”设置为当前文本的内容。
		*</li>
		*</p>
		*@param text 文本内容。
		*@param ...args 文本替换参数。
		*/
		__proto.lang=function(text,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10){
			text=Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] :text;
			if (arguments.length < 2){
				this._text=text;
				}else {
				for (var i=0,n=arguments.length;i < n;i++){
					text=text.replace("{"+i+"}",arguments[i+1]);
				}
				this._text=text;
			}
		}

		/**
		*渲染文字。
		*@param begin 开始渲染的行索引。
		*@param visibleLineCount 渲染的行数。
		*/
		__proto.renderText=function(begin,visibleLineCount){
			var graphics=this.graphics;
			graphics.clear();
			var ctxFont=(this.italic ? "italic " :"")+(this.bold ? "bold " :"")+this.fontSize+"px "+this.font;
			Browser.context.font=ctxFont;
			var padding=this.padding;
			var startX=padding[3];
			var textAlgin="left";
			var lines=this._lines;
			var lineHeight=this.leading+this._charSize.height;
			var tCurrBitmapFont=this._currBitmapFont;
			if (tCurrBitmapFont){
				lineHeight=this.leading+tCurrBitmapFont.getMaxHeight();
			};
			var startY=padding[0];
			if ((!tCurrBitmapFont)&& this._width > 0 && this._textWidth <=this._width){
				if (this.align=="right"){
					textAlgin="right";
					startX=this._width-padding[1];
					}else if (this.align=="center"){
					textAlgin="center";
					startX=this._width *0.5+padding[3]-padding[1];
				}
			}
			if (this._height > 0){
				var tempVAlign=(this._textHeight > this._height)? "top" :this.valign;
				if (tempVAlign==="middle")
					startY=(this._height-visibleLineCount *lineHeight)*0.5+padding[0]-padding[2];
				else if (tempVAlign==="bottom")
				startY=this._height-visibleLineCount *lineHeight-padding[2];
			};
			var style=this._style;
			if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize){
				var bitmapScale=tCurrBitmapFont.fontSize / this.fontSize;
			}
			if (this._clipPoint){
				graphics.save();
				if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize){
					var tClipWidth=0;
					var tClipHeight=0;
					this._width ? tClipWidth=(this._width-padding[3]-padding[1]):tClipWidth=this._textWidth;
					this._height ? tClipHeight=(this._height-padding[0]-padding[2]):tClipHeight=this._textHeight;
					tClipWidth *=bitmapScale;
					tClipHeight *=bitmapScale;
					graphics.clipRect(padding[3],padding[0],tClipWidth,tClipHeight);
					}else {
					graphics.clipRect(padding[3],padding[0],this._width ? (this._width-padding[3]-padding[1]):this._textWidth,this._height ? (this._height-padding[0]-padding[2]):this._textHeight);
				}
			};
			var password=style.password;
			if (("prompt" in this)&& this['prompt']==this._text)
				password=false;
			var x=0,y=0;
			var end=Math.min(this._lines.length,visibleLineCount+begin)|| 1;
			for (var i=begin;i < end;i++){
				var word=lines[i];
				var _word;
				if (password){
					var len=word.length;
					word="";
					for (var j=len;j > 0;j--){
						word+="·";
					}
				}
				x=startX-(this._clipPoint ? this._clipPoint.x :0);
				y=startY+lineHeight *i-(this._clipPoint ? this._clipPoint.y :0);
				this.underline && this.drawUnderline(textAlgin,x,y,i);
				if (tCurrBitmapFont){
					var tWidth=this.width;
					if (tCurrBitmapFont.autoScaleSize){
						tWidth=this.width *bitmapScale;
					}
					tCurrBitmapFont.drawText(word,this,x,y,this.align,tWidth);
					}else {
					if (Render.isWebGL){
						this._words || (this._words=[]);
						_word=this._words.length > (i-begin)? this._words[i-begin] :new WordText();
						_word.setText(word);
						}else {
						_word=word;
					}
					style.stroke ? graphics.fillBorderText(_word,x,y,ctxFont,this.color,style.strokeColor,style.stroke,textAlgin):graphics.fillText(_word,x,y,ctxFont,this.color,textAlgin);
				}
			}
			if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize){
				var tScale=1 / bitmapScale;
				this.scale(tScale,tScale);
			}
			if (this._clipPoint)
				graphics.restore();
			this._startX=startX;
			this._startY=startY;
		}

		/**
		*绘制下划线
		*@param x 本行坐标
		*@param y 本行坐标
		*@param lineIndex 本行索引
		*/
		__proto.drawUnderline=function(align,x,y,lineIndex){
			var lineWidth=this._lineWidths[lineIndex];
			switch (align){
				case 'center':
					x-=lineWidth / 2;
					break ;
				case 'right':
					x-=lineWidth;
					break ;
				case 'left':
				default :
					break ;
				}
			y+=this._charSize.height;
			this._graphics.drawLine(x,y,x+lineWidth,y,this.underlineColor || this.color,1);
		}

		/**
		*<p>排版文本。</p>
		*<p>进行宽高计算，渲染、重绘文本。</p>
		*/
		__proto.typeset=function(){
			this._isChanged=false;
			if (!this._text){
				this._clipPoint=null;
				this._textWidth=this._textHeight=0;
				this.graphics.clear();
				return;
			}
			Browser.context.font=this._getCSSStyle().font;
			this._lines.length=0;
			this._lineWidths.length=0;
			this.parseLines(this._text);
			this.evalTextSize();
			if (this.checkEnabledViewportOrNot())
				this._clipPoint || (this._clipPoint=new Point(0,0));
			else
			this._clipPoint=null;
			var endLine=this._lines.length;
			if (this.overflow !=Text.VISIBLE){
				var func=this.overflow==Text.HIDDEN ? Math.floor :Math.ceil;
				endLine=Math.min(endLine,func((this.height-this.padding[0]-this.padding[2])/ (this.leading+this._charSize.height)));
			}
			this.renderText(0,endLine);
			this.repaint();
		}

		__proto.evalTextSize=function(){
			var nw=NaN,nh=NaN;
			nw=Math.max.apply(this,this._lineWidths);
			if (this._currBitmapFont)
				nh=this._lines.length *(this._currBitmapFont.getMaxHeight()+this.leading)+this.padding[0]+this.padding[2];
			else
			nh=this._lines.length *(this._charSize.height+this.leading)+this.padding[0]+this.padding[2];
			if (nw !=this._textWidth || nh !=this._textHeight){
				this._textWidth=nw;
				this._textHeight=nh;
				if(!this._width||!this._height)
					this.model&&this.model.size(this._width||this._textWidth,this._height||this._textHeight);
			}
		}

		__proto.checkEnabledViewportOrNot=function(){
			return this.overflow==Text.SCROLL && ((this._width > 0 && this._textWidth > this._width)|| (this._height > 0 && this._textHeight > this._height));
		}

		/**
		*快速更改显示文本。不进行排版计算，效率较高。
		*<p>如果只更改文字内容，不更改文字样式，建议使用此接口，能提高效率。</p>
		*@param text 文本内容。
		*/
		__proto.changeText=function(text){
			if (this._text!==text){
				this.lang(text+"");
				if (this._graphics && this._graphics.replaceText(this._text)){
					}else {
					this.typeset();
				}
			}
		}

		/**
		*@private
		*分析文本换行。
		*/
		__proto.parseLines=function(text){
			var needWordWrapOrTruncate=this.wordWrap || this.overflow==Text.HIDDEN;
			if (needWordWrapOrTruncate){
				var wordWrapWidth=this.getWordWrapWidth();
			};
			var measureResult=Browser.context.measureText("阳");
			this._charSize.width=measureResult.width;
			this._charSize.height=(measureResult.height || this.fontSize);
			var lines=text.replace(/\r\n/g,"\n").split("\n");
			for (var i=0,n=lines.length;i < n;i++){
				if (i < n-1)
					lines[i]+="\n";
				var line=lines[i];
				if (needWordWrapOrTruncate)
					this.parseLine(line,wordWrapWidth);
				else {
					this._lineWidths.push(this.getTextWidth(line));
					this._lines.push(line);
				}
			}
		}

		/**
		*@private
		*解析行文本。
		*@param line 某行的文本。
		*@param wordWrapWidth 文本的显示宽度。
		*/
		__proto.parseLine=function(line,wordWrapWidth){
			var ctx=Browser.context;
			var lines=this._lines;
			var maybeIndex=0;
			var execResult;
			var charsWidth=NaN;
			var wordWidth=NaN;
			var startIndex=0;
			charsWidth=this.getTextWidth(line);
			if (charsWidth <=wordWrapWidth){
				lines.push(line);
				this._lineWidths.push(charsWidth);
				return;
			}
			charsWidth=this._currBitmapFont ? this._currBitmapFont.getMaxWidth():this._charSize.width;
			maybeIndex=Math.floor(wordWrapWidth / charsWidth);
			(maybeIndex==0)&& (maybeIndex=1);
			charsWidth=this.getTextWidth(line.substring(0,maybeIndex));
			wordWidth=charsWidth;
			for (var j=maybeIndex,m=line.length;j < m;j++){
				charsWidth=this.getTextWidth(line.charAt(j));
				wordWidth+=charsWidth;
				if (wordWidth > wordWrapWidth){
					if (this.wordWrap){
						var newLine=line.substring(startIndex,j);
						if (newLine.charCodeAt(newLine.length-1)< 255){
							execResult=/[^\x20-]+$/.exec(newLine);
							if (execResult){
								j=execResult.index+startIndex;
								if (execResult.index==0)
									j+=newLine.length;
								else
								newLine=line.substring(startIndex,j);
							}
						}
						lines.push(newLine);
						this._lineWidths.push(wordWidth-charsWidth);
						startIndex=j;
						if (j+maybeIndex < m){
							j+=maybeIndex;
							charsWidth=this.getTextWidth(line.substring(startIndex,j));
							wordWidth=charsWidth;
							j--;
							}else {
							lines.push(line.substring(startIndex,m));
							this._lineWidths.push(this.getTextWidth(lines[lines.length-1]));
							startIndex=-1;
							break ;
						}
						}else if (this.overflow==Text.HIDDEN){
						lines.push(line.substring(0,j));
						this._lineWidths.push(this.getTextWidth(lines[lines.length-1]));
						return;
					}
				}
			}
			if (this.wordWrap && startIndex !=-1){
				lines.push(line.substring(startIndex,m));
				this._lineWidths.push(this.getTextWidth(lines[lines.length-1]));
			}
		}

		__proto.getTextWidth=function(text){
			if (this._currBitmapFont)
				return this._currBitmapFont.getTextWidth(text);
			else
			return Browser.context.measureText(text).width;
		}

		/**
		*获取换行所需的宽度。
		*/
		__proto.getWordWrapWidth=function(){
			var p=this.padding;
			var w=NaN;
			if (this._currBitmapFont && this._currBitmapFont.autoScaleSize)
				w=this._width *(this._currBitmapFont.fontSize / this.fontSize);
			else
			w=this._width;
			if (w <=0){
				w=this.wordWrap ? 100 :Browser.width;
			}
			w <=0 && (w=100);
			return w-p[3]-p[1];
		}

		/**
		*返回字符的位置信息。
		*@param charIndex 索引位置。
		*@param out 输出的Point引用。
		*@return 返回Point位置信息。
		*/
		__proto.getCharPoint=function(charIndex,out){
			this._isChanged && Laya.timer.runCallLater(this,this.typeset);
			var len=0,lines=this._lines,startIndex=0;
			for (var i=0,n=lines.length;i < n;i++){
				len+=lines[i].length;
				if (charIndex < len){
					var line=i;
					break ;
				}
				startIndex=len;
			};
			var ctxFont=(this.italic ? "italic " :"")+(this.bold ? "bold " :"")+this.fontSize+"px "+this.font;
			Browser.context.font=ctxFont;
			var width=this.getTextWidth(this._text.substring(startIndex,charIndex));
			var point=out || new Point();
			return point.setTo(this._startX+width-(this._clipPoint ? this._clipPoint.x :0),this._startY+line *(this._charSize.height+this.leading)-(this._clipPoint ? this._clipPoint.y :0));
		}

		/**
		*表示文本的高度，以像素为单位。
		*/
		__getset(0,__proto,'textHeight',function(){
			this._isChanged && Laya.timer.runCallLater(this,this.typeset);
			return this._textHeight;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'width',function(){
			if (this._width)
				return this._width;
			return this.textWidth;
			},function(value){
			if (value !=this._width){
				_super.prototype._$set_width.call(this,value);
				this.isChanged=true;
			}
		});

		/**
		*文本的字体名称，以字符串形式表示。
		*<p>默认值为："Arial"，可以通过Text.defaultFont设置默认字体。</p> *
		*@see laya.display.css.Font#defaultFamily
		*/
		__getset(0,__proto,'font',function(){
			return this._getCSSStyle().fontFamily;
			},function(value){
			if (this._currBitmapFont){
				this._currBitmapFont=null;
				this.scale(1,1);
			}
			if (Text._bitmapFonts && Text._bitmapFonts[value]){
				this._currBitmapFont=Text._bitmapFonts[value];
			}
			this._getCSSStyle().fontFamily=value;
			this.isChanged=true;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'height',function(){
			if (this._height)return this._height;
			return this.textHeight;
			},function(value){
			if (value !=this._height){
				_super.prototype._$set_height.call(this,value);
				this.isChanged=true;
			}
		});

		/**
		*垂直行间距（以像素为单位）。
		*/
		__getset(0,__proto,'leading',function(){
			return this._getCSSStyle().leading;
			},function(value){
			this._getCSSStyle().leading=value;
			this.isChanged=true;
		});

		/**当前文本的内容字符串。*/
		__getset(0,__proto,'text',function(){
			return this._text || "";
			},function(value){
			if (this._text!==value){
				this.lang(value+"");
				this.isChanged=true;
				this.event("change");
			}
		});

		__getset(0,__proto,'lines',function(){
			return this._lines;
		});

		/**
		*表示文本的宽度，以像素为单位。
		*/
		__getset(0,__proto,'textWidth',function(){
			this._isChanged && Laya.timer.runCallLater(this,this.typeset);
			return this._textWidth;
		});

		/**
		*指定文本的字体大小（以像素为单位）。
		*<p>默认为20像素，可以通过 <code>Text.defaultSize</code> 设置默认大小。</p>
		*/
		__getset(0,__proto,'fontSize',function(){
			return this._getCSSStyle().fontSize;
			},function(value){
			this._getCSSStyle().fontSize=value;
			this.isChanged=true;
		});

		/**
		*指定文本是否为粗体字。
		*<p>默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。</p>
		*/
		__getset(0,__proto,'bold',function(){
			return this._getCSSStyle().bold;
			},function(value){
			this._getCSSStyle().bold=value;
			this.isChanged=true;
		});

		/**
		*表示文本的颜色值。可以通过 <code>Text.defaultColor</code> 设置默认颜色。
		*<p>默认值为黑色。</p>
		*/
		__getset(0,__proto,'color',function(){
			return this._getCSSStyle().color;
			},function(value){
			if (this._getCSSStyle().color !=value){
				this._getCSSStyle().color=value;
				if (!this._isChanged && this._graphics){
					this._graphics.replaceTextColor(this.color)
					}else {
					this.isChanged=true;
				}
			}
		});

		/**
		*<p>描边颜色，以字符串表示。</p>
		*默认值为 "#000000"（黑色）;
		*/
		__getset(0,__proto,'strokeColor',function(){
			return this._getCSSStyle().strokeColor;
			},function(value){
			this._getCSSStyle().strokeColor=value;
			this.isChanged=true;
		});

		/**
		*表示使用此文本格式的文本是否为斜体。
		*<p>默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。</p>
		*/
		__getset(0,__proto,'italic',function(){
			return this._getCSSStyle().italic;
			},function(value){
			this._getCSSStyle().italic=value;
			this.isChanged=true;
		});

		/**
		*表示文本的水平显示方式。
		*<p><b>取值：</b>
		*<li>"left"： 居左对齐显示。</li>
		*<li>"center"： 居中对齐显示。</li>
		*<li>"right"： 居右对齐显示。</li>
		*</p>
		*/
		__getset(0,__proto,'align',function(){
			return this._getCSSStyle().align;
			},function(value){
			this._getCSSStyle().align=value;
			this.isChanged=true;
		});

		/**
		*表示文本的垂直显示方式。
		*<p><b>取值：</b>
		*<li>"top"： 居顶部对齐显示。</li>
		*<li>"middle"： 居中对齐显示。</li>
		*<li>"bottom"： 居底部对齐显示。</li>
		*</p>
		*/
		__getset(0,__proto,'valign',function(){
			return this._getCSSStyle().valign;
			},function(value){
			this._getCSSStyle().valign=value;
			this.isChanged=true;
		});

		/**
		*表示文本是否自动换行，默认为false。
		*<p>若值为true，则自动换行；否则不自动换行。</p>
		*/
		__getset(0,__proto,'wordWrap',function(){
			return this._getCSSStyle().wordWrap;
			},function(value){
			this._getCSSStyle().wordWrap=value;
			this.isChanged=true;
		});

		/**
		*边距信息。
		*<p>数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。</p>
		*/
		__getset(0,__proto,'padding',function(){
			return this._getCSSStyle().padding;
			},function(value){
			this._getCSSStyle().padding=value;
			this.isChanged=true;
		});

		/**
		*文本背景颜色，以字符串表示。
		*/
		__getset(0,__proto,'bgColor',function(){
			return this._getCSSStyle().backgroundColor;
			},function(value){
			this._getCSSStyle().backgroundColor=value;
			this.isChanged=true;
		});

		/**
		*文本边框背景颜色，以字符串表示。
		*/
		__getset(0,__proto,'borderColor',function(){
			return this._getCSSStyle().borderColor;
			},function(value){
			this._getCSSStyle().borderColor=value;
			this.isChanged=true;
		});

		/**
		*<p>描边宽度（以像素为单位）。</p>
		*默认值0，表示不描边。
		*/
		__getset(0,__proto,'stroke',function(){
			return this._getCSSStyle().stroke;
			},function(value){
			this._getCSSStyle().stroke=value;
			this.isChanged=true;
		});

		/**
		*<p>指定文本字段是否是密码文本字段。</p>
		*<p>如果此属性的值为 true，则文本字段被视为密码文本字段，并使用星号而不是实际字符来隐藏输入的字符。如果为 false，则不会将文本字段视为密码文本字段。</p>
		*<p>默认值为false。</p>
		*/
		__getset(0,__proto,'asPassword',function(){
			return this._getCSSStyle().password;
			},function(value){
			this._getCSSStyle().password=value;
			this.isChanged=true;
		});

		/**
		*一个布尔值，表示文本的属性是否有改变。若为true表示有改变。
		*/
		__getset(0,__proto,'isChanged',null,function(value){
			if (this._isChanged!==value){
				this._isChanged=value;
				value && Laya.timer.callLater(this,this.typeset);
			}
		});

		/**
		*设置横向滚动量。
		*<p>即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。</p>
		*/
		/**
		*获取横向滚动量。
		*/
		__getset(0,__proto,'scrollX',function(){
			if (!this._clipPoint)
				return 0;
			return this._clipPoint.x;
			},function(value){
			if (this.overflow !=Text.SCROLL || (this.textWidth < this._width || !this._clipPoint))
				return;
			value=value < this.padding[3] ? this.padding[3] :value;
			var maxScrollX=this._textWidth-this._width;
			value=value > maxScrollX ? maxScrollX :value;
			var visibleLineCount=this._height / (this._charSize.height+this.leading)| 0+1;
			this._clipPoint.x=value;
			this.renderText(this._lastVisibleLineIndex,visibleLineCount);
		});

		/**
		*设置纵向滚动量（px)。即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
		*/
		/**
		*获取纵向滚动量。
		*/
		__getset(0,__proto,'scrollY',function(){
			if (!this._clipPoint)
				return 0;
			return this._clipPoint.y;
			},function(value){
			if (this.overflow !=Text.SCROLL || (this.textHeight < this._height || !this._clipPoint))
				return;
			value=value < this.padding[0] ? this.padding[0] :value;
			var maxScrollY=this._textHeight-this._height;
			value=value > maxScrollY ? maxScrollY :value;
			var startLine=value / (this._charSize.height+this.leading)| 0;
			this._lastVisibleLineIndex=startLine;
			var visibleLineCount=(this._height / (this._charSize.height+this.leading)| 0)+1;
			this._clipPoint.y=value;
			this.renderText(startLine,visibleLineCount);
		});

		/**
		*获取横向可滚动最大值。
		*/
		__getset(0,__proto,'maxScrollX',function(){
			return (this.textWidth < this._width)? 0 :this._textWidth-this._width;
		});

		/**
		*获取纵向可滚动最大值。
		*/
		__getset(0,__proto,'maxScrollY',function(){
			return (this.textHeight < this._height)? 0 :this._textHeight-this._height;
		});

		Text.registerBitmapFont=function(name,bitmapFont){
			Text._bitmapFonts || (Text._bitmapFonts={});
			Text._bitmapFonts[name]=bitmapFont;
		}

		Text.unregisterBitmapFont=function(name,destroy){
			(destroy===void 0)&& (destroy=true);
			if (Text._bitmapFonts && Text._bitmapFonts[name]){
				var tBitmapFont=Text._bitmapFonts[name];
				if (destroy){
					tBitmapFont.destroy();
				}
				delete Text._bitmapFonts[name];
			}
		}

		Text.langPacks=null
		Text.VISIBLE="visible";
		Text.SCROLL="scroll";
		Text.HIDDEN="hidden";
		Text._bitmapFonts=null
		return Text;
	})(Sprite)


	/**
	*<code>Component</code> 是ui控件类的基类。
	*<p>生命周期：preinitialize > createChildren > initialize > 组件构造函数</p>
	*/
	//class laya.ui.Component extends laya.display.Sprite
	var Component=(function(_super){
		function Component(){
			this._comXml=null;
			this._dataSource=null;
			this._toolTip=null;
			this._tag=null;
			this._disabled=false;
			this._gray=false;
			Component.__super.call(this);
			this._layout=LayoutStyle.EMPTY;
			this.preinitialize();
			this.createChildren();
			this.initialize();
		}

		__class(Component,'laya.ui.Component',_super);
		var __proto=Component.prototype;
		Laya.imps(__proto,{"laya.ui.IComponent":true})
		/**@inheritDoc */
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			this._dataSource=this._layout=null;
			this._tag=null;
			this._toolTip=null;
		}

		/**
		*<p>预初始化。</p>
		*@internal 子类可在此函数内设置、修改属性默认值
		*/
		__proto.preinitialize=function(){}
		/**
		*<p>创建并添加控件子节点。</p>
		*@internal 子类可在此函数内创建并添加子节点。
		*/
		__proto.createChildren=function(){}
		/**
		*<p>控件初始化。</p>
		*@internal 在此子对象已被创建，可以对子对象进行修改。
		*/
		__proto.initialize=function(){}
		/**
		*<p>延迟运行指定的函数。</p>
		*<p>在控件被显示在屏幕之前调用，一般用于延迟计算数据。</p>
		*@param method 要执行的函数的名称。例如，functionName。
		*@param args 传递给 <code>method</code> 函数的可选参数列表。
		*
		*@see #runCallLater()
		*/
		__proto.callLater=function(method,args){
			Laya.timer.callLater(this,method,args);
		}

		/**
		*<p>如果有需要延迟调用的函数（通过 <code>callLater</code> 函数设置），则立即执行延迟调用函数。</p>
		*@param method 要执行的函数名称。例如，functionName。
		*@see #callLater()
		*/
		__proto.runCallLater=function(method){
			Laya.timer.runCallLater(this,method);
		}

		/**
		*<p>立即执行影响宽高度量的延迟调用函数。</p>
		*@internal <p>使用 <code>runCallLater</code> 函数，立即执行影响宽高度量的延迟运行函数(使用 <code>callLater</code> 设置延迟执行函数)。</p>
		*@see #callLater()
		*@see #runCallLater()
		*/
		__proto.commitMeasure=function(){}
		/**
		*<p>重新调整对象的大小。</p>
		*/
		__proto.changeSize=function(){
			this.event("resize");
		}

		/**
		*@private
		*<p>获取对象的布局样式。</p>
		*/
		__proto.getLayout=function(){
			this._layout===LayoutStyle.EMPTY && (this._layout=new LayoutStyle());
			return this._layout;
		}

		/**
		*对象从显示列表移除的事件侦听处理函数。
		*/
		__proto.onRemoved=function(){
			this.parent.off("resize",this,this.onCompResize);
		}

		/**
		*对象被添加到显示列表的事件侦听处理函数。
		*/
		__proto.onAdded=function(){
			this.parent.on("resize",this,this.onCompResize);
			this.resetLayoutX();
			this.resetLayoutY();
		}

		/**
		*父容器的 <code>Event.RESIZE</code> 事件侦听处理函数。
		*/
		__proto.onCompResize=function(){
			if (this._layout && this._layout.enable){
				this.resetLayoutX();
				this.resetLayoutY();
			}
		}

		/**
		*<p>重置对象的 <code>X</code> 轴（水平方向）布局。</p>
		*/
		__proto.resetLayoutX=function(){
			var parent=this.parent;
			if (parent){
				var layout=this._layout;
				if (!isNaN(layout.anchorX))this.pivotX=layout.anchorX *this.width;
				if (!isNaN(layout.centerX)){
					this.x=(parent.width-this.displayWidth)*0.5+layout.centerX;
					}else if (!isNaN(layout.left)){
					this.x=layout.left;
					if (!isNaN(layout.right)){
						this.width=(parent._width-layout.left-layout.right)/ this.scaleX;
					}
					}else if (!isNaN(layout.right)){
					this.x=parent.width-this.displayWidth-layout.right;
				}
			}
		}

		/**
		*<p>重置对象的 <code>Y</code> 轴（垂直方向）布局。</p>
		*/
		__proto.resetLayoutY=function(){
			var parent=this.parent;
			if (parent){
				var layout=this._layout;
				if (!isNaN(layout.anchorY))this.pivotY=layout.anchorY *this.height;
				if (!isNaN(layout.centerY)){
					this.y=(parent.height-this.displayHeight)*0.5+layout.centerY;
					}else if (!isNaN(layout.top)){
					this.y=layout.top;
					if (!isNaN(layout.bottom)){
						this.height=(parent._height-layout.top-layout.bottom)/ this.scaleY;
					}
					}else if (!isNaN(layout.bottom)){
					this.y=parent.height-this.displayHeight-layout.bottom;
				}
			}
		}

		/**
		*对象的 <code>Event.MOUSE_OVER</code> 事件侦听处理函数。
		*/
		__proto.onMouseOver=function(e){
			Laya.stage.event("showtip",this._toolTip);
		}

		/**
		*对象的 <code>Event.MOUSE_OUT</code> 事件侦听处理函数。
		*/
		__proto.onMouseOut=function(e){
			Laya.stage.event("hidetip",this._toolTip);
		}

		/**
		*<p>表示显示对象的宽度，以像素为单位。</p>
		*<p><b>注：</b>当值为0时，宽度为自适应大小。</p>
		*/
		__getset(0,__proto,'width',function(){
			if (this._width)return this._width;
			return this.measureWidth;
			},function(value){
			if (this._width !=value){
				this._width=value;
				this.model && this.model.size(this._width,this._height);
				this.callLater(this.changeSize);
				if (this._layout.enable && (!isNaN(this._layout.centerX)|| !isNaN(this._layout.right)|| !isNaN(this._layout.anchorX)))this.resetLayoutX();
			}
		});

		/**
		*<p>对象的显示宽度（以像素为单位）。</p>
		*/
		__getset(0,__proto,'displayWidth',function(){
			return this.width *this.scaleX;
		});

		/**
		*<p>在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。</p>
		*/
		__getset(0,__proto,'centerX',function(){
			return this._layout.centerX;
			},function(value){
			this.getLayout().centerX=value;
			this.layOutEabled=true;
			this.resetLayoutX();
		});

		/**
		*<p>对象的显示高度（以像素为单位）。</p>
		*/
		__getset(0,__proto,'displayHeight',function(){
			return this.height *this.scaleY;
		});

		/**
		*<p>显示对象的实际显示区域高度（以像素为单位）。</p>
		*/
		__getset(0,__proto,'measureHeight',function(){
			var max=0;
			this.commitMeasure();
			for (var i=this.numChildren-1;i >-1;i--){
				var comp=this.getChildAt(i);
				if (comp.visible){
					max=Math.max(comp.y+comp.height *comp.scaleY,max);
				}
			}
			return max;
		});

		/**
		*<p>显示对象的实际显示区域宽度（以像素为单位）。</p>
		*/
		__getset(0,__proto,'measureWidth',function(){
			var max=0;
			this.commitMeasure();
			for (var i=this.numChildren-1;i >-1;i--){
				var comp=this.getChildAt(i);
				if (comp.visible){
					max=Math.max(comp.x+comp.width *comp.scaleX,max);
				}
			}
			return max;
		});

		/**
		*<p>表示显示对象的高度，以像素为单位。</p>
		*<p><b>注：</b>当值为0时，高度为自适应大小。</p>
		*@return
		*/
		__getset(0,__proto,'height',function(){
			if (this._height)return this._height;
			return this.measureHeight;
			},function(value){
			if (this._height !=value){
				this._height=value;
				this.model && this.model.size(this._width,this._height);
				this.callLater(this.changeSize);
				if (this._layout.enable && (!isNaN(this._layout.centerY)|| !isNaN(this._layout.bottom)|| !isNaN(this._layout.anchorY)))this.resetLayoutY();
			}
		});

		/**@inheritDoc */
		__getset(0,__proto,'scaleX',_super.prototype._$get_scaleX,function(value){
			if (_super.prototype._$get_scaleX.call(this)!=value){
				_super.prototype._$set_scaleX.call(this,value);
				this.callLater(this.changeSize);
				this._layout.enable && this.resetLayoutX();
			}
		});

		/**@inheritDoc */
		__getset(0,__proto,'scaleY',_super.prototype._$get_scaleY,function(value){
			if (_super.prototype._$get_scaleY.call(this)!=value){
				_super.prototype._$set_scaleY.call(this,value);
				this.callLater(this.changeSize);
				this._layout.enable && this.resetLayoutY();
			}
		});

		/**
		*<p>数据赋值，通过对UI赋值来控制UI显示逻辑。</p>
		*<p>简单赋值会更改组件的默认属性，使用大括号可以指定组件的任意属性进行赋值。</p>
		*@example 以下示例中， <code>label1、checkbox1</code> 分别为示例的name属性值。
		<listing version="3.0">
		//默认属性赋值
		dataSource={label1:"改变了label",checkbox1:true};//(更改了label1的text属性值，更改checkbox1的selected属性)。
		//任意属性赋值
		dataSource={label2:{text:"改变了label",size:14},checkbox2:{selected:true,x:10}};
		</listing>
		*@return
		*/
		__getset(0,__proto,'dataSource',function(){
			return this._dataSource;
			},function(value){
			this._dataSource=value;
			for (var prop in this._dataSource){
				if (this.hasOwnProperty(prop)){
					this[prop]=this._dataSource[prop];
				}
			}
		});

		/**
		*<p>鼠标悬停提示。</p>
		*<p>可以赋值为文本 <code>String</code> 或函数 <code>Handler</code> ，用来实现自定义样式的鼠标提示和参数携带等。</p>
		*@example 以下例子展示了三种鼠标提示：
		<listing version="3.0">
		private var _testTips:TestTipsUI=new TestTipsUI();
		private function testTips():void {
			//简单鼠标提示
			btn2.toolTip="这里是鼠标提示&lt;b&gt;粗体&lt;/b&gt;&lt;br&gt;换行";
			//自定义的鼠标提示
			btn1.toolTip=showTips1;
			//带参数的自定义鼠标提示
			clip.toolTip=new Handler(this,showTips2,["clip"]);
		}

		private function showTips1():void {
			_testTips.label.text="这里是按钮["+btn1.label+"]";
			tip.addChild(_testTips);
		}

		private function showTips2(name:String):void {
			_testTips.label.text="这里是"+name;
			tip.addChild(_testTips);
		}

		</listing>
		*/
		__getset(0,__proto,'toolTip',function(){
			return this._toolTip;
			},function(value){
			if (this._toolTip !=value){
				this._toolTip=value;
				if (value !=null){
					this.on("mouseover",this,this.onMouseOver);
					this.on("mouseout",this,this.onMouseOut);
					}else {
					this.off("mouseover",this,this.onMouseOver);
					this.off("mouseout",this,this.onMouseOut);
				}
			}
		});

		/**
		*<p>从组件顶边到其内容区域顶边之间的垂直距离（以像素为单位）。</p>
		*/
		__getset(0,__proto,'top',function(){
			return this._layout.top;
			},function(value){
			this.getLayout().top=value;
			this.layOutEabled=true;
			this.resetLayoutY();
		});

		/**
		*<p>从组件底边到其内容区域底边之间的垂直距离（以像素为单位）。</p>
		*/
		__getset(0,__proto,'bottom',function(){
			return this._layout.bottom;
			},function(value){
			this.getLayout().bottom=value;
			this.layOutEabled=true;
			this.resetLayoutY();
		});

		/**
		*<p>从组件左边到其内容区域左边之间的水平距离（以像素为单位）。</p>
		*/
		__getset(0,__proto,'left',function(){
			return this._layout.left;
			},function(value){
			this.getLayout().left=value;
			this.layOutEabled=true;
			this.resetLayoutX();
		});

		/**
		*<p>从组件右边到其内容区域右边之间的水平距离（以像素为单位）。</p>
		*/
		__getset(0,__proto,'right',function(){
			return this._layout.right;
			},function(value){
			this.getLayout().right=value;
			this.layOutEabled=true;
			this.resetLayoutX();
		});

		/**
		*<p>在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。</p>
		*/
		__getset(0,__proto,'centerY',function(){
			return this._layout.centerY;
			},function(value){
			this.getLayout().centerY=value;
			this.layOutEabled=true;
			this.resetLayoutY();
		});

		/**X轴锚点，值为0-1*/
		__getset(0,__proto,'anchorX',function(){
			return this._layout.anchorX;
			},function(value){
			this.getLayout().anchorX=value;
			this.layOutEabled=true;
			this.resetLayoutX();
		});

		/**Y轴锚点，值为0-1*/
		__getset(0,__proto,'anchorY',function(){
			return this._layout.anchorY;
			},function(value){
			this.getLayout().anchorY=value;
			this.layOutEabled=true;
			this.resetLayoutY();
		});

		/**
		*<p>对象的标签。</p>
		*@internal 冗余字段，可以用来储存数据。
		*/
		__getset(0,__proto,'tag',function(){
			return this._tag;
			},function(value){
			this._tag=value;
		});

		/**
		*@private
		*<p>指定对象是否可使用布局。</p>
		*<p>如果值为true,则此对象可以使用布局样式，否则不使用布局样式。</p>
		*@param value 一个 Boolean 值，指定对象是否可使用布局。
		*/
		__getset(0,__proto,'layOutEabled',null,function(value){
			if (this._layout && this._layout.enable !=value){
				this._layout.enable=value;
				if (this.parent){
					this.onAdded();
					}else if (!this.hasListener("added")){
					this.on("added",this,this.onAdded);
					this.on("removed",this,this.onRemoved);
				}
			}
		});

		/**
		*XML 数据。
		*/
		__getset(0,__proto,'comXml',function(){
			return this._comXml;
			},function(value){
			this._comXml=value;
		});

		/**是否变灰。*/
		__getset(0,__proto,'gray',function(){
			return this._disabled;
			},function(value){
			if (value!==this._gray){
				this._gray=value;
				UIUtils.gray(this,value);
			}
		});

		/**是否禁用页面，设置为true后，会变灰并且禁用鼠标。*/
		__getset(0,__proto,'disabled',function(){
			return this._disabled;
			},function(value){
			if (value!==this._disabled){
				this.gray=this._disabled=value;
				this.mouseEnabled=!value;
			}
		});

		return Component;
	})(Sprite)


	/**
	*<code>Mesh</code> 类用于创建文件网格数据模板。
	*/
	//class laya.d3.resource.models.Mesh extends laya.d3.resource.models.BaseMesh
	var Mesh=(function(_super){
		function Mesh(url){
			this._materials=null;
			this._subMeshes=null;
			this._useFullBone=true;
			this._url=null;
			Mesh.__super.call(this);
			this._subMeshes=[];
			this._materials=[];
			this._url=url;
			if (this._loaded)
				this._generateBoundingObject();
			else
			this.once("loaded",this,this._generateBoundingObject);
		}

		__class(Mesh,'laya.d3.resource.models.Mesh',_super);
		var __proto=Mesh.prototype;
		__proto._generateBoundingObject=function(){
			var pos=this.positions;
			BoundBox1.createfromPoints(pos,this._boundingBox);
			BoundSphere1.createfromPoints(pos,this._boundingSphere);
		}

		/**
		*添加子网格（开发者禁止修改）。
		*@param subMesh 子网格。
		*/
		__proto.add=function(subMesh){
			subMesh._indexOfHost=this._subMeshes.length;
			this._subMeshes.push(subMesh);
			this._subMeshCount++;
		}

		/**
		*移除子网格。
		*@param subMesh 子网格。
		*@return 是否成功。
		*/
		__proto.remove=function(subMesh){
			var index=this._subMeshes.indexOf(subMesh);
			if (index < 0)return false;
			this._subMeshes.splice(index,1);
			this._subMeshCount--;
			return true;
		}

		/**
		*获得子网格。
		*@param index 子网格索引。
		*@return 子网格。
		*/
		__proto.getSubMesh=function(index){
			return this._subMeshes[index];
		}

		/**
		*获得子网格数量。
		*@return 子网格数量。
		*/
		__proto.getSubMeshCount=function(){
			return this._subMeshes.length;
		}

		/**
		*清除子网格。
		*@return 子网格。
		*/
		__proto.clear=function(){
			this._subMeshes.length=0;
			this._subMeshCount=0;
			return this;
		}

		/**@private */
		__proto.disableUseFullBone=function(){
			this._useFullBone=false;
		}

		__proto.getRenderElementsCount=function(){
			return this._subMeshes.length;
		}

		__proto.getRenderElement=function(index){
			return this._subMeshes[index];
		}

		/**
		*<p>彻底清理资源。</p>
		*<p><b>注意：</b>会强制解锁清理。</p>
		*/
		__proto.dispose=function(){
			this._resourceManager.removeResource(this);
			laya.resource.Resource.prototype.dispose.call(this);
			for (var i=0;i < this._subMeshes.length;i++)
			this._subMeshes[i].dispose();
			this._subMeshes=null;
			this._subMeshCount=0;
		}

		/**
		*获取网格顶点
		*@return 网格顶点。
		*/
		__getset(0,__proto,'positions',function(){
			var vertices=[];
			var submesheCount=this._subMeshes.length;
			for (var i=0;i < submesheCount;i++){
				var subMesh=this._subMeshes[i];
				var vertexBuffer=subMesh.getVertexBuffer();
				var positionElement;
				var vertexElements=vertexBuffer.vertexDeclaration.getVertexElements();
				var j=0;
				for (j=0;j < vertexElements.length;j++){
					var vertexElement=vertexElements[j];
					if (vertexElement.elementFormat==="vector3" && vertexElement.elementUsage==="POSITION"){
						positionElement=vertexElement;
						break ;
					}
				};
				var verticesData=vertexBuffer.getData();
				for (j=0;j < verticesData.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
					var ofset=j+positionElement.offset / 4;
					var position=new Vector3(verticesData[ofset+0],verticesData[ofset+1],verticesData[ofset+2]);
					vertices.push(position);
				}
			}
			return vertices;
		});

		/**
		*获取材质队列的浅拷贝。
		*@return 材质队列的浅拷贝。
		*/
		__getset(0,__proto,'materials',function(){
			return this._materials.slice();
		});

		Mesh.load=function(url){
			url=URL.formatURL(url);
			var mesh=Resource.meshCache[url];
			if (!mesh){
				mesh=Resource.meshCache[url]=new Mesh(url);
				var loader=new Loader();
				loader.once("complete",null,function(data){
					new LoadModel(data,mesh,mesh._materials,url);
					mesh._loaded=true;
					mesh.event("loaded",mesh);
				});
				loader.load(url,"arraybuffer");
			}
			return mesh;
		}

		return Mesh;
	})(BaseMesh)


	/**
	*动画播放控制器
	*/
	//class laya.display.AnimationPlayerBase extends laya.display.Sprite
	var AnimationPlayerBase=(function(_super){
		function AnimationPlayerBase(){
			this.loop=false;
			this._index=0;
			this._count=0;
			this._isPlaying=false;
			this._labels=null;
			this._controlNode=null;
			AnimationPlayerBase.__super.call(this);
			this._interval=Config.animationInterval;
		}

		__class(AnimationPlayerBase,'laya.display.AnimationPlayerBase',_super);
		var __proto=AnimationPlayerBase.prototype;
		/**
		*播放动画。
		*@param start 开始播放的动画索引或label。
		*@param loop 是否循环。
		*@param name 如果name为空(可选)，则播放当前动画，如果不为空，则播放全局缓存动画（如果有）
		*/
		__proto.play=function(start,loop,name){
			(start===void 0)&& (start=0);
			(loop===void 0)&& (loop=true);
			(name===void 0)&& (name="");
			this._isPlaying=true;
			this.index=((typeof start=='string'))?this._getFrameByLabel(start):start;
			this.loop=loop;
			if (this.interval > 0){
				this.timerLoop(this.interval,this,this._frameLoop,null,true);
			}
		}

		/**@private */
		__proto._getFrameByLabel=function(label){
			var i=0;
			for (i=0;i < this._count;i++){
				if (this._labels[i]==label)return i;
			}
			return 0;
		}

		/**@private */
		__proto._frameLoop=function(){
			this._index++;
			if (this._index >=this._count){
				if (this.loop){
					this._index=0;
					this.event("complete");
					}else {
					this._index--;
					this.stop();
					this.event("complete");
					return;
				}
			}
			this.index=this._index;
		}

		/**@private */
		__proto._setControlNode=function(node){
			if (this._controlNode){
				this._controlNode.off("display",this,this._$3__onDisplay);
				this._controlNode.off("undisplay",this,this._$3__onDisplay);
			}
			this._controlNode=node;
			if (node){
				node.on("display",this,this._$3__onDisplay);
				node.on("undisplay",this,this._$3__onDisplay);
			}
		}

		/**@private */
		__proto._$3__onDisplay=function(){
			if (this._isPlaying){
				if (this._controlNode.displayedInStage)this.play(this._index,this.loop);
				else this.clearTimer(this,this._frameLoop);
			}
		}

		/**
		*停止播放。
		*/
		__proto.stop=function(){
			this._isPlaying=false;
			this.clearTimer(this,this._frameLoop);
		}

		/**
		*增加一个标签到index帧上，播放到此index后会派发label事件
		*@param label 标签名称
		*@param index 索引位置
		*/
		__proto.addLabel=function(label,index){
			if (!this._labels)this._labels={};
			this._labels[index]=label;
		}

		/**
		*删除某个标签
		*@param label 标签名字，如果label为空，则删除所有Label
		*/
		__proto.removeLabel=function(label){
			if (!label)this._labels=null;
			else if (this._labels){
				for (var name in this._labels){
					if (this._labels[name]===label){
						delete this._labels[name];
						break ;
					}
				}
			}
		}

		/**
		*切换到某帧并停止
		*@param position 帧索引或label
		*/
		__proto.gotoAndStop=function(position){
			this.index=((typeof position=='string'))?this._getFrameByLabel(position):position;
			this.stop();
		}

		/**
		*@private
		*显示到某帧
		*@param value 帧索引
		*
		*/
		__proto._displayToIndex=function(value){}
		/**清理。方便对象复用。*/
		__proto.clear=function(){
			this.stop();
			this._labels=null;
		}

		/**动画长度。*/
		__getset(0,__proto,'count',function(){
			return this._count;
		});

		/**播放间隔(单位：毫秒)。*/
		/**播放间隔(单位：毫秒)。*/
		__getset(0,__proto,'interval',function(){
			return this._interval;
			},function(v){
			this._interval=v;
			if (this._isPlaying && v > 0){
				this.timerLoop(v,this,this._frameLoop,null,true);
			}
		});

		/**当前播放索引。*/
		__getset(0,__proto,'index',function(){
			return this._index;
			},function(value){
			this._index=value;
			this._displayToIndex(value);
			if (this._labels && this._labels[value])this.event("label",this._labels[value]);
		});

		return AnimationPlayerBase;
	})(Sprite)


	/**
	*<p> <code>Stage</code> 类是显示对象的根节点。</p>
	*可以通过 Laya.stage 访问。
	*/
	//class laya.display.Stage extends laya.display.Sprite
	var Stage=(function(_super){
		function Stage(){
			this.focus=null;
			this._offset=null;
			this.frameRate="fast";
			this.desginWidth=0;
			this.desginHeight=0;
			this.canvasRotation=false;
			this.canvasDegree=0;
			this.renderingEnabled=true;
			this._screenMode="none";
			this._scaleMode="noscale";
			this._alignV="top";
			this._alignH="left";
			this._bgColor="black";
			this._mouseMoveTime=0;
			this._renderCount=0;
			this._safariOffsetY=0;
			Stage.__super.call(this);
			this.offset=new Point();
			this._canvasTransform=new Matrix();
			this.mouseEnabled=true;
			this.hitTestPrior=true;
			this._displayedInStage=true;
			var _this=this;
			var window=Browser.window;
			window.addEventListener("focus",function(){
				_this.event("focus");
			});
			window.addEventListener("blur",function(){
				_this.event("blur");
				if (_this._isInputting())Input["inputElement"].target.focus=false;
			});
			var hidden="hidden",state="visibilityState",visibilityChange="visibilitychange";
			var document=window.document;
			if (typeof document.hidden!=="undefined"){
				visibilityChange="visibilitychange";
				state="visibilityState";
				}else if (typeof document.mozHidden!=="undefined"){
				visibilityChange="mozvisibilitychange";
				state="mozVisibilityState";
				}else if (typeof document.msHidden!=="undefined"){
				visibilityChange="msvisibilitychange";
				state="msVisibilityState";
				}else if (typeof document.webkitHidden!=="undefined"){
				visibilityChange="webkitvisibilitychange";
				state="webkitVisibilityState";
			}
			window.document.addEventListener(visibilityChange,visibleChangeFun);
			function visibleChangeFun (){
				if (Browser.document[state]=="hidden"){
					_this.event("blur");
					if (_this._isInputting())Input["inputElement"].target.focus=false;
					}else {
					_this.event("focus");
				}
			}
			window.addEventListener("resize",function(){
				if (_this._isInputting())return;
				if (Browser.onSafari)
					_this._safariOffsetY=(Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight)-Browser.window.innerHeight;
				_this._resetCanvas();
			});
			window.addEventListener("orientationchange",function(e){
				if (_this._isInputting())Input["inputElement"].target.focus=false;
				_this._resetCanvas();
			});
			this.on("mousemove",this,this._onmouseMove);
		}

		__class(Stage,'laya.display.Stage',_super);
		var __proto=Stage.prototype;
		/**
		*在移动端输入时，输入法弹出期间不进行画布尺寸重置。
		*/
		__proto._isInputting=function(){
			return (Browser.onMobile && Input.isInputting);
		}

		/**@private */
		__proto._changeCanvasSize=function(){
			this.setScreenSize(Browser.clientWidth *Browser.pixelRatio,Browser.clientHeight *Browser.pixelRatio);
		}

		/**@private */
		__proto._resetCanvas=function(){
			var canvas=Render._mainCanvas;
			var canvasStyle=canvas.source.style;
			canvas.size(1,1);
			canvasStyle.transform=canvasStyle.webkitTransform=canvasStyle.msTransform=canvasStyle.mozTransform=canvasStyle.oTransform="";
			this.renderingEnabled=false;
			Laya.timer.once(100,this,this._changeCanvasSize);
		}

		/**
		*设置屏幕大小，场景会根据屏幕大小进行适配。
		*@param screenWidth 屏幕宽度。
		*@param screenHeight 屏幕高度。
		*/
		__proto.setScreenSize=function(screenWidth,screenHeight){
			var rotation=false;
			if (this._screenMode!=="none"){
				var screenType=screenWidth / screenHeight < 1 ? "vertical" :"horizontal";
				rotation=screenType!==this._screenMode;
				if (rotation){
					var temp=screenHeight;
					screenHeight=screenWidth;
					screenWidth=temp;
				}
			}
			this.canvasRotation=rotation;
			var canvas=Render._mainCanvas;
			var canvasStyle=canvas.source.style;
			var mat=this._canvasTransform.identity();
			var scaleMode=this._scaleMode;
			var scaleX=screenWidth / this.desginWidth;
			var scaleY=screenHeight / this.desginHeight;
			var canvasWidth=this.desginWidth;
			var canvasHeight=this.desginHeight;
			var realWidth=screenWidth;
			var realHeight=screenHeight;
			var pixelRatio=Browser.pixelRatio;
			this._width=this.desginWidth;
			this._height=this.desginHeight;
			switch (scaleMode){
				case "noscale":
					scaleX=scaleY=1;
					realWidth=this.desginWidth;
					realHeight=this.desginHeight;
					break ;
				case "showall":
					scaleX=scaleY=Math.min(scaleX,scaleY);
					canvasWidth=realWidth=Math.round(this.desginWidth *scaleX);
					canvasHeight=realHeight=Math.round(this.desginHeight *scaleY);
					break ;
				case "noborder":
					scaleX=scaleY=Math.max(scaleX,scaleY);
					realWidth=Math.round(this.desginWidth *scaleX);
					realHeight=Math.round(this.desginHeight *scaleY);
					break ;
				case "full":
					scaleX=scaleY=1;
					this._width=canvasWidth=screenWidth;
					this._height=canvasHeight=screenHeight;
					break ;
				case "fixedwidth":
					scaleY=scaleX;
					this._height=screenHeight / scaleX;
					canvasHeight=Math.round(screenHeight / scaleX);
					break ;
				case "fixedheight":
					scaleX=scaleY;
					this._width=screenWidth / scaleY;
					canvasWidth=Math.round(screenWidth / scaleY);
					break ;
				}
			scaleX *=this.scaleX;
			scaleY *=this.scaleY;
			if (scaleX===1 && scaleY===1){
				this.transform && this.transform.identity();
				}else {
				this.transform || (this.transform=new Matrix());
				this.transform.a=scaleX / (realWidth / canvasWidth);
				this.transform.d=scaleY / (realHeight / canvasHeight);
				this.model && this.model.scale(this.transform.a,this.transform.d);
			}
			canvas.size(canvasWidth,canvasHeight);
			RunDriver.changeWebGLSize(canvasWidth,canvasHeight);
			mat.scale(realWidth / canvasWidth / pixelRatio,realHeight / canvasHeight / pixelRatio);
			if (this._alignH==="left")this.offset.x=0;
			else if (this._alignH==="right")this.offset.x=screenWidth-realWidth;
			else this.offset.x=(screenWidth-realWidth)*0.5 / pixelRatio;
			if (this._alignV==="top")this.offset.y=0;
			else if (this._alignV==="bottom")this.offset.y=screenHeight-realHeight;
			else this.offset.y=(screenHeight-realHeight)*0.5 / pixelRatio;
			if (!this._offset){
				this._offset=new Point(parseInt(canvasStyle.left)|| 0,parseInt(canvasStyle.top)|| 0);
				canvasStyle.left=canvasStyle.top="0px";
			}
			this.offset.x+=this._offset.x;
			this.offset.y+=this._offset.y;
			this.offset.x=Math.round(this.offset.x);
			this.offset.y=Math.round(this.offset.y);
			canvasStyle.top=this._safariOffsetY+"px";
			mat.translate(this.offset.x,this.offset.y);
			this.canvasDegree=0;
			if (rotation){
				if (this._screenMode==="horizontal"){
					mat.rotate(Math.PI / 2);
					mat.translate(screenHeight / pixelRatio,0);
					this.canvasDegree=90;
					}else {
					mat.rotate(-Math.PI / 2);
					mat.translate(0,screenWidth / pixelRatio);
					this.canvasDegree=-90;
				}
			}
			if (mat.a < 0.00000000000001)mat.a=mat.d=0;
			if (mat.tx < 0.00000000000001)mat.tx=0;
			if (mat.ty < 0.00000000000001)mat.ty=0;
			canvasStyle.transformOrigin=canvasStyle.webkitTransformOrigin=canvasStyle.msTransformOrigin=canvasStyle.mozTransformOrigin=canvasStyle.oTransformOrigin="0px 0px 0px";
			canvasStyle.transform=canvasStyle.webkitTransform=canvasStyle.msTransform=canvasStyle.mozTransform=canvasStyle.oTransform="matrix("+mat.toString()+")";
			this.renderingEnabled=true;
			this._repaint=1;
			this.event("resize");
		}

		/**@inheritDoc */
		__proto.repaint=function(){
			this._repaint=1;
		}

		/**@inheritDoc */
		__proto.parentRepaint=function(){}
		/**@private */
		__proto._loop=function(){
			this.render(Render.context,0,0);
			return true;
		}

		/**@private */
		__proto._onmouseMove=function(e){
			this._mouseMoveTime=Browser.now();
		}

		/**@inheritDoc */
		__proto.render=function(context,x,y){
			Render.isFlash && this.repaint();
			this._renderCount++;
			var frameMode=this.frameRate==="mouse" ? (((Browser.now()-this._mouseMoveTime)< 2000)? "fast" :"slow"):this.frameRate;
			var isFastMode=(frameMode!=="slow");
			var isDoubleLoop=(this._renderCount % 2===0);
			var ctx=context;
			Stat.renderSlow=!isFastMode;
			if (isFastMode || isDoubleLoop){
				Stat.loopCount++;
				MouseManager.instance.runEvent();
				Laya.timer._update();
				if (Render.isConchNode){
					var customList=Sprite.CustomList;
					for (var i=0,n=customList.length;i < n;i++){
						customList[i].customRender(customList[i].customContext,0,0);
					}
					return;
				}
				if (this.renderingEnabled){
					Render.isWebGL ? ctx.clear():RunDriver.clear(this._bgColor);
					_super.prototype.render.call(this,context,x,y);
				}
			}
			if (Render.isConchNode)return;
			if (this.renderingEnabled && (isFastMode || !isDoubleLoop)){
				Render.isWebGL && RunDriver.clear(this._bgColor);
				RunDriver.beginFlush();
				context.flush();
				RunDriver.endFinish();
			}
			VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
		}

		/**@private */
		__proto._requestFullscreen=function(){
			var element=Browser.document.documentElement;
			if (element.requestFullscreen){
				element.requestFullscreen();
				}else if (element.mozRequestFullScreen){
				element.mozRequestFullScreen();
				}else if (element.webkitRequestFullscreen){
				element.webkitRequestFullscreen();
				}else if (element.msRequestFullscreen){
				element.msRequestFullscreen();
			}
		}

		/**@private */
		__proto._fullScreenChanged=function(){
			Laya.stage.event("fullscreenchange");
		}

		/**退出全屏*/
		__proto.exitFullscreen=function(){
			var document=Browser.document;
			if (document.exitFullscreen){
				document.exitFullscreen();
				}else if (document.mozCancelFullScreen){
				document.mozCancelFullScreen();
				}else if (document.webkitExitFullscreen){
				document.webkitExitFullscreen();
			}
		}

		/**
		*垂直对齐方式。
		*<p><ul>取值范围：
		*<li>"top" ：居顶部对齐；</li>
		*<li>"middle" ：居中对齐；</li>
		*<li>"bottom" ：居底部对齐；</li>
		*</ul></p>
		*/
		__getset(0,__proto,'alignV',function(){
			return this._alignV;
			},function(value){
			this._alignV=value;
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
			this.desginWidth=value;
			_super.prototype._$set_width.call(this,value);
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
			this.desginHeight=value;
			_super.prototype._$set_height.call(this,value);
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		/**鼠标在 Stage 上的 X 轴坐标。*/
		__getset(0,__proto,'mouseX',function(){
			return Math.round(MouseManager.instance.mouseX / this.clientScaleX);
		});

		/**鼠标在 Stage 上的 Y 轴坐标。*/
		__getset(0,__proto,'mouseY',function(){
			return Math.round(MouseManager.instance.mouseY / this.clientScaleY);
		});

		/**
		*<p>缩放模式。</p>
		*<p><ul>取值范围：
		*<li>"noscale" ：不缩放；</li>
		*<li>"exactfit" ：全屏不等比缩放；</li>
		*<li>"showall" ：最小比例缩放；</li>
		*<li>"noborder" ：最大比例缩放；</li>
		*<li>"full" ：不缩放，stage的宽高等于屏幕宽高；</li>
		*<li>"fixedwidth" ：宽度不变，高度根据屏幕比缩放；</li>
		*<li>"fixedheight" ：高度不变，宽度根据屏幕比缩放；</li>
		*</ul></p>
		*默认值为 "noscale"。
		*/
		__getset(0,__proto,'scaleMode',function(){
			return this._scaleMode;
			},function(value){
			this._scaleMode=value;
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		/**
		*水平对齐方式。
		*<p><ul>取值范围：
		*<li>"left" ：居左对齐；</li>
		*<li>"center" ：居中对齐；</li>
		*<li>"right" ：居右对齐；</li>
		*</ul></p>
		*默认值为"left"。
		*/
		__getset(0,__proto,'alignH',function(){
			return this._alignH;
			},function(value){
			this._alignH=value;
			Laya.timer.callLater(this,this._changeCanvasSize);
		});

		/**舞台的背景颜色，默认为黑色，null为透明。*/
		__getset(0,__proto,'bgColor',function(){
			return this._bgColor;
			},function(value){
			this._bgColor=value;
			this.model && this.model.bgColor(value);
			if (value){
				Render.canvas.style.background=value;
				}else {
				Render.canvas.style.background="none";
			}
		});

		/**当前视窗由缩放模式导致的 X 轴缩放系数。*/
		__getset(0,__proto,'clientScaleX',function(){
			return this._transform ? this._transform.getScaleX():1;
		});

		/**当前视窗由缩放模式导致的 Y 轴缩放系数。*/
		__getset(0,__proto,'clientScaleY',function(){
			return this._transform ? this._transform.getScaleY():1;
		});

		/**
		*场景布局类型。
		*<p><ul>取值范围：
		*<li>"none" ：不更改屏幕</li>
		*<li>"horizontal" ：自动横屏</li>
		*<li>"vertical" ：自动竖屏</li>
		*</ul></p>
		*/
		__getset(0,__proto,'screenMode',function(){
			return this._screenMode;
			},function(value){
			this._screenMode=value;
		});

		/**是否开启全屏，用户点击后进入全屏*/
		__getset(0,__proto,'fullScreenEnabled',null,function(value){
			var document=Browser.document;
			var canvas=Render.canvas;
			if (value){
				canvas.addEventListener('mousedown',this._requestFullscreen);
				canvas.addEventListener('touchstart',this._requestFullscreen);
				document.addEventListener("fullscreenchange",this._fullScreenChanged);
				document.addEventListener("mozfullscreenchange",this._fullScreenChanged);
				document.addEventListener("webkitfullscreenchange",this._fullScreenChanged);
				document.addEventListener("msfullscreenchange",this._fullScreenChanged);
				}else {
				canvas.removeEventListener('mousedown',this._requestFullscreen);
				canvas.removeEventListener('touchstart',this._requestFullscreen);
				document.removeEventListener("fullscreenchange",this._fullScreenChanged);
				document.removeEventListener("mozfullscreenchange",this._fullScreenChanged);
				document.removeEventListener("webkitfullscreenchange",this._fullScreenChanged);
				document.removeEventListener("msfullscreenchange",this._fullScreenChanged);
			}
		});

		Stage.SCALE_NOSCALE="noscale";
		Stage.SCALE_EXACTFIT="exactfit";
		Stage.SCALE_SHOWALL="showall";
		Stage.SCALE_NOBORDER="noborder";
		Stage.SCALE_FULL="full";
		Stage.SCALE_FIXED_WIDTH="fixedwidth";
		Stage.SCALE_FIXED_HEIGHT="fixedheight";
		Stage.ALIGN_LEFT="left";
		Stage.ALIGN_RIGHT="right";
		Stage.ALIGN_CENTER="center";
		Stage.ALIGN_TOP="top";
		Stage.ALIGN_MIDDLE="middle";
		Stage.ALIGN_BOTTOM="bottom";
		Stage.SCREEN_NONE="none";
		Stage.SCREEN_HORIZONTAL="horizontal";
		Stage.SCREEN_VERTICAL="vertical";
		Stage.FRAME_FAST="fast";
		Stage.FRAME_SLOW="slow";
		Stage.FRAME_MOUSE="mouse";
		return Stage;
	})(Sprite)


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.shader.d2.fillTexture.FillTextureShader extends laya.webgl.shader.Shader
	var FillTextureShader=(function(_super){
		function FillTextureShader(){
			var vs="attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform mat4 mmat;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*vec4(position.x,position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_texcoord = texcoord;  \n}";
			var ps="precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nuniform vec4 u_texRange;\nuniform vec2 u_offset;\nvoid main() {\n	vec2 newTexCoord;\n	newTexCoord.x = mod(((u_offset.x + v_texcoord.x) * u_texRange.y),u_texRange.y) + u_texRange.x;\n	newTexCoord.y = mod(((u_offset.y + v_texcoord.y) * u_texRange.w),u_texRange.w) + u_texRange.z;\n	vec4 t_color = texture2D(texture, newTexCoord);\n	gl_FragColor = t_color.rgba;\n}";
			FillTextureShader.__super.call(this,vs,ps,"fillTextureShader");
		}

		__class(FillTextureShader,'laya.webgl.shader.d2.fillTexture.FillTextureShader',_super);
		__static(FillTextureShader,
		['shader',function(){return this.shader=new FillTextureShader();}
		]);
		return FillTextureShader;
	})(Shader)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.shader.d2.Shader2X extends laya.webgl.shader.Shader
	var Shader2X=(function(_super){
		function Shader2X(vs,ps,saveName,nameMap){
			this._params2dQuick1=null;
			this._params2dQuick2=null;
			this._shaderValueWidth=NaN;
			this._shaderValueHeight=NaN;
			Shader2X.__super.call(this,vs,ps,saveName,nameMap);
		}

		__class(Shader2X,'laya.webgl.shader.d2.Shader2X',_super);
		var __proto=Shader2X.prototype;
		__proto.upload2dQuick1=function(shaderValue){
			this.upload(shaderValue,this._params2dQuick1 || this._make2dQuick1());
		}

		__proto._make2dQuick1=function(){
			if (!this._params2dQuick1){
				this.activeResource();
				this._params2dQuick1=[];
				var params=this._params,one;
				for (var i=0,n=params.length;i < n;i++){
					one=params[i];
					if (!Render.isFlash && (one.name==="size" || one.name==="mmat" || one.name==="position" || one.name==="texcoord"))continue ;
					this._params2dQuick1.push(one);
				}
			}
			return this._params2dQuick1;
		}

		__proto.detoryResource=function(){
			_super.prototype.detoryResource.call(this);
			this._params2dQuick1=null;
			this._params2dQuick2=null;
		}

		__proto.upload2dQuick2=function(shaderValue){
			this.upload(shaderValue,this._params2dQuick2 || this._make2dQuick2());
		}

		__proto._make2dQuick2=function(){
			if (!this._params2dQuick2){
				this.activeResource();
				this._params2dQuick2=[];
				var params=this._params,one;
				for (var i=0,n=params.length;i < n;i++){
					one=params[i];
					if (!Render.isFlash && (one.name==="size"))continue ;
					this._params2dQuick2.push(one);
				}
			}
			return this._params2dQuick2;
		}

		Shader2X.create=function(vs,ps,saveName,nameMap){
			return new Shader2X(vs,ps,saveName,nameMap);
		}

		return Shader2X;
	})(Shader)


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.shader.d2.skinAnishader.SkinAniShader extends laya.webgl.shader.Shader
	var SkinAniShader1=(function(_super){
		function SkinAniShader(){
			var vs="attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform mat4 mmat;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*vec4(position.x,position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_texcoord = texcoord;  \n}";
			var ps="precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nvoid main() {\n	vec4 t_color = texture2D(texture, v_texcoord);\n	gl_FragColor = t_color.rgba;\n}";
			SkinAniShader.__super.call(this,vs,ps,"SpineShader");
		}

		__class(SkinAniShader,'laya.webgl.shader.d2.skinAnishader.SkinAniShader',_super,'SkinAniShader1');
		__static(SkinAniShader,
		['shader',function(){return this.shader=new SkinAniShader();}
		]);
		return SkinAniShader;
	})(Shader)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.utils.Buffer2D extends laya.webgl.utils.Buffer
	var Buffer2D=(function(_super){
		function Buffer2D(){
			this._maxsize=0;
			this._upload=true;
			this._uploadSize=0;
			Buffer2D.__super.call(this);
			this.lock=true;
		}

		__class(Buffer2D,'laya.webgl.utils.Buffer2D',_super);
		var __proto=Buffer2D.prototype;
		__proto._bufferData=function(){
			this._maxsize=Math.max(this._maxsize,this._byteLength);
			if (Stat.loopCount % 30==0){
				if (this._buffer.byteLength > (this._maxsize+64)){
					this.memorySize=this._buffer.byteLength;
					this._buffer=this._buffer.slice(0,this._maxsize+64);
					this._checkArrayUse();
				}
				this._maxsize=this._byteLength;
			}
			if (this._uploadSize < this._buffer.byteLength){
				this._uploadSize=this._buffer.byteLength;
				Buffer._gl.bufferData(this._bufferType,this._uploadSize,this._bufferUsage);
				this.memorySize=this._uploadSize;
			}
			Buffer._gl.bufferSubData(this._bufferType,0,this._buffer);
		}

		__proto._bufferSubData=function(offset,dataStart,dataLength){
			(offset===void 0)&& (offset=0);
			(dataStart===void 0)&& (dataStart=0);
			(dataLength===void 0)&& (dataLength=0);
			this._maxsize=Math.max(this._maxsize,this._byteLength);
			if (Stat.loopCount % 30==0){
				if (this._buffer.byteLength > (this._maxsize+64)){
					this.memorySize=this._buffer.byteLength;
					this._buffer=this._buffer.slice(0,this._maxsize+64);
					this._checkArrayUse();
				}
				this._maxsize=this._byteLength;
			}
			if (this._uploadSize < this._buffer.byteLength){
				this._uploadSize=this._buffer.byteLength;
				Buffer._gl.bufferData(this._bufferType,this._uploadSize,this._bufferUsage);
				this.memorySize=this._uploadSize;
			}
			if (dataStart || dataLength){
				var subBuffer=this._buffer.slice(dataStart,dataLength);
				Buffer._gl.bufferSubData(this._bufferType,offset,subBuffer);
				}else {
				Buffer._gl.bufferSubData(this._bufferType,offset,this._buffer);
			}
		}

		__proto._checkArrayUse=function(){}
		__proto._bind_upload=function(){
			if (!this._upload)
				return false;
			this._upload=false;
			this._bind();
			this._bufferData();
			return true;
		}

		__proto._bind_subUpload=function(offset,dataStart,dataLength){
			(offset===void 0)&& (offset=0);
			(dataStart===void 0)&& (dataStart=0);
			(dataLength===void 0)&& (dataLength=0);
			if (!this._upload)
				return false;
			this._upload=false;
			this._bind();
			this._bufferSubData(offset,dataStart,dataLength);
			return true;
		}

		__proto._resizeBuffer=function(nsz,copy){
			if (nsz < this._buffer.byteLength)
				return this;
			this.memorySize=nsz;
			if (copy && this._buffer && this._buffer.byteLength > 0){
				var newbuffer=new ArrayBuffer(nsz);
				var n=new Uint8Array(newbuffer);
				n.set(new Uint8Array(this._buffer),0);
				this._buffer=newbuffer;
			}else
			this._buffer=new ArrayBuffer(nsz);
			this._checkArrayUse();
			this._upload=true;
			return this;
		}

		__proto.append=function(data){
			this._upload=true;
			var byteLen=0,n;
			byteLen=data.byteLength;
			if ((data instanceof Uint8Array)){
				this._resizeBuffer(this._byteLength+byteLen,true);
				n=new Uint8Array(this._buffer,this._byteLength);
				}else if ((data instanceof Uint16Array)){
				this._resizeBuffer(this._byteLength+byteLen,true);
				n=new Uint16Array(this._buffer,this._byteLength);
				}else if ((data instanceof Float32Array)){
				this._resizeBuffer(this._byteLength+byteLen,true);
				n=new Float32Array(this._buffer,this._byteLength);
			}
			n.set(data,0);
			this._byteLength+=byteLen;
			this._checkArrayUse();
		}

		__proto.getBuffer=function(){
			return this._buffer;
		}

		__proto.setNeedUpload=function(){
			this._upload=true;
		}

		__proto.getNeedUpload=function(){
			return this._upload;
		}

		__proto.upload=function(){
			var scuess=this._bind_upload();
			Buffer._gl.bindBuffer(this._bufferType,null);
			Buffer._bindActive[this._bufferType]=null;
			Shader.activeShader=null
			return scuess;
		}

		__proto.subUpload=function(offset,dataStart,dataLength){
			(offset===void 0)&& (offset=0);
			(dataStart===void 0)&& (dataStart=0);
			(dataLength===void 0)&& (dataLength=0);
			var scuess=this._bind_subUpload();
			Buffer._gl.bindBuffer(this._bufferType,null);
			Buffer._bindActive[this._bufferType]=null;
			Shader.activeShader=null
			return scuess;
		}

		__proto.detoryResource=function(){
			_super.prototype.detoryResource.call(this);
			this._upload=true;
			this._uploadSize=0;
		}

		__proto.clear=function(){
			this._byteLength=0;
			this._upload=true;
		}

		__getset(0,__proto,'bufferLength',function(){
			return this._buffer.byteLength;
		});

		__getset(0,__proto,'byteLength',_super.prototype._$get_byteLength,function(value){
			if (this._byteLength===value)
				return;
			value <=this._buffer.byteLength || (this._resizeBuffer(value *2+256,true));
			this._byteLength=value;
		});

		Buffer2D.__int__=function(gl){
			IndexBuffer2D.QuadrangleIB=IndexBuffer2D.create(0x88E4);
			GlUtils.fillIBQuadrangle(IndexBuffer2D.QuadrangleIB,16);
		}

		Buffer2D.UNICOLOR="UNICOLOR";
		Buffer2D.MVPMATRIX="MVPMATRIX";
		Buffer2D.MATRIX1="MATRIX1";
		Buffer2D.MATRIX2="MATRIX2";
		Buffer2D.DIFFUSETEXTURE="DIFFUSETEXTURE";
		Buffer2D.NORMALTEXTURE="NORMALTEXTURE";
		Buffer2D.SPECULARTEXTURE="SPECULARTEXTURE";
		Buffer2D.EMISSIVETEXTURE="EMISSIVETEXTURE";
		Buffer2D.AMBIENTTEXTURE="AMBIENTTEXTURE";
		Buffer2D.REFLECTTEXTURE="REFLECTTEXTURE";
		Buffer2D.MATRIXARRAY0="MATRIXARRAY0";
		Buffer2D.FLOAT0="FLOAT0";
		Buffer2D.UVAGEX="UVAGEX";
		Buffer2D.CAMERAPOS="CAMERAPOS";
		Buffer2D.ALBEDO="ALBEDO";
		Buffer2D.ALPHATESTVALUE="ALPHATESTVALUE";
		Buffer2D.FOGCOLOR="FOGCOLOR";
		Buffer2D.FOGSTART="FOGSTART";
		Buffer2D.FOGRANGE="FOGRANGE";
		Buffer2D.MATERIALAMBIENT="MATERIALAMBIENT";
		Buffer2D.MATERIALDIFFUSE="MATERIALDIFFUSE";
		Buffer2D.MATERIALSPECULAR="MATERIALSPECULAR";
		Buffer2D.MATERIALREFLECT="MATERIALREFLECT";
		Buffer2D.LIGHTDIRECTION="LIGHTDIRECTION";
		Buffer2D.LIGHTDIRDIFFUSE="LIGHTDIRDIFFUSE";
		Buffer2D.LIGHTDIRAMBIENT="LIGHTDIRAMBIENT";
		Buffer2D.LIGHTDIRSPECULAR="LIGHTDIRSPECULAR";
		Buffer2D.POINTLIGHTPOS="POINTLIGHTPOS";
		Buffer2D.POINTLIGHTRANGE="POINTLIGHTRANGE";
		Buffer2D.POINTLIGHTATTENUATION="POINTLIGHTATTENUATION";
		Buffer2D.POINTLIGHTDIFFUSE="POINTLIGHTDIFFUSE";
		Buffer2D.POINTLIGHTAMBIENT="POINTLIGHTAMBIENT";
		Buffer2D.POINTLIGHTSPECULAR="POINTLIGHTSPECULAR";
		Buffer2D.SPOTLIGHTPOS="SPOTLIGHTPOS";
		Buffer2D.SPOTLIGHTDIRECTION="SPOTLIGHTDIRECTION";
		Buffer2D.SPOTLIGHTSPOT="SPOTLIGHTSPOT";
		Buffer2D.SPOTLIGHTRANGE="SPOTLIGHTRANGE";
		Buffer2D.SPOTLIGHTATTENUATION="SPOTLIGHTATTENUATION";
		Buffer2D.SPOTLIGHTDIFFUSE="SPOTLIGHTDIFFUSE";
		Buffer2D.SPOTLIGHTAMBIENT="SPOTLIGHTAMBIENT";
		Buffer2D.SPOTLIGHTSPECULAR="SPOTLIGHTSPECULAR";
		Buffer2D.TIME="TIME";
		Buffer2D.VIEWPORTSCALE="VIEWPORTSCALE";
		Buffer2D.CURRENTTIME="CURRENTTIME";
		Buffer2D.DURATION="DURATION";
		Buffer2D.GRAVITY="GRAVITY";
		Buffer2D.ENDVELOCITY="ENDVELOCITY";
		Buffer2D.FLOAT32=4;
		Buffer2D.SHORT=2;
		return Buffer2D;
	})(Buffer)


	/**
	*@private
	*<code>FileBitmap</code> 是图片文件资源类。
	*/
	//class laya.resource.FileBitmap extends laya.resource.Bitmap
	var FileBitmap=(function(_super){
		function FileBitmap(){
			this._src=null;
			this._onload=null;
			this._onerror=null;
			FileBitmap.__super.call(this);
		}

		__class(FileBitmap,'laya.resource.FileBitmap',_super);
		var __proto=FileBitmap.prototype;
		/**
		*载入完成处理函数。
		*/
		__getset(0,__proto,'onload',null,function(value){
		});

		/**
		*文件路径全名。
		*/
		__getset(0,__proto,'src',function(){
			return this._src;
			},function(value){
			this._src=value;
		});

		/**
		*错误处理函数。
		*/
		__getset(0,__proto,'onerror',null,function(value){
		});

		return FileBitmap;
	})(Bitmap)


	/**
	*<code>HTMLCanvas</code> 是 Html Canvas 的代理类，封装了 Canvas 的属性和方法。。请不要直接使用 new HTMLCanvas！
	*/
	//class laya.resource.HTMLCanvas extends laya.resource.Bitmap
	var HTMLCanvas=(function(_super){
		function HTMLCanvas(type){
			//this._ctx=null;
			this._is2D=false;
			HTMLCanvas.__super.call(this);
			var _$this=this;
			this._source=this;
			if (type==="2D" || (type==="AUTO" && !Render.isWebGL)){
				this._is2D=true;
				this._source=Browser.createElement("canvas");
				var o=this;
				o.getContext=function (contextID,other){
					if (_$this._ctx)return _$this._ctx;
					var ctx=_$this._ctx=_$this._source.getContext(contextID,other);
					if (ctx){
						ctx._canvas=o;
						if(!Render.isFlash)ctx.size=function (w,h){
						};
					}
					return ctx;
				}
			}else this._source={};
		}

		__class(HTMLCanvas,'laya.resource.HTMLCanvas',_super);
		var __proto=HTMLCanvas.prototype;
		/**
		*清空画布内容。
		*/
		__proto.clear=function(){
			this._ctx && this._ctx.clear();
		}

		/**
		*销毁。
		*/
		__proto.destroy=function(){
			this._ctx && this._ctx.destroy();
			this._ctx=null;
		}

		/**
		*释放。
		*/
		__proto.release=function(){}
		/**
		*@private
		*设置 Canvas 渲染上下文。
		*@param context Canvas 渲染上下文。
		*/
		__proto._setContext=function(context){
			this._ctx=context;
		}

		/**
		*获取 Canvas 渲染上下文。
		*@param contextID 上下文ID.
		*@param other
		*@return Canvas 渲染上下文 Context 对象。
		*/
		__proto.getContext=function(contextID,other){
			return this._ctx ? this._ctx :(this._ctx=HTMLCanvas._createContext(this));
		}

		/**
		*获取内存大小。
		*@return 内存大小。
		*/
		__proto.getMemSize=function(){
			return 0;
		}

		/**
		*设置宽高。
		*@param w 宽度。
		*@param h 高度。
		*/
		__proto.size=function(w,h){
			if (this._w !=w || this._h !=h){
				this._w=w;
				this._h=h;
				this._ctx && this._ctx.size(w,h);
				this._source && (this._source.height=h,this._source.width=w);
			}
		}

		/**
		*Canvas 渲染上下文。
		*/
		__getset(0,__proto,'context',function(){
			return this._ctx;
		});

		/**
		*是否当作 Bitmap 对象。
		*/
		__getset(0,__proto,'asBitmap',null,function(value){
		});

		HTMLCanvas.create=function(type){
			return new HTMLCanvas(type);
		}

		HTMLCanvas.TYPE2D="2D";
		HTMLCanvas.TYPE3D="3D";
		HTMLCanvas.TYPEAUTO="AUTO";
		HTMLCanvas._createContext=null
		return HTMLCanvas;
	})(Bitmap)


	//class laya.webgl.atlas.AtlasWebGLCanvas extends laya.resource.Bitmap
	var AtlasWebGLCanvas=(function(_super){
		function AtlasWebGLCanvas(){
			this._flashCacheImage=null;
			this._flashCacheImageNeedFlush=false;
			AtlasWebGLCanvas.__super.call(this);
		}

		__class(AtlasWebGLCanvas,'laya.webgl.atlas.AtlasWebGLCanvas',_super);
		var __proto=AtlasWebGLCanvas.prototype;
		/***重新创建资源*/
		__proto.recreateResource=function(){
			this.startCreate();
			var gl=WebGL.mainContext;
			var glTex=this._source=gl.createTexture();
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,0x0DE1,glTex);
			gl.texImage2D(0x0DE1,0,0x1908,this._w,this._h,0,0x1908,0x1401,null);
			gl.texParameteri(0x0DE1,0x2801,0x2601);
			gl.texParameteri(0x0DE1,0x2800,0x2601);
			gl.texParameteri(0x0DE1,0x2802,0x812F);
			gl.texParameteri(0x0DE1,0x2803,0x812F);
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			this.memorySize=this._w *this._h *4;
			this.compoleteCreate();
		}

		/***销毁资源*/
		__proto.detoryResource=function(){
			if (this._source){
				WebGL.mainContext.deleteTexture(this._source);
				this._source=null;
				this.memorySize=0;
			}
		}

		/**采样image到WebGLTexture的一部分*/
		__proto.texSubImage2D=function(xoffset,yoffset,bitmap){
			if (!Render.isFlash){
				var gl=WebGL.mainContext;
				var preTarget=WebGLContext.curBindTexTarget;
				var preTexture=WebGLContext.curBindTexValue;
				WebGLContext.bindTexture(gl,0x0DE1,this._source);
				(xoffset-1 >=0)&& (gl.texSubImage2D(0x0DE1,0,xoffset-1,yoffset,0x1908,0x1401,bitmap));
				(xoffset+1 <=this._w)&& (gl.texSubImage2D(0x0DE1,0,xoffset+1,yoffset,0x1908,0x1401,bitmap));
				(yoffset-1 >=0)&& (gl.texSubImage2D(0x0DE1,0,xoffset,yoffset-1,0x1908,0x1401,bitmap));
				(yoffset+1 <=this._h)&& (gl.texSubImage2D(0x0DE1,0,xoffset,yoffset+1,0x1908,0x1401,bitmap));
				gl.texSubImage2D(0x0DE1,0,xoffset,yoffset,0x1908,0x1401,bitmap);
				(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
				}else {
				if (!this._flashCacheImage){
					this._flashCacheImage=HTMLImage.create(null);
					this._flashCacheImage.image.createCanvas(this._w,this._h);
				};
				var bmData=bitmap.bitmapdata;
				(xoffset-1 >=0)&& (this._flashCacheImage.image.copyPixels(bmData,0,0,bmData.width-1,bmData.height,xoffset,yoffset));
				(xoffset+1 <=this._w)&& (this._flashCacheImage.image.copyPixels(bmData,0,0,bmData.width+1,bmData.height,xoffset,yoffset));
				(yoffset-1 >=0)&& (this._flashCacheImage.image.copyPixels(bmData,0,0,bmData.width,bmData.height-1,xoffset,yoffset));
				(yoffset+1 <=this._h)&& (this._flashCacheImage.image.copyPixels(bmData,0,0,bmData.width+1,bmData.height,xoffset,yoffset));
				this._flashCacheImage.image.copyPixels(bmData,0,0,bmData.width,bmData.height,xoffset,yoffset);
				(this._flashCacheImageNeedFlush)|| (this._flashCacheImageNeedFlush=true);
			}
		}

		/**采样image到WebGLTexture的一部分*/
		__proto.texSubImage2DPixel=function(xoffset,yoffset,width,height,pixel){
			var gl=WebGL.mainContext;
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,0x0DE1,this._source);
			var pixels=new Uint8Array(pixel.data);
			gl.texSubImage2D(0x0DE1,0,xoffset,yoffset,width,height,0x1908,0x1401,pixels);
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
		}

		/***
		*设置图片宽度
		*@param value 图片宽度
		*/
		__getset(0,__proto,'width',_super.prototype._$get_width,function(value){
			this._w=value;
		});

		/***
		*设置图片高度
		*@param value 图片高度
		*/
		__getset(0,__proto,'height',_super.prototype._$get_height,function(value){
			this._h=value;
		});

		return AtlasWebGLCanvas;
	})(Bitmap)


	/**
	*...
	*@author
	*/
	//class laya.webgl.resource.WebGLCharImage extends laya.resource.Bitmap
	var WebGLCharImage=(function(_super){
		function WebGLCharImage(canvas,char){
			this.borderSize=12;
			//this._ctx=null;
			//this._allowMerageInAtlas=false;
			//this._enableMerageInAtlas=false;
			//this.canvas=null;
			//this.char=null;
			WebGLCharImage.__super.call(this);
			this.canvas=canvas;
			this.char=char;
			this._enableMerageInAtlas=true;
			var bIsConchApp=Render.isConchApp;
			if (bIsConchApp){
				this._ctx=canvas;
				}else {
				this._ctx=canvas.getContext('2d',undefined);
			};
			var xs=char.xs,ys=char.ys;
			var t=null;
			if (bIsConchApp){
				this._ctx.font=char.font;
				t=this._ctx.measureText(char.char);
				char.width=t.width *xs;
				char.height=t.height *ys;
				}else {
				t=Utils.measureText(char.char,char.font);
				char.width=t.width *xs;
				char.height=t.height *ys;
			}
			this.onresize(char.width+this.borderSize *2,char.height+this.borderSize *2);
		}

		__class(WebGLCharImage,'laya.webgl.resource.WebGLCharImage',_super);
		var __proto=WebGLCharImage.prototype;
		Laya.imps(__proto,{"laya.webgl.resource.IMergeAtlasBitmap":true})
		__proto.recreateResource=function(){
			this.startCreate();
			var char=this.char;
			var bIsConchApp=Render.isConchApp;
			var xs=char.xs,ys=char.ys;
			this.onresize(char.width+this.borderSize *2,char.height+this.borderSize *2);
			this.canvas && (this.canvas.height=this._h,this.canvas.width=this._w);
			if (bIsConchApp){
				var nFontSize=char.fontSize;
				if (xs !=1 || ys !=1){
					nFontSize=parseInt(nFontSize*((xs>ys)?xs:ys)+"");
				};
				var sFont="normal 100 "+nFontSize+"px Arial";
				if (char.borderColor){
					sFont+=" 1 "+char.borderColor;
				}
				this._ctx.font=sFont;
				this._ctx.textBaseline="top";
				this._ctx.fillStyle=char.fillColor;
				this._ctx.fillText(char.char,this.borderSize,this.borderSize,null,null,null);
				}else {
				this._ctx.save();
				(this._ctx).clearRect(0,0,char.width+this.borderSize *2,char.height+this.borderSize *2);
				this._ctx.font=char.font;
				this._ctx.textBaseline="top";
				this._ctx.translate(this.borderSize,this.borderSize);
				if (xs !=1 || ys !=1){
					this._ctx.scale(xs,ys);
				}
				if (char.fillColor && char.borderColor){
					this._ctx.strokeStyle=char.borderColor;
					this._ctx.lineWidth=char.lineWidth;
					this._ctx.strokeText(char.char,0,0,null,null,0,null);
					this._ctx.fillStyle=char.fillColor;
					this._ctx.fillText(char.char,0,0,null,null,null);
					}else {
					if (char.lineWidth===-1){
						this._ctx.fillStyle=char.fillColor ? char.fillColor :"white";
						this._ctx.fillText(char.char,0,0,null,null,null);
						}else {
						this._ctx.strokeStyle=char.borderColor?char.borderColor:'white';
						this._ctx.lineWidth=char.lineWidth;
						this._ctx.strokeText(char.char,0,0,null,null,0,null);
					}
				}
				this._ctx.restore();
			}
			char.borderSize=this.borderSize;
			this.compoleteCreate();
		}

		__proto.onresize=function(w,h){
			this._w=w;
			this._h=h;
			if ((this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight)){
				this._allowMerageInAtlas=true
				}else {
				this._allowMerageInAtlas=false;
				throw new Error("文字尺寸超出大图合集限制！");
			}
		}

		__proto.clearAtlasSource=function(){}
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0,__proto,'allowMerageInAtlas',function(){
			return this._allowMerageInAtlas;
		});

		__getset(0,__proto,'atlasSource',function(){
			return this.canvas;
		});

		/**
		*是否创建私有Source,通常禁止修改
		*@param value 是否创建
		*/
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0,__proto,'enableMerageInAtlas',function(){
			return this._enableMerageInAtlas;
			},function(value){
			this._enableMerageInAtlas=value;
		});

		return WebGLCharImage;
	})(Bitmap)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.resource.WebGLRenderTarget extends laya.resource.Bitmap
	var WebGLRenderTarget=(function(_super){
		function WebGLRenderTarget(width,height,surfaceFormat,surfaceType,depthStencilFormat,mipMap,repeat,minFifter,magFifter){
			//this._frameBuffer=null;
			//this._depthStencilBuffer=null;
			//this._surfaceFormat=0;
			//this._surfaceType=0;
			//this._depthStencilFormat=0;
			//this._mipMap=false;
			//this._repeat=false;
			//this._minFifter=0;
			//this._magFifter=0;
			(surfaceFormat===void 0)&& (surfaceFormat=0x1908);
			(surfaceType===void 0)&& (surfaceType=0x1401);
			(depthStencilFormat===void 0)&& (depthStencilFormat=0x81A5);
			(mipMap===void 0)&& (mipMap=false);
			(repeat===void 0)&& (repeat=false);
			(minFifter===void 0)&& (minFifter=-1);
			(magFifter===void 0)&& (magFifter=1);
			WebGLRenderTarget.__super.call(this);
			this._w=width;
			this._h=height;
			this._surfaceFormat=surfaceFormat;
			this._surfaceType=surfaceType;
			this._depthStencilFormat=depthStencilFormat;
			this._mipMap=mipMap;
			this._repeat=repeat;
			this._minFifter=minFifter;
			this._magFifter=magFifter;
		}

		__class(WebGLRenderTarget,'laya.webgl.resource.WebGLRenderTarget',_super);
		var __proto=WebGLRenderTarget.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			var gl=WebGL.mainContext;
			this._frameBuffer || (this._frameBuffer=gl.createFramebuffer());
			this._source || (this._source=gl.createTexture());
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,0x0DE1,this._source);
			gl.texImage2D(0x0DE1,0,0x1908,this._w,this._h,0,this._surfaceFormat,this._surfaceType,null);
			var minFifter=this._minFifter;
			var magFifter=this._magFifter;
			var repeat=this._repeat ? 0x2901 :0x812F;
			var isPot=Arith.isPOT(this._w,this._h);
			if (isPot){
				if (this._mipMap)
					(minFifter!==-1)|| (minFifter=0x2703);
				else
				(minFifter!==-1)|| (minFifter=0x2601);
				(magFifter!==-1)|| (magFifter=0x2601);
				gl.texParameteri(0x0DE1,0x2801,minFifter);
				gl.texParameteri(0x0DE1,0x2800,magFifter);
				gl.texParameteri(0x0DE1,0x2802,repeat);
				gl.texParameteri(0x0DE1,0x2803,repeat);
				this._mipMap && gl.generateMipmap(0x0DE1);
				}else {
				(minFifter!==-1)|| (minFifter=0x2601);
				(magFifter!==-1)|| (magFifter=0x2601);
				gl.texParameteri(0x0DE1,0x2801,minFifter);
				gl.texParameteri(0x0DE1,0x2800,magFifter);
				gl.texParameteri(0x0DE1,0x2802,0x812F);
				gl.texParameteri(0x0DE1,0x2803,0x812F);
			}
			gl.bindFramebuffer(0x8D40,this._frameBuffer);
			gl.framebufferTexture2D(0x8D40,0x8CE0,0x0DE1,this._source,0);
			if (this._depthStencilFormat){
				this._depthStencilBuffer || (this._depthStencilBuffer=gl.createRenderbuffer());
				gl.bindRenderbuffer(0x8D41,this._depthStencilBuffer);
				gl.renderbufferStorage(0x8D41,this._depthStencilFormat,this._w,this._h);
				switch (this._depthStencilFormat){
					case 0x81A5:
						gl.framebufferRenderbuffer(0x8D40,0x8D00,0x8D41,this._depthStencilBuffer);
						break ;
					case 0x8D48:
						gl.framebufferRenderbuffer(0x8D40,0x8D20,0x8D41,this._depthStencilBuffer);
						break ;
					case 0x84F9:
						gl.framebufferRenderbuffer(0x8D40,0x821A,0x8D41,this._depthStencilBuffer);
						break ;
					}
			}
			gl.bindFramebuffer(0x8D40,null);
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			gl.bindRenderbuffer(0x8D41,null);
			this.memorySize=this._w *this._h *4;
			this.compoleteCreate();
		}

		__proto.detoryResource=function(){
			if (this._frameBuffer){
				WebGL.mainContext.deleteTexture(this._source);
				WebGL.mainContext.deleteFramebuffer(this._frameBuffer);
				WebGL.mainContext.deleteRenderbuffer(this._depthStencilBuffer);
				this._source=null;
				this._frameBuffer=null;
				this._depthStencilBuffer=null;
				this.memorySize=0;
			}
		}

		__getset(0,__proto,'frameBuffer',function(){
			return this._frameBuffer;
		});

		__getset(0,__proto,'depthStencilBuffer',function(){
			return this._depthStencilBuffer;
		});

		return WebGLRenderTarget;
	})(Bitmap)


	//class laya.webgl.shader.d2.value.TextSV extends laya.webgl.shader.d2.value.TextureSV
	var TextSV=(function(_super){
		function TextSV(args){
			TextSV.__super.call(this,0x40);
			this.defines.add(0x40);
		}

		__class(TextSV,'laya.webgl.shader.d2.value.TextSV',_super);
		var __proto=TextSV.prototype;
		__proto.release=function(){
			TextSV.pool[TextSV._length++]=this;
			this.clear();
		}

		__proto.clear=function(){
			_super.prototype.clear.call(this);
		}

		TextSV.create=function(){
			if (TextSV._length)return TextSV.pool[--TextSV._length];
			else return new TextSV(null);
		}

		TextSV.pool=[];
		TextSV._length=0;
		return TextSV;
	})(TextureSV)


	/**
	*<code>DirectionLight</code> 类用于创建平行光。
	*/
	//class laya.d3.core.light.DirectionLight extends laya.d3.core.light.LightSprite
	var DirectionLight1=(function(_super){
		function DirectionLight(){
			this._direction=null;
			DirectionLight.__super.call(this);
			this._diffuseColor=new Vector3(1.0,1.0,1.0);
			this._ambientColor=new Vector3(0.6,0.6,0.6);
			this._specularColor=new Vector3(1.0,1.0,1.0);
			this._reflectColor=new Vector3(1.0,1.0,1.0);
			this._direction=new Vector3(0.0,-0.5,-1.0);
		}

		__class(DirectionLight,'laya.d3.core.light.DirectionLight',_super,'DirectionLight1');
		var __proto=DirectionLight.prototype;
		/**
		*更新平行光相关渲染状态参数。
		*@param state 渲染状态参数。
		*/
		__proto.updateToWorldState=function(state){
			if (state.scene.enableLight){
				var shaderValue=state.worldShaderValue;
				var loopCount=Stat.loopCount;
				state.shaderDefs.add(0x40);
				shaderValue.pushValue("LIGHTDIRDIFFUSE",this.diffuseColor.elements,loopCount);
				shaderValue.pushValue("LIGHTDIRAMBIENT",this.ambientColor.elements,loopCount);
				shaderValue.pushValue("LIGHTDIRSPECULAR",this.specularColor.elements,loopCount);
				shaderValue.pushValue("LIGHTDIRECTION",this.direction.elements,loopCount);
			}
		}

		/**
		*设置平行光的方向。
		*@param value 平行光的方向。
		*/
		/**
		*获取平行光的方向。
		*@return 平行光的方向。
		*/
		__getset(0,__proto,'direction',function(){
			return this._direction;
			},function(value){
			this._direction=value;
		});

		/**
		*获取平行光的类型。
		*@return 平行光的类型。
		*/
		__getset(0,__proto,'lightType',function(){
			return 1;
		});

		return DirectionLight;
	})(LightSprite)


	/**
	*<p><code>Input</code> 类用于创建显示对象以显示和输入文本。</p>
	*
	*@example 以下示例代码，创建了一个 <code>Text</code> 实例。
	*<listing version="3.0">
	*package
	*{
		*import laya.display.Input;
		*import laya.events.Event;
		*public class Input_Example
		*{
			*private var input:Input;
			*public function Input_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*input=new Input();//创建一个 Input 类的实例对象 input 。
				*input.text="这个是一个 Input 文本示例。";
				*input.color="#008fff";//设置 input 的文本颜色。
				*input.font="Arial";//设置 input 的文本字体。
				*input.bold=true;//设置 input 的文本显示为粗体。
				*input.fontSize=30;//设置 input 的字体大小。
				*input.wordWrap=true;//设置 input 的文本自动换行。
				*input.x=100;//设置 input 对象的属性 x 的值，用于控制 input 对象的显示位置。
				*input.y=100;//设置 input 对象的属性 y 的值，用于控制 input 对象的显示位置。
				*input.width=300;//设置 input 的宽度。
				*input.height=200;//设置 input 的高度。
				*input.italic=true;//设置 input 的文本显示为斜体。
				*input.borderColor="#fff000";//设置 input 的文本边框颜色。
				*Laya.stage.addChild(input);//将 input 添加到显示列表。
				*input.on(Event.FOCUS,this,onFocus);//给 input 对象添加获得焦点事件侦听。
				*input.on(Event.BLUR,this,onBlur);//给 input 对象添加失去焦点事件侦听。
				*input.on(Event.INPUT,this,onInput);//给 input 对象添加输入字符事件侦听。
				*input.on(Event.ENTER,this,onEnter);//给 input 对象添加敲回车键事件侦听。
				*}
			*private function onFocus():void
			*{
				*trace("输入框 input 获得焦点。");
				*}
			*private function onBlur():void
			*{
				*trace("输入框 input 失去焦点。");
				*}
			*private function onInput():void
			*{
				*trace("用户在输入框 input 输入字符。文本内容：",input.text);
				*}
			*private function onEnter():void
			*{
				*trace("用户在输入框 input 内敲回车键。");
				*}
			*}
		*}
	*</listing>
	*<listing version="3.0">
	*var input;
	*Input_Example();
	*function Input_Example()
	*{
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*onInit();
		*}
	*function onInit()
	*{
		*input=new laya.display.Input();//创建一个 Input 类的实例对象 input 。
		*input.text="这个是一个 Input 文本示例。";
		*input.color="#008fff";//设置 input 的文本颜色。
		*input.font="Arial";//设置 input 的文本字体。
		*input.bold=true;//设置 input 的文本显示为粗体。
		*input.fontSize=30;//设置 input 的字体大小。
		*input.wordWrap=true;//设置 input 的文本自动换行。
		*input.x=100;//设置 input 对象的属性 x 的值，用于控制 input 对象的显示位置。
		*input.y=100;//设置 input 对象的属性 y 的值，用于控制 input 对象的显示位置。
		*input.width=300;//设置 input 的宽度。
		*input.height=200;//设置 input 的高度。
		*input.italic=true;//设置 input 的文本显示为斜体。
		*input.borderColor="#fff000";//设置 input 的文本边框颜色。
		*Laya.stage.addChild(input);//将 input 添加到显示列表。
		*input.on(laya.events.Event.FOCUS,this,onFocus);//给 input 对象添加获得焦点事件侦听。
		*input.on(laya.events.Event.BLUR,this,onBlur);//给 input 对象添加失去焦点事件侦听。
		*input.on(laya.events.Event.INPUT,this,onInput);//给 input 对象添加输入字符事件侦听。
		*input.on(laya.events.Event.ENTER,this,onEnter);//给 input 对象添加敲回车键事件侦听。
		*}
	*function onFocus()
	*{
		*console.log("输入框 input 获得焦点。");
		*}
	*function onBlur()
	*{
		*console.log("输入框 input 失去焦点。");
		*}
	*function onInput()
	*{
		*console.log("用户在输入框 input 输入字符。文本内容：",input.text);
		*}
	*function onEnter()
	*{
		*console.log("用户在输入框 input 内敲回车键。");
		*}
	*</listing>
	*<listing version="3.0">
	*import Input=laya.display.Input;
	*class Input_Example {
		*private input:Input;
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*this.input=new Input();//创建一个 Input 类的实例对象 input 。
			*this.input.text="这个是一个 Input 文本示例。";
			*this.input.color="#008fff";//设置 input 的文本颜色。
			*this.input.font="Arial";//设置 input 的文本字体。
			*this.input.bold=true;//设置 input 的文本显示为粗体。
			*this.input.fontSize=30;//设置 input 的字体大小。
			*this.input.wordWrap=true;//设置 input 的文本自动换行。
			*this.input.x=100;//设置 input 对象的属性 x 的值，用于控制 input 对象的显示位置。
			*this.input.y=100;//设置 input 对象的属性 y 的值，用于控制 input 对象的显示位置。
			*this.input.width=300;//设置 input 的宽度。
			*this.input.height=200;//设置 input 的高度。
			*this.input.italic=true;//设置 input 的文本显示为斜体。
			*this.input.borderColor="#fff000";//设置 input 的文本边框颜色。
			*Laya.stage.addChild(this.input);//将 input 添加到显示列表。
			*this.input.on(laya.events.Event.FOCUS,this,this.onFocus);//给 input 对象添加获得焦点事件侦听。
			*this.input.on(laya.events.Event.BLUR,this,this.onBlur);//给 input 对象添加失去焦点事件侦听。
			*this.input.on(laya.events.Event.INPUT,this,this.onInput);//给 input 对象添加输入字符事件侦听。
			*this.input.on(laya.events.Event.ENTER,this,this.onEnter);//给 input 对象添加敲回车键事件侦听。
			*}
		*private onFocus():void {
			*console.log("输入框 input 获得焦点。");
			*}
		*private onBlur():void {
			*console.log("输入框 input 失去焦点。");
			*}
		*private onInput():void {
			*console.log("用户在输入框 input 输入字符。文本内容：",this.input.text);
			*}
		*private onEnter():void {
			*console.log("用户在输入框 input 内敲回车键。");
			*}
		*}
	*</listing>
	*/
	//class laya.display.Input extends laya.display.Text
	var Input=(function(_super){
		function Input(){
			this._focus=false;
			this._multiline=false;
			this._editable=true;
			this._restrictPattern=null;
			this.inputElementXAdjuster=0;
			this.inputElementYAdjuster=0;
			this._prompt='';
			this._promptColor="#A9A9A9";
			this._originColor="#000000";
			this._content='';
			Input.__super.call(this);
			this._maxChars=1E5;
			this._width=100;
			this._height=20;
			this.multiline=false;
			this.overflow=Text.SCROLL;
			this.on("mousedown",this,this._onMouseDown);
			this.on("undisplay",this,this._onUnDisplay);
		}

		__class(Input,'laya.display.Input',_super);
		var __proto=Input.prototype;
		/**@private */
		__proto._onUnDisplay=function(e){
			this.focus=false;
		}

		/**@private */
		__proto._onMouseDown=function(e){
			this.focus=true;
			Browser.document.addEventListener(Browser.enableTouch ? "touchstart" :"mousedown",laya.display.Input._checkBlur);
		}

		/**@inheritDoc*/
		__proto.render=function(context,x,y){
			laya.display.Sprite.prototype.render.call(this,context,x,y);
		}

		/**
		*在输入期间，如果 Input 实例的位置改变，调用该方法同步输入框的位置。
		*/
		__proto._syncInputTransform=function(){
			var style=this.nativeInput.style;
			var stage=Laya.stage;
			var rec;
			rec=Utils.getGlobalPosAndScale(this);
			var a=stage._canvasTransform.a,d=stage._canvasTransform.d;
			var x=(rec.x+this.padding[3]+this.inputElementXAdjuster)*stage.clientScaleX *a+Math.max(0,stage.offset.x);
			var y=(rec.y+this.padding[0]+this.inputElementYAdjuster)*stage.clientScaleY *d+Math.max(0,stage.offset.y);
			Input.inputContainer.setPos(x,y);
			var inputWid=this._width-this.padding[1]-this.padding[3];
			var inputHei=this._height-this.padding[0]-this.padding[2];
			this.nativeInput.setSize(inputWid,inputHei);
			if (Render.isConchApp){
				this.nativeInput.setPos(x,y);
			}
			if (!this._getVisible())this.focus=false;
			if (stage.transform || rec.width !=1 || rec.height !=1 || a !=1 || d !=1){
				x=stage.clientScaleX *a *rec.width;
				y=stage.clientScaleY *d *rec.height;
				var ts="scale("+x+","+y+")";
				if (ts !=style.transform){
					style.transform=ts;
					if (Render.isConchApp){
						this.nativeInput.setScale(x,y);
					}
				}
			}
		}

		/**@private */
		__proto._getVisible=function(){
			var target=this;
			while (target){
				if (target.visible===false)return false;
				target=target.parent;
			}
			return true;
		}

		/**选中所有文本。*/
		__proto.select=function(){
			this.nativeInput.select();
		}

		/**@private 设置输入法（textarea或input）*/
		__proto._setInputMethod=function(){
			Input.input.parentElement && (Input.inputContainer.removeChild(Input.input));
			Input.area.parentElement && (Input.inputContainer.removeChild(Input.area));
			Input.inputElement=(this._multiline ? Input.area :Input.input);
			Input.inputContainer.appendChild(Input.inputElement);
		}

		/**@private */
		__proto._focusIn=function(){
			var input=this.nativeInput;
			this._focus=true;
			var cssStyle=input.style;
			cssStyle.whiteSpace=(this.wordWrap ? "pre-wrap" :"nowrap");
			this._setPromptColor();
			input.readOnly=!this._editable;
			input.maxLength=this._maxChars;
			var padding=this.padding;
			input.value=this._content;
			input.type=this.asPassword ? "password" :"text";
			input.placeholder=this._prompt;
			Laya.stage.off("keydown",this,this._onKeyDown);
			Laya.stage.on("keydown",this,this._onKeyDown);
			Laya.stage.focus=this;
			this.event("focus");
			if (Browser.onPC)input.focus();
			var temp=this._text;
			this._text=null;
			this.typeset();
			input.setColor(this._originColor);
			input.setFontSize(this.fontSize);
			input.setFontFace(this.font);
			if (Render.isConchApp){
				input.setMultiAble && input.setMultiAble(this._multiline);
			}
			cssStyle.lineHeight=(this.leading+this.fontSize)+"px";
			cssStyle.fontStyle=(this.italic ? "italic" :"normal");
			cssStyle.fontWeight=(this.bold ? "bold" :"normal");
			cssStyle.textAlign=this.align;
			cssStyle.padding="0 0";
			this._syncInputTransform();
			if (!Render.isConchApp && Browser.onPC)
				Laya.timer.frameLoop(1,this,this._syncInputTransform);
		}

		// 设置DOM输入框提示符颜色。
		__proto._setPromptColor=function(){
			Input.promptStyleDOM=Browser.getElementById("promptStyle");
			if (!Input.promptStyleDOM){
				Input.promptStyleDOM=Browser.createElement("style");
				Browser.document.head.appendChild(Input.promptStyleDOM);
			}
			Input.promptStyleDOM.innerText="input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {"+"color:"+this._promptColor+"}"+"input:-moz-placeholder, textarea:-moz-placeholder {"+"color:"+this._promptColor+"}"+"input::-moz-placeholder, textarea::-moz-placeholder {"+"color:"+this._promptColor+"}"+"input:-ms-input-placeholder, textarea:-ms-input-placeholder {"+"color:"+this._promptColor+"}";
		}

		/**@private */
		__proto._focusOut=function(){
			this._focus=false;
			this._text=null;
			this._content=Input.inputElement.value;
			if (!this._content){
				_super.prototype._$set_text.call(this,this._prompt);
				_super.prototype._$set_color.call(this,this._promptColor);
			}
			else{
				_super.prototype._$set_text.call(this,this._content);
				_super.prototype._$set_color.call(this,this._originColor);
			}
			Laya.stage.off("keydown",this,this._onKeyDown);
			Laya.stage.focus=null;
			this.event("blur");
			if (Render.isConchApp)this.nativeInput.blur();
			Browser.onPC && Laya.timer.clear(this,this._syncInputTransform);
			Browser.document.removeEventListener(Browser.enableTouch ? "touchstart" :"mousedown",laya.display.Input._checkBlur);
		}

		/**@private */
		__proto._onKeyDown=function(e){
			if (e.keyCode===13){
				if (Browser.onMobile && !this._multiline)
					this.focus=false;
				this.event("enter");
			}
		}

		/**表示是否是多行输入框。*/
		__getset(0,__proto,'multiline',function(){
			return this._multiline;
			},function(value){
			this._multiline=value;
			this.valign=value ? "top" :"middle";
		});

		/**@inheritDoc */
		__getset(0,__proto,'color',_super.prototype._$get_color,function(value){
			if (this._focus)
				this.nativeInput.setColor(value);
			_super.prototype._$set_color.call(this,this._content?value:this._promptColor);
			this._originColor=value;
		});

		/**
		*设置输入提示符颜色。
		*/
		__getset(0,__proto,'promptColor',function(){
			return this._promptColor;
			},function(value){
			this._promptColor=value;
			if (!this._content)_super.prototype._$set_color.call(this,value);
		});

		/**
		*获取对输入框的引用实例。
		*/
		__getset(0,__proto,'nativeInput',function(){
			return this._multiline ? Input.area :Input.input;
		});

		// 因此 调用focus接口是无法都在移动平台立刻弹出键盘的
		/**
		*表示焦点是否在显示对象上。
		*/
		__getset(0,__proto,'focus',function(){
			return this._focus;
			},function(value){
			var input=this.nativeInput;
			if (this._focus!==value){
				laya.display.Input.isInputting=value;
				if (value){
					input.target && (input.target.focus=false);
					input.target=this;
					this._setInputMethod();
					Browser.container.appendChild(Input.inputContainer);
					this._focusIn();
				}
				else{
					input.target=null;
					this._focusOut();
					Browser.container.removeChild(Input.inputContainer);
					if (Render.isConchApp){
						input.setPos(-10000,-10000);
					}
				}
			}
		});

		/**@inheritDoc */
		__getset(0,__proto,'text',function(){
			if (this._focus)
				return this.nativeInput.value;
			else
			return this._text || "";
			},function(value){
			_super.prototype._$set_color.call(this,this._originColor);
			value+='';
			if (this._focus){
				this.nativeInput.value=value || '';
				this.event("change");
			}
			else{
				if (!this._multiline)
					value=value.replace(/\r?\n/g,'');
				this._content=value;
				if(value)
					_super.prototype._$set_text.call(this,value);
				else{
					_super.prototype._$set_text.call(this,this._prompt);
					_super.prototype._$set_color.call(this,this.promptColor);
				}
			}
		});

		/**
		*字符数量限制，默认为10000。
		*设置字符数量限制时，小于等于0的值将会限制字符数量为10000。
		*/
		__getset(0,__proto,'maxChars',function(){
			return this._maxChars;
			},function(value){
			if (value <=0)
				value=1E5;
			this._maxChars=value;
		});

		/**
		*设置输入提示符。
		*/
		__getset(0,__proto,'prompt',function(){
			return this._prompt;
			},function(value){
			if (!this._text && value)
				_super.prototype._$set_color.call(this,this._promptColor);
			this.promptColor=this._promptColor;
			if(this._text)
				_super.prototype._$set_text.call(this,(this._text==this._prompt)?value:this._text);
			else
			_super.prototype._$set_text.call(this,value);
			this._prompt=value;
		});

		/**限制输入的字符。*/
		__getset(0,__proto,'restrict',function(){
			if (this._restrictPattern){
				return this._restrictPattern.source;
			}
			return "";
			},function(pattern){
			if (pattern){
				pattern="[^"+pattern+"]";
				if (pattern.indexOf("^^")>-1)
					pattern=pattern.replace("^^","");
				this._restrictPattern=new RegExp(pattern,"g");
			}
			else
			this._restrictPattern=null;
		});

		/**
		*是否可编辑。
		*/
		__getset(0,__proto,'editable',function(){
			return this._editable;
			},function(value){
			this._editable=value;
		});

		Input.__init__=function(){
			Input._createInputElement();
			if (Browser.onMobile){
				Render.canvas.addEventListener(Input.IOS_IFRAME ? "click" :"touchend",Input._popupInputMethod);
			}
		}

		Input._popupInputMethod=function(){
			if (!laya.display.Input.isInputting)return;
			var input=laya.display.Input.inputElement;
			input.selectionStart=input.selectionEnd=input.value.length;
			input.focus();
			Laya.timer.once(300,null,function(){
				input.scrollIntoView();
			});
		}

		Input._createInputElement=function(){
			Input._initInput(Input.area=Browser.createElement("textarea"));
			Input._initInput(Input.input=Browser.createElement("input"));
			Input.inputContainer=Browser.createElement("div");
			Input.inputContainer.style.position="absolute";
			Input.inputContainer.appendChild(Input.input);
			Input.inputContainer.appendChild(Input.area);
			Input.inputContainer.setPos=function (x,y){Input.inputContainer.style.left=x+'px';Input.inputContainer.style.top=y+'px';};
		}

		Input._initInput=function(input){
			var style=input.style;
			style.cssText="position:absolute;overflow:hidden;resize:none;z-index:999;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;";
			style.resize='none';
			style.backgroundColor='transparent';
			style.border='none';
			style.outline='none';
			input.addEventListener('input',Input._processInputting);
			input.addEventListener('mousemove',Input._stopEvent);
			input.addEventListener('mousedown',Input._stopEvent);
			input.addEventListener('touchmove',Input._stopEvent);
			if(!Render.isConchApp){
				input.setColor=function (color){input.style.color=color;};
				input.setFontSize=function (fontSize){input.style.fontSize=fontSize+'px';};
				input.setSize=function (w,h){input.style.width=w+'px';input.style.height=h+'px';};
			}
			input.setFontFace=function (fontFace){input.style.fontFamily=fontFace;};
		}

		Input._processInputting=function(e){
			var input=laya.display.Input.inputElement.target;
			var value=laya.display.Input.inputElement.value;
			if (input._restrictPattern){
				value=value.replace(input._restrictPattern,"");
				var prevIndex=Input.inputElement.selectionStart;
				laya.display.Input.inputElement.value=value;
				laya.display.Input.inputElement.selectionStart=laya.display.Input.inputElement.selectionEnd=prevIndex;
			}
			input._text=value;
			input.event("input");
		}

		Input._stopEvent=function(e){
			if(e.type=='touchmove')
				e.preventDefault();
			e.stopPropagation && e.stopPropagation();
		}

		Input._checkBlur=function(e){
			if (e.target !=laya.display.Input.input && e.target !=laya.display.Input.area && e.target !=Input.confirmButton){
				laya.display.Input.inputElement.target.focus=false;
			}
		}

		Input.input=null
		Input.area=null
		Input.inputElement=null
		Input.inputContainer=null
		Input.confirmButton=null
		Input.promptStyleDOM=null
		Input.inputHeight=45;
		Input.isInputting=false;
		__static(Input,
		['IOS_IFRAME',function(){return this.IOS_IFRAME=(Browser.onIOS && Browser.window.top !=Browser.window.self);}
		]);
		return Input;
	})(Text)


	/**
	*<code>Box</code> 类是一个控件容器类。
	*/
	//class laya.ui.Box extends laya.ui.Component
	var Box=(function(_super){
		function Box(){Box.__super.call(this);;
		};

		__class(Box,'laya.ui.Box',_super);
		var __proto=Box.prototype;
		Laya.imps(__proto,{"laya.ui.IBox":true})
		/**@inheritDoc */
		__getset(0,__proto,'dataSource',_super.prototype._$get_dataSource,function(value){
			this._dataSource=value;
			for (var name in value){
				var comp=this.getChildByName(name);
				if (comp)comp.dataSource=value[name];
				else if (this.hasOwnProperty(name))this[name]=value[name];
			}
		});

		return Box;
	})(Component)


	/**
	*关键帧动画播放类
	*
	*/
	//class laya.display.FrameAnimation extends laya.display.AnimationPlayerBase
	var FrameAnimation=(function(_super){
		function FrameAnimation(){
			this._targetDic=null;
			this._animationData=null;
			FrameAnimation.__super.call(this);
			if(FrameAnimation._sortIndexFun==null){
				FrameAnimation._sortIndexFun=MathUtil.sortByKey("index",false,true);
			}
		}

		__class(FrameAnimation,'laya.display.FrameAnimation',_super);
		var __proto=FrameAnimation.prototype;
		/**
		*@private
		*初始化动画数据
		*@param targetDic 对象表
		*@param animationData 动画数据
		*
		*/
		__proto._setUp=function(targetDic,animationData){
			this._labels=null;
			this._targetDic=targetDic;
			this._animationData=animationData;
			this.interval=1000 / animationData.frameRate;
			this._calculateDatas();
		}

		/**@inheritDoc */
		__proto.clear=function(){
			_super.prototype.clear.call(this);
			this._targetDic=null;
			this._animationData=null;
		}

		/**@inheritDoc */
		__proto._displayToIndex=function(value){
			if(!this._animationData)return;
			if(value<0)value=0;
			if(value>this._count)value=this._count;
			var nodes=this._animationData.nodes,i=0,len=nodes.length;
			for(i=0;i<len;i++){
				this._displayNodeToFrame(nodes[i],value);
			}
		}

		/**
		*@private
		*将节点设置到某一帧的状态
		*@param node 节点ID
		*@param frame
		*@param targetDic 节点表
		*
		*/
		__proto._displayNodeToFrame=function(node,frame,targetDic){
			if(!targetDic)targetDic=this._targetDic;
			var target=targetDic[node.target];
			if(!target){
				return;
			};
			var frames=node.frames,key,propFrames,value;
			var keys=node.keys,i=0,len=keys.length;
			for(i=0;i<len;i++){
				key=keys[i];
				propFrames=frames[key];
				if(propFrames.length>frame){
					value=propFrames[frame];
					}else{
					value=propFrames[propFrames.length-1];
				}
				target[key]=value;
			}
		}

		/**
		*@private
		*计算帧数据
		*
		*/
		__proto._calculateDatas=function(){
			if(!this._animationData)return;
			var nodes=this._animationData.nodes,i=0,len=nodes.length,tNode;
			this._count=0;
			for(i=0;i<len;i++){
				tNode=nodes[i];
				this._calculateNodeKeyFrames(tNode);
			}
			this._count+=1;
		}

		/**
		*@private
		*计算某个节点的帧数据
		*@param node
		*
		*/
		__proto._calculateNodeKeyFrames=function(node){
			var keyFrames=node.keyframes,key,tKeyFrames,target=node.target;
			if(!node.frames){
				node.frames={};
			}
			if(!node.keys){
				node.keys=[];
				}else{
				node.keys.length=0;
			}
			for(key in keyFrames){
				tKeyFrames=keyFrames[key];
				if(!node.frames[key]){
					node.frames[key]=[];
				}
				tKeyFrames.sort(FrameAnimation._sortIndexFun);
				node.keys.push(key);
				this._calculateNodePropFrames(tKeyFrames,node.frames[key],key,target);
			}
		}

		/**
		*@private
		*计算节点某个属性的帧数据
		*@param keyframes
		*@param frames
		*@param key
		*@param target
		*
		*/
		__proto._calculateNodePropFrames=function(keyframes,frames,key,target){
			var i=0,len=keyframes.length-1;
			frames.length=keyframes[len].index+1;
			for(i=0;i<len;i++){
				this._dealKeyFrame(keyframes[i]);
				this._calculateFrameValues(keyframes[i],keyframes[i+1],frames);
			}
			if(len==0){
				frames[0]=keyframes[0].value;
			}
			this._dealKeyFrame(keyframes[i]);
		}

		/**
		*@private
		*
		*/
		__proto._dealKeyFrame=function(keyFrame){
			if (keyFrame.label&&keyFrame.label !="")this.addLabel(keyFrame.label,keyFrame.index);
		}

		/**
		*@private
		*计算两个关键帧直接的帧数据
		*@param startFrame
		*@param endFrame
		*@param result
		*
		*/
		__proto._calculateFrameValues=function(startFrame,endFrame,result){
			var i=0,easeFun;
			var start=startFrame.index,end=endFrame.index;
			var startValue=startFrame.value;
			var dValue=endFrame.value-startFrame.value;
			var dLen=end-start;
			if(end>this._count)this._count=end;
			if(startFrame.tween){
				easeFun=Ease[startFrame.tweenMethod];
				if(easeFun==null){
					easeFun=Ease.linearNone;
				}
				for(i=start;i<end;i++){
					result[i]=easeFun(i-start,startValue,dValue,dLen);
				}
				}else{
				for(i=start;i<end;i++){
					result[i]=startValue;
				}
			}
			result[endFrame.index]=endFrame.value;
		}

		FrameAnimation._sortIndexFun=null
		return FrameAnimation;
	})(AnimationPlayerBase)


	/**
	*<code>HTMLImage</code> 用于创建 HTML Image 元素。
	*/
	//class laya.resource.HTMLImage extends laya.resource.FileBitmap
	var HTMLImage=(function(_super){
		function HTMLImage(src){
			this._recreateLock=false;
			this._needReleaseAgain=false;
			HTMLImage.__super.call(this);
			this._init_(src);
		}

		__class(HTMLImage,'laya.resource.HTMLImage',_super);
		var __proto=HTMLImage.prototype;
		__proto._init_=function(src){
			this._src=src;
			this._source=new Browser.window.Image();
			if (src.indexOf("data:image")!=0)this._source.crossOrigin="";
			(src)&& (this._source.src=src);
		}

		/**
		*@inheritDoc
		*/
		__proto.recreateResource=function(){
			var _$this=this;
			if (this._src==="")
				throw new Error("src no null！");
			this._needReleaseAgain=false;
			if (!this._source){
				this._recreateLock=true;
				this.startCreate();
				var _this=this;
				this._source=new Browser.window.Image();
				this._source.crossOrigin="";
				this._source.onload=function (){
					if (_this._needReleaseAgain){
						_this._needReleaseAgain=false;
						_this._source.onload=null;
						_this._source=null;
						return;
					}
					_this._source.onload=null;
					_this.memorySize=_$this._w *_$this._h *4;
					_this._recreateLock=false;
					_this.compoleteCreate();
				};
				this._source.src=this._src;
				}else {
				if (this._recreateLock)
					return;
				this.startCreate();
				this.memorySize=this._w *this._h *4;
				this._recreateLock=false;
				this.compoleteCreate();
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.detoryResource=function(){
			if (this._recreateLock)
				this._needReleaseAgain=true;
			(this._source)&& (this._source=null,this.memorySize=0);
		}

		/***调整尺寸。*/
		__proto.onresize=function(){
			this._w=this._source.width;
			this._h=this._source.height;
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'onload',null,function(value){
			var _$this=this;
			this._onload=value;
			this._source && (this._source.onload=this._onload !=null ? (function(){
				_$this.onresize();
				_$this._onload();
			}):null);
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'onerror',null,function(value){
			var _$this=this;
			this._onerror=value;
			this._source && (this._source.onerror=this._onerror !=null ? (function(){
				_$this._onerror()
			}):null);
		});

		HTMLImage.create=function(src){
			return new HTMLImage(src);
		}

		return HTMLImage;
	})(FileBitmap)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.utils.IndexBuffer2D extends laya.webgl.utils.Buffer2D
	var IndexBuffer2D=(function(_super){
		function IndexBuffer2D(bufferUsage){
			this._uint8Array=null;
			this._uint16Array=null;
			(bufferUsage===void 0)&& (bufferUsage=0x88E4);
			IndexBuffer2D.__super.call(this);
			this._bufferUsage=bufferUsage;
			this._bufferType=0x8893;
			Render.isFlash || (this._buffer=new ArrayBuffer(8));
		}

		__class(IndexBuffer2D,'laya.webgl.utils.IndexBuffer2D',_super);
		var __proto=IndexBuffer2D.prototype;
		__proto._checkArrayUse=function(){
			this._uint8Array && (this._uint8Array=new Uint8Array(this._buffer));
			this._uint16Array && (this._uint16Array=new Uint16Array(this._buffer));
		}

		__proto.getUint8Array=function(){
			return this._uint8Array || (this._uint8Array=new Uint8Array(this._buffer));
		}

		__proto.getUint16Array=function(){
			return this._uint16Array || (this._uint16Array=new Uint16Array(this._buffer));
		}

		IndexBuffer2D.QuadrangleIB=null
		IndexBuffer2D.create=function(bufferUsage){
			(bufferUsage===void 0)&& (bufferUsage=0x88E4);
			return new IndexBuffer2D(bufferUsage);
		}

		return IndexBuffer2D;
	})(Buffer2D)


	/**
	*...
	*@author laya
	*/
	//class laya.webgl.utils.VertexBuffer2D extends laya.webgl.utils.Buffer2D
	var VertexBuffer2D=(function(_super){
		function VertexBuffer2D(vertexStride,bufferUsage){
			this._floatArray32=null;
			this._vertexStride=0;
			VertexBuffer2D.__super.call(this);
			this._vertexStride=vertexStride;
			this._bufferUsage=bufferUsage;
			this._bufferType=0x8892;
			Render.isFlash || (this._buffer=new ArrayBuffer(8));
			this.getFloat32Array();
		}

		__class(VertexBuffer2D,'laya.webgl.utils.VertexBuffer2D',_super);
		var __proto=VertexBuffer2D.prototype;
		__proto.getFloat32Array=function(){
			return this._floatArray32 || (this._floatArray32=new Float32Array(this._buffer));
		}

		__proto.bind=function(ibBuffer){
			(ibBuffer)&& (ibBuffer._bind());
			this._bind();
		}

		__proto.insertData=function(data,pos){
			var vbdata=this.getFloat32Array();
			vbdata.set(data,pos);
			this._upload=true;
		}

		__proto.bind_upload=function(ibBuffer){
			(ibBuffer._bind_upload())|| (ibBuffer._bind());
			(this._bind_upload())|| (this._bind());
		}

		__proto._checkArrayUse=function(){
			this._floatArray32 && (this._floatArray32=new Float32Array(this._buffer));
		}

		__proto.detoryResource=function(){
			_super.prototype.detoryResource.call(this);
			for (var i=0;i < 10;i++)
			WebGL.mainContext.disableVertexAttribArray(i);
		}

		__getset(0,__proto,'vertexStride',function(){
			return this._vertexStride;
		});

		VertexBuffer2D.create=function(vertexStride,bufferUsage){
			(bufferUsage===void 0)&& (bufferUsage=0x88E8);
			return new VertexBuffer2D(vertexStride,bufferUsage);
		}

		return VertexBuffer2D;
	})(Buffer2D)


	/**
	*关键帧动画播放类
	*
	*/
	//class laya.ui.FrameClip extends laya.display.FrameAnimation
	var FrameClip=(function(_super){
		/**
		*创建一个 <code>FrameClip</code> 实例。
		*/
		function FrameClip(){
			FrameClip.__super.call(this);
		}

		__class(FrameClip,'laya.ui.FrameClip',_super);
		return FrameClip;
	})(FrameAnimation)


	/**
	*...
	*@author
	*/
	//class laya.webgl.resource.WebGLImage extends laya.resource.HTMLImage
	var WebGLImage=(function(_super){
		function WebGLImage(src){
			this._image=null;
			this._allowMerageInAtlas=false;
			this._enableMerageInAtlas=false;
			this.repeat=false;
			this.mipmap=false;
			this.minFifter=0;
			this.magFifter=0;
			WebGLImage.__super.call(this,src);
			this.repeat=false;
			this.mipmap=false;
			this.minFifter=-1;
			this.magFifter=-1;
			this._src=src;
			this._image=new Browser.window.Image();
			this._image.crossOrigin="";
			(src)&& (this._image.src=src);
			this._enableMerageInAtlas=true;
		}

		__class(WebGLImage,'laya.webgl.resource.WebGLImage',_super);
		var __proto=WebGLImage.prototype;
		Laya.imps(__proto,{"laya.webgl.resource.IMergeAtlasBitmap":true})
		__proto._init_=function(src){}
		__proto._createWebGlTexture=function(){
			if (!this._image){
				throw "create GLTextur err:no data:"+this._image;
			};
			var gl=WebGL.mainContext;
			var glTex=this._source=gl.createTexture();
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,0x0DE1,glTex);
			gl.texImage2D(0x0DE1,0,0x1908,0x1908,0x1401,this._image);
			var minFifter=this.minFifter;
			var magFifter=this.magFifter;
			var repeat=this.repeat ? 0x2901 :0x812F;
			var isPot=Arith.isPOT(this._w,this._h);
			if (isPot){
				if (this.mipmap)
					(minFifter!==-1)|| (minFifter=0x2703);
				else
				(minFifter!==-1)|| (minFifter=0x2601);
				(magFifter!==-1)|| (magFifter=0x2601);
				gl.texParameteri(0x0DE1,0x2801,minFifter);
				gl.texParameteri(0x0DE1,0x2800,magFifter);
				gl.texParameteri(0x0DE1,0x2802,repeat);
				gl.texParameteri(0x0DE1,0x2803,repeat);
				this.mipmap && gl.generateMipmap(0x0DE1);
				}else {
				(minFifter!==-1)|| (minFifter=0x2601);
				(magFifter!==-1)|| (magFifter=0x2601);
				gl.texParameteri(0x0DE1,0x2801,minFifter);
				gl.texParameteri(0x0DE1,0x2800,magFifter);
				gl.texParameteri(0x0DE1,0x2802,0x812F);
				gl.texParameteri(0x0DE1,0x2803,0x812F);
			}
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			this._image.onload=null;
			this._image=null;
			if (isPot)
				this.memorySize=this._w *this._h *4 *(1+1 / 3);
			else
			this.memorySize=this._w *this._h *4;
			this._recreateLock=false;
		}

		/***重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。*/
		__proto.recreateResource=function(){
			var _$this=this;
			if (this._src==null || this._src==="")
				return;
			this._needReleaseAgain=false;
			if (!this._image){
				this._recreateLock=true;
				this.startCreate();
				var _this=this;
				this._image=new Browser.window.Image();
				this._image.crossOrigin="";
				this._image.onload=function (){
					if (_this._needReleaseAgain){
						_this._needReleaseAgain=false;
						_this._image.onload=null;
						_this._image=null;
						return;
					}
					(!(_this._allowMerageInAtlas && _this._enableMerageInAtlas))? (_this._createWebGlTexture()):(_$this.memorySize=0,_$this._recreateLock=false);
					_this.compoleteCreate();
				};
				this._image.src=this._src;
				}else {
				if (this._recreateLock){
					return;
				}
				this.startCreate();
				(!(this._allowMerageInAtlas && this._enableMerageInAtlas))? (this._createWebGlTexture()):(this.memorySize=0,this._recreateLock=false);
				this.compoleteCreate();
			}
		}

		/***销毁资源*/
		__proto.detoryResource=function(){
			if (this._recreateLock){
				this._needReleaseAgain=true;
			}
			if (this._source){
				WebGL.mainContext.deleteTexture(this._source);
				this._source=null;
				this._image=null;
				this.memorySize=0;
			}
		}

		/***调整尺寸*/
		__proto.onresize=function(){
			this._w=this._image.width;
			this._h=this._image.height;
			(AtlasResourceManager.enabled)&& (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight)? this._allowMerageInAtlas=true :this._allowMerageInAtlas=false;
		}

		__proto.clearAtlasSource=function(){
			this._image=null;
		}

		/**
		*返回HTML Image,as3无internal货friend，通常禁止开发者修改image内的任何属性
		*@param HTML Image
		*/
		__getset(0,__proto,'image',function(){
			return this._image;
		});

		/***
		*设置onload函数
		*@param value onload函数
		*/
		__getset(0,__proto,'onload',null,function(value){
			var _$this=this;
			this._onload=value;
			this._image && (this._image.onload=this._onload !=null ? (function(){
				_$this.onresize();
				_$this._onload();
			}):null);
		});

		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0,__proto,'allowMerageInAtlas',function(){
			return this._allowMerageInAtlas;
		});

		__getset(0,__proto,'atlasSource',function(){
			return this._image;
		});

		/**
		*是否创建私有Source,通常禁止修改
		*@param value 是否创建
		*/
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0,__proto,'enableMerageInAtlas',function(){
			return this._enableMerageInAtlas;
			},function(value){
			this._enableMerageInAtlas=value;
		});

		/***
		*设置onerror函数
		*@param value onerror函数
		*/
		__getset(0,__proto,'onerror',null,function(value){
			var _$this=this;
			this._onerror=value;
			this._image && (this._image.onerror=this._onerror !=null ? (function(){
				_$this._onerror()
			}):null);
		});

		return WebGLImage;
	})(HTMLImage)


	Laya.__init([EventDispatcher,MouseEvent3D,AppGlobalContext,Stage3D,Geometry3D,WebGLContext,LightBase,LoaderManager,Object3D,SubGeometry3D,RenderDrive,Renderer,Transform3D,Material3D,Scene3D,MD5MeshParser,Render,WebGLContext2D,ShaderCompile,Browser,Timer,BitmapTexture,AtlasGrid,RenderTargetMAX,DrawText]);
	new S3DEngineForH5();

})(window,document,Laya);
