/**
 *	永远面向摄像机的面片 
 */
package specter3d.engine.core
{
	import laya.d3.graphics.IndexBuffer3D;
	import laya.d3.graphics.VertexBuffer3D;
	import laya.maths.Matrix;
	
	import specter3d.engine.specter3d;
	import specter3d.engine.bounds.Bound;
	import specter3d.engine.core.camera.Camera3D;
	import specter3d.engine.core.geom.Matrix3D;
	import specter3d.engine.core.geom.Vector3D;
	import specter3d.engine.loaders.AssetType;
	import specter3d.engine.materials.Material3D;
	import specter3d.engine.resources.SubGeometry3D;
	import specter3d.engine.resources.SubGeometryBatch;
	import specter3d.engine.utlis.Matrix3DUtils;

	use namespace specter3d;

	/**
	 * 	永远面向摄像机的面片(贴图灯)
	 */
	public class Sprite3D extends Entity3D
	{
		private static var _sTmpVec3:Vector3D = new Vector3D;
		private static var _sUVVec3D:Vector3D = new Vector3D;
		private static var _sGeometry:SubGeometry3D;
		
		private var _material:Material3D;
		specter3d var _geometry:SubGeometryBatch;					// 模型
		
		specter3d var _vertexTransformDirty:Boolean = false;	// 位置发生变化
		specter3d var _colorTransformDirty:Boolean = false;	// 颜色发生变化
		specter3d var _uvTransformDirty:Boolean = false;		// uv发生变化
		private var _uvTransform:Matrix;
		
		// 场景灯参数
		private var _rotY:Number = 0;					// 旋转(角度)
		private var _width:Number;						// 场景灯长
		private var _height:Number;						// 场景灯宽
		private var _color:Vector3D = new Vector3D;		// 光照颜色
		private var _intensity:Number = 1;				// 光照强度[0,n]
		private var _alpha:Number = 1;					// coloranimator用
		private var _offsetU:Number;					// U偏移 
		private var _offsetV:Number;					// V偏移
		private var _scaleU:Number;						// U缩放
		private var _scaleV:Number;						// V缩放
		private var _uvRotation:Number;					// UV旋转
		
		// 场景灯合并
		specter3d var _batchable : Boolean = false;		// 是否可合并批
		specter3d var _parentBatch : Sprite3DBatch;		// 所属渲染批
		specter3d var _indexInBatch : int = -1;			// 在渲染批中的位置
		specter3d var _batched : Boolean = false;			// 是否已合并到渲染批中
		
		public function Sprite3D( material:Material3D, width:Number, height:Number)
		{
			super();
			
			this.material = material;
			_width = width;
			_height = height;
			if (!_sGeometry)
				_sGeometry = createGeometry();
			_geometry = createGeometry();
			
			// 属于场景灯层
			renderLayer = Entity3D.SceneLight_Layer;
		}
		
		override public function dispose() : void
		{
			if (_parentBatch)
			{
				_parentBatch.removeSprite(this);
				_parentBatch = null;
			}
			_geometry.dispose();
			_geometry = null;
			material = null;
			super.dispose();
		}
		
		protected function createGeometry():SubGeometryBatch
		{
			var geometry:SubGeometryBatch = new SubGeometryBatch();
			
			// 不自动生成法线，切线，uv，顶点色
			geometry.autoDeriveVertexNormals = false;
			geometry.autoDeriveVertexTangents = false;
			geometry.autoGenerateDummyUVs = false;
			geometry.autoDeriveVertexColors = false;
			
			// 默认面片
			geometry.updateVertexData( Vector.<Number>( [-.5, .0, .5, .5, .0, .5, .5, .0, -.5, -.5, .0, -.5] ) );	// 平铺在xz面上
			geometry.updateUVData( Vector.<Number>( [.0, .0, 1.0, .0, 1.0, 1.0, .0, 1.0] ) );
			geometry.updateVertexColorData( Vector.<Number>( [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0] ) );
			geometry.updateIndexData( Vector.<uint>( [0, 1, 2, 0, 2, 3] ) );
			
			return geometry;
		}
		
		public override function get assetType() : String { return AssetType.SPRITE3D; }
		
		public function get castsShadows() : Boolean { return false; }
		public function get castsOutline() : Boolean { return false; }
		
		override protected function getDefaultBoundingVolume():Bound 
		{
			return new BoundingSphere();
		}

		override protected function updateBounds():void 
		{
//			_bounds.fromExtremes(-.5 * _scaleX, -.5 * _scaleY, 0, .5 * _scaleX, .5 * _scaleY, 0);
			var size:Number = 99999999;	// 场景灯总是被收集到
			_bound.fromExtremes(-size, -size, 0, size, size, 0);
			_boundDirty = false;
		}

		override protected function createEntityPartitionNode():EntityNode 
		{
			return new Sprite3DNode( this );
		}

		override protected function updateTransform():void 
		{
			super.updateTransform();
			_transform.prependScale( _width, 1, _height);
		}
		
		override arcane function invalidateTransform() : void
		{
			super.invalidateTransform();
			_vertexTransformDirty = true;
		}
		
		override protected function invalidateSceneTransform() : void
		{
			super.invalidateSceneTransform();
			_vertexTransformDirty = true;
		}
		
		override public function getModelViewProjectionUnsafe():Matrix3D
		{
			return null; // 顶点buffer会乘上模型矩阵，所以shader中只传相机的vp即可，不需要mvp
		}
		
		override public function pushModelViewProjection( camera:Camera3D ):void 
		{
			// 不需要mvp
		}
		
		override public function popModelViewProjection():void
		{
			// 不需要mvp
		}
		
		override public function get zIndex() : Number
		{
			return 0;	// 场景灯会收集到一起，不需要排序
		}
		
		public function getVertexBuffer():VertexBuffer3D 
		{
			updateLightVertices();
			return _geometry.getVertexBuffer(); 
		}
		public function getVertexColorBuffer() : VertexBuffer3D 
		{ 
			updateLightColors();
			return _geometry.getVertexColorBuffer(); 
		}
		public function getUVBuffer():VertexBuffer3D 
		{ 
			updateLightUVs();
			return _geometry.getUVBuffer(); 
		}
		
		public function get vertexCount():uint { return _geometry.numVertices; }
		public function get numTriangles():uint { return _geometry.numTriangles; }
		
		public function getVertexNormalBuffer():VertexBuffer3D { return _geometry.getVertexNormalBuffer(); }
		public function getVertexTangentBuffer():VertexBuffer3D { return _geometry.getVertexTangentBuffer(); }
		public function getSecondaryUVBuffer():VertexBuffer3D { return _geometry.getSecondaryUVBuffer(); }
		public function getCustomBuffer() : VertexBuffer3D { return _geometry.getCustomBuffer(); }
		public function getIndexBuffer():IndexBuffer3D { return _geometry.getIndexBuffer();}
		
		public function get vertexBufferOffset() : int { return _geometry.vertexBufferOffset; }
		public function get colorBufferOffset() : int { return _geometry.colorBufferOffset; }
		public function get UVBufferOffset() : int { return _geometry.UVBufferOffset; }
		public function get normalBufferOffset() : int { return _geometry.normalBufferOffset; }
		public function get tangentBufferOffset() : int { return _geometry.tangentBufferOffset; }
		public function get secondaryUVBufferOffset() : int { return _geometry.secondaryUVBufferOffset; }
		public function get vertexData():Vector.<Number> { return _geometry.vertexData; }
		public function get indexData():Vector.<uint> { return _geometry.indexData; }
		public function get UVData():Vector.<Number> { return _geometry.UVData; }

		public function get uvTransform():Matrix { return null; }
		public function get sourceEntity():Entity3D { return this; }
		
		public function get material():Material3D { return _material; }
		public function set material( value:Material3D ):void 
		{
			if( value == _material ) return;
			if( _material ) _material.removeOwner( this );
			_material = value;
			if( _material ) _material.addOwner( this );
		}
		
		//----------------------------------------------------
		//
		// 场景灯属性
		//
		//----------------------------------------------------
		
		public function get batchable():Boolean { return _batchable; }
		public function set batchable(value:Boolean):void { _batchable = value; }

		public function get rot() : Number { return _rotY; }
		public function set rot(value : Number) : void 
		{ 
			if (_rotY == value) return;
			_rotY = value;
			rotationY = value;
			invalidateTransform();
		}
		
		public function get width():Number { return _width; }
		public function set width( value:Number ):void 
		{
			if( _width == value ) return;
			_width = value;
			invalidateTransform();
		}
		
		public function get height():Number { return _height; }
		public function set height( value:Number ):void 
		{
			if( _height == value ) return;
			_height = value;
			invalidateTransform();
		}
		
		public function get color() : Vector3D { return _color.clone(); }
		public function set color(value : Vector3D) : void 
		{ 
			setColor(value.x, value.y, value.z); 
		}
		
		public function setColor(r:Number, g:Number, b:Number):void
		{
			if (_color.x == r && _color.y == g && _color.z == b) return;
			_color.setTo(r, g, b);
			_colorTransformDirty = true;
		}
		
		public function get intensity() : Number { return _intensity; }
		public function set intensity(value : Number) : void
		{
			if (value == _intensity) return;
			_intensity = value;
			_colorTransformDirty = true;
		}
		
		public function get alpha() : Number { return _alpha; }
		public function set alpha(value : Number) : void
		{
			if (value == _alpha) return;
			_alpha = value;
			_colorTransformDirty = true;
		}
		
		public function get offsetU():Number { return _offsetU; }
		public function set offsetU( value:Number ):void 
		{
			if (value == _offsetU) return;
			_offsetU = value;
			_uvTransformDirty = true;
		}
		
		public function get offsetV():Number { return _offsetV; }
		public function set offsetV( value:Number ):void 
		{
			if (value == _offsetV) return;
			_offsetV = value;
			_uvTransformDirty = true;
		}
		
		public function get scaleU():Number { return _scaleU; }
		public function set scaleU( value:Number ):void 
		{
			if (value == _scaleU) return;
			_scaleU = value;
			_uvTransformDirty = true;
		}
		
		public function get scaleV():Number { return _scaleV; }
		public function set scaleV( value:Number ):void 
		{
			if (value == _scaleV) return;
			_scaleV = value;
			_uvTransformDirty = true;
		}
		
		public function get uvRotation():Number { return _uvRotation; }
		public function set uvRotation( value:Number ):void 
		{
			if (value == _uvRotation) return;
			_uvRotation = value;
			_uvTransformDirty = true;
		}
		
		specter3d function updateLightVertices():void
		{
			if (!_vertexTransformDirty)
				return;
			
			_vertexTransformDirty = false;
			
			var model:Matrix3D = sceneTransform;	// 模型的世界矩阵
			var sVertices:Vectotr.<Number> = _sGeometry.vertexData;
			var toVertices:Vector.<Number> = _geometry.vertexData;
			var length:int = vertexCount;
			
			for (var i:int = 0, j:int = 0, z:int=0; i < length; i++)
			{
				_sTmpVec3.x = sVertices[j++];
				_sTmpVec3.y = sVertices[j++];
				_sTmpVec3.z = sVertices[j++];
				_sTmpVec3.w = 0;
				
				Matrix3DUtils.transformVector(model, _sTmpVec3, _sTmpVec3);	// 顶点位置为乘以世界矩阵后的位置
				
				toVertices[z++] = _sTmpVec3.x;
				toVertices[z++] = _sTmpVec3.y;
				toVertices[z++] = _sTmpVec3.z;
			}
			
			_geometry.vertexBufferDirty = true;
		}
		
		specter3d function updateLightUVs():void
		{
			if (!_uvTransformDirty)
				return;

			_uvTransformDirty = false;

			_uvTransform ||= new Matrix();
			_uvTransform.identity();
			if (_uvRotation != 0) 
				_uvTransform.rotate(_uvRotation);
			if (_scaleU != 1 || _scaleV != 1)
				_uvTransform.scale(_scaleU, _scaleV);
			if (_offsetU != 0 || _offsetV != 0)
				_uvTransform.translate(_offsetU, _offsetV);
			
			var sUVs:Vectotr.<Number> = _sGeometry.UVData;
			var toUVs:Vector.<Number> = _geometry.UVData;
			var length:int = vertexCount;
			
			for (var i:int = 0, j:int = 0, z:int=0; i < length; i++)
			{
				_sTmpVec3.x = sUVs[j++];
				_sTmpVec3.y = sUVs[j++];
				_sTmpVec3.z = 0;
				_sTmpVec3.w = 0;
				
				_sUVVec3D.x = _uvTransform.a;
				_sUVVec3D.y = _uvTransform.b;
				_sUVVec3D.w = _uvTransform.tx;
				toUVs[z++] = dp4(_sUVVec3D, _sTmpVec3);	// 更新U
				
				_sUVVec3D.x = _uvTransform.c;
				_sUVVec3D.y = _uvTransform.d;
				_sUVVec3D.w = _uvTransform.ty;
				toUVs[z++] = dp4(_sUVVec3D, _sTmpVec3);	// 更新V
			}
			
			_geometry.uvBufferDirty = true;
		}
		
		specter3d function updateLightColors():void
		{
			if (!_colorTransformDirty)
				return;
			
			_colorTransformDirty = false;
			
			var toColors:Vector.<Number> = _geometry.vertexColorData;
			var length:int = vertexCount;
			
			for (var i:int = 0, z:int=0; i < length; i++)
			{
				toColors[z++] = _color.x;
				toColors[z++] = _color.y;
				toColors[z++] = _color.z;
				toColors[z++] = _alpha * _intensity;	// 更新强度
			}
			
			_geometry.vertexColorBufferDirty = true;
		}

		private function dp4(A:Vector3D, B:Vector3D):Number
		{
			return A.x*B.x + A.y*B.y + A.z*B.z + A.w*B.w;
		}
	}
}